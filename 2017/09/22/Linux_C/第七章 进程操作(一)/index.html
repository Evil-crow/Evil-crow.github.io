<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>第七篇 进程控制(一) | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第七篇 进程控制(一)</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第七篇 进程控制(一)</h1><div class="post-meta">Sep 22, 2017<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span></div><div class="post-content"><p><em>经历了上一周悲剧的学习,这一周,我决定让自己充实起来,</em></p>
<p><em>而进程控制(Peocess_Control)的学习尤为关键</em></p>
<p><em>所以,下面即为我的收获,本章的学习分为两部分</em></p>
<p><em>第一部分是进程的了解,以及相关操作</em></p>
<p><em>第二部分就是进程的一些其他操作,以及项目的一些实现要点</em></p>
<hr>
<h5 id="一-进程"><a href="#一-进程" class="headerlink" title="一,进程"></a>一,进程</h5><ul>
<li>进程的概念</li>
</ul>
<p>了解什么是进程,进程的概念以及特点.</p>
<p>进程的概念总结后有以下几点:(进程与程序,线程的区别)</p>
<ol>
<li><p>进程是一个动态的实体,是操作系统分配资源的基本单位</p>
</li>
<li><p>进程与程序的区别在于:</p>
<p>程序只是代码块,而进程是将代码移至内存中,之后为其分配资源以及空间运行中的程序,</p>
<p>可以这样理解进程,即特点之一是动态的</p>
</li>
<li><p>进程与线程:</p>
<p>为了使计算机能够在同一时间执行更多的任务,又在进程中划分了多个线程,</p>
<p>线程是操作系统所能操作控制的最 小单位,</p>
<p>进程分配有资源和内存,对于这些内容,线程不单独享用,多个线程共享这些资源以及内存,</p>
<p>同一个进程可以创建和撤销多个线程,</p>
<p>多个线程可以在进程中并行进行.</p>
</li>
</ol>
<p>以上即为进程的基本概念.</p>
<p>其实我们可以从计算机的发展过程来看:</p>
<p>1.进程最早是分时操作系统(一个计算机史上的分支方向)的基本单位</p>
<p>2.后来是面向进程编程的操作系统 <strong>(例如 UNIX, Linux Kernel &lt; 2.6)</strong></p>
<p>3.直到现在,是以面向线程编程的操作系统.进程只是线程的容器,  <strong>(现代大多数操作系统,Linux Kernel&gt;2.6)</strong></p>
<p>进程(Peocess)一直是十分重要的概念,可以说进程是计算机对计算机资源的调度方式</p>
<p>这样才能使计算机能够执行任务.</p>
<hr>
<ul>
<li>关于进程的特点:</li>
</ul>
<p>动态性:进程是动态产生的,也是动态消亡的</p>
<p>并发性:多个进程可以并行进行</p>
<p>独立性:单个进程可独立进行,系统为其分配资源,是计算机调度的基本单位</p>
<p>异步性:进程以不可预知的方向前进,速度,耗时,都是不可预知的</p>
<hr>
<ul>
<li>进程标识符(process ID)_PID</li>
</ul>
<p>进程是计算机操作系统资源分配的基本单位,那么,</p>
<p>计算机中同时进行的可能会有成百上千的进程,</p>
<p>所以对进程最直观的区分就是进行编号,即进程ID Process_ID</p>
<p><strong>关于进程标识符:</strong></p>
<blockquote>
<p>所有进程标识符都是惟一的</p>
</blockquote>
<blockquote>
<p>所有进程标识符非负</p>
</blockquote>
<blockquote>
<p>所有的PID,在进程开始时,为其分配PID,之后对其进行操作,进程结束后,PID回收</p>
</blockquote>
<p>Linux操作系统中提供了用于获取PID的相关函数,如下:</p>
<p>头文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>函数声明</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid_t getpid( )</td>
<td>获取到当前进程ID</td>
</tr>
<tr>
<td>pid_t getppid( )</td>
<td>获取当前进程父进程ID</td>
</tr>
<tr>
<td>Pid_t getuid( )</td>
<td>获取当前进程实际用户ID</td>
</tr>
<tr>
<td>pid_t geteuid( )</td>
<td>获取当前进程有效用户ID</td>
</tr>
<tr>
<td>pid_t getgid( )</td>
<td>获取当前进程实际用户组ID</td>
</tr>
<tr>
<td>pid_t getegid( )</td>
<td>获取当前进程有效用户组ID</td>
</tr>
</tbody>
</table>
<p>既然提到进程ID,就不得不进行细分:</p>
<p>1.RUID 实际用户ID:进程的执行者ID,仅只有root可以进行修改</p>
<p>2.EUID 有效用户ID:进程需要执行的用户ID,可以理解为权限ID,即该进程的拥有者</p>
<p>3.SUID 保留设置用户ID:进程切换其有效用户(EUID)时使用</p>
<p>对于这三种用户ID,有这些需要注意的点:</p>
<blockquote>
<p>1.一般用户可以将EUID设置为RUID,SUID其一,root可以将EUID设置为任意合法的UID</p>
</blockquote>
<blockquote>
<p>2.当未设置SUID时,SUID = RUID,当设置SUID后,SUID = EUID</p>
</blockquote>
<blockquote>
<p>root将S,E,RUID进行修改,修改他们的值.一般用户,仅当UID = R/SUID时,可将EUID置为UID,且不会修改值</p>
</blockquote>
<ul>
<li>进程的结构</li>
</ul>
<p>之前上面也提到过,进程时动态的实体,既然是实体,那么他必然有其既定的数据结构</p>
<p>如图:<br><img src="http://img.blog.csdn.net/20170727110851990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>代码段:即是这个进程的代码</p>
<p>数据段:保存的是,进程中的全局变量,常量,静态变量</p>
<p>堆栈段:栈用于函数调用,其中保存着函数的参数,函数的内部定义的局部变量</p>
<p><strong>注意:这三部分实体构成了进程的结构,之后在进程操作中,要特别注意三个段数据的变化</strong></p>
<ul>
<li>进程的状态</li>
</ul>
<p>运行状态:R,<strong>实际上,运行状态与就绪状态,统称可运行状态,R表示</strong></p>
<p>可中断的等待状态:S,<strong>现在可中断的等待状态,称为可终端的睡眠状态,可以被其他程序唤醒</strong></p>
<p>不可中断的等待(睡眠)状态:D,不可被唤醒,直至等待事件完成</p>
<p>僵死状态:Z,已终止,描述符仍在,直至父进程调用wait后才能释放</p>
<p>停止状态:T,表示进程暂停,或者正在被信号跟踪(gdb调试)</p>
<p>同时使用后缀字符进行状态的补全:</p>
<p><strong>&lt; :高优先级程序</strong></p>
<p><strong>N :低优先级进程</strong></p>
<p><strong>L :内存锁页,此页不可以被换出内存</strong></p>
<p><strong>s :该进程为会话首进程</strong></p>
<p><strong>l :多线程进程</strong></p>
<p><strong>+ :进程位于前台进程组</strong></p>
<p>既然上面提到了这么多的进程状态,我们就来看看怎么查看进程状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps  查看进程的基础命令</span><br><span class="line"></span><br><span class="line">常用选项:</span><br><span class="line"></span><br><span class="line">-A,显示所有进程,</span><br><span class="line"></span><br><span class="line">-u显示指定用户进程</span><br><span class="line"></span><br><span class="line">-ef 显示进程信息,搭配命令行(可配合管道使用)</span><br><span class="line"></span><br><span class="line">常用:</span><br><span class="line"></span><br><span class="line">ps -aux 即可成功查看,当前计算机上所有进程</span><br></pre></td></tr></table></figure>
<p>如图:</p>
<ul>
<li>进程的内存映像</li>
</ul>
<p>说了这么多,都是基于软件上的进程概念,那么,实质上进程是如何反映在内存中的呢?</p>
<p>一,将程序拷贝至内存中,使程序变成进程,之后,就是进程在内存中的映像</p>
<p>二,进程在内存中的映像</p>
<p>何为映像?</p>
<p><strong>我的理解就是,映像,即为进程在内存中的实际反映,即是,进程在内存中是如何编排的</strong></p>
<p>首先,来看两张图(图片引自网络)<br><img src="http://img.blog.csdn.net/20170727110724278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170727110743139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从内存的低地址开始,依次填入进程结构块中的内容</p>
<p>通过了解内存映像,可以加深对于进程概念的理解:</p>
<p>可执行程序没有堆栈,存储在硬盘中;进程存储在内存中,有堆栈段</p>
<p>可执行程序存储在硬盘,是静态的,不变的.而进程储存在内存中,是变化的,动态的.</p>
<hr>
<h5 id="二-进程控制"><a href="#二-进程控制" class="headerlink" title="二,进程控制"></a>二,进程控制</h5><p>了解了进程之后,进程控制则是重点内容</p>
<p>进程控制,主要有以下方面:</p>
<ul>
<li><p>创建进程</p>
</li>
<li><p>创建守护进程(后台)</p>
</li>
<li><p>退出进程</p>
</li>
<li><p>执行新程序</p>
</li>
<li><p>等待进程结束</p>
</li>
</ul>
<p><strong>1.创建进程</strong></p>
<p>进程很重要,那么重中之重就是进程的创建了,因为只有创建了进程,才能有后续的进程操作.</p>
<p>在UNIX/Linux中进程的创建只有两种类型:</p>
<blockquote>
<p>由父进程创建出新的子进程</p>
</blockquote>
<blockquote>
<p>由操作系统内核创建出的一些特殊进程,比如,init进程,0,1号进程</p>
</blockquote>
<p>而我们平时进行进程创建的多是第一种类型,即从父进程重新创建出新的子进程</p>
<p>来理解进程的生命过程:</p>
<p><strong>开始 -&gt; 调用函数创建进程 -&gt; 进程执行 -&gt; 进程终止 -&gt; 传递信息给父进程 -&gt; 父进程进行资源的回收 -&gt; 结束</strong></p>
<p>而进程在创建时,则是:</p>
<p><strong>开始-&gt;为进程分配惟一的PID-&gt;分配数据段,堆栈段</strong></p>
<p>首先介绍一个函数,fork( )函数,这是UNIX/Linux中特有的函数,不同于Win下的CreatProcess( )</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>fork在英语中的语义是”分叉,分支”,在程序设计里则是创建新进程的不二法宝.</p>
<p>fork( )一个新进程,主要有两点作用:</p>
<p>1.使用多进程执行一个程序(通常用处不大)</p>
<p>2.fork( )之后,立即调用exec函数族,执行另一个程序(常用法)</p>
<p>现在来理解一下fork( )的实际过程:</p>
<blockquote>
<p>调用fork( )之后,操作系统立马新建一个进程在内存中,称为子进程.</p>
</blockquote>
<blockquote>
<p>子进程与父进程共享代码段,其数据段以及堆栈段为父进程的拷贝,即,调用fork( )之后,</p>
</blockquote>
<blockquote>
<p>创建了两个几乎完全相同的进程,而两个进程的关系,更像是兄弟关系.</p>
</blockquote>
<p>fork进行进程的创建,当进程fork( )创建完后,</p>
<p><strong>fork( )这个特殊的函数会返回两个返回值</strong></p>
<p>来画一张图理解:</p>
<p><img src="http://img.blog.csdn.net/20170727110815381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>如上图,进程fork后,新建了一个子进程,</p>
<p>两个进程并行运行,互相各走各的,</p>
<p><strong>所以希望大家注意一个误区,现在是两个进程在执行fork之后的相同代码</strong></p>
<p><strong>所以才会有不同输出结果! ! !</strong></p>
<p>看下面这段程序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="comment">/* printf("Fork start!");*/</span>            <span class="comment">/*子进程对缓冲区的数据实行了拷贝,虽然fork( )在printf之后*/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Fork start!\n"</span>);</span><br><span class="line">   pid = fork( );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I'm child process! my pid is %d,my father pid is%d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I'm parent process!my pid is %d,my parent pid is%d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170727110942485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>由其进程ID,可以看出其父子进程关系,</p>
<p>比較有意思的是:</p>
<p>Fork start!,打印了一次</p>
<p>但是如果,是使用了上面的那條語句,則會打印两次Fork start!</p>
<p>这是为什么?</p>
<p><strong>这就要提到printf的机制了,他先将内容输出到缓冲区中,然后等待缓冲区刷新进行内容的输出</strong></p>
<p><strong>但是,如果缓冲区没有刷新,也就是说,子进程会将缓冲区拷贝,然后进行输出,在最后程序结束时</strong></p>
<p>可以总结一下,缓冲区刷新的条件:</p>
<p>1.缓冲区满溢出</p>
<p>2.\n ,\t,\v等强制刷新化冲区</p>
<p>3.程序结束时,不管是使用return还是exit,都会清理I/O输出,将缓冲区的内容输出,(默认return,接下来一个例子证明)</p>
<p>再来分析一下上面的程序:</p>
<blockquote>
<p>pid获取fork( )的返回值,fork( )之后是两个进程分别进行fork( )后面的代码</p>
</blockquote>
<blockquote>
<p>swich语句中,</p>
</blockquote>
<blockquote>
<p>父进程获取到的pid是fork第一个返回值–子进程的PID,都是非0的</p>
</blockquote>
<blockquote>
<p>子进程获取到的pid是fork第二个返回值–0,因为子进程无子进程</p>
</blockquote>
<blockquote>
<p>如果fork( )失败,则会返回-1</p>
</blockquote>
<p>fork的返回值很特殊,在进行程序设计时,需要明辨各自的返回值</p>
<p>那么,fork( )的实质清楚了,那么父子进程的运行情况又是什么样的呢?</p>
<p>看代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">char</span> *s;</span><br><span class="line">  <span class="comment">/* printf("Fork start!");*/</span>   <span class="comment">//同上例的缓冲区问题</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Fork start!\n"</span>);</span><br><span class="line">   pid = fork( );</span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         s = <span class="string">"I'm child process! my pid is ,my father pid is\n"</span>;</span><br><span class="line">         k = <span class="number">3</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">/*sleep(1);*/</span></span><br><span class="line">         k = <span class="number">5</span>;</span><br><span class="line">         s = <span class="string">"I'm parent process!my pid is ,my parent pid is\n"</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(k--)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n%d\n"</span>,s,k);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><img src="http://img.blog.csdn.net/20170727111020554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其实但从上面结果来看,结果是不甚明显的,可以看到子父进程勉强是交替进行的,</p>
<p>如果把上面的sleep函数去掉,你会发现,其实是一个进程结束后,另一个进程才进行.</p>
<p>这一定就是对的吗?</p>
<p>事实上,在了解了操作系统的相关内容后,会发现,</p>
<p><strong>父子进程其实是杂乱无章的,而且是随机的,你所看到的规律是因为试验结果比较小导致的</strong></p>
<p><strong>真正决定子父进程顺序的其实是操作系统的调度算法,以及时间片的分配</strong></p>
<p><strong>进程具有异步性,反映出来就是父子进程是随机进行的</strong></p>
<p><strong>而且,需要给大家补充的一个概念,就是计算机同一时间只能处理单进程,多线程</strong></p>
<p><strong>之所以我们平时可以看到计算机同时进行多个任务,这是因为计算机切换进程的速度太快,约1/60s</strong></p>
<hr>
<p>既然上面提到了,父子进程是随机的,主要依靠计算机CPU的调度算法,现在来了解两个特殊的进程:</p>
<p><strong>1.孤儿进程</strong></p>
<p>既然父子进程有异步性,不同时开始,不同时结束.那么,一旦父进程先于子进程结束,</p>
<p>则子进程称为<strong>“孤儿进程”</strong></p>
<p><strong>因为此时该子进程失去了其父进程,而在UNIX类操作系统中,这样的事是不被允许的,一个子进程必须有父进程</strong></p>
<p>这个时候,特殊进程,PID == 1的进程,init进程就派上用场了,</p>
<p><strong>init进程会收养该子进程,成为该子进程的父进程,处理之后的一系列动作</strong></p>
<p>来看一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;                       <span class="comment">/*获取PID的参数*/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Fork start!\n"</span>);</span><br><span class="line">   pid = fork( );                   <span class="comment">/*创建新进程并获取其PID*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         sleep(<span class="number">1</span>);          <span class="comment">/* 此语句用来睡眠,使得子进程后于父进程结束,研究子进程pid的变化*/</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am child process my pid is %d my parent process pid is %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am parent process,my pid is %d, my parent process pid ios %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><img src="http://img.blog.csdn.net/20170727111042059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>注意子进程的ppid(父进程ID),并非上面父进程ID,而是一个奇怪的数字1560,有时是1578,</p>
<p><strong>在/proc中可以看到,里面的编号其实都是PID,15xx,在进入目录,cat status后,会发现</strong></p>
<p><strong>都是名为systemd,1号也是systemd,可以说有多个init进程来接管孤儿进程</strong></p>
<p>你可能会疑惑,为什么对于孤儿进程必须要找一个人来收养,</p>
<p>那么,来看下面一个特殊的进程</p>
<p><strong>2,僵尸进程</strong></p>
<p>上面提到父进程先结束成为孤儿进程,那么子进程先结束便称作<strong>僵尸进程</strong></p>
<p>僵尸进程,不要听上去就感觉耸人听闻,其实他更重要的是因为,进程处于”Z+”,僵死状态</p>
<p><strong>现在来解释上面提出的一个问题:为什么一定要找出一个进程来收养孤儿进程</strong></p>
<p><strong>因为,在UNIX类操作系统中,一个进程消亡,并非是真正的死亡,而是会留下一个称为”僵尸进程”的数据结构</strong></p>
<p><strong>因为,UNIX类操作系统使用此机制,可以避免因为异步的特性,子进程先结束,而是父进程失去子进程信息的情况</strong></p>
<p>那么,这也就带来了一个问题,<strong>有大量地僵尸进程,则会占用进程标识符PID,最终导致资源泄漏</strong></p>
<p>来看一段代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   pid = fork( );</span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am child process my pid is %d,i = %d\n"</span>,getpid( ),i++);</span><br><span class="line">         _exit(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Fork Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         sleep(<span class="number">5</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am parent process my pid is %d,i = %d\n"</span>,getpid( ),i++);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><img src="http://img.blog.csdn.net/20170727111104442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中Z+即为子进程,僵尸进程</p>
<p>至于为什么需要进程来收养孤儿进程 <strong>就是防止不可回收的僵尸进程</strong></p>
<p>僵尸进程大量存在,会严重危害计算机的工作效率</p>
<p>来看看集中解决僵尸进程的办法:</p>
<p>1&gt; 父进程调用wait或者waitpid函数等待子进程的结束</p>
<p>2&gt; 使用信号SIGCHLD,用忽略信号,使得父进程忽略信号,子进程直接移交内核处理</p>
<p>3&gt; 小技巧:kill “僵尸爸爸”,因为一般情况下.僵尸进程很难被杀死</p>
<p>4&gt; 小技巧:连续fork( )两次,并杀死第一次的子进程,之后使用被收养的孤儿进程exec族函数调用新程序</p>
<p><strong>这里,需要给大家明确一个概念:僵尸进程,是很正常的一种情况</strong></p>
<p><strong>是进程结束的必经过程,不过有的进程在进行合理处理后,僵尸进程的时间很短暂,但还是经历了Z+状态</strong></p>
<p><strong>而且,不要将僵尸进程理解成有害而无利的,僵尸进程是因为父进程可能需要获取子进程信息而存在的</strong></p>
<p><strong>在最后,切记一点,在进行僵尸进程的测试时,ps -aux命令需要在另一个终端中使用(个中原因大家自行体会)</strong></p>
<hr>
<p><strong>vfork( )创建新进程</strong></p>
<p>上面的内容都是以fork( )创建新进程为主,那么vfork( )有什么作用呢?</p>
<p><strong>vfork( )也是创建新进程的函数,同样也是调用一次,有两个返回值</strong></p>
<p><strong>vfork( )和fork( )的区别在于:</strong></p>
<p><strong>1.vfork( )共享代码段,和数据空间,两个进程是共享的,而fork( )只有代码段共享,其他部分都是分离的</strong></p>
<p><strong>2.vfork( )调用后,父进程会等待子进程结束才继续进行,相当于使用了wait/waitpid的fork( )函数</strong></p>
<p><strong>由上面的1.即可知,子进程对于一些全局变量的操作在父进程中也是可见的,因为他们共享,而非拷贝</strong></p>
<p><strong>如果在子进程中依赖父进程的行为,则会造成死锁,(互相等待对方进程的完成)</strong></p>
<p><strong>最后,十分重要的一点,只有调用了exec族函数/exit,才能由子进程回到父进程</strong></p>
<p>来通过代码看结果:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">3</span>,i;</span><br><span class="line">   pid = vfork( );                                  <span class="comment">/*创建子进程*/</span></span><br><span class="line">   <span class="comment">/*pid = fork( );*/</span></span><br><span class="line">   <span class="keyword">switch</span>(pid)                                          <span class="comment">/*进行pid判断*/</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         i = <span class="number">3</span>;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">         &#123;</span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//_exit(0);                                        /*注意此处应该如何对子进程进行操作*/</span></span><br><span class="line">         <span class="comment">//return;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         i = <span class="number">5</span>;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">         &#123;</span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在注释掉case 0结束时的两句话时,结果是这样<br><img src="http://img.blog.csdn.net/20170727111134782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>在使用return,结果也这样(顺便可以了解,函数结束时若不作处理,默认是return,返回)<br><img src="http://img.blog.csdn.net/20170727111218674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><strong>这就要讲到,return与exit机制的区别了</strong></p>
<p><strong>return是关键字,而exit是函数</strong></p>
<p><strong>return是函数结尾,用于返回值使用.exit是函数中,用于结束进程使用</strong></p>
<p><strong>尤其是在vfork( )函数中,因为父子进程共享空间</strong></p>
<p><strong>那么,如果使用return,在子进程结束时,会弹栈,破坏公共的堆栈段,等父进程结束时,就会出现错误</strong></p>
<p><strong>可能会返回诡异的栈值,才会出现奇怪的结果,如图一</strong></p>
<p><strong>而使用exit就不会出现这样的结果,exit函数进行进程的结束,并不会破坏公共堆栈段</strong></p>
<p><strong>这就是为什么要使用exit/exec函数族的原因了.</strong></p>
<p>另外,我们再来谈谈exit这个函数</p>
<p><strong>这是个神奇的函数,exit为libc函数,_exit为系统调用Systemcall,exit函数,是封装_exit系统调用而来的</strong></p>
<p><strong>而这两个最大的区别就是,exit会清理I/O输出,即会将所有缓冲区的内容输出,或者写入文件</strong></p>
<p><strong>在main函数中exit(0) ~~ return 0</strong></p>
<hr>
<p>上面的内容即为创建进程的主要内容了,</p>
<p><strong>在这里我想要分享的是,fork( )函数,vfork( )函数其重要作用都是为了新建子进程后调用exec族函数</strong></p>
<p><strong>执行其他程序的,我们这里是为了了解函数特性才这么做的</strong></p>
<p><strong>虽然vfork( )也是比较好用的,但是现行标准是不建议使用vfork( )的</strong></p>
<p><strong>因为vfork( )共享数据段,堆栈段.操作十分干危险,而且在子进程中影响父进程,在实际开发中是十分危险的</strong></p>
<p><strong>如果,vfork( )之后不是立刻进行exec调用,就要十分小心,谨慎判断</strong></p>
<p><strong>但是现在,fork(　）实现了优化，实现了写时拷贝，则使得fork( )之后exec的代价十分小了</strong></p>
<p><strong>所以,现在的建议还是,使用fork( )为好</strong></p>
<hr>
<p><strong>2.创建守护进程</strong></p>
<p>何为守护进程?简单点讲,就是后台进程,不会因为终端键入的信息而响应,也不会将错误信息发送到屏幕上,</p>
<p>此处,我们对守护进程并不深入展开,仅进行守护进程的创建步骤解析:</p>
<p>1.fork( )创建新进程,并结束父进程,交由init接管</p>
<p>2.setsid( )创建新会话,并使该子进程成为会话组长</p>
<p>3.再次fork( ),创建新的子进程,并且结束父进程</p>
<p>4.关闭不必要的文件描述符,</p>
<p>5.设置掩码为0</p>
<p>6.处理信号</p>
<p>通过以上的步骤即可建立一个后台守护进程.</p>
<p>结果如图:<br><img src="http://img.blog.csdn.net/20170727111155217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>可以看到,没有反应,表面上,然后可以发现后台有一个进程在执行</p>
<hr>
<p><strong>3.进程的退出</strong></p>
<p>进程的退出,Linux系统中表示进程的结束,退出的方法分为正常退出和异常退出,主要有以下的方法:</p>
<p>(1)正常退出:</p>
<p>return 进行返回(main中结束进程)</p>
<p>调用exit,_exit,_Exit函数</p>
<p>最后一个线程从启动例程返回</p>
<p>最后一个线程调用pthrad_exit</p>
<p>(2)异常退出:</p>
<p>调用abort函数</p>
<p>接受到信号并终止</p>
<p>最后一个线程对取消请求响应</p>
<p>其中重点注意return,exit的区别,exit,_exit的特色,以上已经讲过,在此不表</p>
<hr>
<p><strong>4.执行新程序</strong></p>
<p>上面提到过fork( ),vfork(　)，实际的重要作用,是创建一个新进程后,立刻进行新程序的调用</p>
<p><strong>而提到新程序的执行,不得不提到的便是exec族函数</strong></p>
<p><strong>通过exec族函数的调用,可以用新的程序来替代当前的进程映像</strong></p>
<p><strong>注意:调用exec族函数并没有新生成进程,调用的同时,原进程”死亡”,其代码段被替换</strong></p>
<p><strong>为其分配新的数据段和堆栈段,惟一相同的就只有PID了,可以说还是同一个进程,但进行的已经是其他程序了</strong></p>
<p>因为exec族函数要调用环境变量,先来了解一下环境变量</p>
<p><strong>通俗点讲,环境变量path,就是在使用程序时,没有告诉其完整路径,系统除了在本目录下寻找以外</strong></p>
<p><strong>还应该去到指定的path路径下去寻找</strong></p>
<p>使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**显示环境变量有两种方式,看代码**</span><br><span class="line"></span><br><span class="line">**第一种,使用在别处定义的全局变量environ**</span><br><span class="line"></span><br><span class="line">``` cpp</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;                  /*在别处定义的系统变量(预定义)*/</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line"></span><br><span class="line">   for(i = 0;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;argv[%d] is %s\n&quot;,i,argv[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for(i = 0;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;%s\n&quot;,environ[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第二种,使用main函数的完整形式,并打印其值envp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv,<span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"argv[%d] is %s\n"</span>,i,argv[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,envp[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上面的两种方法都可以获取到环境变量的值.<br><img src="http://img.blog.csdn.net/20170727111656922?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>exec族函数中,execve为惟一的系统调用,其他的函数都会调用此系统调用</p>
<p><img src="http://img.blog.csdn.net/20170727111433999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170727111445309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>exec族函数的详细用法,查看man手册</strong></p>
<p>来看一段exec演示代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用的新程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"HaHa I'm the program to replace the process!\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"My pid is %d,my parent pid is %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv,<span class="keyword">char</span> **envi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Exec start!\n"</span>);</span><br><span class="line">   pid = fork( );</span><br><span class="line">   <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I am child process !\n"</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"my pid is %d,my parent pid is %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">      execve(<span class="string">"program"</span>,argv,envi);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This sentence won't be print!\n"</span>);</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is parent process!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果会发现,调用exec族函数后,进程的PID是不会改变的,<br><img src="http://img.blog.csdn.net/20170727111555352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中还有许多项目是保留的:</p>
<p>1.当前工作目录</p>
<p>2.根目录</p>
<p>3.使用的屏蔽字</p>
<p>4.控制终端</p>
<p>5.文件锁</p>
<hr>
<p><strong>5.等待进程结束</strong></p>
<p>前面提到过,父进程需要等待子进程的结束,可以避免僵尸进程</p>
<p>那么,如何等待进程的结束,调用wait,waitpid函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc)</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p><strong>wait函数会返回等待进程的PID,如果statloc指向不为空,会将退出码储存在statloc指向的变量中</strong></p>
<p><strong>在这里需要注意的是,退出码是一个字段,并非是单个数字,可以用宏去取出退出码中的信息</strong></p>
<p>举个例子:</p>
<p><strong>WIFEXITED(&amp;statloc)</strong>即可取出其中的信息</p>
<p>关于wait函数的宏,详情请查找man手册,</p>
<p>现在介绍waitpid函数,其中pid表示目标子进程的PID,statloc意义相同,options是可以添加的选项</p>
<p><strong>可以看出,waitpid函数yuwait的一个重要区别就是,wait只等待第一个结束的子进程</strong></p>
<p><strong>而waitpid函数,可以等待指定的子进程结束,而且waitpid提供了wait的非阻塞版本</strong></p>
<p><strong>即,在调用了waitpid后,使父进程不被挂起,而立刻返回,提供了WNOHANG这样的一个选项</strong></p>
<p>下面是一个演示的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> status;                              <span class="comment">/*用来记录wait返回值*/</span></span><br><span class="line">   <span class="keyword">int</span> pid;                                 <span class="comment">/*记录fork的返回值*/</span></span><br><span class="line">   <span class="keyword">int</span> exit_code,k;                           <span class="comment">/*设置退出码,用于获取结束信息*/</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"fork start!\n"</span>);</span><br><span class="line">   pid = fork( );                      <span class="comment">/*新进程已经建立,父子进程并行,或者说是操作系统对进程的快速切换*/</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         k = <span class="number">4</span>;                             <span class="comment">/*之后子进程循环操作,使父进程阻塞的依据*/</span></span><br><span class="line">         exit_code = <span class="number">45</span>;                    <span class="comment">/*子进程设置退出码,之后可以在父进程中获取*/</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         exit_code = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pid [^]!= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">int</span> status;                          <span class="comment">/*此即为wait函数中的statloc变量,用于获取退出码*/</span></span><br><span class="line">      <span class="keyword">pid_t</span>  child_pid;                   <span class="comment">/*wait函数的返回值,用于取得结束的子进程的pid*/</span></span><br><span class="line"></span><br><span class="line">      child_pid = wait(&amp;status);           <span class="comment">/*获取到退出码(退出码中储存着退出时的信息,是一个字段,可用宏取出其中信息)以及结束的子进程的pid*/</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Child process has exited!It's pid is %d\n"</span>,child_pid);</span><br><span class="line">      <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Child process has exited,It's exit_code is %d\n"</span>,WEXITSTATUS(status));   <span class="comment">//WEXITSTTUS宏用来获取exit函数低8位</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Child process exit abnormally\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(k--)</span><br><span class="line">   &#123;</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Child process is running!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">exit</span>(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><img src="http://img.blog.csdn.net/20170727111339029?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>可以看到父进程处于阻塞状态,即在等待子进程的结束</p>
<hr>
<p>以上即为基本的进程操作,如果代码有问题,可以到我的Github上来进行查看</p>
<p>++<a href="https://github.com/Evil-crow/Linux_C/tree/master/Chapter_VII" target="_blank" rel="noopener">传送门</a>++</p>
<p>下次会谈谈进程控制中的其他操作,诸如改变进程的优先级,用户的权限操作之类的,</p>
<p>如果本篇Blog有问题,可以在评论区中提出</p>
<p>July 27, 2017 11:00 AM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2017/09/22/Linux_C/第七章 进程操作(一)/" data-id="cjjk62p2x005md6nr8fkvkvp8" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsElEQVR42u3aQW4CMQwFUO5/aSp1VYkOfNsxsHizQnRmkpdKTrB9u8XX/fe6+vz3m8enHv+aPPV459X9By48PDy81tSvrschJwuULMTzRcnnjIeHh7fNq24GeRB/vkzVN+dzxsPDw/sGXnLATcJ69RCfLBMeHh7ed/KqAT1ZrPlmg4eHh/cpXpKMyAfLh0/Y+Xzw8PDw3sObF8De//mt9T08PDy8eEvIr+oBenLULswKDw8Pb4GXDN9LUlQLYJNGrhczx8PDw1vgnWp+6iU4kjlU77kE4+Hh4R3i5YzJ0fZUS1a5GQsPDw/vKO9sWO+lEqLyfzGpgYeHh7fH6xX+e8mCPOjnvwOiFAYeHh7eUV7+0upReGNjyDczPDw8vD3exuTyIF4twlX/GXh4eHgbvGpw76V3q2mOZEMqlL7w8PDwFngJMgHnpax5KiRKc+Dh4eEt8Ko//qvhfn6Y7t2Ph4eH935e7yBbLVnlCzoqy+Hh4eEt8Mq9BsVCfv79ZCGip/Dw8PDGvBwzWbkkdTtpt7p8Ax4eHt4aL08WnDoi54uYpzOaWWo8PDy8Im9S0JqnWQup2FYTAx4eHt4er5ckrZa7eof1cqNA3u+Ah4eHt8Drhea8EaEa7pNk8eXoeHh4eEd5vZap6jDVJtR5OhgPDw9vj5ccTPOjbTWVkG8k1RHx8PDw9ni9Ali+GfTSGb2ZvMhS4+Hh4R3l5Q9UYck3oxRtnhXGw8PDG/PuxWty5K22YU02kn96yvDw8PAO8aoxdh6He7F9cvTHw8PD2+DlhaVTS5AUuubtX3h4eHjbvGpQrobpxV3r+cLh4eHhfQGvlxTO0xDJVlHYwPDw8PA+yquma3tH5FMlNzw8PLxtXq9BatIEkBe9qu/Bw8PD2+bNC1GTEJ+3GuSNBXh4eHhrvB+1BA0BMbrmpAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Linux-C/">Linux_C</a></div><div class="post-nav"><a class="pre" href="/2017/09/22/Linux_C/第七章 进程控制及其操作(二)/">第七章 进程控制(二)</a><a class="next" href="/2017/09/22/Linux/第四篇  安装系统与多重引导/">第四篇 安装系统与多重引导</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Binutils/">Binutils</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Binutils/man/">man</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/一些经验/">一些经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/编程语言/">编程语言</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP/">CSAPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Server/SQL/">SQL</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shellscript/">Shellscript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/System-Programming/">System Programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VimScript/">VimScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shellscript/">shellscript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/一些经验/">一些经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文档/">文档</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Coding/" style="font-size: 15px;">Coding</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/力量的源泉/" style="font-size: 15px;">力量的源泉</a> <a href="/tags/Computer/" style="font-size: 15px;">Computer</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/File-system/" style="font-size: 15px;">File system</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/装机/" style="font-size: 15px;">装机</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/TLPI/" style="font-size: 15px;">TLPI</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/English/" style="font-size: 15px;">English</a> <a href="/tags/Linux-C/" style="font-size: 15px;">Linux_C</a> <a href="/tags/项目文档/" style="font-size: 15px;">项目文档</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/计算机系统/" style="font-size: 15px;">计算机系统</a> <a href="/tags/Exprt-C-Programming/" style="font-size: 15px;">Exprt_C_Programming</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/C++/C3P_VI/">VI Function</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/SQL/MySQL_start/">MySQL入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/C++/C_C++_expr/">C/C++坑点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/12/Linux/linux_setting/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/10/C++/pointer_and_reference/">指针与引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/TLPI/syscall/">Linux x86_64系统调用的实现过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/Other/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/C/Expert_C_Programming/data_mem/"><咸鱼书>_运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/C/Expert_C_Programming/error_jmp/">聊一聊C中的异常处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/30/C/Expert_C_Programming/c_link/"><咸鱼书>_链接那点事</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>