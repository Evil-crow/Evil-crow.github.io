<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CS:APP(二)信息的表示与处理 | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CS:APP(二)信息的表示与处理</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CS:APP(二)信息的表示与处理</h1><div class="post-meta">Dec 30, 2017<span> | </span><span class="category"><a href="/categories/Bible/">Bible</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2017/12/30/Coding/CSAPP/csapp_II/" href="/2017/12/30/Coding/CSAPP/csapp_II/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#信息存储"><span class="toc-number">1.</span> <span class="toc-text">信息存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寻址与字节顺序"><span class="toc-number">2.</span> <span class="toc-text">寻址与字节顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#寻址"><span class="toc-number">2.1.</span> <span class="toc-text">寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节顺序"><span class="toc-number">2.2.</span> <span class="toc-text">字节顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言的位运算"><span class="toc-number">3.</span> <span class="toc-text">C语言的位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#位级运算"><span class="toc-number">3.1.</span> <span class="toc-text">位级运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑运算"><span class="toc-number">3.2.</span> <span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移位运算"><span class="toc-number">3.3.</span> <span class="toc-text">移位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数编码"><span class="toc-number">4.</span> <span class="toc-text">整数编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无符号数-U-与补码-T-的编码"><span class="toc-number">4.1.</span> <span class="toc-text">无符号数(U)与补码(T)的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无符号数与补码转换"><span class="toc-number">4.2.</span> <span class="toc-text">无符号数与补码转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数位扩展与截断"><span class="toc-number">4.3.</span> <span class="toc-text">数位扩展与截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有符号数与无符号数的建议"><span class="toc-number">4.4.</span> <span class="toc-text">有符号数与无符号数的建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数位运算"><span class="toc-number">5.</span> <span class="toc-text">数位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无符号加法"><span class="toc-number">5.1.</span> <span class="toc-text">无符号加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补码加法"><span class="toc-number">5.2.</span> <span class="toc-text">补码加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数字乘法"><span class="toc-number">5.3.</span> <span class="toc-text">数字乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乘以常数"><span class="toc-number">5.4.</span> <span class="toc-text">乘以常数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浮点数"><span class="toc-number">6.</span> <span class="toc-text">浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE浮点表示"><span class="toc-number">6.1.</span> <span class="toc-text">IEEE浮点表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#舍入"><span class="toc-number">6.2.</span> <span class="toc-text">舍入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码相关"><span class="toc-number">7.</span> <span class="toc-text">编码相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#合适的数据类型"><span class="toc-number">7.1.</span> <span class="toc-text">合适的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提高程序的可移植性"><span class="toc-number">7.2.</span> <span class="toc-text">提高程序的可移植性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进行标准的编码"><span class="toc-number">7.3.</span> <span class="toc-text">进行标准的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从数字编码中学习"><span class="toc-number">7.4.</span> <span class="toc-text">从数字编码中学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数位的扩展与截断"><span class="toc-number">7.5.</span> <span class="toc-text">数位的扩展与截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点运算"><span class="toc-number">7.6.</span> <span class="toc-text">浮点运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C语言中的浮点数"><span class="toc-number">7.7.</span> <span class="toc-text">C语言中的浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p><em>这一章开始的内容可就是实打实的计算机底层系统知识了,首先,系统信息的表示</em></p>
<p><em>首先约定,从这一章开始,CSAPP每篇博客,是以两部分组成,一部分是知识总结,另一部分是编码相关</em></p>
<p><em>语言的描述,仍然以C语言为主,系统基于x86_64的Linux平台</em></p>
<p><em>同时对于这一章的学习,是从数学原理入手的,不过不用担心,只要拥有高中代数的知识即可</em></p>
<p><em>PS: 美国高中代数的知识, 中国初中数学知识</em></p>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>首先介绍了信息存储基于的几种进制方式,(2,8,16)</p>
<p>了解计算机的,基本上都懂,我就不赘述了</p>
<p>下面来看看<strong>字</strong>数据大小:</p>
<p><strong>字(word):1 word = 2 bytes = 16 bits 1个字 = 2 个字节 = 16位</strong></p>
<p><strong>OK,上面这句话其实是错的,他指的是16位机的情况,字其实就是指计算机一次处理数据的字节数,</strong></p>
<p><strong>视具体的处理器而言,32位机,就是(4字节/字).64位机就是(8字节/字)</strong></p>
<p><strong>字长(word size): 指明指针数据的标称大小,是进行内存地址编码的描述,简单的讲,就是1个字的字节数</strong></p>
<p>举个例子: W位字长的操作系统,即是可以访问的内存范围为 0 ~ $2^w-1$</p>
<p>近年来,32位过渡到64位的趋势越来越明显,内存可访问区域也从4GB扩展到16EB</p>
<p>而进行编译时,我们可以指定类型,<strong>程序如何运行,不决定于机器,而决定于它是如何编译的</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -m32 prog.c     可以运行于32/64位</span><br><span class="line">linux&gt; gcc -m64 prog.c     运行于64位机</span><br></pre></td></tr></table></figure>
<p>下面来看看C规定的数据类型大小</p>
<table><tr><td colspan="2">C声明</td><td colspan="2">字节数</td></tr><tr><td>有符号</td><td>无符号</td><td>32位</td><td>64位</td></tr><tr><td>[signed] char</td><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td>\</td><td>4</td><td>4</td></tr><tr><td>float</td><td>\</td><td>4</td><td>4</td></tr><tr><td>double</td><td>\</td><td>8</td><td>8</td></tr></table>

<p>从上表可以看出,字,是计算机处理数据的单位(基本单位是字节)</p>
<p><strong>字是地址编码的标称值,所以,C指针的数据类型大小与字长保持一致,我们常说指针4字节,实际上是32位</strong></p>
<p><strong>而对于64位 sizeof(pointer) = 8</strong></p>
<h2 id="寻址与字节顺序"><a href="#寻址与字节顺序" class="headerlink" title="寻址与字节顺序"></a>寻址与字节顺序</h2><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>寻址的问题上,我们需要讨论的是,<strong>址,到底指的是什么 ? </strong></p>
<p><strong>实际上,地址指的是,该变量/数据首字节地址,为什么,多字节存储数据时,不可能表示出所有地址</strong></p>
<p><strong>所以,使用首字节地址进行表示即可.计算机知道每种数据类型的大小,最后进行切割获取即可</strong></p>
<p><strong>所以,就有 char *str = “abcd” 的用法, str指这个字符串的首地址</strong></p>
<h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><p>既然提到字节顺序的问题,那么就有一个不得不讨论的问题了</p>
<blockquote>
<p>　在之前，数据较小的时候，需要多个字节进行存储时，　直接存储即可</p>
</blockquote>
<blockquote>
<p>　但随着时代的进步，对于一个数据需要进行多个字节存储时，如何安排顺序就是一个问题了！</p>
</blockquote>
<p>对于字节顺序的问题，有两种解决方法，可以概括为：</p>
<p>１. 大端法</p>
<p><strong>高字节，低地址的存储,与阅读习惯相同</strong></p>
<p>２. 小端法</p>
<p><strong>低字节,低地址的存储,与阅读习惯相反</strong></p>
<p>看下面这个例子:</p>
<p>对于数字0x01234567编码</p>
<table><tr><td colspan="6">大端法</td></tr><tr><td></td><td>0x100</td><td>0x101</td><td>0x102</td><td>0x103</td><td></td></tr><tr><td>…</td><td>01</td><td>23</td><td>45</td><td>67</td><td>…</td></tr><tr><td colspan="6">小端法</td></tr><tr><td></td><td>0x100</td><td>0x101</td><td>0x102</td><td>0x103</td><td></td></tr><tr><td>…</td><td>67</td><td>45</td><td>23</td><td>01</td><td>…</td></tr></table>

<p><strong>大端与小端法并没有优劣性得差异,根据情况去使用即可</strong></p>
<p>但是,需要注意的是,只要使用了一种编码方式,就必须保持下来</p>
<p><strong>选择任何字节顺序并没有技术上的差异.只要选择了一种规则,并且始终如一的坚持下去,对于哪种字节排序都是任意的</strong></p>
<p>在以下三种情况下,字节顺序是十分重要的:</p>
<ol>
<li><p>进行网络编程时,需要规定好Client/Server的字节顺序,否则,接受方收到的是反序数据</p>
</li>
<li><p>在阅读时,需要指定顺序,最常见的一种情况就是,在阅读反汇编器生成的代码时,若不清楚字节顺序很烦恼</p>
</li>
<li><p>编写规避正常的程序时,举个例子,进行C语言强制类型转换时,</p>
</li>
</ol>
<p>下面是一个,查看当前机器时大端还是小端的程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2x\n"</span>,*(<span class="keyword">char</span> *)&amp;x);    <span class="string">"78"</span>为小端,<span class="string">"12"</span> 为大端</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释: 取X地址指向的首地址,并打印其值,至于为什么不用10进制,因为中间的数值转换不够清晰明了</p>
<p>而且从上面可以看出:</p>
<p><strong>所谓强制类型转换,并没有改变位模式中的内容,只是改变了解读的方式</strong></p>
<p><strong>从侧面也验证了:信息 = 位 + 上下文,单纯的位数据是没有意义的</strong></p>
<h2 id="C语言的位运算"><a href="#C语言的位运算" class="headerlink" title="C语言的位运算"></a>C语言的位运算</h2><p>首先,需要介绍的是布尔代数.</p>
<p>C中的位运算是基于布尔代数的.</p>
<p>主要介绍,<strong>位级运算,移位运算,逻辑运算</strong></p>
<h3 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h3><p>主要由<strong> &amp; , | , ^ , ~</strong>等运算符组成</p>
<p> &amp; 与 | 按位与或已经很常用了</p>
<p> 重点介绍一下,^, 异或</p>
<p> <strong>异或,相当于位级运算中的逆元,异或一个重要的性质是:</strong></p>
<p><strong> ( a ^ b ) ^ a = b </strong></p>
<p>那么,就可以处理一个很实际的问题,对于100w+1个数,其中50w对数是相同的,如何找出唯一不同的数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		res ^= <span class="built_in">array</span>[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是利用异或的性质来处理这个问题 ! </p>
<p>而位运算常用的最重要的性质,就是求 <strong>掩码</strong></p>
<p>而掩码的求解,其中需要用到 ~ 取反运算符</p>
<p>这个时候,使用~0 要比0xFF的可移植性更高</p>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>C中的逻辑运算,就是 &amp;&amp;, || , ! 与或非,三种</p>
<p>不管是从符号上,还是从使用上,都很容易与位运算混淆</p>
<p><strong>区分位运算与逻辑运算:</strong></p>
<p><strong>1.位运算只有在特殊的情况下,或者被限制在0~1之间,才会与逻辑运算有相同的行为</strong></p>
<p><strong>2,另一个重要的区别就是,逻辑运算的中断/短路原则,p&amp;&amp;*p++ 并不会导致空指针的访问</strong></p>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>移位运算中,具体概念不再赘述</p>
<p>更重要的是谈一谈两种移位方式以及对编程影响:</p>
<p><strong>左移: 都是逻辑的,补0</strong></p>
<p><strong>右移: 分为算术右移,逻辑右移.unsigned为逻辑右移,补码为算术右移,要保证正负性</strong></p>
<p>然而,问题来了,对于不同的编辑器与机器,右移到底是逻辑的,还是算术的,界定并不是很清楚,是情况而定</p>
<p><strong>一般情况下,假定机器对于有符号数,算术右移.同时,对于无符号数,右移必须是逻辑的</strong></p>
<blockquote>
<p>在Java中,对于右移的类型界定十分清楚</p>
</blockquote>
<blockquote>
<p>“&gt;&gt;” 表示逻辑右移</p>
</blockquote>
<blockquote>
<p>“&gt;&gt;&gt;” 表示算术右移</p>
</blockquote>
<h2 id="整数编码"><a href="#整数编码" class="headerlink" title="整数编码"></a>整数编码</h2><p><em>接下来的内容,可谓是本章的精华了,计算机如何存储数制与信息 ? 如何规避错误而写出正确的代码 ? </em></p>
<p><em>一一,都会的到解答</em></p>
<p><em>简述本节: 介绍以无符号数(Unsigned)与补码(有符号数)T为主</em></p>
<p><em>接下来,会先引入一系列的数学术语</em></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$B2T_w$</td>
<td>函数</td>
<td>二进制转补码</td>
</tr>
<tr>
<td>$B2U_w$</td>
<td>函数</td>
<td>二进制转无符号数</td>
</tr>
<tr>
<td>$U2B_w$</td>
<td>函数</td>
<td>无符号数转二进制</td>
</tr>
<tr>
<td>$U2T_w$</td>
<td>函数</td>
<td>无符号数转补码</td>
</tr>
<tr>
<td>$T2B_w$</td>
<td>函数</td>
<td>补码转二进制</td>
</tr>
<tr>
<td>$T2U_w$</td>
<td>函数</td>
<td>补码转无符号数</td>
</tr>
<tr>
<td>$TMin_w$</td>
<td>常数</td>
<td>最小补码</td>
</tr>
<tr>
<td>$TMax_w$</td>
<td>常数</td>
<td>最大补码</td>
</tr>
<tr>
<td>$UMax_w$</td>
<td>常数</td>
<td>最大无符号数</td>
</tr>
<tr>
<td>$+_w^t$</td>
<td>操作</td>
<td>补码加法</td>
</tr>
<tr>
<td>$+_w^u$</td>
<td>操作</td>
<td>无符号数加法</td>
</tr>
<tr>
<td>$*_w^t$</td>
<td>操作</td>
<td>补码乘法</td>
</tr>
<tr>
<td>$*_w^u$</td>
<td>操作</td>
<td>无符号数乘法</td>
</tr>
<tr>
<td>$-_w^t$</td>
<td>操作</td>
<td>补码减法</td>
</tr>
<tr>
<td>$-_w^u$</td>
<td>操作</td>
<td>无符号数减法</td>
</tr>
</tbody>
</table>
<p>32位机器与64位机器夹杂,是目前的趋势,下面看一看C语言要求的数据类型最低标准</p>
<table>
<thead>
<tr>
<th>C数据类型</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>[signed] char</td>
<td>-127</td>
<td>127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>short</td>
<td>-32767</td>
<td>32767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>int</td>
<td>-32767</td>
<td>32767</td>
</tr>
<tr>
<td>unsigned</td>
<td>0</td>
<td>6555</td>
</tr>
<tr>
<td>long</td>
<td>-2147483647</td>
<td>2147483647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>int32_t</td>
<td>-2147483647</td>
<td>2147483647</td>
</tr>
<tr>
<td>uint32_t</td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>int64_t</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
</tr>
<tr>
<td>uint64_t</td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody>
</table>
<p><em>C/C++支持有/无符号数,Java只支持无符号数(更想学Java了,滑稽)</em></p>
<h3 id="无符号数-U-与补码-T-的编码"><a href="#无符号数-U-与补码-T-的编码" class="headerlink" title="无符号数(U)与补码(T)的编码"></a>无符号数(U)与补码(T)的编码</h3><p>先来上数学原理:</p>
<p>$$<br>B2U_w(\vec x) \dot = \sum_{i=0}^{w-1}x_i2^i<br>$$</p>
<p>$$<br>B2T_w(\vec x) \dot = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i<br>$$</p>
<p>由上面两式可以看出,不管是二进制位向量转无符号数还是补码,都是权值码</p>
<p>进行指定位权的赋值即可</p>
<p>补码的编码规则则是:</p>
<p><strong>最高位位权为负权重,其余位权为正值,进行位权累加即可,</strong></p>
<p><em>PS:这里想起了,<del>刘建元</del>发哥,大一讲计导的时候,补码的概念其实解释的不是很清晰,讲的是补码的求法</em></p>
<p><strong>那么,为什么重点讲补码呢 ? ,这是因为现今的计算机基本上都是采用补码的,原因在下面:</strong></p>
<table><tr><td rowspan="2"> 数</td><td colspan="4">字长w</td></tr><tr><td>8</td><td>16</td><td>32</td><td>64</td></tr><tr><td rowspan="2">$UMax_w$</td><td>0xFF</td><td>0xFFFF</td><td>0xFFFFFFFF</td><td>0xFFFFFFFFFFFFFFFF</td></tr><tr><td>255</td><td>65535</td><td>4294967295</td><td>18446744073709551615</td></tr><tr><td rowspan="2">$TMin_w$</td><td>0x80</td><td>0x8000</td><td>0x80000000</td><td>0x8000000000000000</td></tr><tr><td>-128</td><td>-32768</td><td>-2147483648</td><td>-9223372036854775808</td></tr><tr><td rowspan="2">$TMax_w$</td><td>0x7F</td><td>0x7FFF</td><td>0x7FFFFFFF</td><td>0x7FFFFFFFFFFFFFFF</td></tr><tr><td>127</td><td>32767</td><td>2147483647</td><td>9223372036854775807</td></tr><tr><td>-1</td><td>0xFF</td><td>0xFFFF</td><td>0xFFFFFFFF</td><td>0xFFFFFFFFFFFFFFFF</td></tr><tr><td>0</td><td>0x00</td><td>0x0000</td><td>0x00000000</td><td>0x000000000000000</td></tr></table>

<p>从上面可以看出 $|TMin_w|  = TMax_w + 1$</p>
<p>显而易见,稍不注意,便会产生因此而生的Bug,那么,为什么会有这样的情况出现</p>
<p><strong>因为,补码表示的一半是负数,另一部分是非负数,占用了一个正数的位置,所以可表示的正数少1</strong></p>
<p><strong>那么,这与为什么采取补码有关系吗 ? 有 ! ,正因此,数字编码没有浪费,同时规避了一些问题</strong></p>
<p><strong>所以才采用了补码,而原码,反码的编码方式,存在+/-0,浪费了数字编码</strong></p>
<p><em>PS:在java中,标准十分明确,而且只允许存在有符号数(Java越来越吸引我了,滑稽)</em></p>
<h3 id="无符号数与补码转换"><a href="#无符号数与补码转换" class="headerlink" title="无符号数与补码转换"></a>无符号数与补码转换</h3><p>既然存在有两种编码方式,那么这两种方式,总归有需要进行相互转换的时候</p>
<p>补码转无符号数由下面的两个函数来实现:</p>
<p>$$<br>T2U_w(x) = x + 2^w ,(x &lt; 0)<br>$$</p>
<p>$$<br>T2U_w(x) = x ,(x \ge 0)<br>$$</p>
<p>结合可得:</p>
<p>$$<br>T2U_w(x) = x + x_{w-1}2^w<br>$$</p>
<p>当x为负数时,则最高为定为负权值,$-x_{w-1}2^{w-1}$</p>
<p>而在无符号数中,对于此得解释是正权值,从负到正加上$2^w$,而$x\ge0$,相同</p>
<p>同上理,无符号数转补码就有下面两个函数实现:</p>
<p>$$<br>U2T_w(x) = x - 2^w (x \ge TMax_w)<br>$$</p>
<p>$$<br>U2T_w(x) = x (x &lt; 0)<br>$$</p>
<p>结合,可得:</p>
<p>$$<br>U2T_w(x) = -x_{w-1}2^w + x<br>$$</p>
<p>同上理,不再赘述.</p>
<p>那么,无符号数与补码的转换,语言是如何实现的?</p>
<p><strong>不清楚Java的实现机理.但是,在C/C++中,依靠的是强制类型转换</strong></p>
<p>使用强制类型转换,可以进行不同类型间的转换</p>
<p><strong>实质:对位的解释改变,不改变位中的值.解释后,位不变,表示的值可能会改变.具体实现,就是上面的函数</strong></p>
<p><strong>(注:目前讨论的还仅是相同位数的情况)</strong></p>
<h3 id="数位扩展与截断"><a href="#数位扩展与截断" class="headerlink" title="数位扩展与截断"></a>数位扩展与截断</h3><p>数位扩展/截断有什么用呢?</p>
<p>这样和你讲吧,作用还是很大的!</p>
<p><strong>在不同数位间,进行数的转换时,用到的就是数位的扩展(低位到高位)</strong></p>
<p><strong>那么,同理,(高位到低位)就是数位得截断了</strong></p>
<p>先来说无符号的扩展</p>
<p><strong>很简单,给左边加上要求数位的0即可,称为0扩展</strong></p>
<p>那么,补码的扩展呢?</p>
<p>来看个公式:</p>
<p>$$<br>B2T_{w+1}([x_{w-1},x_{w-1},\dots,x_{w-2},\dots,x_0]) = B2T_w([x_{w-1},\dots,x_0])<br>$$</p>
<p>这种扩展称为,<strong>符号扩展</strong></p>
<p><strong>符号扩展的原理是,应用 : $2^w - 2^{w-1} = 2^{w-1}$这个属性的,推理略</strong></p>
<p>上面这两种扩展,<strong>都会保证原数值不改变</strong></p>
<p>下面来看看,数字的截断.</p>
<p><strong>数字的截断遵循: 由低位开始截断,对于无符号数这这样</strong></p>
<p><strong>对于补码,先将补码视为无符号数,之后进行截断,最后转回补码</strong></p>
<p>$$<br>x’ = x \ mod \ 2^w<br>$$</p>
<p>原理是$2^{w+t} \ mod \ 2^w = 0 \ (t \ge 1)$</p>
<h3 id="有符号数与无符号数的建议"><a href="#有符号数与无符号数的建议" class="headerlink" title="有符号数与无符号数的建议"></a>有符号数与无符号数的建议</h3><p><strong>因为程序中经常会使用显式的强制类型转换,或者隐式的自动类型转换,导致了某些非直观的错误</strong></p>
<p><strong>而这些非直观的细微错误,经常会导致程序的崩溃</strong></p>
<p>看下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_length</span><span class="params">(<span class="keyword">float</span> a[ ], <span class="keyword">unsigned</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		operation(...);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环中,如果有不怀好意的人,传入TMax,之类的数,便使程序进入死循环</p>
<p>实例:</p>
<p>在FreeBSD开源项目的getpeername()函数的实现上,出现了重大错误</p>
<p><strong>实际问题出现在传递参数位负值,而memcpy()函数中,len为size_t无符号类型,会导致内存月越界</strong></p>
<h2 id="数位运算"><a href="#数位运算" class="headerlink" title="数位运算"></a>数位运算</h2><p>前面讨论完了数字的表示,那么后面自然要谈谈数字的运算了</p>
<h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>首先,根据数学知识,易得,两个w位的无符号数相加,可能会溢出为(w+1)位,</p>
<p>但是,只有w位来表示,所以就要进行<strong>数字的截断</strong>了</p>
<p>当未溢出时,即为原结果.溢出时,丢弃最高位,即求mod运算即可</p>
<p>整理后的公式为:</p>
<p>$$<br>x +_w^u y = (x+y) \ mod \ 2^w<br>$$</p>
<p>那么,我们很容易知道无符号加法溢出的条件:<strong>当x + y = s, 且 x &gt; s </strong>时,则发生了溢出</p>
<p>同时,既然知道了加法,那么就可以用此加法来求反</p>
<p>$$<br>-x_w^u = 2^w -x (x &gt; 0)<br>$$</p>
<p>$$<br>-x_w^u = x (x = 0)<br>$$</p>
<p>推理:即为加法求逆,即可</p>
<h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>补码加法,是一项很重要的内容.</p>
<p><strong>常见的溢出问题,都是由此而生的</strong></p>
<p>同理,有数学知识,易得,:<strong>补码加法,会发生上下溢出,</strong></p>
<p><strong>同理,还是进行数位的截断</strong></p>
<p>正数,少1,表示少了$2^w$</p>
<p>负数,少1,表示多了$2^w$</p>
<p>中间值,并不会溢出</p>
<p>可以通过下面的公式表示:</p>
<p>$$<br>x +_w^t y = x + y -2^w (x+y\ge TMax_w)<br>$$</p>
<p>$$<br>x +_w^t y = x+y \ (TMin_w &lt; x+y \leq TMax_w)<br>$$</p>
<p>$$<br>x +_w^t y = x+y+2^w (x+y &lt; TMin_w)<br>$$</p>
<p>但是,实际上机器加法的实现,是这样:<strong>先进行补码转无符号数,之后进行加法运算,最后又转回无符号数</strong></p>
<p>$$<br>x+_w^ty = U2T_w[(x+y)\ mod\ 2^w]<br>$$</p>
<p>实际实现方式如上</p>
<p>同理,我们可获取到,检查补码加法溢出的方法:</p>
<p><strong>x &gt; 0,y &gt; 0, s &lt;= 0 ,发生了正溢出</strong></p>
<p><strong>x &lt; 0, y &lt; 0, s &gt; 0, 发生了负溢出</strong></p>
<p>还可以得到补码的非:</p>
<p>$$<br>-x_w^t = TMin_w (x = TMin_w)<br>$$</p>
<p>$$<br>-x_w^t = -x (x &gt; TMin_w)<br>$$</p>
<p>需要十分注意的是,TMin非是自身</p>
<p>推理:补码加法的逆</p>
<h3 id="数字乘法"><a href="#数字乘法" class="headerlink" title="数字乘法"></a>数字乘法</h3><p>对于,乘法的内容,没有什么要谈得</p>
<p>对于无符号数:</p>
<p>乘法,便是对乘积取模即可</p>
<p>对于补码而言:</p>
<p><strong>虽然乘积与无符号数是不同的,但是可以保证其低位等价性</strong></p>
<p><strong>所以,同加法实现,借助于无符号数的加法实现</strong></p>
<p>公式如下:</p>
<p>$$<br>x*_w^u = (x\cdot y)\ mod \ 2^w<br>$$</p>
<p>$$<br>x*_w^ty = U2T_w[(x\cdot y)\ mod \ 2^w]<br>$$</p>
<h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><p>下面要谈得是很好玩的东西了,乘法.</p>
<p>在计算机中,乘法不同与加减法和移位运算.</p>
<p><strong>乘法的开销十分大,达到10个左右的时钟周期,加减法为1个.即使是Intel Core i7乘法也得3个周期</strong></p>
<p>所以,计算机,一般情况下是不想做乘法的,更倾向于做加减法和移位</p>
<p><strong>那么,用加减法和移位运算来优化乘法,不就好了么</strong></p>
<p>先来看看,移位运算的实质</p>
<p>$$<br>x &lt;&lt; k = x \cdot 2^k<br>$$</p>
<p>推导:</p>
<p>$$<br>  B2U_{w+k}[x_{w-1+k},x_{x-2+k},\cdots,x_{0+k}]<br>$$</p>
<p>$$<br> = \sum_{i=0}^{w}x_i2^{i+k}<br>$$</p>
<p>$$<br> = 2^k\sum x_i2^i<br>$$</p>
<p>$$<br>=2^k\cdot x<br>$$</p>
<p>有上述推理,可得,移位运算的实质</p>
<p>那么,我们就可以如此优化乘法:</p>
<p><strong>将乘数,拆开称为2的幂之和,在分开进行加法运算即可</strong></p>
<p>举个例子:</p>
<p>$$<br>x \cdot 13 = x \cdot (2^2+2^3+2^0) = (x&lt;&lt;2)+(x&lt;&lt;3)+x<br>$$</p>
<p>如此,在一定情况下,可以加速乘法运算.至于实际,取决于机器的指令,与其高度相关</p>
<p>乘法如此优化,那么除法呢?</p>
<p><strong>除法相对于乘法更慢,需要30个左右的周期</strong></p>
<p><strong>举一反三,我们此时应该使用的是右移,逻辑/算术右移具体视情况而定</strong></p>
<p><strong>而且,除法不能像乘法一样进行累加,只能除以2的幂(移位加速时)</strong></p>
<p><strong>在无符号数优化除法时,会得到向0舍入的值,而补码除法会视情况而定,正数向下舍入,负数向上舍入</strong></p>
<p><strong>这便不能保证统一,所以,需要设置”偏置’量,来进行优化调整</strong></p>
<p>即对于,负值,进行偏置,然后进行移位运算</p>
<p>偏置值为<strong>x/y,则为 (y-1),推理见CS:APP(P73)</strong></p>
<p>C语言表达式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &lt; <span class="number">0</span> ? x+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure>
<p>最后,总结一下,对于正数的运算,都是基于”模运算”的</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>相对于,整数.对于浮点数的介绍,就不是那么多了.</p>
<p><strong>计算机对于浮点数计算速度的需求 &gt; 准确程度</strong></p>
<p>首先,需要了解,负数的二进制表示–<strong>使用负幂,与十进制也是类似的</strong></p>
<h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>IEEE浮点表示,是这里的重点</p>
<p>IEEE浮点表示,基于这样的形式:</p>
<p>$$<br>V = (-1)^s \cdot M \cdot 2^E<br>$$</p>
<p>介绍一下各个符号的含义:</p>
<p>V: 表示浮点值</p>
<p>s: 表示符号位</p>
<p>M: 表示尾数,默认个位是1的</p>
<p>E: 阶码,即为2的幂</p>
<p>其中需要注意的是不同位数,M,E的数目不同</p>
<p><strong>32位: s = 1 , k = 8 , n = 23</strong></p>
<p><strong>64位: s = 1 , k = 11 , n = 52</strong></p>
<p><strong>偏置量: $2^{w-1}-1$, 这里的偏置量是为阶码设置的,为了将阶码映射到正数范围</strong></p>
<p><strong>全部是使用无符号数表示,使用时,减去偏置值,即可获得真正的阶码值</strong></p>
<p><strong>非规格化值 偏置为$\ 1-Bias$,规格化偏置值为$\ e-Bias$</strong></p>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>表示的方法限制了浮点数的范围和精度,浮点数只能近似的进行计算,于是如何找到最近的匹配值成为问题</p>
<p>这就是<strong>舍入</strong>存在的意义了</p>
<p>一般情况下,舍入:有四种</p>
<p><strong>向偶数舍入, 向0舍入, 向下舍入, 向上舍入</strong></p>
<p><strong>默认一般是先偶数舍入</strong></p>
<p><strong>因为目前对舍入要求不多,暂时掠过</strong></p>
<h2 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h2><h3 id="合适的数据类型"><a href="#合适的数据类型" class="headerlink" title="合适的数据类型"></a>合适的数据类型</h3><p>从数据类型上可以看出,在不同位数处理器上,对于数据类型的大小界定是不同的</p>
<p>为此,在ISO99的C标准,即C99中提供了两个新的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int32_t</span><br><span class="line">int64_t</span><br></pre></td></tr></table></figure>
<p>指定了处理器类型的int数据类型</p>
<p><strong>显式的使用对应机器上的数据类型,可以避免一些意想不到的错误</strong></p>
<p><strong>同时,兼容性/可移植性 与 准确性,向来是相悖的,在某些情况下,准确的代码比可移植性更为重要</strong></p>
<h3 id="提高程序的可移植性"><a href="#提高程序的可移植性" class="headerlink" title="提高程序的可移植性"></a>提高程序的可移植性</h3><p>上面提到了使用准确的,对应于机器的数据类型,但同时,随着计算机的发展</p>
<p><strong>编写可移植性高的代码,也是众望所归</strong></p>
<p>那么,提高可移植性有哪些办法呢?</p>
<p>1.使用运行时确定数据类型的方法</p>
<p>比如,<strong>sizeof(elemtype)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * byte_pointer</span><br><span class="line">void show_bytes((byte_pointer)start, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2x"</span>,start[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	show_bytes(byte_pointer(&amp;x),sizefo(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中便使用sizeof(int)提高程序可移植性</p>
<h3 id="进行标准的编码"><a href="#进行标准的编码" class="headerlink" title="进行标准的编码"></a>进行标准的编码</h3><p>C/C++优化能多的内容是未定义的,需要根据实际情况去界定</p>
<p>而对于Java,反而是十分稳定的,对于任何的标准,都是一板一眼,(PS:搞的我都想学Java了)</p>
<p><strong>进行标准规范的编码时,很有用的一个办法是,使用括号,尤其是在你对优先级不是很清楚时,</strong></p>
<p><strong>不要为了自己的代码优雅,而写出Bug代码</strong></p>
<p>举个例子: <strong>*process_list-&gt;data ,就是错误的用法</strong></p>
<p>而<strong>(*process_list)-&gt;data</strong>才是正确的用法,优先级的问题,需要十分注意</p>
<h3 id="从数字编码中学习"><a href="#从数字编码中学习" class="headerlink" title="从数字编码中学习"></a>从数字编码中学习</h3><p>上面提到了,U,T两类数字编码,那么,就有一个常见的问题了</p>
<p>当算式中使用的是不同的数字编码时,那么就需要进行强制类型转换,</p>
<p><strong>在程序员不手动处理的时候,会自动类型转换</strong></p>
<p>看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">-3</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; a)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Haha!\n);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf("</span>OK!<span class="string">"\n);</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>你认为结果会是什么?</p>
<p>实际上结果是,Haha,<strong>给个提示,类型转换的优先级,unsigned &gt; int</strong></p>
<p>从上面的例子,可以得出,我们要进行正确类型的编码(系统编程的特殊情形除外)</p>
<p><strong>对于这一处,规定统一的数据类型即可规避这项错误</strong></p>
<p><strong>准确的了解不同数制的转换,十分重要</strong></p>
<p><strong>可以参考 CS:APP(P53) 图2-19的进制升级表来理解</strong></p>
<h3 id="数位的扩展与截断"><a href="#数位的扩展与截断" class="headerlink" title="数位的扩展与截断"></a>数位的扩展与截断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> sx = <span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> uy = sx;</span><br></pre></td></tr></table></figure>
<p>此处发生的是:<strong>(unsigned int)(int)sx</strong>而不是<strong>(unsigned int)(unsigned short)sx</strong></p>
<p><strong>所以,对于强制类型转换时,需要十分注意运算符的顺序</strong></p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>这是这部分第二个重点的内容,</p>
<p><strong>首先,强调,浮点运算不具有结合性,满足单调性</strong></p>
<p>举个例子:</p>
<p>$$<br>(3.14 + \ln10)-\ln10 = 0<br>$$</p>
<p>$$<br>3.14 + (\ln 10 - \ln10) \neq 0<br>$$</p>
<p><strong>这便是浮点加法的不可结合性,其他同理</strong></p>
<p><strong>也告诫我们,进行浮点运算时,需要十分小心</strong></p>
<h3 id="C语言中的浮点数"><a href="#C语言中的浮点数" class="headerlink" title="C语言中的浮点数"></a>C语言中的浮点数</h3><p>既然谈到了,浮点数,那么正数与浮点数之间的强制类型转换,就不得不提了</p>
<p><strong>int –&gt; float ,不会溢出,可能被舍入</strong></p>
<p><strong>int/float  –&gt; double , 能够保证准确的精度</strong></p>
<p><strong>double –&gt; float , 因为表示范围,精度的减小,可能能够溢出或舍入,丢失精度</strong></p>
<p><strong>float/double  –&gt; int , 值会向0舍入,而且C标准对于这种情况是未定义的.</strong></p>
<p><strong>上面这些内容,是作为一个合格程序员,所必须要掌握的,不然是没办法处理好各种各样情况的</strong></p>
<p><strong>虽然,从理论上讲,应该使用相同的数据类型,但是,那毕竟是痴心妄想,除了某些奇葩语言 (Lisp)滑稽</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSAPP–信息的表示和处理,是内容十分丰富的一章,也是看的我想shi的一章</p>
<p>因为,浮点数的内容并不是重点,所以并不是很详细,抱歉</p>
<p>另外,课后习题有时间也可做做,十分有用.</p>
<p>下一章可就是程序机器级表示了,也不是什么好啃的内容, . . .</p>
<p>December, 2017 5:17 AM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://evil-crow.github.io/2017/12/30/Coding/CSAPP/csapp_II/" data-id="cjoilxp41000wdonrgmmpthux" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aQXLjMAwEwPz/095rLuLOgHKqRLVOKZdton1AQAA/P/Hz+fW077/67NUr+Sn1g4GB8VjGZ/lcHbAOMQk0+bYkNgwMjPcw1kEk6fLqU1EQ8bmXr2NgYGAs35MUf7PQMTAwML7BWBeUefmIgYGBMbvE5hfO2cX1j+7iGBgYD2TkXfe///sr8w0MDIxHMT7ls5+gE0AdFQYGxtGMPMHNho7tdXcnHgwMjFMZswWLvHycDSzbhh0GBsYbGMmQIC/y2mWytiS9TLgYGBiHMtb56t6Eu06dybrGfzItBgbGoYx20SFfudgpFtuWHAYGBsbsWpuk2nWiL/AYGBhHM5LibKfdP1va2PoRMTAwjmPkYd3V6G/Lwa2uIQYGxkGMtimfl5V50HnZejkSwMDAOJSx09xPLqhtwp2BMTAw3sBow2rT686ooF62wMDAOJTxjXFje/xs2aL+j4GBgfFARlII5rOFFjMrB+ski4GB8XDGbCSwszo2K/iKYQMGBsahjNl1dPbZWUKPEjcGBsaLGXmqXYfeptT6ezAwMF7AyNcpklb++uCdAWdU22JgYBzE2F+naNt2bVIuikIMDIxDGW2ay1NtW/bd1ZjDwMA4ldEOAGYXzv2fbGt4iYGBcQQjHzreNf4sViiSqDAwMDBGBdxOIs7XODAwMDCShlqbIvMWW3E6BgbGCxjt2tZOiO0Y4OZ2GwYGxgMZO1fH/MraXmj3r9YYGBhHMP4Bfo5Bz9dCmDsAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/CSAPP/">CSAPP</a></div><div class="post-nav"><a class="pre" href="/2018/01/21/Coding/C/C_Traps_Pitfalls/trap1/">语法陷阱与词法陷阱</a><a class="next" href="/2017/12/28/Coding/CSAPP/csapp_I/">CS:APP(一)计算机系统概述</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://evil-crow.github.io/2017/12/30/Coding/CSAPP/csapp_II/';
    this.page.identifier = '2017/12/30/Coding/CSAPP/csapp_II/';
    this.page.title = 'CS:APP(二)信息的表示与处理';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//Evilcrow.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//Evilcrow.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://Evilcrow.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Bible/">Bible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Guide/">Guide</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ShellScript/">ShellScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/Guide/">Guide</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/CodeStyle/" style="font-size: 15px;">CodeStyle</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/ShellScript/" style="font-size: 15px;">ShellScript</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/Coding/EffSTL/stl1/"><STL> Containers</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/Coding/EffC++/effective5/"><星月夜> Implementations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/Coding/C/Expert_C_Programming/data_mem/"><咸鱼书> 运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/Coding/EffC++/effective4/"><星月夜> Designs and Declarations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/Coding/EffC++/effective3/"><星月夜> Resource Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/Coding/EffC++/effective2/"><星月夜> Constructors, Destructors, and Assignment Operators</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/Coding/EffC++/effective1/"><星月夜> Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/Guide/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Guide/Fedora_KDE/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/Question_Answer/C/two_level_array/">一个C语言指针的问题让我翻车</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//Evilcrow.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>