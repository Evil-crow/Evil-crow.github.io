<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>指针与引用 | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">指针与引用</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">指针与引用</h1><div class="post-meta">Jun 10, 2018<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a><a href="/categories/编程语言/C-C/">C/C++</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-C-中的复合类型"><span class="toc-number">1.</span> <span class="toc-text">一, C++中的复合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-一些问题的解答"><span class="toc-number">2.</span> <span class="toc-text">二, 一些问题的解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-引用绑定唯一对象为什么还能赋值"><span class="toc-number">2.1.</span> <span class="toc-text">1. 引用绑定唯一对象为什么还能赋值?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-指针的四种状态"><span class="toc-number">2.2.</span> <span class="toc-text">2. 指针的四种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-关于空指针-Null-Pointer"><span class="toc-number">2.3.</span> <span class="toc-text">3. 关于空指针(Null Pointer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-指针比较时的相等情况"><span class="toc-number">2.4.</span> <span class="toc-text">4. 指针比较时的相等情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-复合类型的声明"><span class="toc-number">2.5.</span> <span class="toc-text">5. 复合类型的声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-事实上-const才是最恶心的"><span class="toc-number">3.</span> <span class="toc-text">三, 事实上,const才是最恶心的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-const和指针"><span class="toc-number">3.1.</span> <span class="toc-text">1. const和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-对const的引用"><span class="toc-number">3.2.</span> <span class="toc-text">2. 对const的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-拷贝时的const"><span class="toc-number">3.3.</span> <span class="toc-text">3. 拷贝时的const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-指针-引用赋值时类型不匹配的情形之一"><span class="toc-number">3.4.</span> <span class="toc-text">4. 指针/引用赋值时类型不匹配的情形之一</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-处理类型"><span class="toc-number">4.</span> <span class="toc-text">四, 处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-typedef"><span class="toc-number">4.1.</span> <span class="toc-text">1. typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-模板类型推导"><span class="toc-number">4.2.</span> <span class="toc-text">2. 模板类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-auto自动类型推导"><span class="toc-number">4.3.</span> <span class="toc-text">3. auto自动类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-decltype类型指示符"><span class="toc-number">4.4.</span> <span class="toc-text">4. decltype类型指示符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#X-附C-11使用部分"><span class="toc-number">5.</span> <span class="toc-text">X: 附C++11使用部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-long-long类型"><span class="toc-number">5.1.</span> <span class="toc-text">1. long long类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-列表初始化"><span class="toc-number">5.2.</span> <span class="toc-text">2. 列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-nullptr常量"><span class="toc-number">5.3.</span> <span class="toc-text">3. nullptr常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-constexpr变量"><span class="toc-number">5.4.</span> <span class="toc-text">4. constexpr变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-类型别名说明符-auto自动类型推导-decltype类型指示符"><span class="toc-number">5.5.</span> <span class="toc-text">5. 类型别名说明符, auto自动类型推导, decltype类型指示符</span></a></li></ol></li></ol></div></div><div class="post-content"><p><em>最近总算开始正事了,其实C++ primer还是挺好看的,讲道理,真的.</em></p>
<p><em>不过,需要转换思维的东西有点多,这一系列算是自己看C++ Primer的感想</em></p>
<p><em>也不能算是系列笔记,有想法的写一写,同时会将C++11 的内容单独列出来,能写C++11 还是写11吧</em></p>
<h2 id="一-C-中的复合类型"><a href="#一-C-中的复合类型" class="headerlink" title="一, C++中的复合类型"></a>一, C++中的复合类型</h2><p>C++中来分类型,其实就两种内置类型与自定义类型</p>
<p>内置类型,就算术类型与复合类型.</p>
<p>算术类型不提,我们重点来说说复合类型之中的指针与引用</p>
<p><strong>指针: 用修饰符 *来定义声明</strong></p>
<p><strong>引用: 用修饰符 &amp;来定义声明</strong></p>
<blockquote>
<p>指针: 本身是一个对象, 它存储了指向其他对象的地址,所以有指向对象的指针的指针,有多维指针</p>
</blockquote>
<blockquote>
<p>引用: 本身是一个绑定对象的别名,他不是一个对象,所以没有引用的引用,引用的指针</p>
</blockquote>
<p>我们着重来说说这两者的区别:</p>
<ol>
<li><p>首先是本质上, 指针是对象, 引用并非对象.所以有多维指针,指针的引用.但是没有多维引用,引用指针</p>
</li>
<li><p>从是否有初始化的必要上. 指针可以不初始化(但是是随机值,建议初始化), </p>
<p>引用因为绑定对象不可变,所以必须初始化.而且初始化后绑定对象不可更改,指针则可以任意修改.</p>
</li>
</ol>
<h2 id="二-一些问题的解答"><a href="#二-一些问题的解答" class="headerlink" title="二, 一些问题的解答"></a>二, 一些问题的解答</h2><h3 id="1-引用绑定唯一对象为什么还能赋值"><a href="#1-引用绑定唯一对象为什么还能赋值" class="headerlink" title="1. 引用绑定唯一对象为什么还能赋值?"></a>1. 引用绑定唯一对象为什么还能赋值?</h3><p>上面我们说过,引用绑定的对象是唯一的,仅仅在初始化的时候完成绑定.之后便不能修改.那么下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> &amp;c = a;</span><br><span class="line">c = b;    <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p>为什么? 不是绑定对象后,引用不能修改么…</p>
<p><strong>haha, 实际上是被使用指针的习惯禁锢住了, 使用引用的时候,就已经变成绑定的对象了</strong></p>
<p><strong>所以, 我们在初始化的步骤以外,并不可能修改引用绑定的对象,这也是为什么使用引用必须初始化的原因</strong></p>
<p>上面的代码中,使用,引用c变成(int)a, 引用b变成(int)a</p>
<h3 id="2-指针的四种状态"><a href="#2-指针的四种状态" class="headerlink" title="2. 指针的四种状态"></a>2. 指针的四种状态</h3><p>我们可以定义指针,指针在他的生命周期中可以存在四种状态:</p>
<ol>
<li><p>指向某一个对象</p>
</li>
<li><p>指向某一个对象的下一个位置</p>
</li>
<li><p>指向空(即空指针)</p>
</li>
<li><p>无效指针,其他例外情况(一般为野指针)</p>
</li>
</ol>
<p>1, 4不多说,2的情况,可能大家会比较会比较奇怪</p>
<p>其实2的情况,即使是C中也是保留的.</p>
<p><strong>C中,保证数组末端下一个位置的指针有效,但是其中的内容不作保证</strong></p>
<p><strong>C++中,在使用STL中的end()方法时,获取到的就是容器末尾的下一个位置,同样是保证指针有效</strong></p>
<p>这都是为了处理一些边界情况,或者做一些有效性判断而保证的.</p>
<h3 id="3-关于空指针-Null-Pointer"><a href="#3-关于空指针-Null-Pointer" class="headerlink" title="3. 关于空指针(Null Pointer)"></a>3. 关于空指针(Null Pointer)</h3><p>空指针,是一个特殊情况,即是为了保证指针不乱指向,出现一线难以调试的Bug存在的,一般用来初始化,</p>
<p>或者收尾工作使用.</p>
<p>常用来做空指针的几个值: nullptr, 0, NULL(需要&lt; cstdlib &gt;)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> *q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *r = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>其中,我们强烈建议,使用<code>int *p = nullpter</code>的形式</p>
<p><code>NULL</code>也只是<code>#include &lt;cstdlib&gt;</code>中的一个<code>#define NULL 0</code></p>
<p>0 也不能很明确的标识Null Pointer, 故使用C++11标准新规定的nullpter最为恰当</p>
<h3 id="4-指针比较时的相等情况"><a href="#4-指针比较时的相等情况" class="headerlink" title="4. 指针比较时的相等情况"></a>4. 指针比较时的相等情况</h3><p>一般来讲,我们用指针来做判断,进行比较不会出什么大问题,但是也有例外</p>
<p>下面的这种情况,没有遇到之前是匪夷所思的,不过理解其中原因也就没问题了</p>
<p><strong>某一个对象的指针,可能等于某个对象下一个位置的指针</strong></p>
<p><strong>其中的原因就是: 编译器可能进行了连续的内存分配,将两个变量连续分配,就会出现这种情况</strong></p>
<h3 id="5-复合类型的声明"><a href="#5-复合类型的声明" class="headerlink" title="5. 复合类型的声明"></a>5. 复合类型的声明</h3><p>类型在复合一点,就是指针的指针,指针的引用了</p>
<p><strong>因为,引用并非实际对象,只是绑定对象的别名,所以不存在引用的引用,引用的指针,切记</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *&amp;r = b;</span><br><span class="line"><span class="keyword">int</span> **&amp;t = c;</span><br></pre></td></tr></table></figure>
<p>上面,指针的引用,指针的指针的引用看上去是有点蛋疼.</p>
<p><strong>我们从最靠近标识符的符号开始分析,一切就比较明了了</strong></p>
<p>具体可以参见这篇博客<a href="https://evil-crow.github.io/2018/05/23/C/Expert_C_Programming/c_statement/">传送门&gt;&gt;</a> ,讲道理,没有C声明晦涩,复杂(C++和C恶心声明程度更甚)</p>
<h2 id="三-事实上-const才是最恶心的"><a href="#三-事实上-const才是最恶心的" class="headerlink" title="三, 事实上,const才是最恶心的"></a>三, 事实上,const才是最恶心的</h2><p>const是一个很有用的关键字,它赋予了变量在一定情况下的只读属性</p>
<p>那么,指针/引用和const结合起来就比较恶心了</p>
<h3 id="1-const和指针"><a href="#1-const和指针" class="headerlink" title="1. const和指针"></a>1. const和指针</h3><p>这个其实都是我们在C中玩烂的内容了,</p>
<p>无非就是两种,指向const的指针和const指针.不过现在我们赋予他们两个新的名字</p>
<p><strong>顶层const(top-level): 指的是对本身的const</strong></p>
<p><strong>底层const(low-level): 指的是对指向对象的const</strong></p>
<p>顶层/底层const于指针之间的关系,在C++中同C,没有啥区别</p>
<p>我们重点来说说对于引用的问题</p>
<h3 id="2-对const的引用"><a href="#2-对const的引用" class="headerlink" title="2. 对const的引用"></a>2. 对const的引用</h3><p>在const上,很多人也在说,const的顶层/底层啥的</p>
<p><strong>其实,我个人觉得引用,就叫对const的引用就好,不要扯上顶层/底层的概念</strong></p>
<p><strong>为什么? 因为引用本身就不是对象,顶层const失去意义.</strong></p>
<p><strong>底层cosnt说的是,指向对象,但是引用绑定同一个,没有指向啊</strong></p>
<p><em>其实,讲道理,也可以说着两种顶层/底层const, 因为引用指向常量(具有const的变量)时,就是底层const</em></p>
<p><em>而引用,虽然本身并非对象,没有顶层const的概念,但是他初始化绑定后不可变,也可以说时有种”顶层”感觉</em></p>
<p>所以,我的建议是,对const的引用,说法足矣.别整那些有的没的</p>
<h3 id="3-拷贝时的const"><a href="#3-拷贝时的const" class="headerlink" title="3. 拷贝时的const"></a>3. 拷贝时的const</h3><p><em>这个才是,const这里的重点,呃喔门进行程序设计的时候,免不了进行赋值操作等各种东西</em></p>
<p><em>那么,对于含有const的变量,拷贝之时,有什么要注意的吗?</em></p>
<p><strong>简单的来说,顶层const属性会丢失. (引用不讲顶层const的概念,不多说)</strong></p>
<p><strong>如果,需要顶层cosnt,手动加上const即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> src = &amp;temp;</span><br><span class="line"><span class="keyword">int</span> *des = src;     #=&gt; des, <span class="keyword">int</span>* 顶层<span class="keyword">const</span>丢失</span><br></pre></td></tr></table></figure>
<p>引用这里的情况,其实是这样,</p>
<p><strong>指针,会丢失顶层const,但是引用”隐式的”含有顶层const属性,(也因为它没有顶层const的概念)</strong></p>
<p><strong>所以才说,引用后不再是顶层const了, 但是你引用的const变量,依然是const变量,</strong></p>
<p><strong>不能因为引用,就使得对外开放,通过引用将const变量修改,所以引用是底层const(也就是对const的引用)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;        <span class="comment">// j #=&gt; int</span></span><br><span class="line"><span class="keyword">int</span> &amp;k = i;       <span class="comment">// Error, 应该改为 const int &amp;k = i;</span></span><br></pre></td></tr></table></figure>
<p>另外的情况就是: <strong>底层const会进行保留</strong></p>
<p>用指针来说,若指向对象是const变量,则指针一定要是底层const指针,不然就会被意外修改</p>
<p>对引用,只能说是另一种形式的”底层”const,引用绑定const变量,</p>
<p>即是说引用绑定对象不可变,也是一种形式的”底层”const</p>
<p>而引用,自身绑定的对象不可变,也就是另一种形式的”顶层”const</p>
<h3 id="4-指针-引用赋值时类型不匹配的情形之一"><a href="#4-指针-引用赋值时类型不匹配的情形之一" class="headerlink" title="4. 指针/引用赋值时类型不匹配的情形之一"></a>4. 指针/引用赋值时类型不匹配的情形之一</h3><p>我们进行数据赋值操作时,常常要注意一个问题: <strong>类型匹配的问题</strong></p>
<p><em>C/C++中比较弱类型的部分,会自动发生类型转换,C中一般给warning:,C++一般是error:</em></p>
<p>但是,在指针,引用赋值时,一般情况下要严格遵守类型匹配原则,除了两种情况以外:</p>
<p><em>首先,必须是不同类型的指针,不同类型的引用之间. 算术类型与指针/引用时无论如何不能进行转换的,</em></p>
<p><strong>我们的例外情况之一就是: 对于初始化cosnt引用,可以赋予不同类型的引用</strong></p>
<p><strong>但是,要求是,可以完成类型转换的情况,而且,更甚于使用字面量,非const变量,表达式之类的进行初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;a = db;              <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">3.14</span>;      <span class="comment">// b = 3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">3</span>;               <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;d = <span class="number">3</span>;         <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>首先来说说进行,不同引用/指针类型之间的赋值.</p>
<p>其实在其中完成了这样的步骤:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = db;</span><br><span class="line">cosnt <span class="keyword">int</span> &amp;b = temp;</span><br></pre></td></tr></table></figure>
<p>对,没错.实际上他用了一个临时值来进行保存,这个临时值发生了类型准换,当然会丢失精度</p>
<p>那么<code>int &amp;a = db</code>为什么会失败?</p>
<p>因为,我们实际上时进行临时值的绑定,修改临时值并不能修改<code>db</code>,但是const变量就不是为了修改的</p>
<p>而<code>int &amp;a</code>时为了修改的,既然绑定临时值并不能修改,所以,这样的行为自然就是错误的了.</p>
<p>指针的话,</p>
<p><strong>指的是,可以使用非常量指针,来进行常量指针(是底层cosnt,顶层const想都不用想)的初始化</strong></p>
<p><strong>不同指针类型之间,进行初始化,如果不使用强制类型转化(轻则:warning, 重则:error)</strong></p>
<p><em>至于,为什么可以忽略顶层const, 引用不需要考虑,而指针,即使开放出去,新赋值的指针也只能修改</em></p>
<p><em>他们指向的对象,而不能修改原指针</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> src = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *des = src;</span><br></pre></td></tr></table></figure>
<p>即: des只能修改a,修改不到src,所以,src的顶层cosnt属性,不要就不要了.</p>
<h2 id="四-处理类型"><a href="#四-处理类型" class="headerlink" title="四, 处理类型"></a>四, 处理类型</h2><p>如今C++发展日新月异,越来越牛<del>(gou)</del>皮<del>(pi)</del></p>
<p>类型也是越写越长,我们逐渐难以推断出,某个变量到底会是什么类型,这就是个十足的问题了</p>
<p>于是乎,出现了这么几种进行类型推导的好东西:</p>
<h3 id="1-typedef"><a href="#1-typedef" class="headerlink" title="1. typedef"></a>1. typedef</h3><p>其实C中也用过了,就是类型别名(type alias),这个东西只能你自己起名字</p>
<p><em>局限性还是很大的,你要是也不认识,不就没办法玩了</em></p>
<p><strong>所以,我们推荐下面这几种方法</strong></p>
<h3 id="2-模板类型推导"><a href="#2-模板类型推导" class="headerlink" title="2. 模板类型推导"></a>2. 模板类型推导</h3><p>很牛皮, 不过我现在也用不上,不提了,后面补</p>
<h3 id="3-auto自动类型推导"><a href="#3-auto自动类型推导" class="headerlink" title="3. auto自动类型推导"></a>3. auto自动类型推导</h3><p>这个是C++11种新出来的好东西</p>
<p>这东西,当年也是从C中出来的,不过已经废了很多年了(PS: 表示自动变量有个球用)</p>
<p>所以,C++11对此关键字,继续重写.作为自动类型推导关键字</p>
<p><strong>auto根据初始值,进行类型推导,所以它必需要进行初始化,不然搞锤子</strong></p>
<p><strong>另外,auto其实是模板类型推导过来的,所以实际上auto就是个占位符T,不能用做类型</strong></p>
<p><code>auto i = auto j;</code>这就是错误的,编译会炸的</p>
<p><em>auto自动类型推导,会根据情况,进行一定程度的修改,使其更符合自动类型推导</em></p>
<p><strong>也就是说,会出现不一致的情况,它会忽略顶层const,底层cosnt则会保留,如果有需要顶层const,显式声明.</strong></p>
<p><strong>对于字面量的情况,必须是对cosnt的引用,否则还是编译不通过,很简单,不能为非const引用绑定字面值</strong></p>
<p><code>auto &amp;i = 42</code>错误, <code>const auto &amp;i = 42</code> 编译通过</p>
<p>另外,要注意的:<strong>对引用使用时,auto会使用引用绑定的类型进行推导</strong></p>
<p>也就是说: <strong>一般变量进行类型推导, 变量的顶层const属性会丢失. 而引用则能保留顶层const属性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i;    <span class="comment">// a #=&gt; int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = i;   <span class="comment">// b #=&gt; const int&amp;</span></span><br></pre></td></tr></table></figure>
<p><em>好吧,我错怪C++ Primer的翻译了,我的错.</em></p>
<p>来看看下面这些例子,和你想的一样吗?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;      <span class="comment">// i #=&gt; const int</span></span><br><span class="line"><span class="keyword">auto</span> j = i;            <span class="comment">// j #=&gt; int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;k = i;     <span class="comment">// k #=&gt; const int &amp;, 没有const,会error</span></span><br><span class="line"><span class="keyword">auto</span> *p = &amp;i;          <span class="comment">// p #=&gt; const int *, 因为它指向const常量,所以得是底层cosnt指针</span></span><br><span class="line"><span class="keyword">auto</span> p = &amp;i;           <span class="comment">// 结果同上,指针不显式声明可以推导,引用则会被推导为一般类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> j2 = i, &amp;k2 = i; <span class="comment">// j2 #=&gt; const int k2 #=&gt; const int &amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-decltype类型指示符"><a href="#4-decltype类型指示符" class="headerlink" title="4. decltype类型指示符"></a>4. decltype类型指示符</h3><p><em>上面使用auto时,你可能还会抱怨,会出问题,不一定符合,const会丢失之类的</em></p>
<p>但是,我明确的说,<strong>decltype一定符合你的需求,它会切实进行类型推导</strong></p>
<p>当然,两个类型推导之间会所不同. 具体来说:</p>
<ol>
<li><p><code>auto</code>是根据初始值进行类型推导,所以它一定会发生赋值操作</p>
<p>而<code>decltype</code>只是根据表达式结果推导,并不实际计算</p>
</li>
<li><p><code>auto</code>在对于引用推导时,使用引用绑定类型,<code>decltype</code>则会将其作为引用使用.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> i = a; 			<span class="comment">// i #=&gt; int ,丢失顶层const, a只是个const int,使用引用绑定类型</span></span><br><span class="line"><span class="keyword">decltype</span>(a) b;  		<span class="comment">// Error, 推导出来是引用类型,而引用类型必须初始化</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p> <strong>切记: 引用类型,只有在<code>decltype</code>这里是引用,其他时候都使用其绑定类型</strong></p>
<ol start="3">
<li>便是,<code>decltype</code>中奇特的<code>(())</code>了, 他会将变量作为表达式,获取引用类型</li>
</ol>
<p><strong><code>decltype</code>中有一个大坑, 当decltype的表达式可以作为赋值语句的左值时,decltype的结果是引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) a = i;       <span class="comment">// a #=&gt; int </span></span><br><span class="line"><span class="keyword">decltype</span>(*p) b;              <span class="comment">// Error, b #=&gt; int &amp;</span></span><br></pre></td></tr></table></figure>
<p><strong>不要奇怪解引用的结果是引用,因为它可以作为左值</strong></p>
<p>总结一下: </p>
<p><strong>1. 使用变量,一定会得到你想要的变量类型,当然,在你不使用<code>decltype((var))</code>的情况下</strong></p>
<p><strong>2. 使用表达式, 如果可以作为左值,那么,他就是引用,上面的r+0, 并不能做引用,它是int</strong></p>
<p>讲道理,上面这些还是收货颇丰的.</p>
<h2 id="X-附C-11使用部分"><a href="#X-附C-11使用部分" class="headerlink" title="X: 附C++11使用部分"></a>X: 附C++11使用部分</h2><p><em>这部分是关于C++11 特性使用的实例,每次补上几个,从一开始就要求自己使用C++11</em></p>
<h3 id="1-long-long类型"><a href="#1-long-long类型" class="headerlink" title="1. long long类型"></a>1. long long类型</h3><p>其实就是个类型扩展,没啥意思,C中也引入了,C11中</p>
<h3 id="2-列表初始化"><a href="#2-列表初始化" class="headerlink" title="2. 列表初始化"></a>2. 列表初始化</h3><p>这个之前比较鸡肋,现在C++11全面支持,我们可以这样用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">type a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">type <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">type a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>使用列表初始化,最大的好处就是: 再出现丢失精度风险的时候,会报warning</strong></p>
<p>当然肯定不止这么一点,我们后面再说</p>
<h3 id="3-nullptr常量"><a href="#3-nullptr常量" class="headerlink" title="3. nullptr常量"></a>3. nullptr常量</h3><p>这个是为了C++11 全面兼容,0 效果一般,不明显, NULL需要&lt; cstdlib &gt;支持,不如直接使用nullptr </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// declare a null pointer</span></span><br></pre></td></tr></table></figure>
<h3 id="4-constexpr变量"><a href="#4-constexpr变量" class="headerlink" title="4. constexpr变量"></a>4. constexpr变量</h3><p>在确定会是常量时,我们使用constexpr,来让编译器进行检测,一般只能用静态区变量/表达式初始化.</p>
<p>因为堆栈上的变量,地址未分配,编译期不能确定.后面还会有constexpr函数出现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">4</span>, b = <span class="number">5</span>;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>要求,必须足够简单,能够在编译期确定值</p>
<h3 id="5-类型别名说明符-auto自动类型推导-decltype类型指示符"><a href="#5-类型别名说明符-auto自动类型推导-decltype类型指示符" class="headerlink" title="5. 类型别名说明符, auto自动类型推导, decltype类型指示符"></a>5. 类型别名说明符, auto自动类型推导, decltype类型指示符</h3><p>这三个家伙是为了同一目的的.</p>
<p><code>using</code>只是半个<code>typedef</code>的替代品,完全一致</p>
<p><code>auto</code>, <code>decltype</code>前面已经详细说过,就看看怎么用吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">using</span> Node = struct node;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.begin(), i != vec.end(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省得写 std::vector&lt;int&gt;::iterator it = vec.begin();</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((a)) b = a;   #=&gt; b#=&gt; <span class="keyword">int</span> &amp;</span><br></pre></td></tr></table></figure>
<p>最后再给大家两个建议:</p>
<ol>
<li><p>多去外面的世界看看,挺好的</p>
</li>
<li><p>多用IDE,类型推导不明确时,鼠标放上去就行了,Vim还没有这种功能</p>
</li>
<li><p>typeid(var).name(), 输出的结果真的是俄式踏马的瓜皮…</p>
</li>
</ol>
<hr>
<p>这次我们就先说到这里,C++还是很有意思的,就是内容太多了.</p>
<p>现在还是要爆肝,一般也就在是在迷糊的时候写博客</p>
<p>不然,哪有那么多时间,E3期间,就等大法放大招好吧.</p>
<p>他要是放大招,我就,我就 立马买张25仔:完全版 庆祝一下.</p>
<p>June 11, 2018 12:20 AM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://evil-crow.github.io/2018/06/10/C++/Other/pointer_and_reference/" data-id="cjls68ilb007blbnraeddvltr" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACs0lEQVR42u3awW7jMAwE0P7/T2eBPfUSd4aUsl3g+RQEqa2ng8UO+fUVX6+/1/fP7775/v27OyT3zO984MLDw8MbLf3d9W5xySKePz//1f43eHh4eLd5yWGQw5LXffKUdrvx8PDwfhuvfUACTgplPDw8vP+XlxTH+aGSl9ftQYWHh4f3GV77z3+7HXkgm2/f4awFDw8PL+bNGmD/9vP1/h4eHh7eqKu+ufJiOinuZ6vFw8PDu8F7blPtD5JNgX4sCMbDw8M7yktaXMnt8lDgVJwRgfHw8PAu8GaHxGwQKimgk01cHW94eHh4a17+0s9f0Pni8rbW8B8APDw8vAu8aGipvOlmg/KD5Hlr8PDw8O7xNq/mNibI9zthJ8/Cw8PDu8fLX8rt4tpoYzZAUJ9ReHh4eAveLE7NC/G2tdZucbQSPDw8vKO8GwFuPiLQjhHUYw14eHh4l3n7sjt5cBEljIYVfggj8PDw8Na8Nk59Bdc+UHi+W/1cPDw8vKO8NmZt22OzRtc+4MDDw8P7DG8W3SZRQtv02rTQ3k5G4OHh4R3lJQ94XnQby7ajBrOjCA8PD+/zvLYlNgt2N0V2VFLj4eHhHeXlwWj7m9mmJJtVHy14eHh413izQGEVs47GDvKIGQ8PD+8eb/+wUyNW7dBAW9zj4eHhneXtR6Y27LwJ10bMeHh4eDd4+VjV5pu84M5DjVXWgoeHh3eIlw9UtYtuW2J5jPtDRIKHh4d3lPcqr1MRatsSm4W8eHh4eDd4sxducmycGm/Nj40VEg8PD6/k5THEpqSeFej7thkeHh7ePd7mFX92eGsfQ+Dh4eH9Nl7eJNs3xvKyPhq3wsPDw/s4b9bcyov1pBCv22Z4eHh413iz1/294+RYiwsPDw/vWve8ntUqv58NdbWbdaC/h4eHh/fE+wMckZKXcxDRyAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/C-Primer/">C++Primer</a></div><div class="post-nav"><a class="pre" href="/2018/06/20/C++/Other/C_C++_expr/">C/C++坑点总结</a><a class="next" href="/2018/06/07/TLPI/syscall/">Linux x86_64系统调用的实现过程</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/编程语言/">编程语言</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/Vim/">Vim</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/EvilCrow/">EvilCrow</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/力量的源泉/">力量的源泉</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/C-C/">C/C++</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/standard/" style="font-size: 15px;">standard</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/hole/" style="font-size: 15px;">hole</a> <a href="/tags/experience/" style="font-size: 15px;">experience</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/Shellscript/" style="font-size: 15px;">Shellscript</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/C-Primer/" style="font-size: 15px;">C++Primer</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/effc/"><星月夜>_Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/C++/EffC++/effective1/"><星月夜>_Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Evilcrow/linux_setting/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/tools/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/Expert_C_Programming/data_mem/"><咸鱼书>_运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/two_level_array/">一个C语言指针的问题让我翻车</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/C++/C++Primer/C3P_VI/">VI Function</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/SQL/MySQL_start/">MySQL入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/C++/Other/C_C++_expr/">C/C++坑点总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>