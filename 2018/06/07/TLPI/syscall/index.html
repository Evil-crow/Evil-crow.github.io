<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Linux x86_64系统调用的实现过程 | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux x86_64系统调用的实现过程</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux x86_64系统调用的实现过程</h1><div class="post-meta">Jun 7, 2018<span> | </span><span class="category"><a href="/categories/Unix-Linux/">Unix/Linux</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-从使用一个系统调用开始"><span class="toc-number">1.</span> <span class="toc-text">一, 从使用一个系统调用开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用GDB单步进入"><span class="toc-number">1.1.</span> <span class="toc-text">1. 使用GDB单步进入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-合理推测-ಡωಡ"><span class="toc-number">1.2.</span> <span class="toc-text">2. 合理推测(ಡωಡ)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-分析一个系统调用的源码"><span class="toc-number">2.</span> <span class="toc-text">二, 分析一个系统调用的源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-Warpper-Function如何Warpper"><span class="toc-number">3.</span> <span class="toc-text">三,Warpper Function如何Warpper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-关于中断的小了解"><span class="toc-number">4.</span> <span class="toc-text">四,关于中断的小了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-真正的系统调用实现"><span class="toc-number">5.</span> <span class="toc-text">五,真正的系统调用实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-扩展阅读"><span class="toc-number">6.</span> <span class="toc-text">六,扩展阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他的一些闲杂事情"><span class="toc-number">7.</span> <span class="toc-text">其他的一些闲杂事情</span></a></li></ol></div></div><div class="post-content"><p><em>由于系统调用的分析实现其中涉及一些内核/OS方面的知识,不是十分重要的,我们不进行详细说明</em></p>
<p><em>另外, 此分析,基于glibc-2.26以及Linux-Kernel-4.17,可以获取相关源码阅读</em></p>
<p>从我们以往的理解上来看,系统调用就是使用OS提供的接口,不也就是调用么?</p>
<p>System Call涉及了用户/内核态的切换,有些是需要进入内核态完成的,所以系统调用的存在就很有必要</p>
<p>更重要的一点就是: <strong>使用系统调用,仅仅暴露接口,保证了内核不会被无意/恶意破坏</strong></p>
<p>下面我们开始具体的系统调用实现分析:</p>
<h2 id="一-从使用一个系统调用开始"><a href="#一-从使用一个系统调用开始" class="headerlink" title="一, 从使用一个系统调用开始"></a>一, 从使用一个系统调用开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/tmp/file"</span>, O_RDONLY, <span class="keyword">mode_t</span> mode);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">		do_something(errno);</span><br><span class="line">	</span><br><span class="line">	close(fd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面便是一个简单地使用系统调用的例子,使用了open(系统调用)</p>
<p>那么下一步, <strong>就是,open()函数的实现到底在哪里呢?</strong></p>
<p>有两种方法查看:</p>
<h3 id="1-使用GDB单步进入"><a href="#1-使用GDB单步进入" class="headerlink" title="1. 使用GDB单步进入"></a>1. 使用GDB单步进入</h3><p>这个时候,GDB的Step指令就十分重要了,对于open(),函数它可以单步进入啊!</p>
<p>这不就很明显的看出<code>open()</code>实现在哪里了?</p>
<p><img src="http://p8pmsq2a4.bkt.clouddn.com/gdb_s.png" alt="gdb step指令"></p>
<p><img src="http://p8pmsq2a4.bkt.clouddn.com/locate.png" alt="locate 确定文件位置"></p>
<p>如上</p>
<h3 id="2-合理推测-ಡωಡ"><a href="#2-合理推测-ಡωಡ" class="headerlink" title="2. 合理推测(ಡωಡ)"></a>2. 合理推测(ಡωಡ)</h3><p>我们使用的系统调用都是C实现,而在Linux平台下,使用最多的是GNU C,依赖的libc库为glibc</p>
<p>(PS: 上面是我的本机环境,各位可以根据自己的机器环境去C库进行实现的查找)</p>
<p>见我们的实现依赖于glibc,那么去C可查找理所当然了</p>
<p>然后使用查找关键字的方法就定位到open64.c上了</p>
<p><strong>此处,有一个巨坑,关于/usr/src/debug/, 这个里面glibc不全啊</strong></p>
<p><strong>只是为了调试需要,所集成的一部分glibc实现,同时需要注意我们使用的C库一般都是发行版提供</strong></p>
<p><strong>需要去看glibc源码才能真正看清楚</strong></p>
<h2 id="二-分析一个系统调用的源码"><a href="#二-分析一个系统调用的源码" class="headerlink" title="二, 分析一个系统调用的源码"></a>二, 分析一个系统调用的源码</h2><p>那么,现在就来刺激的了,分析系统调用的源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sysdeps/unix/sysv/linux/open64.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copyright (C) 1991-2018 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">   This file is part of the GNU C Library.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">   modify it under the terms of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License as published by the Free Software Foundation; either</span></span><br><span class="line"><span class="comment">   version 2.1 of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">   Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License along with the GNU C Library; if not, see</span></span><br><span class="line"><span class="comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sysdep-cancel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;not-cancel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OFF_T_MATCHES_OFF64_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTRA_OPEN_FLAGS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTRA_OPEN_FLAGS O_LARGEFILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,</span></span><br><span class="line"><span class="comment">   a third argument is the file protection.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line">			 mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strong_alias (__libc_open64, __open64)</span><br><span class="line">libc_hidden_weak (__open64)</span><br><span class="line">weak_alias (__libc_open64, open64)</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !IS_IN (rtld)</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__open64_nocancel (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line">			      mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">strong_alias (__libc_open64, __open64_nocancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">libc_hidden_def (__open64_nocancel)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OFF_T_MATCHES_OFF64_T</span></span><br><span class="line">strong_alias (__libc_open64, __libc_open)</span><br><span class="line">strong_alias (__libc_open64, __open)</span><br><span class="line">libc_hidden_weak (__open)</span><br><span class="line">weak_alias (__libc_open64, open)</span><br><span class="line"></span><br><span class="line">strong_alias (__open64_nocancel, __open_nocancel)</span><br><span class="line">libc_hidden_weak (__open_nocancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><em>备注: 在本目录下,其实是有4个于open()有关的文件,分别是open.c,open64.c, openat.c, openat64.c</em></p>
<p><em>但是,事实上他们是指不同层次,不同平台上的系统调用,剥开之后,最后都是openat()函数</em></p>
<p><em>但是,我本机是64为,所以是封装的64位openat()函数文件,即open64.c</em></p>
<p>我们可以一行一行分析这个函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function open() -&gt; __libc_open64()</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">2</span> __libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line"><span class="number">3</span> &#123;</span><br><span class="line"><span class="number">4</span>   <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>   <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line"><span class="number">7</span>     &#123;</span><br><span class="line"><span class="number">8</span>       va_list arg;</span><br><span class="line"><span class="number">9</span>       va_start (arg, oflag);</span><br><span class="line"><span class="number">10</span>      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line"><span class="number">11</span>      va_end (arg);</span><br><span class="line"><span class="number">12</span>    &#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span>  <span class="keyword">return</span> SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line"><span class="number">15</span>			 mode);</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> strong_alias (__libc_open64, __libc_open)</span><br><span class="line"><span class="number">18</span> strong_alias (__libc_open64, __open)</span><br><span class="line"><span class="number">19</span> libc_hidden_weak (__open)</span><br><span class="line"><span class="number">20</span> weak_alias (__libc_open64, open)</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> strong_alias (__open64_nocancel, __open_nocancel)</span><br><span class="line"><span class="number">23</span> libc_hidden_weak (__open_nocancel)</span><br></pre></td></tr></table></figure>
<p><em>上面的C是典型的GNU风格,两个空格,看的我想打人,写惯了K&amp;R C的人表示脑子疼</em></p>
<p>6 ~ 8行就是简单的参数判断,我们可以略过</p>
<p>其实你可能会奇怪,好端端的<code>open()</code>,系统调用怎么变成了,<code>__libc_open64()</code></p>
<p><strong>注意17 ~ 23行的宏,他们将别名实现为了宏,事实上,调用open(),就是__libc_open64()</strong></p>
<p>那么,重心来了,就是14行,它实现了,<code>SYSCALL_CANCEL</code>宏来进行操作</p>
<p>看到这里,这一部分文件就足够了,我们已经知道了<code>__libc_open64()</code>只是一个warpper function了</p>
<p>这便是TLPI中第一部分的,Warpper函数</p>
<h2 id="三-Warpper-Function如何Warpper"><a href="#三-Warpper-Function如何Warpper" class="headerlink" title="三,Warpper Function如何Warpper"></a>三,Warpper Function如何Warpper</h2><p>我们要去看warpper function如何工作,也就是去看它是如何进行封装,并且完成用户/系统态切换的</p>
<p>首先,Warrpper的过程,各个平台上都应该是一致的,所以我们去看,sysdeps/unix/sysdeps.h</p>
<p>这个文件中都是宏定义,那么,我们就一步一步来吧,我将宏定义的顺序整理了一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort the macros 已知 SYSCALL_CANCEL</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_CANCEL(...) \</span></span><br><span class="line">  (&#123;									     \</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> sc_ret;							     \</span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P) 						     \</span><br><span class="line">      sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__); 			     \</span><br><span class="line">    <span class="keyword">else</span>								     \</span><br><span class="line">      &#123;									     \</span><br><span class="line">	<span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC ();			     \</span><br><span class="line">	sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);			     \</span><br><span class="line">        LIBC_CANCEL_RESET (sc_cancel_oldtype);				     \</span><br><span class="line">      &#125;									     \</span><br><span class="line">    sc_ret;								     \</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">(&#123; <span class="keyword">long</span> <span class="keyword">int</span> sc_ret; <span class="keyword">if</span> (SINGLE_THREAD_P) sc_ret = INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); <span class="keyword">else</span> &#123; <span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC (); sc_ret = INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); LIBC_CANCEL_RESET (sc_cancel_oldtype); &#125; sc_ret; &#125;);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_DISP(b,...) \</span></span><br><span class="line">  __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL__INLINE_SYSCALL_NARGS(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode)(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL__INLINE_SYSCALL_NARGS_X (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span></span><br><span class="line"><span class="comment">// 这是最神奇的宏,一个计数宏,计算参数的宏</span></span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL4(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span></span><br></pre></td></tr></table></figure>
<p>所以,同一处理后,获取到的是<code>__INLINE_SYSCALLn(name, arguments...); [n个参数]</code></p>
<p>然后用同文件下的宏继续处理后,可以获取到 <code>INLINE_SYSCALL (name, nr, arguments...);</code></p>
<p>既然我们分析的是x86_64平台上系统调用的实现,那么我们就去x86_64下找东西吧</p>
<p>下面找得到的就是具体的上述宏平台上的依赖实现了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/unix/sysv/linux/x86_64/sysdeps.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL(name, nr, args...) \</span></span><br><span class="line">  (&#123;									      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL (name, , nr, args);	      \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))	      \</span><br><span class="line">      &#123;									      \</span><br><span class="line">	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \</span><br><span class="line">	resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;				      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define a macro with explicit types for arguments, which expands inline</span></span><br><span class="line"><span class="comment">   into the wrapper code for a system call.  It should be used when size</span></span><br><span class="line"><span class="comment">   of any argument &gt; size of long int.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> INLINE_SYSCALL_TYPES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL_TYPES(name, nr, args...) \</span></span><br><span class="line">  (&#123;									      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL_TYPES (name, , nr, args);  \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))	      \</span><br><span class="line">      &#123;									      \</span><br><span class="line">	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \</span><br><span class="line">	resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;				      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INTERNAL_SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL(name, err, nr, args...)			\</span></span><br><span class="line">	internal_syscall#<span class="meta">#nr (SYS_ify (name), err, args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INTERNAL_SYSCALL_NCS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL_NCS(number, err, nr, args...)			\</span></span><br><span class="line">	internal_syscall#<span class="meta">#nr (number, err, args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall0(number, err, dummy...)			\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number)							\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall1(number, err, arg1)				\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;			\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1)						\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall2(number, err, arg1, arg2)			\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;			\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2)				\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall3(number, err, arg1, arg2, arg3)		\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;			\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3)			\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall4(number, err, arg1, arg2, arg3, arg4)		\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4);			 	\</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;			\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4)		\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall5(number, err, arg1, arg2, arg3, arg4, arg5)	\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    TYPEFY (arg5, __arg5) = ARGIFY (arg5);			 	\</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4);			 	\</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg5, _a5) <span class="keyword">asm</span> (<span class="string">"r8"</span>) = __arg5;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;			\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),		\</span><br><span class="line">      <span class="string">"r"</span> (_a5)								\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall6(number, err, arg1, arg2, arg3, arg4, arg5, arg6) \</span></span><br><span class="line">(&#123;									\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;					\</span><br><span class="line">    TYPEFY (arg6, __arg6) = ARGIFY (arg6);			 	\</span><br><span class="line">    TYPEFY (arg5, __arg5) = ARGIFY (arg5);			 	\</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4);			 	\</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3);			 	\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2);			 	\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1);			 	\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg6, _a6) <span class="keyword">asm</span> (<span class="string">"r9"</span>) = __arg6;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg5, _a5) <span class="keyword">asm</span> (<span class="string">"r8"</span>) = __arg5;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;			\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;			\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),		\</span><br><span class="line">      <span class="string">"r"</span> (_a5), <span class="string">"r"</span> (_a6)						\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);			\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;						\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>此文件内容超多,所以我们只截取其中重要的部分</strong></p>
<p>我们可以看到下面这样的实现流程:</p>
<p><code>INLINE_SYSCALL(name, nr, args...)</code> -&gt; <code>INTERNAL_SYSCALL(name, ,nr, args)</code> -&gt;</p>
<p><code>internal_syscall##nr (SYS_ify (name), err, args);</code></p>
<p>下面就是具体对应不同参数的函数实现了,其中实现了,产生软中断,进入内核态,然后参数入寄存器,传参</p>
<p>那么,这一些列函数中我们可以看到:</p>
<p><strong>参数只能是6个,可以传递7个参数,一个是系统调用名,是吗? 错的,传递的参数只是建议范围内为7个</strong></p>
<p><strong>其余的呢? 入栈, Register参数就7个罢了</strong></p>
<p>我们来具体看看函数实现,尤其是其中的内联汇编部分(其实我汇编很烂,Intel都不行,ATT就更不多说了)</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (							\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>							\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)							\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),		\</span><br><span class="line">      <span class="string">"r"</span> (_a5), <span class="string">"r"</span> (_a6)						\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其他的不多说,其中最重要的就是, <code>&quot;syscall\n\t&quot;</code>这个东西了</p>
<blockquote>
<p>在32位机上,使用<code>int 0x80</code> 第128中断号,陷入内核,进行系统调用</p>
</blockquote>
<blockquote>
<p>在ARM上,使用<code>swi</code>执行陷入内核</p>
</blockquote>
<blockquote>
<p>唯独少有人说x86_64平台上的软中断,也就是<code>syscall</code>中断向量</p>
</blockquote>
<p>你没有听错,这个B就是叫syscall中断vector,qtmd,看了我半天</p>
<p><em>不过这也是我内核基础不扎实的恶果,深感惭愧</em></p>
<p>至此,Warpper function的任务顺利完成,下来就需要切换到内核态处理了.</p>
<p>我们接下来就得看LinuxKernel的代码了</p>
<h2 id="四-关于中断的小了解"><a href="#四-关于中断的小了解" class="headerlink" title="四,关于中断的小了解"></a>四,关于中断的小了解</h2><p>中断是在引入保护模式(protect mode)之后很重要的一个特性,以此来陷入内核,进入内核态</p>
<p><strong>一般的fault,会重复指令,syscall会vector+1, 执行下一条</strong></p>
<p><em>此处,中断的内容,同样是Kernel重要知识,当然我还是不够清楚,不能清晰地翻出汇编指令解析</em></p>
<p><em>但是,syscall的流程还是比较清楚的</em></p>
<p>首先,来看内核的中断处理例程</p>
<p>既然是64位,肯定看arch/x86/entry/entry_64.S</p>
<p>简单说一下,entry这几个文件</p>
<blockquote>
<p>entry_32.S是32位机使用的</p>
</blockquote>
<blockquote>
<p>entry_64.S是64位机使用的,但是说实话,很像是拼凑的,凌乱不堪,就在32基础上改得,32看着十分清晰</p>
</blockquote>
<blockquote>
<p>entry_64_compat.S 是兼容的,在64位机器上按照32的形式运行,用的是32位的接口</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64_trampoline)</span><br><span class="line">	.....</span><br><span class="line">	<span class="keyword">movq</span>	$entry_SYSCALL_64_stage2, %rdi</span><br><span class="line">	JMP_NOSPEC %rdi</span><br><span class="line">END(entry_SYSCALL_64_trampoline)</span><br><span class="line"></span><br><span class="line"><span class="meta">	.popsection</span></span><br><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64_stage2)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line">	popq	%rdi</span><br><span class="line">	<span class="keyword">jmp</span>	entry_SYSCALL_64_after_hwframe</span><br><span class="line">END(entry_SYSCALL_64_stage2)</span><br><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">swapgs</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">	<span class="keyword">movq</span>	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">	/* Construct struct pt_regs on stack */</span><br><span class="line">	pushq	$__USER_DS			/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">	pushq	PER_CPU_VAR(rsp_scratch)	/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">	pushq	%r11				/* pt_regs-&gt;flags */</span><br><span class="line">	pushq	$__USER_CS			/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">	pushq	%rcx				/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line"><span class="meta">GLOBAL</span>(entry_SYSCALL_64_after_hwframe)</span><br><span class="line">	pushq	%rax				/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">	PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line"></span><br><span class="line">	TRACE_IRQS_OFF</span><br><span class="line"></span><br><span class="line">	/* IRQs are off. */</span><br><span class="line">	<span class="keyword">movq</span>	%rax, %rdi</span><br><span class="line">	<span class="keyword">movq</span>	%rsp, %rsi</span><br><span class="line">	<span class="keyword">call</span>	do_syscall_64		/* returns with IRQs disabled */</span><br><span class="line">	</span><br><span class="line">	.........</span><br><span class="line">END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>
<p>其中删去了很多内容,但是整个思路是:</p>
<ol>
<li><p>去中断向量表查看中断偏移量(很惭愧,没找到),</p>
</li>
<li><p>对应的entry_64.S进行section的调用</p>
</li>
<li><p>对于syscall就是调用到了(其中还有两个函数被我删掉了,仅保留了核心)<code>entry_SYSCALL_64</code></p>
<p><em>其中ENTRY(), END(),都是宏用来进符号表中的函数声明</em></p>
</li>
<li><p>在<code>entry_SYSCALL_64</code>中调用了<code>do_syscall_64()</code></p>
</li>
</ol>
<p><code>do_syscall_64()</code>这是一个外部函数,在common.c中的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/entry/common.c</span></span><br><span class="line"></span><br><span class="line">__<span class="function">visible <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	enter_from_user_mode();</span><br><span class="line">	local_irq_enable();</span><br><span class="line">	ti = current_thread_info();</span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY)</span><br><span class="line">		nr = syscall_trace_enter(regs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * NB: Native and x32 syscalls are dispatched from the same</span></span><br><span class="line"><span class="comment">	 * table.  The only functional difference is the x32 bit in</span></span><br><span class="line"><span class="comment">	 * regs-&gt;orig_ax, which changes the behavior of some syscalls.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nr &amp;= __SYSCALL_MASK;</span><br><span class="line">	<span class="keyword">if</span> (likely(nr &lt; NR_syscalls)) &#123;</span><br><span class="line">*		nr = array_index_nospec(nr, NR_syscalls);</span><br><span class="line">*		regs-&gt;ax = sys_call_table[nr](regs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中标上*的两句就是最重要的,它会去sys_call_table[]全局例程调用表中查找我们想要调用的例程</p>
<p>为什么有这样的机制呢?</p>
<p>因为中断号页只有255,所有的系统调用共享syscall对应的入口,所以我们需要一个数组</p>
<p><strong>在都进入内核态之后,根据每个系统调用的唯一编号来进行唯一标识与识别</strong></p>
<p>这个编号的确定,是有各种各样的宏确定的,<strong>同时要保证LinuxKernel与glibc的编号一致,</strong></p>
<p>我们可以来看这两个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/include/asm/unistd_64.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line">.........</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>
<p>确定好编号后,就可以访问指定函数的地址了</p>
<h2 id="五-真正的系统调用实现"><a href="#五-真正的系统调用实现" class="headerlink" title="五,真正的系统调用实现"></a>五,真正的系统调用实现</h2><p>我们可以查看此文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /include/linux/syscalls.h</span></span><br><span class="line"><span class="comment">// 此文件实现了所有系统调用的声明以及SYSCALL_DEFINEx宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span></span><br><span class="line">		__attribute__((alias(__stringify(__se_sys##name))));	\</span><br><span class="line">	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__))	\</span></span><br><span class="line">	&#123;								\</span><br><span class="line">		<span class="keyword">long</span> ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="line">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span><br><span class="line">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span><br><span class="line">		<span class="keyword">return</span> ret;						\</span><br><span class="line">	&#125;								\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line">	</span><br><span class="line">			.........</span><br><span class="line">	<span class="comment">/* fs/eventfd.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_eventfd2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fs/eventpoll.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct epoll_event __user *event)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> <span class="keyword">sigset_t</span> __user *sigmask,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">size_t</span> sigsetsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fs/fcntl.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_dup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fildes)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_dup3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> oldfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> newfd, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fcntl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fcntl64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line">				</span><br><span class="line">				.......</span><br></pre></td></tr></table></figure>
<p>经常看到其他文档上说到sys_open()是入口,这其实都是早期的说法,实际上,是由宏生成真正的函数定义</p>
<p>同时我们可以根据,此文件中的注释,找到根本意义上的Syscall定义,比如<code>epoll_ctl()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following function implements the controller interface for</span></span><br><span class="line"><span class="comment"> * the eventpoll file that enables the insertion/removal/change of</span></span><br><span class="line"><span class="comment"> * file descriptors inside the interest set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">		struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> full_check = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	error = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">	    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	f = fdget(epfd);</span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line">................</span><br></pre></td></tr></table></figure>
<p><strong>上述即为真真正正最底层,最底层<code>epoll_ctl()</code>的实现</strong></p>
<p><strong>至此,我们便真正追踪到了,系统调用的实现了,其他系统调用的源码,查看方法同理</strong></p>
<h2 id="六-扩展阅读"><a href="#六-扩展阅读" class="headerlink" title="六,扩展阅读"></a>六,扩展阅读</h2><p><a href="https://my.oschina.net/fileoptions/blog/908682" target="_blank" rel="noopener">关于ARM实现</a></p>
<p><a href="https://zhuanlan.zhihu.com/c_144857088" target="_blank" rel="noopener">关系不大,但有价值的glibc分析(脚本Warpper)</a></p>
<p>书籍推荐: &lt; Linux内设设计与实现 &gt;        (PS: 虽然是基于2.6.32,但还是很有意义)</p>
<h2 id="其他的一些闲杂事情"><a href="#其他的一些闲杂事情" class="headerlink" title="其他的一些闲杂事情"></a>其他的一些闲杂事情</h2><p>主要还是最近烦,感觉自己要玩了(beibei狗),看TLPI,突发奇想,想看看syscall的真正实现</p>
<p>但是网上都是ARM,X86是实现(2.6.32),没有X86_64,4版本内核的实现</p>
<p>于是乎我决定来稿一搞</p>
<p>但是自身水平又不行,所以也比较磕绊,其实分析也是不完整的</p>
<p>最后,系统调用的退出,如何添加自己的系统调用这些内容都是不全面的</p>
<p><strong>还是自己学习不扎实,后面落实后会补充的,起码这两天干的事,还是挺有意义的</strong></p>
<p><em>接下来,回归主要任务,TLPI作为辅修,是时候C3P就绪了</em></p>
<p><strong>虽然很烦,但还是那句话:</strong></p>
<blockquote>
<p>生命转瞬即逝, 没时间丧,Fighting!</p>
</blockquote>
<p>June 8, 2018 2:00 AM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2018/06/07/TLPI/syscall/" data-id="cjlrvdcjc003k84nryi99d036" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3awW7jMAxF0fz/T7ubWQxQWLmPtAuIuloZdWzppIBCUvx88Lj+G3d315//fU2eenjIkCFjW8a1HGTi9ZvXs9zd5WuTIUPGOQyyiPU1uctJfG0yZMiQQTbWdNH8PTJkyJDxBmMdUPK/yJAhQ0YtieWFs36w+GIuLkOGjA0ZvOr+99evnG/IkCFjK8YVDlLurwWLtfX8e1aGDBmjGbUElQeCj5XSSPOHDBkyhjI65f5abFY7EP0CliFDxgEMXj5Lm7rShXK8DBkyzmSQZLJThqvVAskXKkOGjNmM+PZyAn7cSJDk2SRVlyFDxq4MUhrjYWIaUPKSHNpeZciQMZRBUtN0g043XB5WfnmPDBkyhjL4kWSaiKZJbPol3ubiMmTIGMdIk0/eJNE5YEg3ZRkyZJzASI8Sa0EhCfjSUDL+n8iQIWNDBj8grLVTrJdYQ94msTJkyBjN4G1b6aKfSm7jXFyGDBmDGHykYWI6Za3ZQoYMGacxSEpJWsH44viMvBQoQ4aMqYxOMwTfOvuh5Je7MmTIOIBRa/BKU820kMffI0OGjBMYT22ObzSZoffLkCFjKOMKx1PPpolucIQpQ4aMcYzOwUC6vfYTZhkyZJzMIEtMN9xOIMjX8KktSIYMGdsyeHLbT2vT5jD0WyFDhgwZYStYrRhXO2yQIUOGjFrWuw7s0pARPStDhowDGLXW0nTiNJEOtm8ZMmSMZqSBWj9krB1t9n8GZMiQsSHjBw4bDcsHpAGLAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/Syscall/">Syscall</a></div><div class="post-nav"><a class="pre" href="/2018/06/10/C++/pointer_and_reference/">指针与引用</a><a class="next" href="/2018/06/04/C/Expert_C_Programming/error_jmp/">聊一聊C中的异常处理</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/编程语言/">编程语言</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/Vim/">Vim</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/EvilCrow/">EvilCrow</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/力量的源泉/">力量的源泉</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/C-C/">C/C++</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/standard/" style="font-size: 15px;">standard</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/hole/" style="font-size: 15px;">hole</a> <a href="/tags/experience/" style="font-size: 15px;">experience</a> <a href="/tags/C-Primer/" style="font-size: 15px;">C++Primer</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Shellscript/" style="font-size: 15px;">Shellscript</a> <a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/effc/"><星月夜>_Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Evilcrow/linux_setting/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/tools/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/Expert_C_Programming/data_mem/"><咸鱼书>_运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/two_level_array/">一个C语言指针的问题让我翻车</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/C++/C3P_VI/">VI Function</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/SQL/MySQL_start/">MySQL入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/C++/C_C++_expr/">C/C++坑点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/10/C++/pointer_and_reference/">指针与引用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>