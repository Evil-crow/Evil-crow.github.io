<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>&lt;咸鱼书&gt;_数组与指针 | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">&lt;咸鱼书&gt;_数组与指针</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">&lt;咸鱼书&gt;_数组与指针</h1><div class="post-meta">May 29, 2018<span> | </span><span class="category"><a href="/categories/C-C/">C/C++</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-声明与定义"><span class="toc-number">1.</span> <span class="toc-text">一, 声明与定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-左右值的问题"><span class="toc-number">2.</span> <span class="toc-text">二, 左右值的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-array与pointer的访问模式"><span class="toc-number">3.</span> <span class="toc-text">三, array与pointer的访问模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-交叉访问会出现什么结果"><span class="toc-number">4.</span> <span class="toc-text">四,交叉访问会出现什么结果?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-定义为指针-声明为数组"><span class="toc-number">4.1.</span> <span class="toc-text">1. 定义为指针, 声明为数组.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-定义为数组-声明为指针"><span class="toc-number">4.2.</span> <span class="toc-text">2. 定义为数组, 声明为指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-array与pointer到底何时相同-何时不同"><span class="toc-number">5.</span> <span class="toc-text">五, array与pointer到底何时相同,何时不同?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-实际上-为什么会发生混淆"><span class="toc-number">6.</span> <span class="toc-text">六, 实际上,为什么会发生混淆?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-专门来说一说字符串指针与其他的指针"><span class="toc-number">7.</span> <span class="toc-text">七, 专门来说一说字符串指针与其他的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-一段深刻的代码"><span class="toc-number">8.</span> <span class="toc-text">八, 一段深刻的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-多维指针与Iliffc向量-指针数组"><span class="toc-number">9.</span> <span class="toc-text">九, 多维指针与Iliffc向量(指针数组)</span></a></li></ol></div></div><div class="post-content"><p><em>数组与指针, 真的是C中, 甚至于C++中也是让人头大的问题, 脑子疼</em></p>
<p><em>但是越难的东西就越要去干他一发,不是吗?</em></p>
<h2 id="一-声明与定义"><a href="#一-声明与定义" class="headerlink" title="一, 声明与定义"></a>一, 声明与定义</h2><p>声明与定义我们之前一直都在说,都是实际上这两个的区别还是很大的.</p>
<p>主要表现在以下方面:</p>
<p><strong>定义: 定义实际上是特殊的声明, 他告诉编译器有这个变量及其类型,并且为他分配空间</strong></p>
<p><strong>声明: 声明则是表明存在这个变量,它的定义在别处.比如extern,表示变量在别处</strong></p>
<p>我们常见的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> a[];      <span class="comment">// 这是合法的, 表明a数组定义在别处,所以不需要提供数组长度</span></span><br></pre></td></tr></table></figure>
<h2 id="二-左右值的问题"><a href="#二-左右值的问题" class="headerlink" title="二, 左右值的问题"></a>二, 左右值的问题</h2><p>这其实也是个历史遗留问题, 很多时候我们都说过左右值,但是从没有详细的谈过</p>
<p>记得最早扯到左右值, 其实是在&lt; C Primer Plus &gt; 中的”=”运算符中,其声明:</p>
<p>只有可修改的左值,可以放在赋值运算符的左侧,可修改的左值是C中新定义的概念</p>
<blockquote>
<p>左值: 指的是可以获取到地址的内容, 所以编译期一定要获取到期内容</p>
</blockquote>
<blockquote>
<p>右值: 只需要获取到它的值即可.只有运行时才能取得值.</p>
<p>所以全局变量在赋值时,要求是const experssion(常量表达式)</p>
<p>数组的维数也是这么要求的,不过在C99推出VLA后,这些都是过去式了.</p>
</blockquote>
<p><em>那么,C中可修改的左值到底是为了什么呢?</em></p>
<p><strong>它的存在是为了遏制数组名赋值的滥用,后面会提到,数组名会被编译器改为首元素的地址</strong></p>
<p><strong>bingo! 数组名也是左值(可以获取到其地址),但它并不是可修改的左值,可修改的左值就是为处理此情况</strong></p>
<h2 id="三-array与pointer的访问模式"><a href="#三-array与pointer的访问模式" class="headerlink" title="三, array与pointer的访问模式"></a>三, array与pointer的访问模式</h2><p>看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"Linux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *a = <span class="string">"Linux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问模式</span></span><br><span class="line"><span class="keyword">char</span> temp = a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>上面的代码中,两种类型肯定不能同时存在!</p>
<p>这里,我们只是来说说编译器的思维模式,如何来进行访问:</p>
<p><strong>对于数组, 取得a的地址, 然后根据下标i以及数据类型,获取偏移量, 直接拿到即可</strong></p>
<p><strong>对于指针, 其实只有8个字节(64位), 那么,访问时,a[4] #=&gt; *(a+4), 先取出a中的内容</strong></p>
<p><strong>然后 a中的地址 + sizeof(类型) * 下标 =&gt; 地址, 取出内容</strong></p>
<p>所以说,指针访问多了一次dereference, 多访问了一次, 在现在来看是无法影响效率的.但是指针更加灵活.</p>
<h2 id="四-交叉访问会出现什么结果"><a href="#四-交叉访问会出现什么结果" class="headerlink" title="四,交叉访问会出现什么结果?"></a>四,交叉访问会出现什么结果?</h2><p><em>此处的交叉访问是我自己拟出来的一个概念, 主要是下面两种情况:</em></p>
<h3 id="1-定义为指针-声明为数组"><a href="#1-定义为指针-声明为数组" class="headerlink" title="1. 定义为指针, 声明为数组."></a>1. 定义为指针, 声明为数组.</h3><p>定义为指针,声明为数组,也是不少人干过的事, 会发生什么样的结果.我们先看看这张图:</p>
<p>上面这幅图就表明了,定义为指针,声明为数组:</p>
<p>**会导致,访问时, 将地址解释为数据,牛头不对马嘴, 此处将地址部分解释为ASC II 字符,显然是不正确的.</p>
<p><strong>严重情况下,修改地址, 这个指针的提领内容就永远也访问不到了</strong></p>
<h3 id="2-定义为数组-声明为指针"><a href="#2-定义为数组-声明为指针" class="headerlink" title="2. 定义为数组, 声明为指针"></a>2. 定义为数组, 声明为指针</h3><p>同上面,先来看看图:</p>
<p>上面这幅图就表明了,定义为数组,声明为指针:</p>
<p><strong>会导致, 访问时, 将数组内容解释为地址,然后去这个地址提领操作, 显然也是不正确的,</strong></p>
<h2 id="五-array与pointer到底何时相同-何时不同"><a href="#五-array与pointer到底何时相同-何时不同" class="headerlink" title="五, array与pointer到底何时相同,何时不同?"></a>五, array与pointer到底何时相同,何时不同?</h2><p>上面说了这么多,我们就直截了当的说清,到底什么时候数组与指针相同,什么时候指针不能等同数组!</p>
<p>总结如下:</p>
<p><strong>1. 数组总是可以写为指针的访问形式, 这是基于底层实现的基地址 + 偏移量的原因</strong></p>
<p><strong>2. 在进行函数传递参数的时候, 数组一律被转化为指针,这是为了效率考虑,而且大多数时候</strong></p>
<p><strong> 我们真的不需要完整的数组内容可可拷贝, 只是对其中一部分内容感兴趣</strong></p>
<p><strong>3. 另外一点,就是数组名表示数组首元素地址</strong></p>
<p>上面这些,就是数组与指针相同的时候,其他时候都是不同的.</p>
<p><strong>编译器看变量的时候, 一个变量就是地址, 一个指针就是地址的地址</strong></p>
<h2 id="六-实际上-为什么会发生混淆"><a href="#六-实际上-为什么会发生混淆" class="headerlink" title="六, 实际上,为什么会发生混淆?"></a>六, 实际上,为什么会发生混淆?</h2><p>这个锅,要甩在出版社身上了!</p>
<p>众所周知, &lt; the C Programming Language &gt; 中提到数组与指针</p>
<blockquote>
<p>As format parementers in function definition<br>(翻页)<br>char s[]<br>is same as<br>char *s;</p>
</blockquote>
<p>OK, 就是这么简单地一件事, 当然锅不能全甩在出版社身上了,开个玩笑而已.</p>
<h2 id="七-专门来说一说字符串指针与其他的指针"><a href="#七-专门来说一说字符串指针与其他的指针" class="headerlink" title="七, 专门来说一说字符串指针与其他的指针"></a>七, 专门来说一说字符串指针与其他的指针</h2><p>简单地说,字符指针是个骚东西.</p>
<p><strong>因为,它可以根据后面的NUL来标识终止.这样的话,就不需要额外的变量来控制边界访问</strong></p>
<p>比如: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure>
<p>其中便是直接通过终止字符来标识, 不然一般二维指针,是需要两个变量标识的;</p>
<p>另外一点就是,使用字符指针,会自动分配空间.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"linux"</span>;     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">f</span> = &#123;</span><span class="number">3.14</span>, ...&#125;; <span class="comment">// Error , 需要分配空间</span></span><br></pre></td></tr></table></figure>
<p>另外对于指针数组进行赋值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str[] = &#123;</span><br><span class="line">    &#123;<span class="string">"Linux"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"Xiyou"</span>&#125;,</span><br><span class="line">&#125;;                     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *integer[] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;                    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>其他类型的指针数组赋值, 安心用数组名赋值好吧 (滑稽;</p>
<p>实际上所谓的字符串,只是一个字符指针,但是其他的类型,可都是需要分配空间的呀! ! !</p>
<h2 id="八-一段深刻的代码"><a href="#八-一段深刻的代码" class="headerlink" title="八, 一段深刻的代码"></a>八, 一段深刻的代码</h2><p>下面这段代码,可以帮助你搞清楚,数组与指针之间的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"NieR:Automata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_array</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p\n"</span>,&amp;<span class="built_in">array</span>, &amp;(<span class="built_in">array</span>[<span class="number">0</span>]), &amp;(<span class="built_in">array</span>[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p, %p\n"</span>,&amp;ptr, &amp;(ptr[<span class="number">0</span>]), &amp;(ptr[<span class="number">1</span>]), ++ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func_array(str);</span><br><span class="line">    func_pointer(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p\n"</span>,&amp;str[<span class="number">0</span>], &amp;(str[<span class="number">0</span>]), &amp;(str[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#=&gt; </span><br><span class="line"><span class="number">0x7ffdf69e1978</span>, <span class="number">0x400630</span>, <span class="number">0x400631</span></span><br><span class="line"><span class="number">0x7ffdf69e1978</span>, <span class="number">0x400631</span>, <span class="number">0x400632</span>, <span class="number">0x400631</span></span><br><span class="line"><span class="number">0x400630</span>, <span class="number">0x400630</span>, <span class="number">0x400631</span></span><br></pre></td></tr></table></figure>
<p>我们现在来解释输出结果:</p>
<p>首先,因为用的是指针,所以第1,2行第1列与后面不同, 后面的地址都是str在静态区的内容</p>
<p><strong>而前面就是实际上str指针的地址, 这就是提领的意义</strong></p>
<p>另外后面,的不同,是因为操作的非原子性, 可以让睡一会儿,或者上个锁处理.</p>
<p><strong>另外,整天说传值, 传址, 实际上哪有传地址,地址其实也是值,函数参数传递就是进行值传递!</strong></p>
<h2 id="九-多维指针与Iliffc向量-指针数组"><a href="#九-多维指针与Iliffc向量-指针数组" class="headerlink" title="九, 多维指针与Iliffc向量(指针数组)"></a>九, 多维指针与Iliffc向量(指针数组)</h2><p>之前很多人整天说<strong>二维数组与二维指针相同, 头给你打烂</strong></p>
<p>实际上,,二维指针与二维数组区别很大,另外加上一个Iliffc向量(便是数组指针)</p>
<p>具体情况是下面这样:</p>
<ul>
<li><p>二维数组: int a[4][5]  #=&gt; 20x4 个字节</p>
</li>
<li><p>指针数组: int *a[5] #=&gt; 5x8 个字节</p>
</li>
<li><p>二维指针: int **a #=&gt; 8个字节</p>
</li>
</ul>
<p>他们进行访问的方法也就不同了:</p>
<ul>
<li><p>二维数组直接在基地址上进行偏移量的求取即可.</p>
</li>
<li><p>指针数组在一次偏移量上找到对应指针,然后提领到其他内存位置, 在进行一次偏移量求取</p>
</li>
<li><p>所以,二维指针进行量此提领,然后去找偏移量找到数据.</p>
</li>
</ul>
<p>那么,在存取效率上,有什么问题?</p>
<p><strong>推荐使用数组指针, 因为数组指针可以保证字符串个数,但是对于每个字符串不限制长度</strong></p>
<p><strong>这样就可以大幅度减少系统中的内存开销,节省空间.</strong></p>
<p><strong>一般情况下,我们尽量能不使用字符串拷贝,就不拷贝,而是引用它的指针,因为拷贝的开销太大了</strong></p>
<p><strong>但是,从另一方面来说,锯齿状数组,即Iliffc向量,因为大小不同,会将数据存在不同的页面上</strong></p>
<p><strong>另一方面考虑来说, 不停的换页,会严重降低效率</strong></p>
<p>说到这里,其实让我想起来了当年小组面试,康康抛出来的一个问题:</p>
<p><em>如何动态分配二维数组 ?</em></p>
<p>今天我就再来说一说:</p>
<p>两种方法:</p>
<p>一.</p>
<p>1&gt; 循环两次分配,先分配一维数组的i个指针的空间, </p>
<p>2&gt; 然后分配二维数组中的j个指针空间.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标分配char a[m][n]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **a = <span class="literal">NULL</span>;</span><br><span class="line">a = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    a[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br></pre></td></tr></table></figure>
<p>二,</p>
<p>另外一种办法,就是直接分配总大小的空间,然后再去分配一维数组指针,缺点是整个全部分配</p>
<p>优点是可以分配出连续的内存来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> **a = <span class="literal">NULL</span>;</span><br><span class="line">a = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * m);</span><br><span class="line">a[<span class="number">0</span>] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * m * n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    a[i] = a[<span class="number">0</span>] + n * i * <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br></pre></td></tr></table></figure>
<p>一次性分配,也只是指最后一步的时候,一次性分配,前面还是一样的</p>
<p>切记:<strong>多维数组的动态分配类似于递归的形式,一层一层分配进去, 一层一层释放出来,严格按照栈的顺序</strong></p>
<p>十, 数组转换为指针形式是非递归的</p>
<p>上面说过,数组是可以转换为指针的,切记,<strong>这是非递归的</strong></p>
<p><strong>意思便是: 二维数组,会变成指针数组,而非二维指针</strong></p>
<p>所以,我们可以说,<strong>main()的原型参数是指针数组,而并非函数指针,这样便可以减少空间开销(锯齿形数组</strong></p>
<hr>
<p>PS: </p>
<p>就说点其他的话吧, 最近真的是脑子疼,没一点劲</p>
<p>各种各样的恶心事,就不说了,康康刚才和我聊了一会儿</p>
<p>让我感受到了时间的紧迫性,</p>
<p>然而我整天都是在逃避,哈哈,可笑得很.整天作逼清高,就他妈一个王八蛋</p>
<p>玩锤子 !</p>
<p>好了,丧这些就够了,在丧下去就真的完了,已经菜到忘了多维数组的动态内存分配了,靠</p>
<p>菜菜菜,有什么办法呢?</p>
<p>干他妈一票大的!</p>
<p>明天, 不,今天开始吧.</p>
<p>C的内容到此为止,后面就是C++, 服务器, 内核(按重要性次序)</p>
<p>反正怎么说,咸鱼书后面的内容,燃我看得很害怕, 大公司面试的问题,是真的可怕,这还是20多年前的问题</p>
<p>真的是感受到恐惧,唉,以前就是个瓜皮,现在开始尽力弥补吧</p>
<p>有这样一句话:</p>
<blockquote>
<p>生命转瞬即逝, 没时间丧      - 单读</p>
</blockquote>
<p>所以,明天,不是今天开始,大干一场!</p>
<p>May 30, 2018 12:39 AM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2018/05/29/C/Expert_C_Programming/array_pointer/" data-id="cji1ogti10064u0nryw7yl2xs" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACu0lEQVR42u3a0W7CMAwFUP7/pzdpT0hAd23HsEmnTxMqrU+Q4uwmt1t8ff1c93/ff5Lck9z/+N3H67Zx4eHh4bVKv35cUkpSaE6tPvnlEODh4eGt8ZJmMGkYyWBdV9X7Fh4eHt5necnUfF1cFTMfFDw8PLzP8iZBQ3U4qotyPDw8vPfzktfnjSEpMWkJST3HshY8PDy8hV2kv/P3+v4eHh4eXmtXPbny+KC3JZY3gydPxsPDw1vgJQFrMutOYogkFqkOYlQoHh4eXovXCwLyaboXTCQtIVr04+Hh4X2I1+w245ijFwQ/WUzj4eHhHeXlr7z+pPeaJIDIkaMRxcPDw4t58wV0L3ittqXr+18ODR4eHt4Cr1dWde6tTujX91SDDDw8PLyzvHzizqf1yRI5GYLCYOHh4eGt8ZIt/8nWV150/vzoXXh4eHjLvN4mfR7sVg945dHDy6fh4eHhLfPySKK3TZUHFtW1caHv4eHh4R3iTUKEPJjIDxlUjyYU8mk8PDy8Ma+3eO0Fr70Vbz4EeHh4eO/k9RavvcVuvnyf/wB4eHh4G7zJoYHJsrgXE1ePLODh4eFt8PJy86B2crQrb0LJz4CHh4e3zcun72qheRycb6HlkTEeHh7eWd48lj11OKBXT7T1hYeHh3eUVz0mlafC1Vi22kgK9eDh4eEt8JLrVEGTVlSNkvHw8PD2ePnknhRX/WSyKI9aDh4eHt4bedUmkU/rx5bCSW14eHh4R3nzJW9vEs+3tXrtBA8PD2+P15tw86MD1WNb+fOrxxTw8PDwzvLyiKF3lCq5f3IU7JeBxsPDw1vjVQ9XVRfH+YTe6114eHh4/4U33yrbaBLlzoOHh4e3xsvD08nhgCT+KMS4eHh4eGu8Uweeqi2kGhmXF9x4eHh4C7zJv/pJKflg5fFxNSzGw8PDO8T7BvZQ72RDujeWAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/编程语言/">编程语言</a><a href="/tags/C/">C</a><a href="/tags/Expert-C-Programming/">Expert_C_Programming</a></div><div class="post-nav"><a class="pre" href="/2018/05/30/C/Expert_C_Programming/c_link/">&lt;咸鱼书&gt;_链接那点事</a><a class="next" href="/2018/05/28/C/Expert_C_Programming/c_technology/">&lt;咸鱼书&gt;_一些常见的技巧</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNzA2OS8xMzYwNQ=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Binutils/">Binutils</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Binutils/man/">man</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP/">CSAPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shellscript/">Shellscript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VimScript/">VimScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shellscript/">shellscript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/一些经验/">一些经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文档/">文档</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/装机/" style="font-size: 15px;">装机</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/力量的源泉/" style="font-size: 15px;">力量的源泉</a> <a href="/tags/Computer/" style="font-size: 15px;">Computer</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/File-system/" style="font-size: 15px;">File system</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Linux-C/" style="font-size: 15px;">Linux_C</a> <a href="/tags/Coding/" style="font-size: 15px;">Coding</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/项目文档/" style="font-size: 15px;">项目文档</a> <a href="/tags/English/" style="font-size: 15px;">English</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/计算机系统/" style="font-size: 15px;">计算机系统</a> <a href="/tags/Exprt-C-Programming/" style="font-size: 15px;">Exprt_C_Programming</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/Other/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/C/Expert_C_Programming/data_mem/"><咸鱼书>_运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/C/Expert_C_Programming/error_jmp/">聊一聊C中的异常处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/30/C/Expert_C_Programming/c_link/"><咸鱼书>_链接那点事</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/C/Expert_C_Programming/array_pointer/"><咸鱼书>_数组与指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/C/Expert_C_Programming/c_technology/"><咸鱼书>_一些常见的技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/tools/size/">Binutils の size</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/C/Expert_C_Programming/c_statement/"><咸鱼书>_C声明问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/C/Expert_C_Programming/little_thing_of_C/"><咸鱼书>_C中的一些小细节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/17/C/Expert_C_Programming/C_origin/"><咸鱼书>_C的本源</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>