<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Ruby学习笔记(三) | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Ruby学习笔记(三)</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Ruby学习笔记(三)</h1><div class="post-meta">Feb 6, 2018<span> | </span><span class="category"><a href="/categories/Ruby/">Ruby</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-类-class"><span class="toc-number">1.</span> <span class="toc-text">一 类 (class)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见类方法"><span class="toc-number">1.1.</span> <span class="toc-text"> 常见类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">1.2.</span> <span class="toc-text"> 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的创建"><span class="toc-number">1.3.</span> <span class="toc-text"> 类的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-实例变量与实例方法"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 实例变量与实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-存取器"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 存取器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-self变量"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 self变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-类方法"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-常量"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-类变量"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-修饰方法的关键字"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 修饰方法的关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展类"><span class="toc-number">1.4.</span> <span class="toc-text"> 扩展类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-给原有类添加方法"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 给原有类添加方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-继承"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-alias与undef"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 alias与undef</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聊一聊”单例类”"><span class="toc-number">1.5.</span> <span class="toc-text">聊一聊”单例类”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-模块-module"><span class="toc-number">2.</span> <span class="toc-text">二 模块 (module)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模块的作用与意义"><span class="toc-number">2.1.</span> <span class="toc-text"> 模块的作用与意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-提供命名空间"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 提供命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-利用Mix-in进行扩展"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 利用Mix-in进行扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建模块"><span class="toc-number">2.2.</span> <span class="toc-text"> 创建模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-常量"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-方法"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mix-in"><span class="toc-number">2.3.</span> <span class="toc-text"> Mix-in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#来聊聊模块方法查找规则"><span class="toc-number">2.4.</span> <span class="toc-text"> 来聊聊模块方法查找规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类与Mix-in"><span class="toc-number">2.5.</span> <span class="toc-text"> 类与Mix-in</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象程序设计"><span class="toc-number">3.</span> <span class="toc-text">面向对象程序设计</span></a></li></ol></div></div><div class="post-content"><p><em>类是Ruby作为面向对象语言的特征之一,模块又是Ruby的特色花样之一,就来聊聊这两方面内容吧</em></p>
<h2 id="一-类-class"><a href="#一-类-class" class="headerlink" title="一 类 (class)"></a>一 类 (class)</h2><p>类是面向对象中,定义对象的数据与行为的结构</p>
<p>类就像是对象的雏形或设计图,决定了对象的行为</p>
<h3 id="常见类方法"><a href="#常见类方法" class="headerlink" title=" 常见类方法"></a><1> 常见类方法</1></h3><p>下面介绍几个常用的方法:</p>
<ol>
<li><p>类方法: new方法</p>
<p> 既然对象是类的实例,那么,类便提供了,创建对象的方法,即为new方法</p>
<p> 同时,数值类,字符串类,数组可以使用字面量来进行初始化</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = Array.new</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">"asa"</span>]</span><br><span class="line">c = <span class="number">123</span></span><br><span class="line">d = hash.new</span><br><span class="line">p d <span class="comment">#=&gt; &#123;&#125;</span></span><br><span class="line">p a <span class="comment">#=&gt; []</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法: class方法</p>
<p> 既然每个对象都是类的实例,那么如何判断改对象的类,使用class方法,可以判断出对象的类</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [ ]</span><br><span class="line">hash = &#123; &#125;</span><br><span class="line">p hash.<span class="keyword">class</span> <span class="comment">#=&gt; "Hash"</span></span><br><span class="line">p array.<span class="keyword">class</span> <span class="comment">#=&gt; "Array"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法: instance_of?</p>
<p> 用于判断某个对象是否属于某方法,和以前的约定一样返回值为真假的以”?”结尾</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = []</span><br><span class="line">p array.instance_of?(Array)   <span class="comment">#=&gt; true</span></span><br><span class="line">p array.instance_of?(String)  <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title=" 继承"></a><2> 继承</2></h3><p>继承是类中很重要一个概念</p>
<p><strong>继承 : 通过扩展已定义的类来创建新的类</strong></p>
<p>那么,继承有什么作用呢?</p>
<ol>
<li><p>再不影响原有类功能的前提下,追加新的功能</p>
</li>
<li><p>可以重定义父类中的功能,使名称相同的方法产生不同的结果</p>
</li>
<li><p>在已有的功能上,追加新的处理,扩展已有功能</p>
</li>
</ol>
<p><strong>新创建的类叫子类(subclass),被继承的类叫父类(superclass)</strong></p>
<p><strong>注意: Ruby不支持父类的多重继承,即一个类只能继承一次,只能有一个父类,Ruby保证了单一继承关系</strong></p>
<p><strong>那么,有时候就是需要多个类的功能该怎么办,后面自有办法,使用模块(module)</strong></p>
<p><strong>Basicobject类shiRuby中最最基础的类,仅仅包含了作为一个类最低限度的方法</strong></p>
<p><strong>所以,Ruby中一般默认的继承类是Object类,我们可以看看这两个类中方法的比较</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p BasicObject.instance_methods</span><br><span class="line"><span class="comment">#=&gt; [:!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]</span></span><br><span class="line"></span><br><span class="line">p Object.instance_methods</span><br><span class="line"><span class="comment">#=&gt; [:remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :public_send, :instance_variable_defined?, :singleton_method, :instance_variable_set, :method, :public_method, :extend, :define_singleton_method, :to_enum, :enum_for, :&lt;=&gt;, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :object_id, :send, :display, :to_s, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variable_get, :instance_variables, :!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]</span></span><br></pre></td></tr></table></figure>
<p><strong>而我们一般创建类时,默认的继承类是Object类,所以,这个类就不能再继承其他类了,</strong></p>
<p><strong>违背单一继承的规则,会抛出异常</strong></p>
<p>下面是一张Ruby中常见类的继承关系图</p>
<p><img src="http://owzoakbc5.bkt.clouddn.com/Screenshot_20180207_182032.png" alt=""></p>
<p>现在,再介绍一种方法,用来辨别继承关系</p>
<p>4.is_a?方法</p>
<p>is_a? 方法用来辨别接收者是否是参数的子类</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p Array.is_a?(Object)  <span class="comment">#=&gt; true</span></span><br><span class="line">p Array.is_a?(String)  <span class="comment">#=&gt; false</span></span><br><span class="line">p Array.is_a?(Array)   <span class="comment">#=&gt; false</span></span><br><span class="line">a = []</span><br><span class="line">p a.is_a?(Array)       <span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="类的创建"><a href="#类的创建" class="headerlink" title=" 类的创建"></a><3> 类的创建</3></h3><p>上面说了那么多,类的创建是怎么做的呢?</p>
<p>类定义的语法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_name</span></span></span><br><span class="line">  class_definition</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中需要介绍的一个是,<strong>initialize方法</strong></p>
<p>类创建一个对象的new方法,就是以initialize方法进行定义的</p>
<p><strong>虽然调用的是new方法,但是再类的定义中就是用的initialize方法</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name = <span class="string">"Ruby"</span>)</span></span></span><br><span class="line">    @name = name   </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"Hello I'm <span class="subst">#&#123;@name&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = HelloWorld.new(<span class="string">"SinCrow"</span>)</span><br><span class="line">n = HelloWorld.new</span><br><span class="line">m.hello   <span class="comment">#=&gt; Hello I'm SinCrow</span></span><br><span class="line">n.hello   <span class="comment">#=&gt; Hello I'm Ruby</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中,new方法便是由initialize方法定义的,传参也是同一道理</p>
<h4 id="3-1-实例变量与实例方法"><a href="#3-1-实例变量与实例方法" class="headerlink" title="3.1 实例变量与实例方法"></a>3.1 实例变量与实例方法</h4><p>之前总是说实例变量,实例方法.到底是怎么使用的呢?</p>
<p><strong>1.实例变量,就是在类的定义中,@var形式的变量,可以在类的实例方法中通用</strong></p>
<p><strong>算是类中实例方法间的全局变量,只要在同一个实例中,就可以超越方法的局限,任意引用,修改实例变量</strong></p>
<p><strong>2.实例方法,顾名思义,实例才能调用的方法,即对象的方法</strong></p>
<p><strong>备注: 不同的实例的实例变量值是可以不同的,而且这些实例变量都是存在的,只要实例存在,就不会消失</strong></p>
<p><strong>反观,局部变量的作用域,生命周期都是在方法中,只能在方法内部使用,方法调用结束,局部变量释放</strong></p>
<h4 id="3-2-存取器"><a href="#3-2-存取器" class="headerlink" title="3.2 存取器"></a>3.2 存取器</h4><p>那么,现在就有一个问题,关于在实例方法中的实例变量,既然是在类中定义的,随着实例存在</p>
<p>如果,需要使用实例变量怎么办呢?</p>
<p>很容易就可以构建下面的两个实例方法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(myname = <span class="string">"Ruby"</span>)</span></span></span><br><span class="line">    @name = myname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span></span><br><span class="line">    @name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name=</span><span class="params">(modify_name)</span></span></span><br><span class="line">    @name = modify_name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是,<strong>name=方法,一定是紧紧相连的,不然就不能定义为方法名</strong></p>
<p>但是,很没意思啊,整天都要些存取器的内容,每个实例变量都要写,所以Ruby提供了定义方法</p>
<table>
<thead>
<tr>
<th>存取器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attr_reader</td>
<td>读方法(name方法)</td>
</tr>
<tr>
<td>attr_writer</td>
<td>写方法(name=方法)</td>
</tr>
<tr>
<td>attr_accessor</td>
<td>皆有</td>
</tr>
</tbody>
</table>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:a</span></span><br><span class="line"><span class="keyword">attr_writer</span> <span class="symbol">:b</span></span><br><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:c</span>, <span class="symbol">:d</span></span><br></pre></td></tr></table></figure>
<p>这样定义就可以了,用法相当于直接调用name方法与name=方法</p>
<h4 id="3-3-self变量"><a href="#3-3-self变量" class="headerlink" title="3.3 self变量"></a>3.3 self变量</h4><p>介绍一个十分特殊的变量,<strong>self变量</strong></p>
<p>以前就提到过,Ruby是完全的面向对象,</p>
<p>实际上,在顶部,是main对象,平时调用的函数式方法也是有接收者的</p>
<p>只不过是不在意接收者的信息,实际上函数式方法的接收者,就是self</p>
<p><strong>我不清楚Java的this指针与self有何区别</strong></p>
<p><strong>但是,Ruby是解释性语言,所以,他的self严格的与上下文息息相关</strong></p>
<p><strong>self变量,其实就是指当前的层次</strong></p>
<p>来看看,下面的例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">self</span>    <span class="comment">#=&gt; main</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfTest</span></span></span><br><span class="line">  p <span class="keyword">self</span>    <span class="comment">#=&gt; SelfTest</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_test</span></span></span><br><span class="line">    p <span class="keyword">self</span>   <span class="comment">#=&gt; #&lt;SelfTest:0x0000000001c48500&gt;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = SelfTest.new</span><br><span class="line">m.method_test</span><br></pre></td></tr></table></figure>
<p><strong>对于最外层顶部来讲,就是main,</strong></p>
<p><strong>对于类来讲,就是类名</strong></p>
<p><strong>对于实例方法来讲,就是本实例,而本实例是存在于内存上的,所以就是地址了</strong></p>
<p>那么,self变量有什么用呢?</p>
<p><strong>可以进行变量自身的调用,而且,可以隐式调用,Ruby缺省条件下,接收者就是self</strong></p>
<p>看下面这个例子:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(myname)</span></span></span><br><span class="line">    @name = myname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"Hello ,My name is <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>实例方法中的hello,获取到,name变量的值,但是,name并不是传进来的参数</p>
<p><strong>而且,这个方法是没有Bug的!</strong></p>
<p><strong>其实这个name是 #{self.name},换成{@name}也是可以的</strong></p>
<p>那么,平时调用函数式方法,是不是也可以加上self呢?</p>
<p><strong>答案是,不行!,函数式方法,多为private(私有)方法,必须是隐式调用</strong></p>
<p><strong>注意: 调用写方法的时候,不能隐式调用,必须显式调用,不然会有很诡异的事情发生呦,来看下面的例子</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"hello"</span>   <span class="comment">#=&gt; name视为变量</span></span><br><span class="line"><span class="keyword">self</span>.name = <span class="string">"hello"</span>  <span class="comment">#=&gt; name= 视为写方法</span></span><br></pre></td></tr></table></figure>
<p>这样懂了吧? (滑稽)</p>
<h4 id="3-4-类方法"><a href="#3-4-类方法" class="headerlink" title="3.4 类方法"></a>3.4 类方法</h4><p>我们在这里就不多纠缠了,类方法就是给类对象使用的方法</p>
<p><strong>对,实际上我们区分方法按照接收者去区分</strong></p>
<p><strong>但是,实际上,Ruby所有的方法都应该叫做实例方法,每一个对象都有类</strong></p>
<p><strong>类方法调用者(接收者)是类,各个类,都是Class类的实例对象</strong></p>
<p>下面介绍4种Ruby类方法的定义形式</p>
<ol>
<li><p>单例方法形式</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在<span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span>已存在条件下</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; Hello</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">	puts <span class="string">"I'm Class method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>class上下文中,引用self形式</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">	  puts <span class="string">"Class method"</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显式标明类名,进行实例方法形式的定义</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>.<span class="title">name</span><span class="params">(myname)</span></span></span><br><span class="line">	puts <span class="string">"my name is <span class="subst">#&#123;myname&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等效于3,类名可以用self变量取代,但是,self切记不能省略,<strong>不然会视为实例方法</strong></p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">name</span></span></span><br><span class="line">	puts <span class="string">"My name is Ruby"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然提到了四种定义的形式,准确的来讲应该是三种,其中<strong>第四种用的最多,单例方法的形式,重复量太大</strong></p>
<p><strong>而将,类方法以实例方法的形式定义,很方便</strong></p>
<p><strong>后面还会有通过模块的方法进行类方法定义,也是很方便的方法</strong></p>
<p><strong>备注: class &lt;&lt; 类名 ~ end 的写法为单例类定义,其中的方法是单例方法,后面会详解</strong></p>
<h4 id="3-5-常量"><a href="#3-5-常量" class="headerlink" title="3.5 常量"></a>3.5 常量</h4><p>类中肯定也是可以定义常量的,一般常量为大写,通过”::”进行访问,类似于类方法的访问</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">VERSION = <span class="string">"v1.0"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p Hello::VERSION <span class="comment">#=&gt; "v1.0"</span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-类变量"><a href="#3-6-类变量" class="headerlink" title="3.6 类变量"></a>3.6 类变量</h4><p>类变量,类似于实例变量,是在整个类的实例方法间都可以任意引用,修改的变量</p>
<p><strong>但是,区别于实例变量,类变量是子类继承后仍然能够存在的变量,存储期更长</strong></p>
<p><strong>实例变量,是随着实例对象存在而存在.那么,类变量就是随着类对象存在而存在</strong></p>
<p><strong>@@class_var是存在于类中的,所以几个实例对象,是共享这个类变量的</strong></p>
<p><strong>,但是,类变量定义存取器,不能使用attr系列方法,attr系列只能给实例变量使用</strong></p>
<p>可以看看下面的例子:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  @@hello_count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(myname = <span class="string">"Ruby"</span>)</span></span></span><br><span class="line">    @name = myname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"my name is <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line">    @@hello_count += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">count</span></span></span><br><span class="line">    @@hello_count</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = Hello.new</span><br><span class="line">b = Hello.new(<span class="string">"NIOH"</span>)</span><br><span class="line">c = Hello.new(<span class="string">"Uncharted"</span>)</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 0</span></span><br><span class="line">a.hello</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 1</span></span><br><span class="line">b.hello</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 2</span></span><br><span class="line">c.hello</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="3-7-修饰方法的关键字"><a href="#3-7-修饰方法的关键字" class="headerlink" title="3.7 修饰方法的关键字"></a>3.7 修饰方法的关键字</h4><p>曾经看过C,C种存在着,static关键字,可以用来修饰函数,使函数只能在本文件中调用,常说的:</p>
<p><strong>具有内部链接的静态类型函数,链接,存储期,作用域是C中进行控制的几个关键点</strong></p>
<p><strong>随着代码组织的不同,相应的关键字发生变化(hepangda说的,不是我说的)</strong></p>
<p>在,Ruby中有这样三个修饰方法的关键字:<strong>public, private, protected</strong></p>
<p>之前被国内的概念误导了很长时间,</p>
<p><strong>他们死要纠缠访问与调用这两个概念, , ,</strong></p>
<p>其实,这三个关键字分得很清楚,可以用下面几句话概括:</p>
<p><strong>1. public以外的两类方法,都不能被显式的实例对象调用</strong></p>
<p><strong>2. public方法为默认属性,可以任意访问调用,无论是类还是实例对象,或是同父类的实例对象</strong></p>
<p><strong>3. protected方法相当于类之内的public方法,可以被随意调用,即所谓的被同父类的实例对象访问</strong></p>
<p><strong>接上一条,也就是指可以在其他的方法中,调用protected方法,其他方法的实例对象是self</strong></p>
<p><strong>4. private方法就更好说了,只能进行隐式的调用,即自身调用(self)</strong></p>
<p><strong>即private是这个类进行私有实现所使用的,只能隐式的被self调用,不能显示地指定接收者</strong></p>
<p><strong>要写,只能 private_method_test,不能obj.private_method_test</strong></p>
<p><strong>有一句话,挺恰当的,private私有方法是内部实现所使用的,对其他的类(非同父类),实例都是不可见的</strong></p>
<p>在Ruby社区提问,得到了这样比较好的答案</p>
<p><del>访问和调用扯半天,真的是拖裤子放P</del></p>
<h3 id="扩展类"><a href="#扩展类" class="headerlink" title=" 扩展类"></a><4> 扩展类</4></h3><h4 id="4-1-给原有类添加方法"><a href="#4-1-给原有类添加方法" class="headerlink" title="4.1 给原有类添加方法"></a>4.1 给原有类添加方法</h4><p>很简单,就是定义和类名相同的类,如果是已存在的类,则会追加方法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">count_word</span></span></span><br><span class="line">    array = split(<span class="regexp">/\s+/</span>)    <span class="comment">#=&gt; array = self.spilt(/\s+/)</span></span><br><span class="line">    <span class="keyword">return</span> array.size</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">"hello world"</span></span><br><span class="line">p str.count_word <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2 继承"></a>4.2 继承</h4><p>前面说了很多次继承了,下面是继承的语法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> &lt; SuperClass</span></span><br><span class="line">  class_definition</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>还是要提醒一点,Ruby缺省继承为Object类</strong></p>
<h4 id="4-3-alias与undef"><a href="#4-3-alias与undef" class="headerlink" title="4.3 alias与undef"></a>4.3 alias与undef</h4><p>这两个关键字在其他语言中可能也用过</p>
<p><strong>alias就是Linux中命令别名的命令,这里同义</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span>  new_name    old_name</span><br><span class="line"><span class="keyword">alias</span> <span class="symbol">:new_symbol</span> <span class="symbol">:old_symbol</span></span><br></pre></td></tr></table></figure>
<p><strong>undef在C中应该也是使用过的,用来取消命令别名</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">undef</span> 方法名</span><br><span class="line"><span class="keyword">undef</span> <span class="symbol">:</span>方法名</span><br></pre></td></tr></table></figure>
<p>用来删除方法定义的,例如:我们可以在子类中删除不需要的父类方法定义,并且重新定义</p>
<h3 id="聊一聊”单例类”"><a href="#聊一聊”单例类”" class="headerlink" title="聊一聊”单例类”"></a>聊一聊”单例类”</h3><p>之前,进行类方法的定义时说过,使用单例类的形式进行类方法的定义</p>
<p>什么叫单例类?</p>
<p><strong>单例类,指的就是,并非对类定义进行修改,只是针对这一个实例进行方法等的修改,只对这一个实例有效</strong></p>
<p><strong>所以叫单例类,单例类中的方法叫单例方法</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">"world"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; str1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"I'm hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str1.hello <span class="comment">#=&gt; "I'm hello"</span></span><br><span class="line">str2.hello <span class="comment">#=&gt; undefined method `hello' for "world":String (NoMethodError)</span></span><br></pre></td></tr></table></figure>
<p>上面的例子即可说明hello方法对于同类实例str1与str2而言,只对str1有效,所以叫做单例方法</p>
<p>那么,我们定义类方法,与单例(实例)又有什么关系呢?</p>
<p><strong>这里就可以清晰地说明: Ruby中一切皆对象,类都是Class类的实例,所以使用单例方法,就是添加类方法</strong></p>
<p>前面说过,Ruby部支持父类多重继承(没有Java diao,对吧?(滑稽))</p>
<p>但是,Ruby却很好的处理了一定情况下的需求,靠得就是模块(module)</p>
<p>下面,我们来仔细看看模块(module)</p>
<h2 id="二-模块-module"><a href="#二-模块-module" class="headerlink" title="二 模块 (module)"></a>二 模块 (module)</h2><h3 id="模块的作用与意义"><a href="#模块的作用与意义" class="headerlink" title=" 模块的作用与意义"></a><1> 模块的作用与意义</1></h3><p>模块为什么存在,从下面两点来说明:</p>
<h4 id="1-1-提供命名空间"><a href="#1-1-提供命名空间" class="headerlink" title="1.1 提供命名空间"></a>1.1 提供命名空间</h4><p>之前其实一直没有注意过,但是,一旦工程量比较大的时候,命名空间就十分重要了.</p>
<p>系统的讲,命名空间就是指<strong>对方法,常量,类的名称进行区分和管理的单位</strong></p>
<p><strong>使用模块(module),天生进行命名空间的区分,互相不污染</strong></p>
<p>举个简单的例子:</p>
<p>很火爆的网络Web服务器Nginx</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_kqueue_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_eventport_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_devpoll_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_epoll_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_select_module;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_init_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_event_module_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_event_process_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_events_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_connections</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_use</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_debug_connection</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ngx_event_core_create_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_core_init_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用ngx作为统一的命名空间,当然这里只是举例子,实际上Ruby中使用模块可以避免命名空间冲突的问题</p>
<p><strong>A模块中的foo方法,与B模块中的foo方法完全是两个方法</strong></p>
<p>我们使用类似于<strong>调用类中的方法的放法来调用模块方法,模块名.方法名,也叫模块函数</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileTest.exist?(<span class="string">"/usr?bin/ruby"</span>)</span><br><span class="line">FileTest.size(<span class="string">"/usr?bin/ruby"</span>)</span><br></pre></td></tr></table></figure>
<p>如果,在当前命名空间中不与模块函数冲突,那么,可以使用include来省略模块名</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> Math</span><br><span class="line">sin(<span class="number">30</span>)</span><br><span class="line">sqrt(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意,一定是不发生命名空间冲突的时候,可以使用include进行命名空间的合并,反之,抛出异常</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sin</span></span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> Math</span><br><span class="line">p sin(<span class="number">5</span>)   </span><br><span class="line"><span class="comment">#&gt; in `sin': wrong number of arguments (given 1, expected 0) (ArgumentError)from test.rb:6:in `&lt;main&gt;'</span></span><br></pre></td></tr></table></figure>
<p><strong>这个错误,会在继承机制中进行解答,见下</strong></p>
<h4 id="1-2-利用Mix-in进行扩展"><a href="#1-2-利用Mix-in进行扩展" class="headerlink" title="1.2 利用Mix-in进行扩展"></a>1.2 利用Mix-in进行扩展</h4><p><strong>前面提到过,Ruby只支持单一父类继承,那么问题来了,如果碰到需要继承多个类的功能时怎么办?</strong></p>
<p>答案是,<strong>使用模块来进行类功能的扩展</strong></p>
<p>可以将模块作为通用功能的实现,来完成多个功能类似的类的扩展</p>
<p><strong>Mix-in指的就是,将通用功能设计在模块中实现,之后include,则module的变量,方法都可以在类中使用</strong></p>
<p>那么,套用前人总结的经验,一般Mix-in解决这两种问题:</p>
<p><strong>1. 虽然两个类拥有相似的功能,但是不惜望将他们作为相同的类来考虑时</strong></p>
<p><strong>2. Ruby不支持父类的多重继承,因此无法对已继承的类添加共通的功能的时候</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mix-<span class="keyword">in</span> Example</span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></span><br><span class="line">  module_difinition</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span></span></span><br><span class="line">  <span class="keyword">include</span> MyModule</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span></span></span><br><span class="line">  <span class="keyword">include</span> MyModule</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="创建模块"><a href="#创建模块" class="headerlink" title=" 创建模块"></a><2> 创建模块</2></h3><p>上面说了这么多,下面说说模块的用法吧</p>
<p>首先,使用<strong>module</strong>关键字</p>
<p>至于语法,与class是一致的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">module_name</span></span></span><br><span class="line">  module_difination</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>下面是一个模块的使用示范</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Hello</span></span></span><br><span class="line">  Version = <span class="string">"v1.0"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  module_function <span class="symbol">:hello</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p Hello::Version    <span class="comment">#=&gt; "v1.0</span></span><br><span class="line">Hello.hello         <span class="comment">#=&gt; "Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> Hello</span><br><span class="line">p Version           <span class="comment">#=&gt; "v1.0"</span></span><br><span class="line">hello               <span class="comment">#=&gt; "Hello"</span></span><br></pre></td></tr></table></figure>
<p>现在来说说上面中的一些之前没有见到过的东西</p>
<h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><p>常量的用法同类中的常量(并非类变量)</p>
<p><strong>模块中,不能出现类变量,实例变量(如有不懂,看前面)</strong></p>
<h4 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h4><p>模块中的方法,定义是同类方法的</p>
<p>但是,需要注意的是:</p>
<p><strong>如果要想使模块函数对外可见,使其可以使用”模块名.方法名”的形式调用</strong></p>
<p><strong>这里指的是,使用模块进行模块函数的调用,任何包含此模块的上下文都可以直接调用模块函数</strong></p>
<p><strong>那么,一定要使用module_function方法,进行模块函数的声明,使其对外可见,参数是模块函数的符号名</strong></p>
<p>另外,</p>
<p><strong>模块方法中的self,是当前模块对象</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">HelloName</span></span></span><br><span class="line">  p <span class="keyword">self</span>              <span class="comment">#=&gt; "HelloName"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    p <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  module_function <span class="symbol">:hello</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">HelloName.hello       <span class="comment">#=&gt; "HelloName"</span></span><br></pre></td></tr></table></figure>
<p><strong>区别于类的不同之处：类中的实例方法，self只当前的对象(实例,有实体)</strong></p>
<p><strong>而模块函数中的self指模块对象,因为模块不具有实例</strong></p>
<p><strong>但是,模块中的self一旦Mix-in之后,便表示类对象,所以,Mix-in一般不建议模块使用self</strong></p>
<h3 id="Mix-in"><a href="#Mix-in" class="headerlink" title=" Mix-in"></a><3> Mix-in</3></h3><p>聊聊Mix-in及其相关</p>
<p>首当其冲的是,判断一个类是否Mix-in了某模块,使用include? 方法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ClassName.<span class="keyword">include</span>?(kernel)   <span class="comment">#=&gt; "true"</span></span><br></pre></td></tr></table></figure>
<p>现在,就来说说一个很关键的,类的继承机制</p>
<p><img src="http://owzoakbc5.bkt.clouddn.com/Screenshot_20180215_033346.png" alt=""></p>
<p><strong>在类中include的模块会做为虚拟的父类进行方法的继承,以及方法的查找</strong></p>
<p>来看一个例子:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">TestModule</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line">  <span class="keyword">include</span> TestModule</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p TestClass.ancestors   <span class="comment">#=&gt; "[TestClass, TestModule, Object, Kernel, BasicObject]"</span></span><br><span class="line">p TestClass.superclass  <span class="comment">#=&gt; "Object"</span></span><br></pre></td></tr></table></figure>
<p>如上所示,TestModule模块作为虚拟的”父类”进入了TestClass的继承顺序列表中</p>
<p>但是,TestClass的直接父类还是Object类</p>
<p><strong>就像这样,我们可以使用模块功能来实现构建多个功能类似的扩展类的需求</strong></p>
<h3 id="来聊聊模块方法查找规则"><a href="#来聊聊模块方法查找规则" class="headerlink" title=" 来聊聊模块方法查找规则"></a><4> 来聊聊模块方法查找规则</4></h3><ol>
<li><p>原类中定义了同名方法时,优先使用类中的方法</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">	puts <span class="string">"M#hello"</span>      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">	puts <span class="string">"C#hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.new.hello <span class="comment">#=&gt; "C#合理咯"</span></span><br></pre></td></tr></table></figure>
<p> 原因就是: <strong>p C.ancestors #=&gt; [C, M, Object, Kernel, BasicObject]</strong></p>
<p> <strong>类的继承顺序上,C类在M模块之前</strong></p>
</li>
<li><p>在同一个类中,优先使用最后一个包含的模块</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">	puts <span class="string">"M1#hello"</span>      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">	puts <span class="string">"M2#hello"</span>      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line">  <span class="keyword">include</span> M2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.new.hello  <span class="comment">#=&gt; "M2#hello"</span></span><br></pre></td></tr></table></figure>
<p> <strong>同理,看继承顺序: [C, M2, M1, Object, Kernel, BasicObject]</strong></p>
</li>
<li><p>嵌套模块和类时,继承也是线性的</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M3</span></span></span><br><span class="line">  <span class="keyword">include</span> M2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line">  <span class="keyword">include</span> M3</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p C.ancestors <span class="comment">#=&gt; "[C, M3, M2, M1, Object, Kernel, BasicObject]"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多次使用include嵌套同一模块,忽略已经包含的模块</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line">  <span class="keyword">include</span> M2</span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p C.ancestors  <span class="comment">#=&gt; "[C, M2, M1, Object, Kernel, BasicObject]"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>之前提到单例方法时,都是使用 “ class &lt;&lt; 实例 ~ end “ 的形式定义单例方法</p>
<p>对于类(Class类的实例)来讲,就是进行类方法的定义</p>
<p>出了使用这种形式以外,我们还可以灵活使用模块,来实现单例方法</p>
<p><strong>同之前的例子,看一下这个例子</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="comment">#module_function :hello</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">"world"</span></span><br><span class="line">str1.extend(Hello)</span><br><span class="line">p str1.hello    <span class="comment">#=&gt; "hello"</span></span><br><span class="line">p str2.hello    <span class="comment">#=&gt; "nil"in `&lt;main&gt;': undefined method `hello' for 										  "world":String (NoMethodError)</span></span><br></pre></td></tr></table></figure>
<p><strong>将单例方法,定义成为模块函数,之后对单例使用Object#extend方法,进行单例方法的扩展即可</strong></p>
<p><strong>注意: 其中的module_funcation是不能有的,他会将模块函数定义为某唉进行调用的外部函数</strong></p>
<p><strong>如果将类作为实例,那自然就是类方法了,</strong></p>
<p>现在,我们可以系统的来说:</p>
<p><strong>使用模块,一方面可以利用Mix-in特性来,扩展类.另一方面,可以使用Object#extend方法来扩展单例</strong></p>
<p><strong>即,使用include可以帮助我们突破继承的限制.extend可以跨过类,使用模块来扩展对象</strong></p>
<h3 id="类与Mix-in"><a href="#类与Mix-in" class="headerlink" title=" 类与Mix-in"></a><5> 类与Mix-in</5></h3><p>之前说过很多次类方法</p>
<p>我们可以这样理解类方法:</p>
<p><strong>1. Class类的实例方法 (任何类都是Class类的实例)</strong></p>
<p><strong>2. 类对象的单例方法(只对此类适用,对其他类不适用,这些类都作为对象来考虑)</strong></p>
<p>所以,在扩展类的方面,我们这样综合类与模块</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"hello,method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Bye</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bye</span></span></span><br><span class="line">    puts <span class="string">"Bye,method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">  <span class="keyword">include</span> Hello         <span class="comment">#=&gt; include将Hello模块扩展为类的实例方法</span></span><br><span class="line">  extend Bye            <span class="comment">#=&gt; extend将Bye扩展为类的类方法</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = Test.new</span><br><span class="line">p m.hello</span><br><span class="line">p Test.bye</span><br></pre></td></tr></table></figure>
<p>又扯到之前提到过的: <strong>其实Ruby中一切皆对象,所谓的类方法其实也是实例方法</strong></p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>这部分,我也不时啃的十分清楚,说说下面几个问题:</p>
<ol>
<li><p>什么是对象</p>
</li>
<li><p>封装与多态</p>
</li>
<li><p>鸭子类型</p>
</li>
</ol>
<hr>
<p><em>来说点其他的吧,寒假学习,确实容易放松,这篇博客拖了很长时间</em></p>
<p><em>一方面是理解起面向对象,走了一点弯路,另一方面还是太皮了</em></p>
<p><em>不过现在搞得差不多了,Ruby整个语法框架差不多了</em></p>
<p><em>后面也就是运算符,异常处理,块的内容,理解消化挺快的</em></p>
<p><em>接下来,就是一系列Ruby默认类的内容了,很方便,有各种黑魔法(可能就拖起来看了,唉~)</em></p>
<p><em>之前逛得太多了,下来改回归Kernel的任务了</em></p>
<p><em>驱动,CS:APP还是要好好对待,估计到开学勉强差不多</em></p>
<p><em>对了,还有算法题,那就好好写写BFS与DFS吧,写的深入一点</em></p>
<p>February 15, 2018 3:41 AM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://yoursite.com/2018/02/06/Ruby/Ruby3/" data-id="cji91l2gf002txgnrtq8f3p6h" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABy0lEQVR42u3aQY6EIBAF0L7/pZ1kth3wV4GMkzxWnWjj00UFfvH5xOP6HfOro3u+r87v3zBwcXGXudd0fHOTh31fzeccGXBxcc9z54+8mSL4V06/seHi4r6Mu1K25nPi4uL+X+58AVTd5ODi4r6fm4OqQUk+2+a9Gi4u7gK3Gpg+8fvBfBcXF7fIvYpjpQzNN0jR03FxcY9w5xMllaQXgiTR6rDM4eLiPsztTZE3StcPcxRKGC4u7gPc/HBVEl70otWbj4iLi3uEu7d45cVx/jluPh8uLu4fcau5ZXUp04tOcHFxz3CTtznTzyl0g3FxcY9w82gjD0arBymil8TFxT3OrTZIclB1zTUspri4uEe4+ZYmjzNWuh64uLhv4O7a2FQp1ZAUFxf3JLeQqsYLl5XDWFGhxMXFfZjbY/UarvlxruGcuLi4B7n5liZvwxSOU+SRLi4u7kFuPqoFKy+LS60UXFzcrdxqQVlf6FRbLM0jHbi4uMvcvHglU/cC03w7hIuLe5JbLV69AxkbljK4uLgv4y41R1sByvCcCC4u7su4vbbrhsUNLi7ucW61uFQD1pUopLlXw8XFXeD2AtOk4ZovgHqRKy4u7gPcH8nXlYxc6+AiAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/编程语言/">编程语言</a></div><div class="post-nav"><a class="pre" href="/2018/03/15/ShellScript/sh4/">ShellScipt拾遗</a><a class="next" href="/2018/02/06/Ruby/Ruby2/">Ruby学习笔记(二)</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Binutils/">Binutils</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Binutils/man/">man</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/编程语言/">编程语言</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP/">CSAPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shellscript/">Shellscript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/System-Programming/">System Programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VimScript/">VimScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shellscript/">shellscript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/一些经验/">一些经验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文档/">文档</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux-C/" style="font-size: 15px;">Linux_C</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/力量的源泉/" style="font-size: 15px;">力量的源泉</a> <a href="/tags/Computer/" style="font-size: 15px;">Computer</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a> <a href="/tags/File-system/" style="font-size: 15px;">File system</a> <a href="/tags/装机/" style="font-size: 15px;">装机</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Coding/" style="font-size: 15px;">Coding</a> <a href="/tags/TLPI/" style="font-size: 15px;">TLPI</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/项目文档/" style="font-size: 15px;">项目文档</a> <a href="/tags/English/" style="font-size: 15px;">English</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/计算机系统/" style="font-size: 15px;">计算机系统</a> <a href="/tags/Exprt-C-Programming/" style="font-size: 15px;">Exprt_C_Programming</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/10/C++/pointer_and_reference/">指针与引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/TLPI/syscall/">Linux x86_64系统调用的实现过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/Other/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/C/Expert_C_Programming/data_mem/"><咸鱼书>_运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/C/Expert_C_Programming/error_jmp/">聊一聊C中的异常处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/30/C/Expert_C_Programming/c_link/"><咸鱼书>_链接那点事</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/C/Expert_C_Programming/array_pointer/"><咸鱼书>_数组与指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/28/C/Expert_C_Programming/c_technology/"><咸鱼书>_一些常见的技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/tools/size/">Binutils の size</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/C/Expert_C_Programming/c_statement/"><咸鱼书>_C声明问题</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>