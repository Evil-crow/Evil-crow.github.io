<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>&lt;星月夜&gt; Resource Management | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">&lt;星月夜&gt; Resource Management</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">&lt;星月夜&gt; Resource Management</h1><div class="post-meta">Sep 19, 2018<span> | </span><span class="category"><a href="/categories/C-C/">C/C++</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-13-Use-objects-to-manage-resource"><span class="toc-number">1.</span> <span class="toc-text">Item 13: Use objects to manage resource</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Standard-Library-Facilities"><span class="toc-number">1.1.</span> <span class="toc-text">Standard Library Facilities</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource-managing-classes"><span class="toc-number">1.2.</span> <span class="toc-text">Resource-managing classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><span class="toc-number">2.</span> <span class="toc-text">Item 14: Think carefully about copying behavior in resource-managing classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#No-Copy"><span class="toc-number">2.1.</span> <span class="toc-text">No Copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Share-Resourse"><span class="toc-number">2.2.</span> <span class="toc-text">Share Resourse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-Reference"><span class="toc-number">2.3.</span> <span class="toc-text">Move Reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deep-Copy"><span class="toc-number">2.4.</span> <span class="toc-text">Deep Copy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-15-Provide-access-to-raw-resources-in-resource-managing-classes"><span class="toc-number">3.</span> <span class="toc-text">Item 15: Provide access to raw resources in resource-managing classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete"><span class="toc-number">4.</span> <span class="toc-text">Item 16: Use the same form in corresponding uses of new and delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements"><span class="toc-number">5.</span> <span class="toc-text">Item 17: Store newed objects in smart pointers in standalone statements</span></a></li></ol></div></div><div class="post-content"><p><em>C++是一门强大的编程语言, 它自信程序员拥有强大的本领驾驭它的各个方面, 所以将资源管理的任务</em><br><em>全部托付给程序员(好吧, 只是为没有GC在洗地…)</em><br><em>从最基础的动态内存分配 ~ 文件描述符(file descriptor) ~ 套接字(socket) ~ 线程(thread)</em><br><em>资源管理的任务无处不在, 因此资源管理便成为我们严格对待的方面</em></p>
<h2 id="Item-13-Use-objects-to-manage-resource"><a href="#Item-13-Use-objects-to-manage-resource" class="headerlink" title="Item 13: Use objects to manage resource"></a>Item 13: Use objects to manage resource</h2><p>对于资源管理, 说的简单了, 其实最重要的就是: <strong>资源泄漏(memory leak)的问题</strong><br>1.不使用的资源, 应该及时释放<br>2.已经释放的资源, 绝对不能使用, 会导致未定义行为</p>
<p>我们从最常见的heap-based资源开始, 先来看看我们平时是怎么做的吧,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;                 <span class="comment">// allocate resource(int) on heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_resource</span><span class="params">(...)</span></span>;	        <span class="comment">// func -- get resource</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = get_resource();      <span class="comment">//request resource</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">delete</span> p;                     <span class="comment">// release resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如我们上面的编码, 我们先申请资源, 最后释放资源, 一切看上去是那么的井然有序.<br><strong>真的能如你所愿吗 ? </strong><br><em>考虑一下: 如果在<code>...</code>中间,存在: 提前return, throw异常, 多重嵌套, 还会正常工作吗 ?</em><br><strong>事实上, 只要是足够正式的工程代码, 极有可能工作流是到不了 资源释放的步骤的.</strong></p>
<p>当然, 通过细致而严谨的编码, 我们可以做到资源管理的安全性<br>但是其中的难度可想而知<br>另一方面, 如果并非是代码维护者, 对于代码做了某些改动, 极有可能导致资源管理的有一次失控</p>
<p><strong>因此, 引入使用对象管理资源的思想, 即资源获得即初始化(RAII)</strong></p>
<blockquote>
<p>那么, 何为RAII?</p>
<p>RAII(Resource Acquisition Is Initialization)<br>字面意思为: 资源获取即初始化. 是有点拗口<br>实际上,它遵循了两个思想:</p>
<ol>
<li>资源一旦初始化(/赋值)即交给对象管理</li>
<li>资源的释放, 交由类机制的析构函数释放</li>
</ol>
</blockquote>
<p>那么, RAII的优点体现在哪里?<br>1.将资源交给对象管理, 只要处理的得当了, 可以避免内存泄漏(某种程度上)<br>2.隔离了资源的所有权, 解放了程序员, 就是说: 简化了资源管理的任务</p>
<p>RAII的资源管理策略, 是真的十分巧妙 !</p>
<p>那么, 如何使用RAII ?<br>分为两类: 类库中已经采用RAII策略的设施以及手动构建RAII类(Resource-managing classes)</p>
<h3 id="Standard-Library-Facilities"><a href="#Standard-Library-Facilities" class="headerlink" title="Standard Library Facilities"></a>Standard Library Facilities</h3><p>目前, 在标准库中已经采用RAII的设施有:<br><code>std::shared_ptr</code>, <code>std::unique_ptr</code>, <code>std::lock_guard</code><br><strong>我们建议对于heap-based资源, 使用这些设施进行管理</strong></p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * int *p = new int;</span></span><br><span class="line"><span class="comment">	 * std::shared_ptr&lt;int&gt; p1(p);</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>);     <span class="comment">// acquire resource when request</span></span><br><span class="line">&#125;                                         <span class="comment">// leave the block with releasing resource</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(&amp;mtx);    <span class="comment">// std facility, not heap-based resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面我们使用了, <code>std::shared_ptr</code>, <code>std::unique_ptr</code>. 这是现在C++ (C++11起)标准库设施.<br>在&lt; EffectiveC++ &gt;, 一书中提及的, <code>std::auto_ptr</code>(已废弃, 算是<code>std::unique_ptr</code>早期版本)<br><code>std::tr1::shared_ptr</code>已经正式纳入标准库, 并非是TR1, TR2扩展, 且TR1, TR2扩展已经废弃</p>
<p>不过,使用智能指针好也罢, 不使用也罢.<br>我们需要注意的是:<br><strong>智能指针的析构, 使用delete, 非delete[]</strong><br><strong>也即是说, 我们对于数组的动态内存分配, 要不然拒绝, 要不然自行构建删除器</strong><br><strong>毕竟, 对于数组类型, 标准库提供了自动析构的, vector以及string等设施(顺序容器)</strong></p>
<h3 id="Resource-managing-classes"><a href="#Resource-managing-classes" class="headerlink" title="Resource-managing classes"></a>Resource-managing classes</h3><p>对于常见的其他资源, 比如:<br><code>socket</code>, <code>file desdcriptor(fd)</code>, <code>thread</code>, <code>mutex</code>等等, <strong>我们更倾向于手动构建RAII类</strong></p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lock(<span class="built_in">std</span>::mutex &amp;mutex);</span><br><span class="line">	~lock();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lock::Lock(<span class="built_in">std</span>::mutex &amp;mutex) : mtx(mutex) &#123; <span class="built_in">std</span>::lock(mtx); &#125;</span><br><span class="line"></span><br><span class="line">Lock::~Lock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::unlock(mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex a;</span><br><span class="line">	<span class="function">Lock <span class="title">lk</span><span class="params">(a)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;                  <span class="comment">// release resource automaticlly</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Socket(<span class="keyword">int</span> fd) : socket_fd(fd) &#123; ; &#125;</span><br><span class="line">	~Socket() &#123;</span><br><span class="line">	    ::close(socket_fd);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = ::socket(...);</span><br><span class="line">    <span class="function">Socket <span class="title">s</span><span class="params">(fd)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;                <span class="comment">// release resource automaticlly</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请记住:</p>
<ol>
<li>为防止资源泄漏. 请使用RAII对象, 它们在构造函数中获得资源并在析构函数中释放资源</li>
<li><del>两个常被使用的RAII Classes 分别是 <code>std::tr1::shared_ptr</code> 和 <code>std::auto_ptr</code></del><br><del>前者通常是较佳选择, 因为其Copy行为比较直观.若选择<code>std::auto_ptr</code>,</del><br><del>复制行为会使它指向null</del></li>
</ol>
</blockquote>
<h2 id="Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="Item 14: Think carefully about copying behavior in resource-managing classes"></a>Item 14: Think carefully about copying behavior in resource-managing classes</h2><p>Emmmmmm, 严格意义上来讲, RAII资源类, 一般而言, 是禁止拷贝的.<br>对, 没错.<br>但是, 什么事情都有例外, 万一真的出现需要拷贝的情况, 我们应该作出什么样的选择呢?</p>
<p>常见的选择有下面四种:</p>
<h3 id="No-Copy"><a href="#No-Copy" class="headerlink" title="No Copy"></a>No Copy</h3><p>这是最常选择的策略, 因为RAII类没有拷贝的必要与需求, 我们何必自找麻烦呢?</p>
<p>那么, 禁止拷贝的手段呢? (之前的条款已经提到过了)</p>
<p>两种手段:<br>1.使用Uncopyable/noncopyable<br>2.明确语义, 不需要拷贝的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boost::noncopyable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) &amp;&amp; !defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS)</span></span><br><span class="line">    <span class="function">BOOST_CONSTEXPR <span class="title">noncopyable</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    ~noncopyable() = <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    noncopyable() &#123;&#125;</span><br><span class="line">    ~noncopyable() &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(BOOST_NO_DELETE_FUNCTIONS)</span></span><br><span class="line">    noncopyable(<span class="keyword">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    noncopyable(<span class="keyword">const</span> noncopyable &amp;);</span><br><span class="line">    noncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncoptable &amp;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using Boost::noncopyable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> :</span> <span class="keyword">public</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete copy function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    Lock(<span class="keyword">const</span> Lock &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Lock &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Lock &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Share-Resourse"><a href="#Share-Resourse" class="headerlink" title="Share Resourse"></a>Share Resourse</h3><p>除了禁止拷贝之外, 我们一般还可以接受, 共享资源.<br>即指: 不同的pointer/reference可以指向相同的资源.</p>
<p>我们一般有这两种手段: 使用智能指针RCSP, 或模拟底层引用计数<br>这两种自然就是 heap-based资源 与 其他类型的资源<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using std::shared_ptr (not std::tr1::shared_ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    Lock(<span class="keyword">const</span> Lock &amp;lk) &#123;                   <span class="comment">// 实现太shi, 差不多这个意思</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pmtx = lk.handle();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex&gt; handle() &#123;</span><br><span class="line">        <span class="keyword">return</span> pmtx;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex, <span class="built_in">std</span>::unlock&gt; pmtx;        <span class="comment">// 将std::unlock作为删除器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using reference-count</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    Lock(<span class="keyword">const</span> Lock &amp;lk) &#123;                   <span class="comment">// 实现太shi, 差不多这个意思</span></span><br><span class="line">        mtx = lk.handle();</span><br><span class="line">		refCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">mutex &amp;<span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mtx;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> refCount;                       <span class="comment">// 引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 细节没注意, 基本上就是这个意思</span></span><br></pre></td></tr></table></figure>
<h3 id="Move-Reference"><a href="#Move-Reference" class="headerlink" title="Move Reference"></a>Move Reference</h3><p>此部分, 和上一部分类似. 其中的区别便是: 转移资源而非共享资源</p>
<p><em>使用现代C++, 我们很容易想到标准库设施</em><br><code>std::unique_ptr</code>进行使用, 其他类的资源(非heap-base)自然就是<code>std::move()</code>了</p>
<h3 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h3><p>这种需求,真的是比较少, 本身RAII资源进行拷贝就少, 深拷贝更是凤毛麟角, 这部分就不再赘述<br>记住: 深拷贝, 拷贝的不仅是指针/引用等, 同时还拷贝了其所指向的对象. (有什么用, 反正现在没用上)</p>
<p>上述我们介绍了四种策略, 但是从真正意义上来讲:<br><strong>我们仅仅接受: 禁止拷贝 + 共享资源</strong><br><em>转移资源/深拷贝 并非是常见且合理的做法</em></p>
<blockquote>
<p>请记住:</p>
<ol>
<li>复制RAII对象必须一并复制它所管理的资源, 所以资源的Copying行为决定RAII对象的Copying行为</li>
<li>普遍而常见的RAII class copying行为是: 抑制copying, 施行引用计数法. 不过其他行为也都可能被实现</li>
</ol>
</blockquote>
<h2 id="Item-15-Provide-access-to-raw-resources-in-resource-managing-classes"><a href="#Item-15-Provide-access-to-raw-resources-in-resource-managing-classes" class="headerlink" title="Item 15: Provide access to raw resources in resource-managing classes"></a>Item 15: Provide access to raw resources in resource-managing classes</h2><p><em>本条款的标题叫做: 在RAII资源类中提供访问资源权限</em></p>
<p><strong>说实话, 看着矛盾是吧? 我们好不容易封装个资源, 现在又要开放接口, 搞事情 ? </strong></p>
<p><strong>客观分析: 其实这并不矛盾, 为什么? 因为我们使用class管理资源的目的并非是为了封装 ! </strong><br><strong>是的, 你没听错, 我们使用class管理资源的主要目的是为了能合理的, 管理和释放 ! </strong></p>
<p><strong>我们甚至可以, 谨慎的实现成员函数来避免直接访问资源, 但是与APIs的交互又该怎么办 ? </strong></p>
<p><em>并且, 纵观标准库中的RAII设施, 同样提供了接口去访问资源.</em><br>比如: <code>std::shared_ptr::get()</code>等</p>
<p><strong>所以, 我们既然本身目的并非是为了封装, 所以我们开放访问资源的接口并非不合理</strong></p>
<p>下面介绍访问资源的两种方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using interface get() etc.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    <span class="built_in">std</span>::sahred_ptr&lt;<span class="built_in">std</span>::mutex&gt; &amp;get() &#123;</span><br><span class="line">        <span class="keyword">return</span> pmtx;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex, <span class="built_in">std</span>::unlock&gt; pmtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using operator TYPE()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pmtx;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex, <span class="built_in">std</span>::unlock&gt; pmtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Usage</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex&gt; &amp;mtx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(lock lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(lk.get());    <span class="comment">// get()</span></span><br><span class="line">	foo(lk);          <span class="comment">// operator TYPE()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么, 我们如何抉择使用哪种方式呢?</p>
<p><strong>各有优劣</strong><br>1.使用显示接口, 可以是我们的意图更加明显, 除了某些极端人士嫌丑陋以外, 也没什么不好的.<br>2.使用隐式转换, 其实容易出问题, 有的时候会出现相反的效果</p>
<blockquote>
<p>请记住:</p>
<ol>
<li>APIs往往要求访问原始资源(raw resource), 所以每一个RAII class应该提供一个”取得其所管理之资源”的方法</li>
<li>对原始资源的访问可能经由显示转换或隐式转换.一般而言显示转换比较安全, 但隐式转换对客户比较方便</li>
</ol>
</blockquote>
<h2 id="Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="Item 16: Use the same form in corresponding uses of new and delete"></a>Item 16: Use the same form in corresponding uses of new and delete</h2><p>使用配对的new和delete 看起来其实是很简单的一个道理.</p>
<p>事实上就是一个很简单的道理.</p>
<p><code>new TYPE[] -&gt; delete [] p;</code><br><code>new TYPE -&gt; delete p;</code></p>
<p>为什么要成对使用, 因为如果不匹配, 就会有这样的问题: (类似于之前讨论指针和数组名混用)</p>
<p>若, 使用delete[ ]不匹配, 就有可能过多释放内存, 甚至于正在使用, 或者无法析构的内存</p>
<p>若. 使用delete不匹配, 就有可能少释放内存, 基本上也是未定义行为.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valagrid的分析</span></span><br><span class="line">==<span class="number">6539</span>== Mismatched <span class="built_in">free</span>() / <span class="keyword">delete</span> / <span class="keyword">delete</span> []</span><br><span class="line">==<span class="number">6539</span>==    at <span class="number">0x4C2E1E8</span>: <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span>*) (vg_replace_malloc.c:<span class="number">576</span>)</span><br><span class="line">==<span class="number">6539</span>==    by <span class="number">0x4005BD</span>: main (in /home/Crow/a.out)</span><br><span class="line">==<span class="number">6539</span>==  Address <span class="number">0x5aeac80</span> is <span class="number">0</span> bytes inside a block of size <span class="number">40</span> alloc'd</span><br><span class="line">==<span class="number">6539</span>==    at <span class="number">0x4C2D8B7</span>: <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">unsigned</span> <span class="keyword">long</span>) (vg_replace_malloc.c:<span class="number">423</span>)</span><br><span class="line">==<span class="number">6539</span>==    by <span class="number">0x4005A8</span>: main (in /home/Crow/a.out)</span><br></pre></td></tr></table></figure>
<p>另外强调两个点:<br>1.对于数组之类的, 我们更建议vector, deque, string等设施<br>2.尤其是typedef等使用手动new, delete简直是毁灭级的, 因为它到底用的哪种new我们一无所知</p>
<p>所以, 一定要保证自己<strong>成对匹配的使用new和delete</strong></p>
<p><del>我曾经在不会C++的时候, 被g卓越因为这个坑过 \白眼</del></p>
<blockquote>
<p>请记住:</p>
<ol>
<li>如果你在new表达式中使用[ ], 必须在相应的delete表达式中也使用[ ].<br>如果你在表达式中不使用[ ], 一定不要在相应的delete表达式中使用[ ].</li>
</ol>
</blockquote>
<h2 id="Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="Item 17: Store newed objects in smart pointers in standalone statements"></a>Item 17: Store newed objects in smart pointers in standalone statements</h2><p>这句话, 看上去有点奇妙, 什么意思呢?</p>
<p><em>以独立的语句将newed对象置入智能指针</em></p>
<p>看个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(std::shared_ptr&lt;int&gt; sp, void (*foo));     // prototype</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>), foo());</span><br></pre></td></tr></table></figure></p>
<p>这其中, 在func()函数调用的时候, 实参和形参匹配时的求值顺序是未定义的</p>
<p>所以, 就有可能出现,下面这样的顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">new</span> p;</span><br><span class="line"><span class="number">2.</span> foo();</span><br><span class="line"><span class="number">3.</span> <span class="built_in">std</span>::sahred_ptr&lt;<span class="keyword">int</span>&gt; (...);</span><br></pre></td></tr></table></figure>
<p>那么, 一旦在第二步骤的时候, “成功”抛出异常, 毁灭级的打击, 这已经造成内存泄露了<br><strong>而且, Debug及其困难, 因为复现的难度已经十分之大 !</strong></p>
<p><strong>所以, 应该以独立的语句将new的资源置于智能指针中, 不同语句之间的求值顺序值确定的
</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pw(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">func(pw, foo());</span><br></pre></td></tr></table></figure>
<p><strong>上升一下: 不仅仅是这种申请资源, 只要是需要确定的顺序的行为, 我们就一定要分成独立的语句, 有的时候紧凑, 花哨的编码, 反而是毁灭的入口</strong></p>
<blockquote>
<p>请记住:</p>
<ol>
<li>以独立语句将newed对象存储于(置入)智能指针!<br>如果不这样做, 一旦异常被抛出, 有可能导致难以察觉的资源泄漏.</li>
</ol>
</blockquote>
<p><em>Tips: 我们在本节中讨论的都是资源泄漏(Resource Leak), 已经不仅仅是内存泄漏(Memory Leak)</em></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://evil-crow.github.io/2018/09/19/C++/EffC++/effective3/" data-id="cjmkqeqvw006u6nnr3tt7vk8k" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACHElEQVR42u3aQW7DMAwEwPz/0+kDCru7lFMg0ugUBLbs8YGgSL5e8Xr/Wu317V2vTywMDIyvZbxv19UDkld8B+t+t+ReDAyMcxhXL3F1TX5XAsife/k/BgYGRhwc8x1mV2JgYGC0ATdPH+/Pnvc7YGBgYLQJXH40za+fPQsDA+McRl51///fH+lvYGBgfBXjXa71AL1Snrt8IgYGxtaMPMDNmo75+EUbcDEwMM5hrAxYtKFzpdz2BwwDA+MAxj1snb1y3ozSTQwMjMMYedqXDEzkBf1kzz9SQwwMjE0ZbUo3Y7ewdh8MDIy9GXkQbHkrr5vgo2iNgYGxBWNGyotls6RzNvyKgYGxK+OpgtpSiCx3HlYNMTAwvpzRFuXzf2aDsHVfEgMDY2vG58ZJ82bAK1j5lRgYGLsy2hbj+ohG206IDswYGBibMlbCZdt0TMp2s3QTAwPjBEbysFnRLU862xYFBgbGOYwWMCuNtUF/2CjFwMA4jNGWvdoxizaIR+0EDAyMAxhJKtaObc0+U/4mGBgYpzFm7cwZuy3n1YdYDAyMjRizQYqnXvGp1iYGBsbejDbMtWW4lXbmU4kpBgbGHowkXLYNxZUvlwdcDAyM0xgrgTJpYbapZ12Sw8DAwIibl0nC17YBooMrBgYGRjx+2g5YJHtGnwADA+MARnKIXS/0J3c9MDOCgYGxHaMdcciHMFaOwe2bYGBgbMr4AUZiVuTvgVHdAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/EffectiveC/">EffectiveC++</a></div><div class="post-nav"><a class="pre" href="/2018/09/26/C++/EffC++/effective4/">&lt;星月夜&gt; Designs and Declarations</a><a class="next" href="/2018/09/13/C++/EffC++/effective2/">&lt;星月夜&gt; Constructors, Destructors, and Assignment Operators</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ShellScript/">ShellScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/Vim/">Vim</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/EvilCrow/">EvilCrow</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/力量的源泉/">力量的源泉</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/hole/" style="font-size: 15px;">hole</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/standard/" style="font-size: 15px;">standard</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/experience/" style="font-size: 15px;">experience</a> <a href="/tags/ShellScript/" style="font-size: 15px;">ShellScript</a> <a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/C-Primer/" style="font-size: 15px;">C++Primer</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/C/Expert_C_Programming/data_mem/"><咸鱼书> 运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/C++/EffC++/effective4/"><星月夜> Designs and Declarations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/C++/EffC++/effective3/"><星月夜> Resource Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/C++/EffC++/effective2/"><星月夜> Constructors, Destructors, and Assignment Operators</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/C++/EffC++/effective1/"><星月夜> Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Evilcrow/linux_setting/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/tools/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/two_level_array/">一个C语言指针的问题让我翻车</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/C++/C++Primer/C3P_VI/">VI Function</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>