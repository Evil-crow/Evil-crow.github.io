<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>&lt;星月夜&gt; Constructors, Destructors, and Assignment Operators | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">&lt;星月夜&gt; Constructors, Destructors, and Assignment Operators</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">&lt;星月夜&gt; Constructors, Destructors, and Assignment Operators</h1><div class="post-meta">Sep 13, 2018<span> | </span><span class="category"><a href="/categories/C-C/">C/C++</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-05-Know-what-functions-C-silently-writes-and-calls"><span class="toc-number">1.</span> <span class="toc-text">Item 05: Know what functions C++ silently writes and calls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want"><span class="toc-number">2.</span> <span class="toc-text">Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-07-Declare-destructors-virtual-in-polymorphic-base-class"><span class="toc-number">3.</span> <span class="toc-text">Item 07: Declare destructors virtual in polymorphic base class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-08-Prevent-exception-from-leaving-destructors"><span class="toc-number">4.</span> <span class="toc-text">Item 08: Prevent exception from leaving destructors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#悄悄掩盖住错误"><span class="toc-number">4.1.</span> <span class="toc-text">悄悄掩盖住错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#让他去死"><span class="toc-number">4.2.</span> <span class="toc-text">让他去死</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-09-Never-call-virtual-function-during-Constructor-or-Destructor"><span class="toc-number">5.</span> <span class="toc-text">Item 09: Never call virtual function during Constructor or Destructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-10-Have-assignment-operators-return-a-reference-to-this"><span class="toc-number">6.</span> <span class="toc-text">Item 10: Have assignment operators return a reference to *this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-11-Handle-assignment-to-self-in-operator"><span class="toc-number">7.</span> <span class="toc-text">Item 11: Handle assignment to self in operator=</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用if-else控制流"><span class="toc-number">7.1.</span> <span class="toc-text">使用if-else控制流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Copy-and-Swap-“CAS”"><span class="toc-number">7.2.</span> <span class="toc-text">使用Copy and Swap (“CAS”)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-12-Copy-all-parts-of-an-object"><span class="toc-number">8.</span> <span class="toc-text">Item 12: Copy all parts of an object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-局部部分"><span class="toc-number">8.1.</span> <span class="toc-text">1. 局部部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-继承成分"><span class="toc-number">8.2.</span> <span class="toc-text">2. 继承成分</span></a></li></ol></li></ol></div></div><div class="post-content"><p><em>上一篇中,我们着重进行了C++中最最基础,和C有很大区别的地方,比如语言联邦, 减少预处理器的使用,</em><br><em>多使用const, 保证使用前初始化对象等几个方面</em></p>
<p><em>这一部分, 我们就来聊聊使C++语法变得如此复杂的”罪魁祸首”之一 —- 复杂的拷贝控制</em></p>
<h2 id="Item-05-Know-what-functions-C-silently-writes-and-calls"><a href="#Item-05-Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="Item 05: Know what functions C++ silently writes and calls"></a>Item 05: Know what functions C++ silently writes and calls</h2><p><em>这是一个关键的点, 我一直因此觉得C++足够傲娇.C/C++有着强大的性能,同时他们又兼具着许多风险行为</em><br><em>如何高效编程, 同时规避风险, 我觉得这就是C/C++的美感之一</em></p>
<p>我们在此处要讨论的是: <strong>在你不知道的情况下, C++默默编写并调用了哪些函数</strong><br>(PS: 此处重要针对讨论的是 <code>class</code>内部的情况, global作用域内, 不可能被凭空塞函数的)</p>
<p>先来看一个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单地例子: <code>class Temp {};</code>我们并没有为它编写任何的成员函数, 那么它可以使用吗?<br>比如:<br><code>Temp a;     // Constructor</code><br><code>Temp a(b);  // Copy-constructor</code><br><code>Temp a = b; // Copy-operator-assignment</code><br><code>{ .... }    // Destructor</code></p>
<p>经过实验, 你可以发现, 上面这些操作都是成功的!<br>为什么? 我们明明没有编写这些成员函数的啊! 这便是<strong>C++默默编写并调用的函数</strong></p>
<p>总共有下面这四(六)类:</p>
<ol>
<li>Constructor</li>
<li>Copy Constructor</li>
<li>Copy assignment operator</li>
<li>Move Constructor        (C++11)</li>
<li>Move assignment operator (C++11)</li>
<li>Destructor</li>
</ol>
<p>这些默默编写的函数存在着下面的特点:<br>1.public &amp;&amp; inline<br>2.默认初始化 &amp;&amp; 逐次拷贝<br>3.编译器生成的版本都是non-virtual的, (继承得来的除外)</p>
<p>暂且记下这些特点, 我们下面的讨论会用到, 并非分析如何处理此情况</p>
<p>所以上面的例子实际上是这样子的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    Temp();</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;);</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;);</span><br><span class="line">    Temp(Temp &amp;&amp;);</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(Temp &amp;&amp;);</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么, 编译器一定会生成这些函数吗? 是不是得思考一下?</p>
<p>我们有下面的结论:<br><strong>assignment operator不一定会生成, 其余的函数照样会生成</strong></p>
<p>考虑这样的情况:<br>1.内含reference的class,<br>2.内含const成员的class<br>3.base class的assignment operator为private</p>
<p>来解释一下这三种情况:<br>1.若含有reference, 拷贝赋值函数到底是修改reference(错误)还是其所指的内容(无意义)?<br>2.const成员怎么可能会被修改!<br>3.若base class的拷贝赋值为private, derive class的拷贝赋值函数便无法生成</p>
<p><strong>简单地来说, 我们设身处地的为编译器着想, 它是否可以处理这种情况, 从而进行判断</strong><br><strong>上面的情况便是: 编译器无法为这些情况处理, 所以它的copy assignment operator创建失败</strong></p>
<blockquote>
<p>请记住</p>
<p>编译器可以暗自为class传播创建default构造函数, copy构造函数, copy assignment 操作,<br>以及析构函数, (以及move 构造函数, move assignment操作 C++11后)</p>
</blockquote>
<h2 id="Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want"><a href="#Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want" class="headerlink" title="Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want"></a>Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</h2><p><em>这一条款的讨论是基于 Item 05的, 处理编译器生成函数的不二法宝</em></p>
<p><strong>首先强调一个事实: 如今可以明确的说明对于编译器生成函数我们持有的态度</strong></p>
<p><em>还是hepangda的说法比较准确, “ C++11之后语言的语义更加明确 “</em><br><em>解释起来就是, C++之前的一些做法, 你不是很明确它的意思, 在一定条件下, 得借助注释才能迅速的理解</em></p>
<p>那么,我们先来说说在现代C++中如何处理这种问题吧,</p>
<p>现代C++中我们可以使用<strong>default, 以及delete</strong>来进行编译器生成函数的控制, 表明我们的态度</p>
<p>如下例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    Temp() = <span class="keyword">default</span>;</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp(Temp &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(Temp &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>通过语义明确的现代C++, 我们可以做到不想编译器自动生成的函数, 明确拒绝</strong><br><strong>如此的做法,也已经成为现代C++的编程规范之一了</strong></p>
<p><em>那么, 之前的C++是如何处理这样的问题呢 ?</em></p>
<p>这种问题还是会出现的, 我们还是之前的态度: 我们不能假定用户并不会犯错, 所以这种情况也应该处理掉的.<br>那么我们的入手点在于: compiler-gengrated functions 都是默认 <code>public &amp; inline</code><br>我们的入手点便是: 将其不能直接使用 =&gt; <strong>使用访问权限的控制手段</strong></p>
<p>我们提供以下两种思路:<br>1.<code>private &amp; implemention</code><br>2.<code>base-class &amp; implemention</code> (1.的基础上改良)</p>
<p>对于1, 我们的思路很明确, 就是使用<code>private</code>访权控制来拒绝我们不想使用的成员函数</p>
<p>但是, <code>member function</code>和<code>friend function</code>会打扰我们.</p>
<p><strong>于是, 我们就给予它便不实现, implmention =&gt; 链接器会报错</strong></p>
<blockquote>
<p>链接器报错 link-error<br>上面说到的链接器报错,是这个原因:<br>按照常人理解, 一般没有实现的函数, 会直接编译错误对吧 ?<br>但是C++因为分离式编译的原因 (区别参考于Java) ,前置声明了解一下, pimpl手法基础<br>知道link期间才会报错, 找不到函数的引用, 也就是实现之处, “no reference to FUNC”</p>
</blockquote>
<p>于是方法1 可以比较好的解决这个问题了.</p>
<p>尽管链接器报错, 也不会影响运行时效率, 可是我们还想尽早的报错为好, 将错误提前到编译期(Compiler)<br>有办法吗? 一定是有的!</p>
<p>使用OOP的手法: 继承<br>我们可以构造一个基类(因为不给予实现),将之继承, 然后正常编写即可.<br><strong>那么为什么会将报错提前至编译期呢 ? </strong></p>
<blockquote>
<p>无法进行构造, 因基类没有构造函数, 就是说一定要是用这个类构建对象, 才能错误提前到编译期</p>
</blockquote>
<p>举个例子如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopy</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    noncopy(<span class="keyword">const</span> noncopy &amp;);</span><br><span class="line">    noncopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncopy &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> :</span> <span class="keyword">public</span> noncopy &#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Temp t;</span><br></pre></td></tr></table></figure></p>
<p>这便是正确的使用举例</p>
<p><strong>我们建议使用现代C++语义明确的手法, C++03, 乃至98的手法, 只是作为开阔思路的解法了解即可</strong></p>
<blockquote>
<p>请记住</p>
<p>为驳回编译器自动(暗自)提供的机能, 可将相应的成员函数声明为privat并且不予实现.<br>使用像uncopyable这样的base class也是一种做法</p>
</blockquote>
<h2 id="Item-07-Declare-destructors-virtual-in-polymorphic-base-class"><a href="#Item-07-Declare-destructors-virtual-in-polymorphic-base-class" class="headerlink" title="Item 07: Declare destructors virtual in polymorphic base class"></a>Item 07: Declare destructors virtual in polymorphic base class</h2><p>如果要在C++中提到 <code>virtual</code>这个词, 经常用在这两个方面: <code>virtual继承</code> 与 <code>virtual function</code></p>
<p>我们这一部分专注于<code>virtual function</code>的内容, 虚继承的内容都是后话.</p>
<p>首先来看一个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base();</span><br><span class="line">    ~base();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">base *pb = get_derive_pointer();   <span class="comment">// 为了多态需求使用, 基类指针(/引用皆可)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br></pre></td></tr></table></figure></p>
<p><code>delete pb;</code><strong>会造成严重的灾难性后果 !</strong><br><strong>因为delete一个基类指针, 而且它的析构函数是non-virtual, 在派生类中, 此析构仅仅是base析构</strong><br><strong>这样, 你也能想到析构的下场了吧, derive部分无法析构, 且指针销毁, 只剩下一个不完全的对象</strong></p>
<p>那么,正确的做法呢?</p>
<p><strong>使用virtual-destructor 在base-class中 (子类继承后,virtual属性一并继承)</strong></p>
<p>这个其实是多态性的基础–C++中,基类指针/引用可以指向派生类的对象, 因此才能实现多态性</p>
<p>这样一来, 就可以舒服的解决这个问题了.</p>
<p><em>那么, 从一个方面来考虑, 未提供nvirtual destructor的函数, 就很麻烦了, 万一被继承就要出篓子</em><br><em>比如: std::stirng, std::iostream等</em><br><em>EffectiveC++的作者在感慨 C++没有的 final 已经在现代C++中加入, 但是我在&lt; string &gt;中还没找到</em><br><em>反正, 注意对于未提供virtual destrutor的class, 可能本来就是没有被设计作为多态base-class考虑</em></p>
<p>我们再来稍微说说vitual的事,</p>
<p>下面这些是, hepangda给我的科普,</p>
<blockquote>
<p>C++中实现的多态是成本最小的之一. 很简单的问题, 使用计算机时, 多态是我们目前不可预测的,<br>在编译期无法预知, 那么最简单的, 就是打表的思想, 我把可能的情况都塞进去, 到时查表就行<br>而具有Basic Object的语言, 就可以完全实现反射, Java, Ruby等…</p>
</blockquote>
<p>基于上面的这段话:<br>virtual实际上对class进行了打表, 将可能的函数指针封进表中, 成为虚表 (virtual table)<br>而每个class中会留一个隐藏的虚表指针vptr (virtual ptr)<br>使用virtual会<strong>大程度的提高开销 ! ! !</strong>, 他会使可执行文件增加容量</p>
<p>举一个EffectiveC++中的例子:<br>(64位环境)一个类中,有两个int, 应该占8个字节, 这个时候加上一个virtual, 多一个vptr<br>class体积增加100% !</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;        =&gt; <span class="number">8</span> Bytes</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~B();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;        =&gt; <span class="number">16</span> Bytes</span><br></pre></td></tr></table></figure>
<p>另外我们再来说说<strong>抽象基类</strong>的事情:<br>abstract class 指的是含纯虚函数的类,<br><em>很不幸, 我们因为没有interface的关键字, 导致定义接口要使用抽象基类的手法</em><br><strong>我们要讨论的是, 如何拥有一个抽象基类</strong></p>
<p><strong>其实,也不麻烦,就是标题的 纯虚析构函数 即可</strong><br><em>因为纯虚 (pure virtaul), 所以是抽象基类</em><br><em>同时又是 virtual 析构函数, 所以不用担心析构的问题</em></p>
<p><strong>这里的窍门是: 要为 pure virtual destructor 提供一份定义</strong><br><strong>否则, derive class 的destructor都会爆炸的, 具体上一条款中关于implemention的问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vitrual ~Temp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Temp::~Temp() &#123; ; &#125;</span><br></pre></td></tr></table></figure>
<p>因此, 给出我们使用virtual的建议:<br><strong>记住: 仅仅在有多态需求时使用virtual函数, 其余时候(仅作为基类, 一般类)能不用就不要用virtual</strong></p>
<blockquote>
<p>请记住</p>
<p>polymorphic(带多态性质的) base classes 应该声明一个virtual 析构函数. 如果class带有任何virtual函数, 它就应该拥有一个virtual析构函数</p>
<p>不是设计用来作为 base classes（基类）或不是设计用于 polymorphically（多态）的 classes（类）就不应该声明 virtual destructor（虚拟析构函数）</p>
</blockquote>
<h2 id="Item-08-Prevent-exception-from-leaving-destructors"><a href="#Item-08-Prevent-exception-from-leaving-destructors" class="headerlink" title="Item 08: Prevent exception from leaving destructors"></a>Item 08: Prevent exception from leaving destructors</h2><p>异常可谓是进行OOP中所必不可少的。<br>从某个方面来说, 使用异常机制可以改变程序设计的模式, 使我们更加专注于逻辑设计<br>将平时繁琐的错误处理情况, 按死在异常中(简单地说, 不容易分心)</p>
<p>C中也实现了近似于异常的机制, 起源于goto的语法, <code>setjump/longjump</code><br>Java中的异常机制十分完善, 并且保证了足够的效率.<br>反观, C++中的异常机制, 因为是后来加入的体系, 所以在性能和效率上都差强人意.</p>
<p>一个不得不承认的事实:<br><strong>C++中应该尽可能少, 甚至不使用异常, 而且我们一般对于异常的处理是杀死</strong></p>
<p>那么, 我们在这一条款中, 到底要讨论什么主题呢？</p>
<p><em>我们对于异常机制的使用, 以及关于OOP设计接口的一部分讨论</em></p>
<p>对于异常的处理, 我们以下面的例子来谈：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLaffair</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SQLaffir();</span><br><span class="line">    ~SQLaffair();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SQL *psql;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们使用指针作为成员, 这也是pimpl手法的应用之一。</p>
<p>我们重点的是要讨论在析构函数中, 如果发生了异常该怎么办？<br>我们一般具有两种手段来处理:</p>
<ol>
<li>悄悄掩盖住错误</li>
<li>让他去死 (PS: Let it die挺好玩的)</li>
</ol>
<h3 id="悄悄掩盖住错误"><a href="#悄悄掩盖住错误" class="headerlink" title="悄悄掩盖住错误"></a>悄悄掩盖住错误</h3><p>这一种处理方法, 在某种程度上是为了软件稳定的妥协。<br>问题并非是毁灭级的失败, 且稳定性更为重要的时候, 我们便放弃对错误的处理, 悄悄掩盖起来</p>
<p>我们为什么会选择悄悄处理错误这样一种决策呢?</p>
<p><em>因为在析构函数中抛出异常意味着 “中断程序” 和 “未定义的行为”</em></p>
<p>即使悄悄吞下错误, 在一定程度上也比引发上面两种行为, 好得多。</p>
<h3 id="让他去死"><a href="#让他去死" class="headerlink" title="让他去死"></a>让他去死</h3><p>这是一种大多数情况的策略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQLaffir::~SQLaffir()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::runtime(<span class="string">"msg"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::runtime re) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是, 这种策略也显得过于粗暴, 用户在被强制中断, 不太友好。</p>
<p>所以, 我们的建议是, 开放一个接口给用户使用, 同时析构进行调用。</p>
<p>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SQLaddair::close = flase;  (TYPE: <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; close;)</span><br><span class="line">SQLaffir::close()</span><br><span class="line">&#123;</span><br><span class="line">    SQLptr.close();</span><br><span class="line">    close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SQLaffair::~SQLaffair()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SQLptr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">            <span class="comment">// 两种策略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的策略便是我们推崇的真正应该使用的处理手法。</p>
<p>为什么这样呢？因为他有如下优点:</p>
<ol>
<li>析构函数中严格的使用”悄悄吞掉” 或 “让他去死”的策略, 避免抛出异常</li>
<li>我们给了用户一个接口, close() 来处理异常情况</li>
</ol>
<p>EffC++中解释了, 使用close()与接口设计的矛盾性：<br>虽然从设计上来讲, 不应该将资源管理权交给用户, 因为不安全。</p>
<p><strong>但是, 我们在此处将资源控制权交给用户, 为什么?</strong></p>
<p>因为,关于SQL连接关闭是不可轻易吞下的错误, 我们应该给予用户以控制并处理错误的权利<br>所以, 此处我们先将问题暴露给用户, <strong>在用户放弃处理的时候, 我们在析构函数中, 使用两种策略处理</strong></p>
<p>综上所述:<br><strong>1. 不能让异常在析构函数中抛出, 会导致未定义行为/crash, 应该选择悄悄吞下/让他去死</strong><br><strong>2. 基于1, 我们应该作出, 必需要处理的异常, 在析构函数之前进行处理, 别让异常等到析构, 往出传播</strong></p>
<p><em>EffectiveC++中, 候捷先生的翻译是: 别让异常逃离析构函数</em><br><strong>私以为更妥当的翻译应该是: 在析构结束之前处理错误, 不要让异常在析构函数中抛出</strong></p>
<blockquote>
<p>请记住</p>
<p>destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后抑制它们或者终止程序。</p>
<p>如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。</p>
</blockquote>
<h2 id="Item-09-Never-call-virtual-function-during-Constructor-or-Destructor"><a href="#Item-09-Never-call-virtual-function-during-Constructor-or-Destructor" class="headerlink" title="Item 09: Never call virtual function during Constructor or Destructor"></a>Item 09: Never call virtual function during Constructor or Destructor</h2><p>继承是面向对象编程中很重要的一个特性.</p>
<p>设计并构建功能完整并强大的继承体系是一项复杂的工程.</p>
<p>在这其中我们会翻一个很经典的错误: <strong>在构造/析构函数中使用virtual函数</strong><br>乍看之下, 是不是还是挺有道理的.</p>
<p><strong>事实上, 这是一个严重的错误: 因为在析构, 构造期间. 类并非完整的, RTTI并不能得到派生类类型</strong><br><strong>因此, 我们所调用的只能是基类版本, 会导致严重的错误! 并不能达到我们的需求. 严重性可想而知.</strong></p>
<p>来看这样一个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base();</span><br><span class="line">	~base();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">log</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base::base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aderive</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Aderive();</span><br><span class="line">	~Aderive();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bderive</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bderive();</span><br><span class="line">	~Bderive();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Aderive ad;</span><br></pre></td></tr></table></figure></p>
<p>上面的示例, 我们构造ad对象, 构造过程会顺利完成.<br><em>但是, 其中使用的log(), 是base::log(), 不得不承认, 这是个令人惊奇的事实.</em></p>
<p><strong>原因正如上面所说: </strong><br><em>基类构造发生在派生类部分构造之前(base part construct before derive part)</em><br><em>我们使用vitual函数, RTTI得到的是base类型, 而非是derive类型, 不能满足我们的要求</em><br><em>更通俗的来讲: 此时的virtual并非是virtual, 仅仅是它自己的版本</em></p>
<p><em>正是因为, derive class尚未初始化完成, 使用派生类中的内容, 可能导致不安全行为/未定义行为</em><br><em>所以, 不允许virtual, 仅仅能使用base::log()版本.derive construct时, virtual不会下降到derive class</em></p>
<p><strong>准确的理由: 此时RTTI结果是base类型,dynamic_cast (此时进入base部分, derive部分视为未定义)</strong><br><strong>析构函数也是同理的.</strong></p>
<p><em>事实上, 防止构造/析构过程中出现virtual调用时很难检测的错误</em><br><strong>因为, 提供了实现版本, 就会出现正常运行, 错误结果的情况.</strong></p>
<p><em>注: pure virtual的版本可以通过编译, 调用会凉凉…</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pure virtual method called</span><br><span class="line">terminate called without an active exception</span><br></pre></td></tr></table></figure></p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base() &#123;init();&#125;;</span><br><span class="line">    ~base()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="built_in">log</span>();&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;                   <span class="comment">// pure virtual 运行, ERROR</span></span><br><span class="line">	<span class="comment">// virtual void log() const &#123;cout &lt;&lt; "base";&#125;     // Result: base</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    derive()&#123;&#125;;</span><br><span class="line">    ~derive()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"derive"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>明白了吗? 即是说, 一旦是impure virtual 就是很难处理的Bug</em></p>
<p>那么, 有没有可以比较好的解决办法呢? <strong>派生类构造向基类传递参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;info)</span></span>;</span><br><span class="line">    void logTransaction(const std::string &amp;info) const);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;info)</span><br><span class="line">&#123;</span><br><span class="line">    logTransaction(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTranscation</span> :</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    BuyTranscation (parameters)</span><br><span class="line">        : Transaction(createLogInfo(parameters))     <span class="comment">// 使用传参的形式完成原多态需求</span></span><br><span class="line">    &#123; ... &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">createLogInfo</span><span class="params">(parameters)</span></span>;   <span class="comment">// static保证此部分与对象无关, 无危险</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>综合所述:<br><strong>不要在构造/析构中使用virtual, 因为这时刻他们的类型是base, RTTI结果亦是如此</strong></p>
<p><em>或者说, 此时刻, 不会从base下降到derive层次</em></p>
<blockquote>
<p>请记住:</p>
<p>在 construction（构造）或 destruction（析构）期间不要调用 virtual functions（虚拟函数），因为这样的调用不会转到比当前执行的 constructor（构造函数）或 destructor（析构函数）所属的 class（类）更深层的 derived class（派生类）。</p>
</blockquote>
<h2 id="Item-10-Have-assignment-operators-return-a-reference-to-this"><a href="#Item-10-Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="Item 10: Have assignment operators return a reference to *this"></a>Item 10: Have assignment operators return a reference to *this</h2><p>此部分的内容实际上较为简单, 主要是阐述了一个关于<code>operator overload</code>的默认约定</p>
<p>即:<strong>运算符重载应该返回*this的引用</strong></p>
<p>我们可以看几个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Obj1 + Obj2;</span><br><span class="line">a = getVal();</span><br></pre></td></tr></table></figure>
<p>为什么可以这样写, 因为a是左值, <strong>返回对*this的引用, 便能保证是左值</strong><br><strong>若返回并非是左值, 则第二次运算会失败, 因为a仅仅是一个右值</strong></p>
<p>简单地说: <strong>我们返回非*this引用也无大碍, 但是,为了与用户习惯以及内置类型行为近似</strong><br><strong>我们强烈建议, 运算符重载返回对*this的引用.</strong></p>
<p><em>PS: 这只是建议, 并非是编程规范</em></p>
<blockquote>
<p>请记住:</p>
<p>让 assignment operators（赋值运算符）返回一个 reference to <em>this（引向 </em>this 的引用）。</p>
</blockquote>
<h2 id="Item-11-Handle-assignment-to-self-in-operator"><a href="#Item-11-Handle-assignment-to-self-in-operator" class="headerlink" title="Item 11: Handle assignment to self in operator="></a>Item 11: Handle assignment to self in operator=</h2><p>如题所示, 这一条款我们主要讨论的是: 在<code>operator=</code>中处理”自赋值”情况</p>
<p><del>这里再喷一下候捷先生的翻译, 不想多说</del></p>
<p>自赋值的问题, 怎么回事?</p>
<p>先来看一个正常的operator=</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Temp &amp;Temp::<span class="keyword">operator</span>=(<span class="keyword">const</span> Object &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line">	<span class="keyword">this</span>-&gt;p = rhs.p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中会造成什么问题吗? <strong>是的, 当自赋值时, 这样的运算符重载会产生未定义的行为, 因为悬垂指针</strong></p>
<p><em>换种思路, 我们再来分析一下, 这种”自赋值”常见吗?</em></p>
<p><em>不幸的是, 基于两方面的原因. “自赋值”是一个不好规避的问题</em><br><em>1. 我们不能假设(assume)用户的行为, <del>把他们当成蠢蛋就行了</del></em><br><em>2. 我们更多的遇到的情况是, “隐式”自赋值</em></p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = ...;</span><br><span class="line"><span class="keyword">int</span> &amp;a = ...;</span><br><span class="line">*p = a;</span><br></pre></td></tr></table></figure></p>
<p><em>上面的例子便是两种常见的”隐式”自赋值情况, 需要十分的当心</em></p>
<p>扯了这么多, 我们就来说说<strong>真正处理自赋值的方法</strong></p>
<h3 id="使用if-else控制流"><a href="#使用if-else控制流" class="headerlink" title="使用if-else控制流"></a>使用if-else控制流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Temp &amp;Temp::<span class="keyword">operator</span>=(<span class="keyword">const</span> Object &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> == rhs)</span><br><span class="line">	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line">	<span class="keyword">this</span>-&gt;p = rhs.p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点: 一旦遇到自赋值, 可以直接退出处理情况.<br>缺点: 增加了控制流, 开销不是那么容易抹掉的</p>
<h3 id="使用Copy-and-Swap-“CAS”"><a href="#使用Copy-and-Swap-“CAS”" class="headerlink" title="使用Copy and Swap (“CAS”)"></a>使用Copy and Swap (“CAS”)</h3><p>也可以简称为CAS, 不过与那个大名鼎鼎的CAS是完全不同的东西.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;rhs);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">const</span> Temp &amp;lhs, <span class="keyword">const</span> Temp &amp;rhs)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Temp::swap(<span class="keyword">const</span> Temp &amp;rhs, <span class="keyword">const</span> Temp &amp;rhs) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Temp &amp;Temp::<span class="keyword">operator</span>=(<span class="keyword">const</span> Object &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Temp t(ths);</span><br><span class="line">	swap(*<span class="keyword">this</span>, t);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点: 可以安全的处理任何情况<br>缺点: 当自赋值可能性比较大时, 效率不如增加控制流的手段.</p>
<p><em>这两种手法, 可以比较好的处理自赋值, 选择那种,我们要根据情况来判断</em><br><em>另外, 禁止自赋值行为时, assert()断言就派上用场了</em><br><code>assert(*this == ths);</code></p>
<blockquote>
<p>请记住:</p>
<p>当一个 object（对象）被赋值给自己的时候，确保 operator= 是行为良好的。技巧包括比较 source（源）和 target objects（目标对象）的地址，关注语句顺序，和 copy-and-swap。</p>
<p>如果两个或更多 objects（对象）相同，确保任何操作多于一个 object（对象）的函数行为正确。</p>
</blockquote>
<h2 id="Item-12-Copy-all-parts-of-an-object"><a href="#Item-12-Copy-all-parts-of-an-object" class="headerlink" title="Item 12: Copy all parts of an object"></a>Item 12: Copy all parts of an object</h2><p>拷贝时勿忘掉任何一个对象成分</p>
<p>这是一句缄言, 拷贝赋值的时候, 缺少成分是最忌讳的</p>
<p>那么, 我们要注意的是什么情况呢?</p>
<p>主要有这样两种情况:<br><strong>1. 局部成分</strong><br><strong>2. 继承成分</strong></p>
<h3 id="1-局部部分"><a href="#1-局部部分" class="headerlink" title="1. 局部部分"></a>1. 局部部分</h3><p>局部部分, 主要考虑的是这样的情况: 后续进行class修改时, 有的局部成分被忘记和省略</p>
<p>那么唯一的办法: <strong>自己相信斟酌, 确认将所有成分进行拷贝</strong></p>
<h3 id="2-继承成分"><a href="#2-继承成分" class="headerlink" title="2. 继承成分"></a>2. 继承成分</h3><p>相对于局部部分, 继承成分乍看之下会很复杂: <strong>因为我们可能使用复杂的继承链</strong></p>
<p>但是, 继承也有继承的好处.</p>
<p><strong>只要我们保证层层严格使用基类的构造函数/拷贝赋值, 就可以保证每一部分不会被遗漏</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个重要问题: 不要试图用构造函数和拷贝构造相互实现, 没有意义! (最多使用私有方法简化重复工作)</strong></p>
<blockquote>
<p>请记住:</p>
<p>copying functions（拷贝函数）应该保证拷贝一个 object（对象）的所有 data members（数据成员）以及所有的 base class parts（基类构件）。</p>
<p>不要试图依据一个 copying functions（拷贝函数）实现另一个。作为代替，将通用功能放入一个供双方调用的第三方函数。</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://evil-crow.github.io/2018/09/13/C++/EffC++/effective2/" data-id="cjne5ke8o00767ynrwjjb2j8f" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACF0lEQVR42u3aO25DMQwEwNz/0k6bxvYu6QSINKoM4/1GBUGR/PqK1+PHaq/P723fUi8MDIx/y3i8XM+uSV78CFb+/DebgoGBcQHj2Ue8via5KwG078XAwMCYPS7/oM2VGBgYGO0nvk4Tk0Np8gQMDAyMNoHLj6b59bN3YWBg3MOYHU3/5vev9DcwMDD+FeNRrn2A3pTnnr4RAwPjaEYe4PZNzZZdj2VgYGAcytgcL9vQuSm3vYFhYGAczZilcXkKuCm91ekmBgbGoYy2ebkJuO0GJS1MDAyMGxizlC4JoxtY+xwMDIyzGW0al4yfJsW12WDZm2kRDAyMQxmfGsJowS0gSUYxMDBOZczSuFlBbdMiLcptGBgYhzLyEYokHdwPwrbBGgMD4wbGrLifH1Dzst0wk8XAwDia8alBihkpbycUQyEYGBjHMdqbZ/8ku9gOW9T5JgYGxkGMWUjNw24boKM0EQMD42hGi9kMUsyaoHVui4GBcQ0jD3N5q3J2SM6TTgwMjHsY+YfOyvottUBiYGBcwJiNO8wKbe3QWHGIxcDAOI4xG6fYF+Y+29rEwMA4m9GGuTzU7tuZw5kRDAyMQxl5kJ2V59qdy78BAwPjNkZbJpu1AfZH2aiFiYGBgbEo1eUDGe3GYWBgYOwLaptnRluAgYFxAaNtBuTFuM29xcEYAwPjaEY74pAcTduy/m8MmWFgYBzB+AYEj6h2aFB6ygAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/EffectiveC/">EffectiveC++</a></div><div class="post-nav"><a class="pre" href="/2018/09/19/C++/EffC++/effective3/">&lt;星月夜&gt; Resource Management</a><a class="next" href="/2018/09/07/C++/EffC++/effective1/">&lt;星月夜&gt; Accustoming Yourself to C++</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ShellScript/">ShellScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/Vim/">Vim</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/EvilCrow/">EvilCrow</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/力量的源泉/">力量的源泉</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/experience/" style="font-size: 15px;">experience</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/standard/" style="font-size: 15px;">standard</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/hole/" style="font-size: 15px;">hole</a> <a href="/tags/ShellScript/" style="font-size: 15px;">ShellScript</a> <a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/C-Primer/" style="font-size: 15px;">C++Primer</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/C++/EffC++/effective5/"><星月夜> Implementations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/C/Expert_C_Programming/data_mem/"><咸鱼书> 运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/C++/EffC++/effective4/"><星月夜> Designs and Declarations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/C++/EffC++/effective3/"><星月夜> Resource Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/C++/EffC++/effective2/"><星月夜> Constructors, Destructors, and Assignment Operators</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/C++/EffC++/effective1/"><星月夜> Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Evilcrow/linux_setting/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/tools/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/two_level_array/">一个C语言指针的问题让我翻车</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>