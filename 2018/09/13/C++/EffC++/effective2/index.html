<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>&lt;星月夜&gt;_Constructors, Destructors, and Assignment Operators | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">&lt;星月夜&gt;_Constructors, Destructors, and Assignment Operators</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">&lt;星月夜&gt;_Constructors, Destructors, and Assignment Operators</h1><div class="post-meta">Sep 13, 2018<span> | </span><span class="category"><a href="/categories/C-C/">C/C++</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-05-Know-what-functions-C-silently-writes-and-calls"><span class="toc-number">1.</span> <span class="toc-text">Item 05: Know what functions C++ silently writes and calls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want"><span class="toc-number">2.</span> <span class="toc-text">Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-07-Declare-destructors-virtual-in-polymorphic-base-class"><span class="toc-number">3.</span> <span class="toc-text">Item 07: Declare destructors virtual in polymorphic base class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-08-Prevent-exception-from-leaving-destructors"><span class="toc-number">4.</span> <span class="toc-text">Item 08: Prevent exception from leaving destructors</span></a></li></ol></div></div><div class="post-content"><p><em>上一篇中,我们着重进行了C++中最最基础,和C有很大区别的地方,比如语言联邦, 减少预处理器的使用,</em><br><em>多使用const, 保证使用前初始化对象等几个方面</em></p>
<p><em>这一部分, 我们就来聊聊使C++语法变得如此复杂的”罪魁祸首”之一 —- 复杂的拷贝控制</em></p>
<h2 id="Item-05-Know-what-functions-C-silently-writes-and-calls"><a href="#Item-05-Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="Item 05: Know what functions C++ silently writes and calls"></a>Item 05: Know what functions C++ silently writes and calls</h2><p><em>这是一个关键的点, 我一直因此觉得C++足够傲娇.C/C++有着强大的性能,同时他们又兼具着许多风险行为</em><br><em>如何高效编程, 同时规避风险, 我觉得这就是C/C++的美感之一</em></p>
<p>我们在此处要讨论的是: <strong>在你不知道的情况下, C++默默编写并调用了哪些函数</strong><br>(PS: 此处重要针对讨论的是 <code>class</code>内部的情况, global作用域内, 不可能被凭空塞函数的)</p>
<p>先来看一个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单地例子: <code>class Temp {};</code>我们并没有为它编写任何的成员函数, 那么它可以使用吗?<br>比如:<br><code>Temp a;     // Constructor</code><br><code>Temp a(b);  // Copy-constructor</code><br><code>Temp a = b; // Copy-operator-assignment</code><br><code>{ .... }    // Destructor</code></p>
<p>经过实验, 你可以发现, 上面这些操作都是成功的!<br>为什么? 我们明明没有编写这些成员函数的啊! 这便是<strong>C++默默编写并调用的函数</strong></p>
<p>总共有下面这四(六)类:</p>
<ol>
<li>Constructor</li>
<li>Copy Constructor</li>
<li>Copy assignment operator</li>
<li>Move Constructor        (C++11)</li>
<li>Move assignment operator (C++11)</li>
<li>Destructor</li>
</ol>
<p>这些默默编写的函数存在着下面的特点:<br>1.public &amp;&amp; inline<br>2.默认初始化 &amp;&amp; 逐次拷贝<br>3.编译器生成的版本都是non-virtual的, (继承得来的除外)</p>
<p>暂且记下这些特点, 我们下面的讨论会用到, 并非分析如何处理此情况</p>
<p>所以上面的例子实际上是这样子的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    Temp();</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;);</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;);</span><br><span class="line">    Temp(Temp &amp;&amp;);</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(Temp &amp;&amp;);</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么, 编译器一定会生成这些函数吗? 是不是得思考一下?</p>
<p>我们有下面的结论:<br><strong>assignment operator不一定会生成, 其余的函数照样会生成</strong></p>
<p>考虑这样的情况:<br>1.内含reference的class,<br>2.内含const成员的class<br>3.base class的assignment operator为private</p>
<p>来解释一下这三种情况:<br>1.若含有reference, 拷贝赋值函数到底是修改reference(错误)还是其所指的内容(无意义)?<br>2.const成员怎么可能会被修改!<br>3.若base class的拷贝赋值为private, derive class的拷贝赋值函数便无法生成</p>
<p><strong>简单地来说, 我们设身处地的为编译器着想, 它是否可以处理这种情况, 从而进行判断</strong><br><strong>上面的情况便是: 编译器无法为这些情况处理, 所以它的copy assignment operator创建失败</strong></p>
<h2 id="Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want"><a href="#Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want" class="headerlink" title="Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want"></a>Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</h2><p><em>这一条款的讨论是基于 Item 05的, 处理编译器生成函数的不二法宝</em></p>
<p><strong>首先强调一个事实: 如今可以明确的说明对于编译器生成函数我们持有的态度</strong></p>
<p><em>还是hepangda的说法比较准确, “ C++11之后语言的语义更加明确 “</em><br><em>解释起来就是, C++之前的一些做法, 你不是很明确它的意思, 在一定条件下, 得借助注释才能迅速的理解</em></p>
<p>那么,我们先来说说在现代C++中如何处理这种问题吧,</p>
<p>现代C++中我们可以使用<strong>default, 以及delete</strong>来进行编译器生成函数的控制, 表明我们的态度</p>
<p>如下例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    Temp() = <span class="keyword">default</span>;</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp(Temp &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(Temp &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>通过语义明确的现代C++, 我们可以做到不想编译器自动生成的函数, 明确拒绝</strong><br><strong>如此的做法,也已经成为现代C++的编程规范之一了</strong></p>
<p><em>那么, 之前的C++是如何处理这样的问题呢 ?</em></p>
<p>这种问题还是会出现的, 我们还是之前的态度: 我们不能假定用户并不会犯错, 所以这种情况也应该处理掉的.<br>那么我们的入手点在于: compiler-gengrated functions 都是默认 <code>public &amp; inline</code><br>我们的入手点便是: 将其不能直接使用 =&gt; <strong>使用访问权限的控制手段</strong></p>
<p>我们提供以下两种思路:<br>1.<code>private &amp; implemention</code><br>2.<code>base-class &amp; implemention</code> (1.的基础上改良)</p>
<p>对于1, 我们的思路很明确, 就是使用<code>private</code>访权控制来拒绝我们不想使用的成员函数</p>
<p>但是, <code>member function</code>和<code>friend function</code>会打扰我们.</p>
<p><strong>于是, 我们就给予它便不实现, implmention =&gt; 链接器会报错</strong></p>
<blockquote>
<p>链接器报错 link-error<br>上面说到的链接器报错,是这个原因:<br>按照常人理解, 一般没有实现的函数, 会直接编译错误对吧 ?<br>但是C++因为分离式编译的原因 (区别参考于Java) ,前置声明了解一下, pimpl手法基础<br>知道link期间才会报错, 找不到函数的引用, 也就是实现之处, “no reference to FUNC”</p>
</blockquote>
<p>于是方法1 可以比较好的解决这个问题了.</p>
<p>尽管链接器报错, 也不会影响运行时效率, 可是我们还想尽早的报错为好, 将错误提前到编译期(Compiler)<br>有办法吗? 一定是有的!</p>
<p>使用OOP的手法: 继承<br>我们可以构造一个基类(因为不给予实现),将之继承, 然后正常编写即可.<br><strong>那么为什么会将报错提前至编译期呢 ? </strong></p>
<blockquote>
<p>无法进行构造, 因基类没有构造函数, 就是说一定要是用这个类构建对象, 才能错误提前到编译期</p>
</blockquote>
<p>举个例子如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopy</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    noncopy(<span class="keyword">const</span> noncopy &amp;);</span><br><span class="line">    noncopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncopy &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> :</span> <span class="keyword">public</span> noncopy &#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Temp t;</span><br></pre></td></tr></table></figure></p>
<p>这便是正确的使用举例</p>
<p><strong>我们建议使用现代C++语义明确的手法, C++03, 乃至98的手法, 只是作为开阔思路的解法了解即可</strong></p>
<h2 id="Item-07-Declare-destructors-virtual-in-polymorphic-base-class"><a href="#Item-07-Declare-destructors-virtual-in-polymorphic-base-class" class="headerlink" title="Item 07: Declare destructors virtual in polymorphic base class"></a>Item 07: Declare destructors virtual in polymorphic base class</h2><p>如果要在C++中提到 <code>virtual</code>这个词, 经常用在这两个方面: <code>virtual继承</code> 与 <code>virtual function</code></p>
<p>我们这一部分专注于<code>virtual function</code>的内容, 虚继承的内容都是后话.</p>
<p>首先来看一个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base();</span><br><span class="line">    ~base();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">base *pb = get_derive_pointer();   <span class="comment">// 为了多态需求使用, 基类指针(/引用皆可)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br></pre></td></tr></table></figure></p>
<p><code>delete pb;</code><strong>会造成严重的灾难性后果 !</strong><br><strong>因为delete一个基类指针, 而且它的析构函数是non-virtual, 在派生类中, 此析构仅仅是base析构</strong><br><strong>这样, 你也能想到析构的下场了吧, derive部分无法析构, 且指针销毁, 只剩下一个不完全的对象</strong></p>
<p>那么,正确的做法呢?</p>
<p><strong>使用virtual-destructor 在base-class中 (子类继承后,virtual属性一并继承)</strong></p>
<p>这个其实是多态性的基础–C++中,基类指针/引用可以指向派生类的对象, 因此才能实现多态性</p>
<p>这样一来, 就可以舒服的解决这个问题了.</p>
<p><em>那么, 从一个方面来考虑, 未提供nvirtual destructor的函数, 就很麻烦了, 万一被继承就要出篓子</em><br><em>比如: std::stirng, std::iostream等</em><br><em>EffectiveC++的作者在感慨 C++没有的 final 已经在现代C++中加入, 但是我在&lt; string &gt;中还没找到</em><br><em>反正, 注意对于未提供virtual destrutor的class, 可能本来就是没有被设计作为多态base-class考虑</em></p>
<p>我们再来稍微说说vitual的事,</p>
<p>下面这些是, hepangda给我的科普,</p>
<blockquote>
<p>C++中实现的多态是成本最小的之一. 很简单的问题, 使用计算机时, 多态是我们目前不可预测的,<br>在编译期无法预知, 那么最简单的, 就是打表的思想, 我把可能的情况都塞进去, 到时查表就行<br>而具有Basic Object的语言, 就可以完全实现反射, Java, Ruby等…</p>
</blockquote>
<p>基于上面的这段话:<br>virtual实际上对class进行了打表, 将可能的函数指针封进表中, 成为虚表 (virtual table)<br>而每个class中会留一个隐藏的虚表指针vptr (virtual ptr)<br>使用virtual会<strong>大程度的提高开销 ! ! !</strong>, 他会使可执行文件增加容量</p>
<p>举一个EffectiveC++中的例子:<br>(64位环境)一个类中,有两个int, 应该占8个字节, 这个时候加上一个virtual, 多一个vptr<br>class体积增加100% !</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;        =&gt; <span class="number">8</span> Bytes</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~B();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;        =&gt; <span class="number">16</span> Bytes</span><br></pre></td></tr></table></figure>
<p>另外我们再来说说<strong>抽象基类</strong>的事情:<br>abstract class 指的是含纯虚函数的类,<br><em>很不幸, 我们因为没有interface的关键字, 导致定义接口要使用抽象基类的手法</em><br><strong>我们要讨论的是, 如何拥有一个抽象基类</strong></p>
<p><strong>其实,也不麻烦,就是标题的 纯虚析构函数 即可</strong><br><em>因为纯虚 (pure virtaul), 所以是抽象基类</em><br><em>同时又是 virtual 析构函数, 所以不用担心析构的问题</em></p>
<p><strong>这里的窍门是: 要为 pure virtual destructor 提供一份定义</strong><br><strong>否则, derive class 的destructor都会爆炸的, 具体上一条款中关于implemention的问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vitrual ~Temp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Temp::~Temp() &#123; ; &#125;</span><br></pre></td></tr></table></figure>
<p>因此, 给出我们使用virtual的建议:<br><strong>记住: 仅仅在有多态需求时使用virtual函数, 其余时候(仅作为基类, 一般类)能不用就不要用virtual</strong></p>
<h2 id="Item-08-Prevent-exception-from-leaving-destructors"><a href="#Item-08-Prevent-exception-from-leaving-destructors" class="headerlink" title="Item 08: Prevent exception from leaving destructors"></a>Item 08: Prevent exception from leaving destructors</h2></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://evil-crow.github.io/2018/09/13/C++/EffC++/effective2/" data-id="cjm4zpmmu0074jfnrtjkcgjy2" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACF0lEQVR42u3aO25DMQwEwNz/0k6bxvYu6QSINKoM4/1GBUGR/PqK1+PHaq/P723fUi8MDIx/y3i8XM+uSV78CFb+/DebgoGBcQHj2Ue8via5KwG078XAwMCYPS7/oM2VGBgYGO0nvk4Tk0Np8gQMDAyMNoHLj6b59bN3YWBg3MOYHU3/5vev9DcwMDD+FeNRrn2A3pTnnr4RAwPjaEYe4PZNzZZdj2VgYGAcytgcL9vQuSm3vYFhYGAczZilcXkKuCm91ekmBgbGoYy2ebkJuO0GJS1MDAyMGxizlC4JoxtY+xwMDIyzGW0al4yfJsW12WDZm2kRDAyMQxmfGsJowS0gSUYxMDBOZczSuFlBbdMiLcptGBgYhzLyEYokHdwPwrbBGgMD4wbGrLifH1Dzst0wk8XAwDia8alBihkpbycUQyEYGBjHMdqbZ/8ku9gOW9T5JgYGxkGMWUjNw24boKM0EQMD42hGi9kMUsyaoHVui4GBcQ0jD3N5q3J2SM6TTgwMjHsY+YfOyvottUBiYGBcwJiNO8wKbe3QWHGIxcDAOI4xG6fYF+Y+29rEwMA4m9GGuTzU7tuZw5kRDAyMQxl5kJ2V59qdy78BAwPjNkZbJpu1AfZH2aiFiYGBgbEo1eUDGe3GYWBgYOwLaptnRluAgYFxAaNtBuTFuM29xcEYAwPjaEY74pAcTduy/m8MmWFgYBzB+AYEj6h2aFB6ygAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/EffectiveC/">EffectiveC++</a></div><div class="post-nav"><a class="pre" href="/2018/09/13/C/Expert_C_Programming/data_mem/">&lt;咸鱼书&gt;_运行时数据结构与内存</a><a class="next" href="/2018/09/07/C++/EffC++/effective1/">&lt;星月夜&gt;_Accustoming Yourself to C++</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/Vim/">Vim</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/EvilCrow/">EvilCrow</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/力量的源泉/">力量的源泉</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/hole/" style="font-size: 15px;">hole</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/standard/" style="font-size: 15px;">standard</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/experience/" style="font-size: 15px;">experience</a> <a href="/tags/Shellscript/" style="font-size: 15px;">Shellscript</a> <a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a> <a href="/tags/C-Primer/" style="font-size: 15px;">C++Primer</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/C/Expert_C_Programming/data_mem/"><咸鱼书>_运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/C++/EffC++/effective2/"><星月夜>_Constructors, Destructors, and Assignment Operators</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/C++/EffC++/effective1/"><星月夜>_Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Evilcrow/linux_setting/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/tools/git_tool/">关于github绿点的常见问题--邮箱</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/C/two_level_array/">一个C语言指针的问题让我翻车</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/C++/C++Primer/C3P_VI/">VI Function</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/SQL/MySQL_start/">MySQL入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/C++/Other/C_C++_expr/">C/C++坑点总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>