<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>&lt;STL&gt; Containers | Road to Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">&lt;STL&gt; Containers</h1><a id="logo" href="/.">Road to Coding</a><p class="description">只要那一抹笑容尚存，我便心无旁骛。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">&lt;STL&gt; Containers</h1><div class="post-meta">Nov 8, 2018<span> | </span><span class="category"><a href="/categories/C-C/">C/C++</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-01-Choose-you-containers-with-care"><span class="toc-number">1.</span> <span class="toc-text">Item 01: Choose you containers with care</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-02-Beware-the-illusion-of-container-independent-code"><span class="toc-number">2.</span> <span class="toc-text">Item 02: Beware the illusion of container-independent code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-03-Make-copying-cheap-and-correct-for-objects-in-containers"><span class="toc-number">3.</span> <span class="toc-text">Item 03:  Make copying cheap and correct for objects in containers.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-04-Call-empty-instead-of-checking-size-against-zero"><span class="toc-number">4.</span> <span class="toc-text">Item 04:  Call empty instead of checking size() against zero.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-05-Prefer-range-member-functions-to-their-single-element-counterparts"><span class="toc-number">5.</span> <span class="toc-text">Item 05: Prefer range member functions to their single-element counterparts.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-06-Be-alert-for-C-’s-most-vexing-parse"><span class="toc-number">6.</span> <span class="toc-text">Item 06:  Be alert for C++’s most vexing parse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-07-When-using-containers-of-newed-pointers-remember-to-delete-the-pointers-before-the-container-is-destroyed"><span class="toc-number">7.</span> <span class="toc-text">Item 07: When using containers of newed pointers, remember to delete the pointers before the container is destroyed.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-08-Never-create-containers-of-auto-ptrs"><span class="toc-number">8.</span> <span class="toc-text">Item 08:  Never create containers of auto_ptrs.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-09-Choose-carefully-among-erasing-options"><span class="toc-number">9.</span> <span class="toc-text">Item 09:  Choose carefully among erasing options</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#删除元素"><span class="toc-number">9.1.</span> <span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照判别式来删除"><span class="toc-number">9.2.</span> <span class="toc-text">按照判别式来删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除元素和额外的操作"><span class="toc-number">9.3.</span> <span class="toc-text">删除元素和额外的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-10-Be-aware-of-allocator-conventions-and-restrictions"><span class="toc-number">10.</span> <span class="toc-text">Item 10:  Be aware of allocator conventions and restrictions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-11-Understand-the-legitimate-uses-of-custom-allocators"><span class="toc-number">11.</span> <span class="toc-text">Item 11:  Understand the legitimate uses of custom allocators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-12-Have-realistic-expectations-about-the-thread-safety-of-STL-containers"><span class="toc-number">12.</span> <span class="toc-text">Item 12: Have realistic expectations about the thread safety of STL containers.</span></a></li></ol></div></div><div class="post-content"><p><em>第一次听说容器的概念还是在C中, 形容存放对象的对象就叫做容器.</em><br><em>当然在C中, 对象与此处的对象不同,广义上的对象,指的是具名分配的内存.</em><br><em>但是容器的概念沿用下来, 在C中数组也被视为一种容器.</em><br><em>那么C++中容器究竟是什么样子, 我们又应该注意些什么要点呢?</em></p>
<p>首先, 我们来说说容器. <strong>用来存放对象的对象就叫做容器</strong><br>在C++中,主要是两(三)种类型的容器: 顺序容器(序列容器) + 关联容器  + 无序关联容器(C++11) [即哈希容器]<br>另外还存在容器适配器(Container Adapter) 以及 span(C++20)</p>
<p>因为我们使用容器, 要容纳各种类型. 所以容器都是模板实现, 故容器是STL的重要组成部分之一</p>
<p>我们就来看看, 容器的使用究竟都需要注意些什么方面吧!</p>
<h2 id="Item-01-Choose-you-containers-with-care"><a href="#Item-01-Choose-you-containers-with-care" class="headerlink" title="Item 01: Choose you containers with care"></a>Item 01: Choose you containers with care</h2><p>是的, 可供我们选择的容器中类相当多. 如何选择适合我们的容器便成了一个问题.<br>我们先从各种容器的特点来进行分析吧, 这样采访便我们确定适合自己使用的类型.</p>
<p>发展至今, 完整的容器列表如下:</p>
<table>
<thead>
<tr>
<th>顺序容器</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>向量,说的简单点就是变长数组(非VLA), 支持尾部的插入, 弹出.适合构造栈</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列, 支持从首尾进行元素的插入和删除</td>
</tr>
<tr>
<td>list</td>
<td>双向链表, 支持首尾的元素插入和删除</td>
</tr>
<tr>
<td>array (C++11)</td>
<td>将内置数组STL化, 支持STL的通用操作, 实用性一般.[不过为了STL规范化]</td>
</tr>
<tr>
<td>forward_list (C++11)</td>
<td>单向链表, 手写的性能最好的单向链表</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>关联容器</th>
<th>无序关联容器</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>unordered_map (C++11)</td>
<td>K-V对集合,底层使用自平衡二叉查找树</td>
</tr>
<tr>
<td>set</td>
<td>unordered_set (C++11)</td>
<td>唯一键集合</td>
</tr>
<tr>
<td>multimap</td>
<td>unordered_multimap (C++11)</td>
<td>(允许重复)K-V对集合</td>
</tr>
<tr>
<td>multiset</td>
<td>unordered_multiset (C++11)</td>
<td>(允许重复)唯一键集合</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>适配器</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>stack</td>
<td>堆栈适配器, 一般使用vector, deque构造</td>
</tr>
<tr>
<td>queue</td>
<td>队列适配器, 一般使用deque构造</td>
</tr>
<tr>
<td>priority_queue</td>
<td>优先队列</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>相接容器</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>span (C++20)</td>
<td>…,看Reference吧,C++20为此还添加了相接迭代器</td>
</tr>
</tbody>
</table>
<p>关于迭代器非法化:</p>
<p><strong>只读方法决不非法化迭代器或引用。修改容器内容的方法可能非法化迭代器和/或引用，
</strong></p>
<p>按照常理我们进行容器的选择时, 按照这样的思路: <em>容器的特点来进行考虑</em></p>
<p>例如:</p>
<ul>
<li>vector擅长在尾后添加/删除元素</li>
<li>deque擅长在首尾添加/删除元素</li>
<li>…</li>
</ul>
<p>然而我们现在要考虑的不仅仅是这些, 我们可以从下面这些方面入手:</p>
<ol>
<li>是否需要在任意位置插入元素</li>
<li>是否关心元素在容器中的排序情况 (此处强推哈希容器, 即无序关联容器)</li>
<li>需要何种类型的迭代器 (vector中是任意访问迭代器, List中是双向迭代器)</li>
<li>查找速度是否是关键因素 (无序关联容器 &gt; 排序vector &gt; 序列容器)</li>
<li>…</li>
</ol>
<p>以上只是我们提出的一些选择容器的建议, 本质上还是要依靠: <strong>我们对于不同容器的熟悉程度决定</strong></p>
<h2 id="Item-02-Beware-the-illusion-of-container-independent-code"><a href="#Item-02-Beware-the-illusion-of-container-independent-code" class="headerlink" title="Item 02: Beware the illusion of container-independent code"></a>Item 02: Beware the illusion of container-independent code</h2><p>STL的设计概念是泛化的思想.没错,它在想办法将元素存放在容器中实现为类型无关的 (使用Template)</p>
<p>也许就会引发出一个问题: <em>你想尝试编写与容器类型无关的代码, 以此来实现更高程度的泛化</em></p>
<p>可行吗 ? <strong>一定不可行</strong></p>
<p>可以稍微考虑一下: 序列容器提供了<code>Container::push_back</code>,<code>Container::push_front</code>等方法, 关联容器则提供了<code>Container::lower_bound</code>, <code>Container::upper_bound</code>, <code>Container::equal_range</code>等方法</p>
<p>这种你如何编写容器无关的代码 ? ? ?</p>
<p>那么,范围缩小一点. 对于同时序列容器, 我们比较<code>list</code>和<code>vector</code></p>
<p><code>list::splice</code>完成列表的链接工作, 保证常数时间.<br><code>vector::reserve</code>用于消除重分配,</p>
<p>这两个小的能力,在<code>list</code>与<code>vector</code>之间可以实现互操作吗？</p>
<p><strong>答案否定的！</strong></p>
<p><strong>最后, 如果我们能够实现真正”泛化”的容器代码, 其所能提供的功能一定是极为有限的</strong><br><strong>这种东西, 还能够叫做STL吗 ? </strong></p>
<p>究其原因, 实质是因为：　<strong>不同的容器是为了不同的功能而设计, 而且他们也提供了不同性能的迭代器</strong><br>因此我们尝试编写容器无关的代码, <strong>从出发点就是错误的, 不同容器有不同用途, 怎么能轻易泛化呢?</strong></p>
<p>但是, 如果真的有一天, 我们需要进行容器的修改, 我们该怎么办呢?</p>
<p>一行一行代码去修改吗? 那肯定是不现实的.</p>
<p>我们可以提供封装技术. 最基础的封装就是类型定义<code>typedef/using</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weight</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> WidgetContainer = <span class="built_in">vector</span>&lt;Widget&gt;;</span><br><span class="line"><span class="keyword">using</span> WCIterator = WidgetContainer::iterator;</span><br><span class="line"></span><br><span class="line">WidgetContainer cw;</span><br><span class="line">widget temp;</span><br><span class="line"><span class="keyword">auto</span> it = find(cw.cbegin(), cw.cend(), temp);</span><br></pre></td></tr></table></figure>
<p>在我们有需要的时候进行替换即可.</p>
<p>再高级一点的封装便是使用面向对象的class机制了</p>
<h2 id="Item-03-Make-copying-cheap-and-correct-for-objects-in-containers"><a href="#Item-03-Make-copying-cheap-and-correct-for-objects-in-containers" class="headerlink" title="Item 03:  Make copying cheap and correct for objects in containers."></a>Item 03:  Make copying cheap and correct for objects in containers.</h2><p>曾经在EffectiveC++的系列博客中, 我们提到过: 我们推荐pass-by-reference 的形式进行值传递<br>我们也说过, C++是一个语言联邦, 我需要根据目前所处的不同领域来决定我们应该使用的方式.</p>
<p><strong>在STL中, 使用的是pass-by-value的形式</strong></p>
<p>没错, 我们将值拷贝进入容器中, 进行操作, 最后又将值拷贝出来.</p>
<p>整个STL的工作方式就是进行拷贝, 为什么呢?<br><em>Container是提供容器功能的, 我们可以同时将一组数据装在不同的容器中进行不同需求的操作</em><br><em>这样, 你明白了, 我们为什么处理拷贝了吗 ?</em></p>
<p>那么,它如何实现呢? 是的依靠你的<code>copy constructor</code> / <code>copy assign operator</code></p>
<p>那么, 比如我们提供下面这样的类型,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp();</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp <span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp <span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它是无法使用容器的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; ::<span class="keyword">new</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(__p)) _T1(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...); &#125;</span><br><span class="line">       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="comment">// 其中 _T1是构造函数, __args是模板变参. 这里的构造, 委托给对象的拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>即使使用C++11,新增加的<code>Container::emplace_back</code>,直接构造,也需要使用<code>Temp::copy_constructor</code></p>
<p>那么, 我们实际进行容器使用的时候, 相当需要注意的一个问题便是: <strong>splice down(剥离)</strong></p>
<p>指的是: <strong>对于基类实例化的容器, 我们存放派生类的对象, 就会导致派生类对象中的派生部分剥离</strong></p>
<p>=&gt; <strong>会导致, 我们使用多态机制失败, 至于为什么, 不言自喻</strong></p>
<p>那么, 我们有什么办法呢? <strong>指针</strong>, Emmm, 是个不错的想法, 但是指针太危险了</p>
<p>有什么办法呢? 我们之前在EffectiveC++的内容中提到过, 智能指针. 是的,这是个不错的想法.</p>
<h2 id="Item-04-Call-empty-instead-of-checking-size-against-zero"><a href="#Item-04-Call-empty-instead-of-checking-size-against-zero" class="headerlink" title="Item 04:  Call empty instead of checking size() against zero."></a>Item 04:  Call empty instead of checking size() against zero.</h2><p>使用<code>Container::empty()</code> 替换 <code>Container::size()</code></p>
<p>这是问题吗? 是的, 在追求效率的STL面前, 适当的编码是真的可以提高效率</p>
<p>为什么呢? 这个问题<br><strong>原因就是: STL规定了实现要求的时间复杂度, 却不限制实现方式</strong></p>
<p>而<code>.empty()</code>是常数时间, <code>.size()</code>对于某些容器并非常数时间.</p>
<p>我们来看这样的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::empty();     <span class="comment">// 空</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::size();      <span class="comment">// 大小</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::splice();    <span class="comment">// 链接操作</span></span><br></pre></td></tr></table></figure></p>
<p>对于标准容器<code>list</code>, 我们将它作为链表来使用, 也即是说: 我们要求它擅长进行节点的创建与链接操作</p>
<p>因此, <code>list::splice</code>的实现被要求是常数时间, 即链接节点的时间复杂度与链表长度无关.<br>所以, 这也就意味着, 我们在<code>list::size</code>实现时, 就达到了线性时间, 因为它必须遍历链表才能求出长度<br>所以, 你懂了吧,为什么我们使用<code>empty()</code>而非<code>size() == 0</code>进行空容器的判断</p>
<p><em>当然, 只是针对于splice是常数时间, size是线性时间实现的STL, 如果有其他实现, 我们便要阅读文档判断</em></p>
<p>STL是追求高性能的标准库设施, 高效的使用STL, 也是我们所努力的目标.</p>
<h2 id="Item-05-Prefer-range-member-functions-to-their-single-element-counterparts"><a href="#Item-05-Prefer-range-member-functions-to-their-single-element-counterparts" class="headerlink" title="Item 05: Prefer range member functions to their single-element counterparts."></a>Item 05: Prefer range member functions to their single-element counterparts.</h2><p>如果说之前的手法都是小打小闹, 那么这一点, 则是明显提高效率的手法 !</p>
<p>Scott Meyers先生首先提出了一个<strong>将某容器c后半部分如何拷贝进vector</strong>的问题.<br>正确答案是 <code>vec.assign(c.cbegin() + c.size() / 2, c.cend());</code></p>
<p>很简洁明了, 不是吗? 另外我要强调的是: <strong>这同时还是相当高效的操作</strong></p>
<p>首先是: 我们经常会写成循环的方式, (<del>如果你写成多重循环, 拖出去斩了</del>)</p>
<p>那么, 这里便是我们所要进行阐述的地方: <strong>使用区间形式的调用 替换(replcae) 单元素形式的调用</strong><br>是的没错, 正是这样: <strong>区间形式的操作, 比你想像中效率要好一大截</strong></p>
<p>主要基于以下三大原因: [这部分主要针对顺序容器]</p>
<ol>
<li><p>区间形式的调用, 减少多次函数调用, (当然<code>inline</code>就不会有额外开销,但这个很难是<code>inline</code>实现)</p>
</li>
<li><p>Emmm ,你仔细想想.顺序容器我们之前说过, 它也是连续内存的容器,<br>所以: <strong>进行元素的修改, 会导致元素的挪移,没错吧 ? </strong><br>那么, 我们如果使用区间形式的调用 =&gt; <strong>是的, 一次到位, 减少了相当大次数的挪移(具体数据自算)</strong></p>
</li>
<li><p>第三个, 是针对STL的动态扩展特性来说的, 因为其动态的特性, 所以我们才舍弃内置数组/C-String<br>当然, <code>std::array(C++11)</code>可以了解一下(统一规范, 没有什么大用…)<br>来了, 关键的: <strong>插入, 修改此类操作, 经常超出容器的容量(区分容量/大小), 会导致重分配</strong><br>重分配一般涉及 <strong>重分配 -&gt; 拷贝构造 -&gt; 析构 -&gt; 释放内存</strong><br>按照, 大多数<code>vector</code>的实现规范, 插入1000个元素, 基本上近似于10次重分配<br>而如果我们使用<strong>区间形式调用, 还是同第二点, 一步到<del>胃</del>, 不对, 一步到位, 效率增长可想而知</strong></p>
</li>
</ol>
<p>听了上面的三点分析, 是不是恍然大悟呢? 我们还没说完:</p>
<blockquote>
<p>Tips:</p>
<ol>
<li>我们最开始展示了<code>Container::assign</code>的用法, 旨在说明, 还存在方便的成员函数可用<br>但是, 我们更范用性的操作是<code>Container::insert</code>, 赋值也是一种插入嘛.<br>不过, 我个人(当然是Scott先生提到过), <code>std::copy</code>其实有相当大的误导性<br>STL, 就是拷贝, 使用<code>copy</code>一方面是会误导我们针对明确语义的<code>assign</code>, <code>insert</code>操作<br>更重要的是, 一般实现, copy展开之后, 基本就是显式循环, <strong>是的, 上面三个分析,不复存在</strong><br>即使你的确使用了区间形式的调用…</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>我们针对第二点, 需要注意的是, 我们能够一步到位的运算挪移,<br>是要建立在迭代器支持的基础上的, 这种迭代器, <strong>前向迭代器往上</strong><br>但是, 一般容器提供的都达到了这一步,<br>除非是<strong>输入迭代器(等同于单元素调用, 步步移动)</strong>, 不然不需要考虑这一点.</li>
</ol>
</blockquote>
<p><em>虽然有上面两个tips, 但是, 好像并无大碍, 不是吗 ? </em></p>
<p>那么,我们需要注意的是什么? <strong>该关联容器了</strong></p>
<p><strong>众所周知, 关联容器, 一般是基于节点的容器, 实现上经常是链表/树等</strong></p>
<p><em>那么, 我们的分析还实用吗 ? </em></p>
<p>我们对于关联容器要从这一方面来切入: 就拿list来说.<br><img src="http://phxjezimr.bkt.clouddn.com/STL_list.png" alt="std::list::insert"></p>
<p>其中要干什么? <strong>修改指针指向, 没错吧?</strong></p>
<p><strong>那么,单次循环插入, 和区间一次链接, 做进行的操作开销, 懂了吧?</strong></p>
<p><em>是的, 指针赋值开销很低, 但是, 不付出开销岂不是更好 ? </em></p>
<p>那么, 我们总结一下:</p>
<ol>
<li>插入(insert)  建议使用<code>std::COntainer::insert(pos, c.cbegin(), c.cend())</code></li>
<li>赋值(assign) 建议使用<code>std::Container::assign(c.cbegin(), c.cend())</code></li>
<li>删除(erase) 建议使用<code>std::Container::erase(c.begin(). c.end());</code></li>
</ol>
<p>是的, 除非你有足够的理由能够推翻三驾马车, 否则,使用区间形式的调用是更好的选择</p>
<h2 id="Item-06-Be-alert-for-C-’s-most-vexing-parse"><a href="#Item-06-Be-alert-for-C-’s-most-vexing-parse" class="headerlink" title="Item 06:  Be alert for C++’s most vexing parse"></a>Item 06:  Be alert for C++’s most vexing parse</h2><p>摆脱C++烦人的分析(parse)机制, 是的,这个问题主要是进行函数原型的诊断所导致的问题</p>
<p>函数原型会有什么问题 ?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weight</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Weight <span class="title">w</span><span class="params">()</span></span>;            <span class="comment">// Error !</span></span><br><span class="line">Weight w;              <span class="comment">// 使用default constructor</span></span><br></pre></td></tr></table></figure></p>
<p>是的, 我们在C++中调用默认构造函数, <strong>一定不能加上括号, 否则会被parse =&gt; function prototype</strong></p>
<p>这种创建对象还比较明显, 下面这种例子就相当隐晦了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::for_each(istream_iterator(file), istream_iterator());</span><br></pre></td></tr></table></figure>
<p>看上去并没有什么问题, 但这也只是看上去没有什么问题..<br>这其实是一个函数原型的声明</p>
<p>我们来分析一下:<br>1: 类型为<code>istream_iterator</code>名为<code>file</code>的变量.<br>2: 返回值为<code>istream_iterator</code>类型, 无参数的函数指针 [此处省略函数名, 所以可以没有(*fp)]</p>
<p>看看我们下面的正常用法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void foo(int (a), void(int));             // 我们在函数原型中是可以省略参数名的</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;                       <span class="comment">// UNP中看到的邪教, 其实声明也不一定放外面</span></span><br><span class="line">    foo(<span class="number">2</span>, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时, 此处说明函数与函数指针, 用法相同, 不过语义是不同的. (指针 | 函数)</span></span><br><span class="line">void foo(int a, void fp(int)) &#123;...&#125;       // 定义中, 因为我们要使用参数, 所以函数名不可省略</span><br></pre></td></tr></table></figure>
<p><strong>我们在此处着重强调的是: 不要因为分析机制而产生误用!</strong></p>
<h2 id="Item-07-When-using-containers-of-newed-pointers-remember-to-delete-the-pointers-before-the-container-is-destroyed"><a href="#Item-07-When-using-containers-of-newed-pointers-remember-to-delete-the-pointers-before-the-container-is-destroyed" class="headerlink" title="Item 07: When using containers of newed pointers, remember to delete the pointers before the container is destroyed."></a>Item 07: When using containers of newed pointers, remember to delete the pointers before the container is destroyed.</h2><p>这一条款, 我觉得可以是 EffectiveC++中 Chapter III 资源管理的扩展 (具象化)</p>
<p><strong>当容器中使用new的到的指针时, 在容器销毁时, 一定要delete掉</strong></p>
<p>这是怎么说? <strong>因为C++中析构和释放内存是两码事</strong></p>
<p>我们从容器中退出时, 它仅仅是, 对象销毁(是的, 指针销毁掉了), <strong>但是, 相关的内存并没有释放掉</strong><br><strong>因此造成了内存泄漏 !(Memory Leak)</strong></p>
<p>来看个例子吧:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Weight *&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (...)</span><br><span class="line">        vec.push_back(<span class="keyword">new</span> Weight); <span class="comment">// vec.emplace_back(new Weight)</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;                 <span class="comment">// Memory Leak</span></span><br></pre></td></tr></table></figure>
<p>那么, 单纯的构造却不delete势必会造成问题.</p>
<p>如果这样呢?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Weight *&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (...)</span><br><span class="line">        vec.push_back(<span class="keyword">new</span> Weight); <span class="comment">// vec.emplace_back(new Weight)</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;var : vec)          <span class="comment">// Iterator 遍历当然也行</span></span><br><span class="line">        <span class="keyword">delete</span> var;</span><br><span class="line">&#125;                 <span class="comment">// Memory Leak</span></span><br></pre></td></tr></table></figure>
<p>这种做法情况比上面好一点, 也只是好一点….<br><strong>因为, 要是第一个delete的时候, throw exception了, 后面又都是内存泄漏</strong></p>
<p>那么, 还有办法吗? 有的!  [其实是个换皮怪]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为我们会修改容器中的元素, 所以不使用Container::c[begin | end]();</span></span><br><span class="line">for_each(vec.begin(), vec.end(), UnaryFunction);</span><br></pre></td></tr></table></figure>
<p>那么, 这个UnaryFunction怎么写 ?</p>
<p>STL中有这么些概念: 谓词, 基类, 函数适配器. (自行了解, 或者我后面会提及)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnaryFunction的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用function object (其实就是函数重载运算符)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteObject</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">const</span> T*, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *pointer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for_each(vec.beign(), vec.end(), DeleteObject&lt;Weight&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. lambda算式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 支持lambda中auto推导, C++11, lambda必须写成具体的类型, 使用template又略显粗糙</span></span><br><span class="line">for_each(vec.begin(), vec.end(), [](<span class="keyword">auto</span> &amp;var)&#123; <span class="keyword">delete</span> vec; &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用bind() C++11 提供, 不同于之前的 bin1st, bin2nd</span></span><br><span class="line"><span class="comment">// 语法丑陋, 暂不展示 [主要是bind提供适配功能, 还要依靠其他函数...]</span></span><br></pre></td></tr></table></figure>
<p><strong>此处, 因为历史原因, 但是现在lambda一个式子就可以把函数对象, 适配器, bind通通吃掉</strong></p>
<p>如果你很喜欢写函数对象也行 (lambda到std::function是不会隐式推导的, 这个时候使用函数对象适配)</p>
<p>关于上面的函数对象例子, 我们必须是知道: <strong>容器元素为Weight, 才能操作, 那么又其他办法吗?</strong></p>
<p>有!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteObject</span> &#123;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T *pointer)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">delete</span> pointer;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(vec.begin(), vec.end(), DeleteObject());    <span class="comment">// 会自行根据传入的参数推断类型</span></span><br></pre></td></tr></table></figure>
<p>有什么好处吗? 有的!<br><em>比如有的类没有虚析构函数, 那么,你继承之后, 如果误以为他有虚析构函数, 而使用基类指针delete</em><br>懂了吧?</p>
<p>但是我们使用模板的形式, 保证自动类型推导.<br><strong>是不是写的代码少, 还反而准确呢? [是的, 代码越少, 错误越少, 乱*</strong>装13就是作死]**</p>
<p>但是, 回到我们的主题上来:  <code>std::for_each</code>只是省得写显示的循环, 还是会有内存泄漏的风险</p>
<p><em>即使是C++20中的提供policy的形式, 也只是可能能够不按顺序操作, 但这一切都是徒劳</em><br><em>可能只有std::TS中的并行算法, 还有机会解决这种问题</em></p>
<p>真的无解了吗? 怎么可能?</p>
<p>想想我们之前在EffectiveC++中的解法: <strong>是的, 使用类管理资源, RAII !, 具体下来就是 智能指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Weight&gt;&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (...)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Weight&gt;(<span class="keyword">new</span> Weight));</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;       <span class="comment">// Memory must be released</span></span><br></pre></td></tr></table></figure>
<p>使用智能指针的形式, 可以保证无论是手工忘记, 还是异常抛出, 资源都一定不会泄漏!</p>
<h2 id="Item-08-Never-create-containers-of-auto-ptrs"><a href="#Item-08-Never-create-containers-of-auto-ptrs" class="headerlink" title="Item 08:  Never create containers of auto_ptrs."></a>Item 08:  Never create containers of auto_ptrs.</h2><p>这一条款是在说: <code>std::auto_ptr</code>类似于<code>std::unique_ptr</code>, 在使用中会被置空, 交出资源.</p>
<p>auto_ptr并非真正意义上的智能指针, 它是历史上一个实现不完全的, <code>std::unqiue_str</code></p>
<p>鉴于至今, 我们已经有<code>std::shared_ptr</code>和<code>std::unique_str</code>以及避免环回的<code>std::weak_ptr</code></p>
<p>所以, 此条款, 我们不再讨论.</p>
<h2 id="Item-09-Choose-carefully-among-erasing-options"><a href="#Item-09-Choose-carefully-among-erasing-options" class="headerlink" title="Item 09:  Choose carefully among erasing options"></a>Item 09:  Choose carefully among erasing options</h2><p>之前我们重点在如何往容器中添加元素, 现在我们来聊聊删除元素的手法<br>对于如何删除容器中的元素的手法, 我们分为三类,三个层次说明:</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ol>
<li><p>顺序容器, 我们使用erase-remove的手法</p>
<p><code>Container::erase</code>是它擦除未指定值并减小容器的物理大小,<br><code>std::remove</code>是迁移（以移动赋值的方式[C++11]）范围中的元素进行移除。保持剩余元素的相对顺序，且不更改容器的物理大小 [即是说, 从remove返回到end()的迭代器不失效, 仍可使用]</p>
<p>所以, 我们将这两个组件配合起来. 使用remove-erase的模式</p>
<p><em>为什么要使用<code>std::remove</code>直接<code>Container::erase</code>不是也能达成效果么? </em><br><strong>想想之前说的, 区间形式的调用和遍历容器单元素调用, 懂了吧 ?</strong></p>
<p>基本形式是这样:<br><code>vec.erase(remove(vec.begin(), vec.end(), val), vec.end());</code></p>
</li>
<li><p><code>std::list</code> (是的, list虽然是顺序容器, 但是它的实现方式又类似于关联容器, 所以要单独拿出来说)</p>
<p>怎么玩? 直接<code>list.remove(val)</code>即可,,为什么不区间 (因为<code>std::list::remove</code>之间移除指定val的元素)</p>
</li>
<li><p>关联容器,我们直接erase即可, 同时保证是对数时间开销<br><strong>注意: 标准关联容器, 没有remove成员函数, 且使用算法可能覆盖容器的值, 更甚至于会破坏容器</strong></p>
</li>
</ol>
<h3 id="按照判别式来删除"><a href="#按照判别式来删除" class="headerlink" title="按照判别式来删除"></a>按照判别式来删除</h3><p>也就是说, 某个满足条件的值被删除, 不仅仅是某个指定的值了.</p>
<ol>
<li><p>顺序容器, 将<code>std::remove</code>更换为使用<code>std::remove_if</code>一切同往常使用</p>
</li>
<li><p><code>std::list</code>我们同样使用<code>std::remove_if</code>即可</p>
</li>
<li><p>关联容器, 这怎么办呢?</p>
<p>不不不, 不能这样来, 因为,关联容器的<code>Container::erase</code>使用之后会是的指向此元素的迭代器失效<br>什么意思, 即我们在循环中, 使用<code>++</code>的时候, 已经是是在一个无效的迭代器上操作, 结果是未定义的<br>那么,怎么办? <strong>保存迭代器的值, 然后进行操作即可, 好办法</strong></p>
<p><em>另一种办法是, 使用Copy_and_Swap的手法, 通过<code>std::remove_copy_if</code> + <code>std::swap</code>操作</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.begin(); i != c.end(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BadValue(*i))</span><br><span class="line">        i = c.erase(i);                  <span class="comment">// 操作成功 !</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p> 上面的操作是难能可贵的, <strong>因为在C++11之前,关联容器的</strong><code>Container::erase()</code><strong>返回void</strong><br> 也即是说: <strong>我们无法得到删除操作后, 下一个合理的位置!</strong><br> 之前的做法是 <code>c.erase(i++);</code> 籍此保证迭代器未失效<br> 所以说: C++11真的是带来了巨变, 为我们提供了高效的操作</p>
<h3 id="删除元素和额外的操作"><a href="#删除元素和额外的操作" class="headerlink" title="删除元素和额外的操作"></a>删除元素和额外的操作</h3><p>怎么说呢?我们这一类说的是, 实际中经常使用的情况: 比如志记需求 (<del>完了, 迷上侯捷的说法了</del>)</p>
<ol>
<li><p>顺序容器</p>
<p><strong>呦霍, 完蛋咯 ~</strong><br>现在无法使用算法了, 因为我们无法在其中进行额外操作. (需求肯定是优先效率的)<br>怎么办呢? 而且 <strong>顺序容器删除后, 后面所有元素的迭代器都会失效的, 因为它基于连续内存分配</strong></p>
<p>想想上面关联容器的做法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.begin(); i != vec.end(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BadValue(*i)) &#123;</span><br><span class="line">     <span class="built_in">log</span>(..);</span><br><span class="line">        i = vec.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;       <span class="comment">// 同理即可 , OK!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>std::list</code></p>
<p>做法同其他顺序容器</p>
</li>
<li><p>关联容器</p>
<p>同我们之前的讨论, 是不是很清晰了呢 ? </p>
</li>
</ol>
<p><strong>小小总结一下:</strong></p>
<p>对于直接删除: <code>remove-erase</code> + <code>std::list::remove</code> + <code>Loop: Container::erase</code><br>条件删除: <code>remove_if-erase + lambda</code> + <code>std::list::remove_if</code> + <code>Loop: Container::erase</code><br>额外操作: <code>Loop: return value</code> + <code>std::list::erase</code> + <code>Loop: return value</code></p>
<h2 id="Item-10-Be-aware-of-allocator-conventions-and-restrictions"><a href="#Item-10-Be-aware-of-allocator-conventions-and-restrictions" class="headerlink" title="Item 10:  Be aware of allocator conventions and restrictions"></a>Item 10:  Be aware of allocator conventions and restrictions</h2><p>Allocator是一个相当重要的内容, 但是也没有想想中那么重要… (历史遗留问题比较严重)</p>
<p>因为这部分内容是真的比较操蛋, 所以我拣重要的来说, 至于深刻理解分配机制: 等我STL源码吧.</p>
<p>重要的内容有下面几点:</p>
<ol>
<li>分配器是一个模板, 其实不难理解, 因为他要针对各种STL容器来进行施用</li>
<li>提供类型,<code>Allocator::pointer</code>与<code>Allocator::reference</code>, 但是, 始终为<code>T *</code>与<code>T &amp;</code></li>
<li>尽量不要使Allocator含有状态, 也就是说: <strong>避免分配器中使用非静态成员</strong><br>[因为我们对于同一容器特化的不同实例, 都要能施用相同的分配和释放操作]</li>
<li><code>std::Allocator</code>的使用习惯与<code>new operator</code>并不相同, 体现在函数参数传递与返回值上</li>
<li><code>std::rebind</code>是施行于某些类型上的关键 !</li>
</ol>
<p>我们在这里详细来说<code>std::Allocator::rebind</code>, 它其实只是一个提供类型的, — <strong>模板</strong></p>
<p>举个例子: <code>std::list</code>的普遍实现采用了链表的形式, 也就是说, 一般是这样:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Allocator = allocator&lt;T&gt; &gt;</span><br><span class="line">class _list &#123;</span><br><span class="line">class ListNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode(T x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *left;</span><br><span class="line">    ListNode *right;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list内部使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">list</span> &#123;</span>                            <span class="comment">// class不像namespace, 它必须是连续的</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::allocator&lt;T&gt; allocator_list;     <span class="comment">// 使用</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是的, 我们<code>list</code>的类型是<code>int</code>, 但是我们要分配的是<code>int</code>吗? <strong>否 !</strong>,我们要分配的是: <strong>ListNode</strong></p>
<p>于是, <code>std::allocator::rebind</code>的作用出来了: <strong>重新绑定元素类型, 以供分配器使用</strong></p>
<p>一般是这样的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> allocator&lt;U&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;T&gt; =&gt; Allocator = allocator&lt;T&gt; =&gt; </span><br><span class="line"><span class="keyword">typename</span> Allocator::rebind&lt;ListNode&gt;::other =&gt;</span><br><span class="line">allocator&lt;ListNode&gt; [即为所需分配器] [rebind这个叫法也挺形象的]</span><br></pre></td></tr></table></figure>
<h2 id="Item-11-Understand-the-legitimate-uses-of-custom-allocators"><a href="#Item-11-Understand-the-legitimate-uses-of-custom-allocators" class="headerlink" title="Item 11:  Understand the legitimate uses of custom allocators"></a>Item 11:  Understand the legitimate uses of custom allocators</h2><p>紧接着上一条: 这条是自定义分配器的用法</p>
<p>对于这部分内容: 粗略地说两句</p>
<p>首先, 符合标准Allocator一样, 提供pointer, 以及reference.</p>
<p>并且不保存状态(即只有静态成员), 而且, 符合Allocator的使用习惯.</p>
<p>这些内容, 反正说的比较含糊,… 实用性一般, 具体用到再细说吧.</p>
<h2 id="Item-12-Have-realistic-expectations-about-the-thread-safety-of-STL-containers"><a href="#Item-12-Have-realistic-expectations-about-the-thread-safety-of-STL-containers" class="headerlink" title="Item 12: Have realistic expectations about the thread safety of STL containers."></a>Item 12: Have realistic expectations about the thread safety of STL containers.</h2><p>对于STL, 我们不能对其线程安全性有过多的期望, 何出此言?</p>
<p>标准只是期望: 多线程读容器OK, 多线程写容器OK.</p>
<p>但是这些只是期望而已, 你不能对其有依赖, 因为有的实现符合, 有的实现并不支持.</p>
<p>那么, 我们要求STL提供线程安全会怎么样? </p>
<p><strong>没有好下场.</strong></p>
<p>将线程同步的内容置于STL的实现中, 想法很美好,但是这无疑会让STL变得异常冗余复杂<br><strong>使得STL丧失了其高效快捷的特点, 而且,退一步讲, 万一不需要线程支持, 那么多余的工作反而影响效率</strong></p>
<p>基于上面的分析: 我们不要求STL来提供线程安全的支持, 我们使用手动线程同步</p>
<p>怎么办呢? <code>std::mutex</code> + <code>std::cond_varible</code> 一般使用互斥锁 + 条件变量就OK</p>
<p>但是, 死锁的问题, 还在威胁着我们.</p>
<p>想想看, lock也不就是一种资源么? 对于资源, 我们一般怎么办? Resource Management</p>
<p><strong>没错, RAII !</strong></p>
<p>标准库中, <code>std::shared_ptr</code> 和 <code>std::lock_guard</code> 是已经实现的RAII实例</p>
<p>通过使用这些设施 ,以及我们手动的RAII, 便可以自行完成线程安全的STL使用</p>
<p>下面是C++Reference中, 对线程安全的描述: [其中标识了一部分保证的线程安全操作]</p>
<p><img src="http://phxjezimr.bkt.clouddn.com/thread_safety.png" alt="线程安全"></p>
<hr>
<p>STL的内容真的好多, 实现想必是相当的精彩, (xxx之前一直喷,但是我觉得还可以, 就是写的风格不太好)</p>
<p>最近确实火烧眉毛了, 但是EffectiveSTL还不错, 挺有意思的.</p>
<p>其实我现在最困惑的时: 如何能够详实的将自己学到的技术落实下来.</p>
<p><strong>可能只能多看, 同时写的时候,一开始刻意去用吧, 不然真的是有点尬, , , </strong></p>
<p>怎么说呢, 迅速结束这些, Network Programm的内容 + Operation System的内容也不会少,</p>
<p>管他呢, 干就完事了.</p>
<p>November 10, 2018 5:35 PM</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://evil-crow.github.io/2018/11/08/Important/EffSTL/stl1/" data-id="cjofkrk1a003jocnr7e4vohiq" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACK0lEQVR42u3aS27DMAwFwNz/0u62BWrnkXQCWBqvgnwkTRYPFKXXK36OX0/1+/lvq7OUHwwMjMcyjsvneoLriasj55/+MyMGBsYGjLNFnH0n/1Xyd+Tznr6PgYGBUXx9FpeT8TEwMDDmwZfEa4LBwMDAmGxir2M02ejm43xwL46BgfFARt51//7rj5xvYGBgPIpxFJ9eCTiJ1GhVGBgYSzPygKsWdkmBOAlcDAyMPRm9YM0bZ9W/pnxRDAMDY1FG79Cxx65e/0o2un8qXAwMjEUZd5WD1cODXtxHB5kYGBiLMvLNZL6gyQh51GJgYOzAqDa28oKs11arRnyzX4iBgfEoRk66brHlk/VKxsKqMDAwlmP0Fje5ZtG761XuGmJgYCzHyBv3yblhXrn1xo+uWWBgYCzEyC9M5MeT86htnmNgYGAsysi3oNULYZMR8oB+UxpiYGAsyui14++K5hsufmFgYCzKyK8+VFv/1dHy4MbAwNiHMYnLa1jSsOst/fSvxMDA2IDRi7lJZFePQt/MiIGBsQ2jutHNR+hdsCjELgYGxgaMXlzmVyLyEZrHmRgYGIsyjuJzXcZVF9o7KjgtCjEwMBZlVGOuF5Hz5lqh6YaBgbEoIw/ZyeveVhYDAwNjEnzVDWqy9R215DAwMDDGTbHkQkZ1BAwMDIwkcPOGWnXMZJzbSkMMDIyHMKqHAXkzrvpp9UgVAwNjB8akoV9t0vVi+q6CFQMD44GMHwrf0T93+jz2AAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/EffectiveSTL/">EffectiveSTL</a></div><div class="post-nav"><a class="next" href="/2018/10/09/Important/EffC++/effective5/">&lt;星月夜&gt; Implementations</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'evil-crow',
  repo: 'evil-crow.github.io',
  oauth: {
    client_id: '1c81bedb1f161c78ec76',
    client_secret: '29bf11687745096e8640698a23483cb6c643d944',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Bible/">Bible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Documents/">Documents</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Guide/">Guide</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ShellScript/">ShellScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/">Unix/Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Unix-Linux/Guide/">Guide</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/CodeStyle/" style="font-size: 15px;">CodeStyle</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/vbird/" style="font-size: 15px;">vbird</a> <a href="/tags/RegExpression/" style="font-size: 15px;">RegExpression</a> <a href="/tags/LinuxC/" style="font-size: 15px;">LinuxC</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a> <a href="/tags/Binuntils/" style="font-size: 15px;">Binuntils</a> <a href="/tags/EffectiveC/" style="font-size: 15px;">EffectiveC++</a> <a href="/tags/Ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/EffectiveSTL/" style="font-size: 15px;">EffectiveSTL</a> <a href="/tags/ShellScript/" style="font-size: 15px;">ShellScript</a> <a href="/tags/Syscall/" style="font-size: 15px;">Syscall</a> <a href="/tags/VimScript/" style="font-size: 15px;">VimScript</a> <a href="/tags/CTrapsAndPitfalls/" style="font-size: 15px;">CTrapsAndPitfalls</a> <a href="/tags/Expert-C-Programming/" style="font-size: 15px;">Expert_C_Programming</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/Important/EffSTL/stl1/"><STL> Containers</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/09/Important/EffC++/effective5/"><星月夜> Implementations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/Important/C/Expert_C_Programming/data_mem/"><咸鱼书> 运行时数据结构与内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/Important/EffC++/effective4/"><星月夜> Designs and Declarations</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/Important/EffC++/effective3/"><星月夜> Resource Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/Important/EffC++/effective2/"><星月夜> Constructors, Destructors, and Assignment Operators</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/Important/EffC++/effective1/"><星月夜> Accustoming Yourself to C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/Guide/GDB/multprocess/">GDB调试系列(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/Guide/Fedora_KDE/">Linux的常用配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/Question_Answer/C/two_level_array/">一个C语言指针的问题让我翻车</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Road to Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>