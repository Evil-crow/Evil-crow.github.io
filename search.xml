<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一个C语言指针的问题让我翻车</title>
      <link href="/2018/07/28/C/two_level_array/"/>
      <url>/2018/07/28/C/two_level_array/</url>
      <content type="html"><![CDATA[<p><em>现在真的是水的不行.一天天的,混不下去了,以后还是转业算了,当个肥宅最TM开心了</em></p><p>起因是小伙伴问了我一个需求实现: 函数中分配二维数组,返回值又已经被使用.</p><p>那么,<strong>自然而然就是指针的指针了,传参数三维指针(不然改个锤子)</strong></p><p>以往的代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">foo</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * <span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line"><span class="comment">// *(p + i) = (char *)malloc(sizeof(char) * n);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一般的二维数组的分配实现.</p><p>改用指针的指针传递,实际上至需要修改其中几个小地方就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> ***p, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*p) = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * <span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        (*p)[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了,不使用数组下标语法糖的形式,使用原生指针怎么写?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(*p + i) = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br></pre></td></tr></table></figure><p>而之前的错误形式是这样的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(**p + i) = ....       <span class="comment">// x</span></span><br></pre></td></tr></table></figure><p>究其本质,还是自大,不扎实.</p><p>不过想了一下,主要是这些没考虑到:</p><ul><li><p>简便写法 <code>(*p)[i]</code>, 没错,这样解引用就和原来一样了</p></li><li><p>为什么可以写成<code>*(*p + i)</code>？</p><p>同理，想想之前的下标语法糖，　这里只不过解引用了一下，还原为二维指针，然后进行移动</p><p>到了其他的位置，　当然是一个维度中，也就是<code>int a[m][n]</code>,m层次上的移动.从(*p)[0][n]到</p><p>(*p)[1][n], 之后解引用不就是对应一维指针,(指向字符串的),然后该咋来咋来,该咋用咋用.</p><p><strong>这其中有一个很重要的点: 数组名就是数组首元素地址,进行与整型的计算时,就是数组元素移动</strong></p><p><strong>我特么把</strong><code>*(*p + i)</code>和<code>*(&amp;(*p) + i)</code><strong>混淆了,后面的才是下一个指向二维数组的指针</strong></p><p><code>arr[index] = *(arr + index)</code><strong>这么简单的问题都凉了,GG算了</strong></p></li><li><p>为什么不能写<code>(**p + i)</code></p><p>为什么,这到是个锤子! <code>(char **)p =&gt; (char) **p</code>,此时加上整型的计算结果,是整型.</p><p>我们要获取可使用的指针,或去糖之后,都是有解引用的,这个简直不能看.而且此时<code>(**p) =&gt; char *</code></p><p>内存并没有分配,是未定义的值,求得的结果是nil +　index的值.. </p></li><li><p>另外再扯一点</p><p>事实上, 分清数组和指针,多看两眼</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello world"</span>;        <span class="comment">// str中保存了字符串字面量的地址</span></span><br><span class="line"><span class="keyword">char</span> sstr[<span class="number">100</span>] = <span class="string">"..."</span>;           <span class="comment">// sstr中存的就是值,sstr地址值与sstr[0]一致</span></span><br></pre></td></tr></table></figure></li></ul><p>好了,就说这么多吧.后面的自己在想想就好了.</p><p>有兴趣了,看看这几个就可以了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">12</span>];</span><br><span class="line">a[<span class="number">1</span>];        <span class="comment">// *(a + 1)</span></span><br><span class="line">&amp;a;          <span class="comment">// value: &amp;a == &amp;a[0]; &amp;a + 1 == &amp;a[0] + sizeof(int) * array_length;</span></span><br><span class="line">&amp;a+<span class="number">1</span>;        <span class="comment">// &amp;a[0] + sizeof(int) * array_length</span></span><br><span class="line">*(a+<span class="number">1</span>);      <span class="comment">// a[1], a=&gt; &amp;a[0], *(&amp;a[0] + 1) = a[1]</span></span><br><span class="line">(<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>)[<span class="number">-1</span>];  <span class="comment">//a[12];</span></span><br></pre></td></tr></table></figure><p><em>PS: 今天看到了很多牛皮的博客,牛皮的人怎么这么多,我有想了想我,唉,垃圾一个,脑子疼</em></p><p><em>我觉得,以后不能再把心情这种写在技术总结里面了,太消极,别人看见也不好</em></p><p><em>而且,我文笔并不好啊,就是个看漫画,打游戏的死肥宅.</em></p><p><strong>如果有机会了,准备写写漫画或者游戏的简评,</strong></p><p><em>再说吧,太远了,还是先弄好C++了.(逃</em></p><p>July 28, 2018 11:41 AM</p>]]></content>
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hole </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VI Function</title>
      <link href="/2018/07/14/C++/C3P_VI/"/>
      <url>/2018/07/14/C++/C3P_VI/</url>
      <content type="html"><![CDATA[<h2 id="一-返回数组的指针-引用"><a href="#一-返回数组的指针-引用" class="headerlink" title="一.返回数组的指针/引用"></a>一.返回数组的指针/引用</h2><p>有以下四种形式的操作:</p><h3 id="1-直接撸"><a href="#1-直接撸" class="headerlink" title="1.直接撸"></a>1.直接撸</h3><p>这个就需要扎实一点的C声明基础了,(PS: 不清楚的可以翻我之前写过的东西)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type (*/&amp; function(arguments))[<span class="built_in">array</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*func())[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="2-使用类型别名"><a href="#2-使用类型别名" class="headerlink" title="2.使用类型别名"></a>2.使用类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arr = <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">arr *<span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-使用后置类型-C-11新特性"><a href="#3-使用后置类型-C-11新特性" class="headerlink" title="3.使用后置类型 (C++11新特性)"></a>3.使用后置类型 (C++11新特性)</h3><p>这个特性十分好用, 前面使用auto做返回类型占位符, 后面使用’-&gt;’进行标识</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto func() -&gt; Type;</span><br><span class="line"></span><br><span class="line">auto func() -&gt; int(*)[10];</span><br></pre></td></tr></table></figure><p>不过要注意的是: 后面的Type,一定是类型,也就是说,没有变量名,复杂类型时好用,简单类型没必要</p><h3 id="4-使用decltype-类型说明符"><a href="#4-使用decltype-类型说明符" class="headerlink" title="4.使用decltype()类型说明符"></a>4.使用decltype()类型说明符</h3><p>既然上面用了auto, decltype肯定也是可以用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(variable) */&amp; func();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">descltype(a) *func();</span><br></pre></td></tr></table></figure><p><strong>不过,其中要注意的是,decltype(), 仅仅能获取类型,并不能转换为指针/引用,所以*/&amp;还是必不可少的</strong></p><p>下面通过一个例子来进行展示用法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数原型,返回数组的引用,且数组中包含10个string对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> (&amp;func())[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">using</span> str_arr = <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function">str_arr &amp;<span class="title">func_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">auto func__() -&gt; std::string (&amp;)[10];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(a) &amp;func___();</span><br></pre></td></tr></table></figure><p><strong>返回数组这样写,所以,返回函数指针大家也懂了吧,也就是 [ ] 与 ( ) 的区别</strong></p><p><em>当然, C/C++禁止返回函数类型(C++11目前不清楚),只能返回函数指针</em></p><h2 id="二-函数原型-签名-声明"><a href="#二-函数原型-签名-声明" class="headerlink" title="二,函数原型,签名,声明"></a>二,函数原型,签名,声明</h2><p>这其实是几个混淆的概念,不过也差不多,不同的叫法罢了</p><p>以后,规定代码习惯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;       <span class="comment">// 显式说明无参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;<span class="comment">// 隐式说明无参</span></span><br></pre></td></tr></table></figure><p>以后约定, <strong>除了函数定义,以外其他部分使用隐式无参说明</strong></p><p><em>不然太难看了</em></p><p>也就是下面这种结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Temp();</span><br><span class="line">~Temp();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Temp::Temp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-关于传参"><a href="#三-关于传参" class="headerlink" title="三, 关于传参"></a>三, 关于传参</h2><p><em>既然,我们写了C++, 就要写C++风格的C++, 毕竟不是竞赛选手, C风格的C++还是算了吧</em></p><p>有以下两个要求:</p><h3 id="1-尽量使用引用"><a href="#1-尽量使用引用" class="headerlink" title="1. 尽量使用引用"></a>1. 尽量使用引用</h3><p><em>区别于C中大量使用指针,C++建议摒弃指针,在尽可能的情况下,多用引用</em></p><ul><li><p>指针不安全,引用一定是经过初始化的</p></li><li><p>指针会引起大程度的拷贝,引用可以避免类类型,大数组的拷贝开销</p></li></ul><h3 id="2-尽量使用常量引用"><a href="#2-尽量使用常量引用" class="headerlink" title="2. 尽量使用常量引用"></a>2. 尽量使用常量引用</h3><p><em>将对常量的引用变量定义为普通引用是常见的错误,对没错, 是错误.</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag = is_string("Hello, world");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若为普通引用,则不能这样调用</span></span><br></pre></td></tr></table></figure><p><strong>其中,关键的就是,const在不同程度上赋值时的相容性,顶层无意义, 底层需注意</strong></p><p>上面只是其中一个问题, 另一方面,更重要的是:</p><p><strong>大型程序开发时, 多层函数嵌套,可能就传递了一个参数</strong></p><p>但是,上层是const string&amp;, 内层是普通引用,那就不能直接使用</p><p>有以下,三个办法:</p><ul><li><p>实现一个新的版本,overloaded, 去你妈的, 累死了</p></li><li><p>在其中,做一个副本拷贝, string str为s 的副本</p></li><li><p>根本上解决,修改普通引用为常量引用, 对的没错,是这样.</p></li></ul><p>总结:</p><p><strong>1. 尽量用引用,避免使用指针</strong></p><p><strong>2. 在确定不会发生修改变量的时候, 一定传递参数为对常量的引用, 即 const引用</strong></p><p>update: July 13, 2018 11:57 PM</p><h2 id="四-可变参数"><a href="#四-可变参数" class="headerlink" title="四, 可变参数"></a>四, 可变参数</h2><p>这个东西,大家平时摸得最多的函数,—启蒙函数 printf(“%s”,…);</p><p>C++中三种实现可变参数的方法:</p><h3 id="1-initializer-list"><a href="#1-initializer-list" class="headerlink" title="1. initializer_list"></a>1. initializer_list</h3><p>对于相同类型可变参,使用initializer_list类模板</p><p>其基本操作如下:</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>initializer_list&lt; T &gt; lt</td><td>初始化</td></tr><tr><td>initializer_list&lt; string &gt; lt = {a, b, c…}</td><td>初始化</td></tr><tr><td>lt2(lt)</td><td>复制初始化(构造函数重载),两个initializer_list, 共享同一组元素</td></tr><tr><td>lt2 = lt</td><td>同上,(C++对C复制的兼容)</td></tr><tr><td>lt.size()</td><td>lt的元素个数</td></tr><tr><td>lt.begin()</td><td>容器通用操作, 头迭代器</td></tr><tr><td>lt.end()</td><td>容器通用操作, 尾迭代器</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : init)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; lt = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">    func(lt);</span><br><span class="line">    func(&#123;<span class="string">"haha"</span>, <span class="string">"Bloodbore"</span>, <span class="string">"The last of US"</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意: initializer_list中的元素,是const只读的, 所以说,不能用头尾指针迭代,懂我意思吧</strong></p><h3 id="2-使用可变参模板"><a href="#2-使用可变参模板" class="headerlink" title="2. 使用可变参模板"></a>2. 使用可变参模板</h3><p>后面在&lt; 模板 &gt; 模块会详细分析的</p><h3 id="3-省略形参符"><a href="#3-省略形参符" class="headerlink" title="3. 省略形参符"></a>3. 省略形参符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure><p>还是那句话,写C++风格的C++, 这个做法,是留给与C接口的C++函数的</p><p>就像<code>extern &quot;C&quot;</code>一样</p><h2 id="五-返回的二三事"><a href="#五-返回的二三事" class="headerlink" title="五, 返回的二三事"></a>五, 返回的二三事</h2><h3 id="1-引用返回是左值"><a href="#1-引用返回是左值" class="headerlink" title="1. 引用返回是左值"></a>1. 引用返回是左值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global array</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not-reference return value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return value: reference</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = func1();</span><br><span class="line">    func2() = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : a)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>是的,一般函数返回值都是用来接收, 但是引用返回就是左值</strong></p><p><strong>不过,符合左值,那就给他放左边呗, 很正常的, 当然得是非常量引用,即非const引用</strong></p><h3 id="2-使用列表初始化返回值"><a href="#2-使用列表初始化返回值" class="headerlink" title="2. 使用列表初始化返回值"></a>2. 使用列表初始化返回值</h3><p><strong>注意, 使用列表初始化时, 内置类型只能包含一个值,(这不废话么)</strong></p><p><strong>其他类型,由其构造函数决定放回的列表如何用来初始化返回类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"Bloodbore"</span>, <span class="string">"The Last Of US"</span>, <span class="string">"Final Fansty X/X-2"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec = func();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.begin(); i != vec.end(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六-函数重载-Overloaded"><a href="#六-函数重载-Overloaded" class="headerlink" title="六, 函数重载(Overloaded)"></a>六, 函数重载(Overloaded)</h2><p><em>不由得,想起了,某老师的, 函数重(zhong)载, 大家懂得都懂, 还有下学期的爪哇也是他 \摊手</em></p><h3 id="1-为什么要有函数重载"><a href="#1-为什么要有函数重载" class="headerlink" title="1. 为什么要有函数重载"></a>1. 为什么要有函数重载</h3><p><em>肯定是有硬性需求呗,</em></p><p>工程量越来越大,起名字越来越难. 另一方面,就是有些功能类似,只是参数/返回类型略有区别的函数</p><p><del>另外起名字占位,岂不是很丑陋 ?</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C style</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs_double</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ style</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么,函数重载根据什么来区分?</p><p><strong>函数传入参数的类型或者个数, 其中必须要有差异, 编译器才能进行正确的重载选择</strong></p><p><strong>切记: 返回类型是不能进行区分的, 因为函数执行后,才能获取到返回类型</strong></p><h3 id="2-函数重载的坑"><a href="#2-函数重载的坑" class="headerlink" title="2. 函数重载的坑"></a>2. 函数重载的坑</h3><p>主要有三个方面会出现函数重载失败的情况: (当然重载失败有语法上的,也有运行时的,这里指语法上的)</p><ul><li>省略形参名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;       <span class="comment">// 语法上,重载失败, 同一函数</span></span><br></pre></td></tr></table></figure><ul><li>类型别名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> funck = <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(fuck)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>const的情况</li></ul><p>这里<code>const</code>怎么会插上一脚呢?, 因为进行赋值时, const的特点: <strong>顶层无意义(可忽略), 底层需注意</strong></p><p>赋值时, 顶层const属性丢失,所以是一样的,底层对常量的指针和引用,都是不一样的,可进行函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *)</span></span>;          <span class="comment">// 重载失败, 顶层const属性丢失</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="function">viud <span class="title">foo</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;           <span class="comment">// success, 对常量的引用和常量引用的确是不同的</span></span><br></pre></td></tr></table></figure><h3 id="3-const-cast到底怎么玩"><a href="#3-const-cast到底怎么玩" class="headerlink" title="3. const_cast到底怎么玩?"></a>3. const_cast到底怎么玩?</h3><p>之前说过,基本上是在overloaded中使用这个显式的转换</p><p><strong>const_cast&lt;&gt;, 基本上用于进行const形参接收普通形参是的情况</strong></p><p><strong>简单地说,我们使用const形参,他可以相容普通形参,的那是我们要让其优先选择非常量形参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">is_string</span><span class="params">(cosnt <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> stirng &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">is_stirng</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> i = is_string(cosnt_cast&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span> &amp;&gt;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的实现一般, (C++在之后面向对象的时候,我们更倾向于用已经实现的函数去实现新的功能)</p><p><code>const&lt;Type&gt;(var)</code> 实现从<code>const &lt;=&gt; non-const</code>的转换</p><p>根据我们的需要进行转换, 同时,这个转换只是进行<code>const</code>属性的改变</p><p>若用其实现<code>static_cast</code>的功能,肯定就错了.</p><p><strong>注意: <code>const &lt;=&gt; non-const</code>之间进行转换的时候,我们要自己保证转换的可行性,别乱j8给人修改</strong></p><h2 id="来深层次的分析Overloaded"><a href="#来深层次的分析Overloaded" class="headerlink" title="来深层次的分析Overloaded"></a>来深层次的分析Overloaded</h2><h3 id="1-编译器实现"><a href="#1-编译器实现" class="headerlink" title="1. 编译器实现"></a>1. 编译器实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 据说, 经过编译后,是这个名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _func_int(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">void</span> _func_double(<span class="keyword">double</span>);</span><br></pre></td></tr></table></figure><p>这样,直接检索名字不就行了.</p><h3 id="2-Overloaded的过程"><a href="#2-Overloaded的过程" class="headerlink" title="2. Overloaded的过程"></a>2. Overloaded的过程</h3><p>首先从结果上来说,有这样三种结果:</p><p>最佳匹配, 重载失败, 二义性错误</p><p>来看过程:</p><ul><li><p>1.首先确定本次调用的函数集,成为<strong>候选函数</strong></p><p><em>候选函数的条件, 函数名符合, 且作用域内可见</em></p></li><li><p>2.在候选函数中,选择出,<strong>可行函数</strong></p><p><em>可行函数的条件, 函数参数个数符合, 每个实参类型符合,或者可以发生转换</em></p></li><li><p>3.寻找<strong>最佳匹配</strong></p><p>如果能够找到,则存在最佳匹配,进行调用.</p><p>如果还存在多个可行函数,无法抉择,则产生二义性错误</p></li></ul><p><strong>那么,如何选择最佳函数?</strong></p><p>首先, 之后一个参数的函数, 很简单: 是就是, 不是就不是</p><p>那么,多个参数的函数呢?</p><p>要求符合下面两个要求:</p><p><strong>1. 任何一个参数的匹配都不劣于其他可行函数</strong></p><p><strong>2. 至少有一个参数的匹配优于其他可行函数的对应参数匹配</strong></p><p><em>通俗点说, 各方面表现不差于别人,还有其他亮点, 就被录取了</em></p><p>如下图:</p><p> <img src="http://p8uroi1uf.bkt.clouddn.com/overloaded.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 候选函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * void func(int);</span></span><br><span class="line"><span class="comment"> * void func(int, int);</span></span><br><span class="line"><span class="comment"> * void func(double, double);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 2. 可行函数</span></span><br><span class="line"><span class="comment"> * void func(int, int);</span></span><br><span class="line"><span class="comment"> * void func(double, double);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 3. 最佳匹配</span></span><br><span class="line"><span class="comment"> * 两个函数,都分别在其中一个参数上最佳匹配</span></span><br><span class="line"><span class="comment"> * 又在另一个参数上,有转换</span></span><br><span class="line"><span class="comment"> * 所以,结果是 二义性错误</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-C-类型转换层次"><a href="#3-C-类型转换层次" class="headerlink" title="3. C++类型转换层次"></a>3. C++类型转换层次</h3><p>为了适合函数重载(当然还有其他地方)</p><p>C++将类型转换分为下唉面这么几个层次:</p><ul><li><p>精确匹配</p><ol><li><p>实参类型与形参匹配 (精确匹配)</p></li><li><p>array-to-pointer, function-to-pointer ,在传参过程中</p></li><li><p>顶层cosnt的添加与删除</p></li></ol></li><li><p>const转换实现的匹配</p></li><li><p>类型提升带来的匹配</p></li><li><p>算术类型转换或指针转换</p></li><li><p>类类型的转换.</p></li></ul><p><strong>根据上面5个层次的不同,来分析函数重载的最佳匹配即可</strong></p><p>update: July 14, 2018 11:53 AM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL入门</title>
      <link href="/2018/06/25/SQL/MySQL_start/"/>
      <url>/2018/06/25/SQL/MySQL_start/</url>
      <content type="html"><![CDATA[<h2 id="一-安装问题"><a href="#一-安装问题" class="headerlink" title="一,安装问题"></a>一,安装问题</h2><p>此处仅仅谈到Linux平台的安装方法,Win下可以通过现成安装包方式安装</p><p>Mac没接触过,不了解.不过听说<code>brew</code>也挺好用?(反正我是<code>dnf</code>毒奶粉)</p><p>下面的流程摘自MySQL官网,相当于间接翻译一下,(…), Fc的特化版本,其他发行版同理,有区别</p><p>在官网中可以找到适合自己发行版的repo,按照说明选择的好,至于不对应版本,会有什么差错,我也不知道.</p><p><a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">这是官网链接&gt;&gt;</a></p><p>首先里面提供了三个版本</p><p><code>MySQL Enterprise Edition</code><br><code>MySQL Cluster CGE</code><br><code>MySQL Community Edition</code></p><p>如果你是个人用户,或者学习用,还是乖乖用社区版,完全足够了</p><p><a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">所以,这个才是真的链接&gt;&gt;</a></p><p>左边侧栏,就可以选择合理的,安装方式,</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/website.png" alt="左侧边栏"></p><p>我们以MySQL Yum Repository安装为例来说明:</p><h3 id="1-找到适合自己的repo"><a href="#1-找到适合自己的repo" class="headerlink" title="1. 找到适合自己的repo"></a>1. 找到适合自己的repo</h3><p>在下面的选择中进行repo下载:</p><p>然后使用<code>sudo rpm -Uvh your-system-version.rpm</code></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/repoi.png" alt="repo"></p><p>(隔壁的dpkg同理,packman惹不起)</p><h3 id="2-选择版本系列"><a href="#2-选择版本系列" class="headerlink" title="2. 选择版本系列"></a>2. 选择版本系列</h3><p>习惯使用repo的人会知道,同一个repo也会有不同的版本, 而MySQL经常比较的就是5.x和现在的8.x了</p><p><em>6.x是留给告诉迭代的版本的, 也就是现在5.x的后继,7.x是留给集群版本的,提前插眼</em></p><p><em>所以现在最新的就是8.x了,不用疑惑的</em></p><p><code>shell&gt; yum repolist all | grep mysql</code> 查看现在支持的版本</p><p><code>shell&gt; sudo dnf config-manager --disable mysql80-community</code><br><code>shell&gt; sudo dnf config-manager --enable mysql57-community</code></p><p>进行指定版本的限制</p><p><code>shell&gt; yum repolist all | grep mysql</code> 重新查看,即可,要使用5.7还是8.0随意</p><h3 id="3-进行repo缓存"><a href="#3-进行repo缓存" class="headerlink" title="3. 进行repo缓存"></a>3. 进行repo缓存</h3><p><code>shell&gt; sudo dnf makecache</code></p><h3 id="4-安装mysql"><a href="#4-安装mysql" class="headerlink" title="4. 安装mysql"></a>4. 安装mysql</h3><p><code>shell&gt; sudo yum install mysql-community-server</code></p><p>会自动处理依赖的</p><h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5. 启动服务"></a>5. 启动服务</h3><p><code>shell&gt; sudo systemctl start mysqld</code> 启动服务</p><p><code>shell&gt; sudo systemctl status mysqld</code> 查看服务状态</p><h3 id="6-进行密码的设定"><a href="#6-进行密码的设定" class="headerlink" title="6. 进行密码的设定"></a>6. 进行密码的设定</h3><p>MySQL Server Initialization (as of MySQL 5.7): At the initial start up of the server, the following happens, given that the data directory of the server is empty:</p><p>The server is initialized.</p><p>An SSL certificate and key files are generated in the data directory.</p><p>The validate_password plugin is installed and enabled.</p><p>A superuser account ‘root‘@’localhost’ is created. A password for the superuser is set and stored in the error log file. To reveal it, use the following command:</p><p><code>shell&gt; sudo grep &#39;temporary password&#39; /var/log/mysqld.log</code></p><p>Change the root password as soon as possible by logging in with the generated, temporary password and set a custom password for the superuser account:</p><p><code>shell&gt; mysql -uroot -p</code></p><p><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;;</code></p><p>上面这段话的意思时: 启动服务,mysql已经默认创建了root@localhost用户</p><p>同时给你吧密码安排到日志文件里面了,你运行第一条命令找出密码,然后进去改密码</p><p>就这样就好了</p><p>但是,<strong>我TM日志是空的…</strong></p><p>所以还有下面的邪道方法:</p><p>进入<code>/etc/my.cnf</code> 进行登录不需要密码的状态,具体是添加</p><p><code>skip-grant-tables</code>,实现免密码登录</p><p><code>mysql -uroot</code>  登入数据库</p><p><code>update user set password=password(&#39;123456&#39;) where user=&#39;root&#39; and host=&#39;localhost&#39;;</code></p><p>修改用户名密码</p><p>记得完了修改文件,取消免密码登录,然后<strong>重启服务</strong>,就可以正常使用了</p><h2 id="二-初始MySQL"><a href="#二-初始MySQL" class="headerlink" title="二,初始MySQL"></a>二,初始MySQL</h2><p>作为一个经典的SQL,这么多年来经久不衰还是由他的理由的</p><p>有下面几个了解一下的:</p><ol><li><p>默认port –3306</p></li><li><p>有社区版和专业版</p></li><li><p>现属于Oracle公司</p></li></ol><p>了解足够了</p><h2 id="三-常用的最基础操作"><a href="#三-常用的最基础操作" class="headerlink" title="三,常用的最基础操作"></a>三,常用的最基础操作</h2><h3 id="1-启动和停止服务"><a href="#1-启动和停止服务" class="headerlink" title="1. 启动和停止服务"></a>1. 启动和停止服务</h3><p>这个就够了,有使用Linux经验的,谁还是不会撞墙去吧…</p><h3 id="2-登录与退出"><a href="#2-登录与退出" class="headerlink" title="2. 登录与退出"></a>2. 登录与退出</h3><p>登录是这样的形式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [-option] [-arguments]</span><br></pre></td></tr></table></figure><p>常用option:</p><ol><li><p>-p –passwd[] 指定密码</p></li><li><p>-P 指定端口</p></li><li><p>-u 指定用户</p></li><li><p>-H 指定主机</p></li><li><p>–prompt 设定提示符</p></li><li><p>-D 指定数据库</p></li></ol><p>退出就比较简单了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; quit;</span><br><span class="line">shell&gt; <span class="built_in">exit</span>;</span><br><span class="line">shell&gt; \q;</span><br></pre></td></tr></table></figure><p>三种形式都可以</p><h3 id="3-SQL命名规范"><a href="#3-SQL命名规范" class="headerlink" title="3. SQL命名规范"></a>3. SQL命名规范</h3><p>虽然网上说随个人习惯,不敏感大小写,但是还是遵循一下规范的好:</p><p><strong>命令, 函数, 保留字一律使用大写</strong></p><p><strong>数据库名, 表名, 索引名等一律使用小写</strong></p><p><strong>SQL语句一律都是 ; 结尾</strong></p><p>也就是说,出来是这种画风</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> k1;</span><br></pre></td></tr></table></figure><h3 id="4-常用操作"><a href="#4-常用操作" class="headerlink" title="4. 常用操作"></a>4. 常用操作</h3><h4 id="1-gt-显式-切换-创建数据库"><a href="#1-gt-显式-切换-创建数据库" class="headerlink" title="1&gt; 显式,切换,创建数据库"></a>1&gt; 显式,切换,创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] K2 [<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name;</span><br></pre></td></tr></table></figure><p>花括号为必选项, 方括号为可选项. 后面是设置编码, [IF NOT EXISTS], 可以免除一个WARNING</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;    // 显示数据库</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">database</span>;      // 切换数据库</span><br></pre></td></tr></table></figure><h4 id="2-gt-修改数据库属性"><a href="#2-gt-修改数据库属性" class="headerlink" title="2&gt; 修改数据库属性"></a>2&gt; 修改数据库属性</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [db_name] [<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name</span><br></pre></td></tr></table></figure><p>比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> K2 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8;   //修改K2数据库编码为utf-8</span><br></pre></td></tr></table></figure><h4 id="3-gt-删除数据库"><a href="#3-gt-删除数据库" class="headerlink" title="3&gt; 删除数据库"></a>3&gt; 删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] db_name</span><br></pre></td></tr></table></figure><p>IF EXISTS 的用法同上</p><h4 id="4-gt-闲杂命令"><a href="#4-gt-闲杂命令" class="headerlink" title="4&gt; 闲杂命令"></a>4&gt; 闲杂命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();    // 显示版本</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>();       // 显示日期;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();       // 显示用户;</span><br></pre></td></tr></table></figure><p>(PS: 数据库操作还是挺好玩的,我都是跑路了,当个数据库管理员也不错,开玩笑的,还是写C/C++舒服)</p><hr>]]></content>
      
      <categories>
          
          <category> Server </category>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++坑点总结</title>
      <link href="/2018/06/20/C++/C_C++_expr/"/>
      <url>/2018/06/20/C++/C_C++_expr/</url>
      <content type="html"><![CDATA[<p><em>下面都是我进行C/C++语言知识的坑点总结,当然也就是说,以后可能会有Kernel, Server总结</em></p><p><em>当然,不在乎头发了,这都不是事(笑)</em></p><h2 id="18-6-20"><a href="#18-6-20" class="headerlink" title="18.6.20"></a>18.6.20</h2><h3 id="1-函数传参的指针与引用"><a href="#1-函数传参的指针与引用" class="headerlink" title="1. 函数传参的指针与引用"></a>1. 函数传参的指针与引用</h3><p>曾经可能在无数的书上看过:</p><blockquote><p>要修改变量的值,要不使用传值(call by value) + 返回值(return value)</p></blockquote><blockquote><p>要不就使用传址(call by pointer) (PS: 当然前面说的话有问题,传地址也是传值,指针的值)</p></blockquote><blockquote><p>只不过是指针有修改指向变量的特性罢了. </p><p>另一种传参方式,C中没有,C++中用引用,即call by reference</p></blockquote><p>上面的话,其实看的人玄乎.就会写出这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">add_data</span><span class="params">(Node *head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_data_</span><span class="params">(Node **head)</span></span>;</span><br></pre></td></tr></table></figure><p>第二种是正确的,第一种也是正确的,是的,没错,但是解释起来都是牵强的</p><p><strong>并非上面两种解释方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_data</span><span class="params">(Node *head)</span></span>;</span><br></pre></td></tr></table></figure><p>不信,你试试这样进行修改,也完全是可以的.</p><p>那么,实际上是什么问题?</p><p>用我的话来解释, </p><p><strong>修改函数外部的对象,传对象的地址(即指针),或者对象的引用进来,便可以直接修改外部的值</strong></p><p><strong>传值,进来,进行修改,然后将值返回, 来修改外部变量的值,是重新给对象赋值的做法</strong></p><p><strong>这其中会出产生一个误区, 函数形参也是自动变量,为什么可以返回指针</strong></p><p><code>Node *add_data(Node *data);</code>, 这个函数,它传入指针,<strong>实质上发生了这样的事:</strong></p><p><strong>使用实参初始化形参,然后操作形参,形参在函数结束后的确这个指针对象被释放,但是它的值还是有效的</strong></p><p><strong>这里的值,指的是他和指向的值,它的值,要这样获取,&amp;head, 此head对象释放,但是它的值还保证有效</strong></p><p><strong>而这个值,返回之后,进行赋值,整个过程中没有变化,所以这个指针返回值是可以的</strong></p><p><strong>我们经常说的,不要返回指针,指的是: 函数内部船舰的对象的指针,因为这些对象都会被释放</strong></p><p><strong>他们的指针,返回后的操作,都是未定义的危险行为</strong></p><p>上面说了那么多,我们实际怎么操作呢?</p><p><em>1. 首先思考,是否需要对传入的参数,进行改变, 从而选择参数的地址,或者函数结束后重新赋值的方式</em></p><p><em>2. 返回非函数内部创建的对象的指针,是可行的,因为他不随函数结束而释放,典型的是malloc,引用同理</em></p><p><em>3. 指针,也只是值,不要特殊对待,之后call by value以及call by reference</em></p><h3 id="2-关于printf控制符的选择"><a href="#2-关于printf控制符的选择" class="headerlink" title="2. 关于printf控制符的选择"></a>2. 关于printf控制符的选择</h3><p>不知道大家有没有疑惑过,float的控制符,是%f</p><p><em>那么,double的控制符到底是什么 ? </em></p><p>如果也使用%f是会出错的</p><p><strong>结论是: printf使用%f, scanf]使用%lf</strong></p><p><em>但是,在进行文件格式化写入,读出(fprintf, fscanf)是还是有问题…</em></p><p><strong>不过,使用open, write, read等系统调用,好像就没有这个问题了</strong></p><h3 id="3-关于错误处理"><a href="#3-关于错误处理" class="headerlink" title="3. 关于错误处理"></a>3. 关于错误处理</h3><p>这个其实是一个偏向于系统设计的问题</p><p>C++中有异常处理,不多考虑了</p><p>C中虽然有non-local “goto”, 但是很容易混乱也不提</p><p>所以,<strong>建议像Linux系统调用设计一样</strong></p><p><strong>我们可以设置全局的错误标识量,然后返回error code,再用标准的错误函数去进行错误信息的处理</strong></p><p><strong>这样就会显得错误处理自然了许多, 同时也不会是软件耦合度过高</strong></p><hr>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 一些经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux的常用配置</title>
      <link href="/2018/06/12/Linux/linux_setting/"/>
      <url>/2018/06/12/Linux/linux_setting/</url>
      <content type="html"><![CDATA[<p><em>这是一篇自己给自己看的使用指南, 还是认真的记录一下比较好</em></p><h2 id="一-基础内容"><a href="#一-基础内容" class="headerlink" title="一, 基础内容"></a>一, 基础内容</h2><p>这一部分是每一个Linux安装成功之后,所要进行的合理操作</p><p>这里,针对我的机型,我用Fedora来举例子, 当然基本上是通用的redhat配置</p><h3 id="1-添加自己的sudo权限"><a href="#1-添加自己的sudo权限" class="headerlink" title="1. 添加自己的sudo权限"></a>1. 添加自己的sudo权限</h3><p>作为Redhat系的传统,不提供sudo权限的添加,需要自己去进行修改.</p><p>Debian系设置好sudo权限,之后自行passwd</p><p>具体操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/sudoers</span><br><span class="line">/ALL</span><br><span class="line">(多按几次n, 找到ALL,有root的地方)</span><br><span class="line">a</span><br><span class="line">(仿照上面进行自己用户名的添加)</span><br><span class="line">Esc -&gt; :wq!</span><br><span class="line"></span><br><span class="line">退出终端(刷新一下, OK!)</span><br></pre></td></tr></table></figure><h3 id="2-添加合理的软件源"><a href="#2-添加合理的软件源" class="headerlink" title="2. 添加合理的软件源"></a>2. 添加合理的软件源</h3><p>作为Fedora用户,着重推荐这两个源, FDZH以及RPMFusion的源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://repo.fdzh.org/FZUG/free/27/x86_64/noarch/fzug-release-27-0.2.noarch.rpm</span><br><span class="line">RPM Fusion的源需要去官网下载repo,之后使用rpm安装即可</span><br></pre></td></tr></table></figure><p><a href="https://rpmfusion.org" target="_blank" rel="noopener">RPMFusion&gt;&gt;</a></p><p><a href="https://github.com/FZUG/repo/wiki/添加-FZUG-源" target="_blank" rel="noopener">FDZH&gt;&gt;</a></p><p>其他的源,根据自己的使用情况进行配置</p><p>添加好源之后,进行软件源的获取缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf makecache</span><br></pre></td></tr></table></figure><h3 id="3-快捷键的设置"><a href="#3-快捷键的设置" class="headerlink" title="3. 快捷键的设置"></a>3. 快捷键的设置</h3><p>此处,对于gnome可以按照这样的顺序:</p><ul><li>setting -&gt; device -&gt; keyboard -&gt; add shortcuts</li></ul><p>对于KDE,可以这样来设置</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/kde_shortcuts.png" alt="setting shortcuts"></p><h3 id="4-关闭神油SElinux"><a href="#4-关闭神油SElinux" class="headerlink" title="4. 关闭神油SElinux"></a>4. 关闭神油SElinux</h3><p>我基本也没用过, 反正就是个神油玩意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/selinux/config</span><br><span class="line"><span class="string">"SELINUX=enabled"</span> -&gt; <span class="string">"SELINUX=disabled"</span></span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure><h3 id="5-善用alias"><a href="#5-善用alias" class="headerlink" title="5. 善用alias"></a>5. 善用alias</h3><p>在~/.bashrc中善于添加命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> aliyun_Crow=<span class="string">'ssh Crow@ww.xxx.yyy.zzz'</span></span><br></pre></td></tr></table></figure><p>上面的命令别名配上,ssh免密码登录简直不要太nice</p><p>另外就是自己写的几个小脚本,在其他地方也使用了,做些合理性判断,挺好用的</p><h2 id="二-KDE的一些设置"><a href="#二-KDE的一些设置" class="headerlink" title="二, KDE的一些设置"></a>二, KDE的一些设置</h2><p>这部分就是专门针对于KDE的设置了,用gnome的同学,我可能提供不了多少帮助了</p><p>不过有两点:</p><ol><li><p>gnome使用 <code>sudo dnf install gnome-tweak-tool</code> 超级好用</p></li><li><p>gnome下IDE字体显示还是很好看的,KDE简直看不了,逼得我用Vim + VSCode</p></li></ol><p>下面是对于KDE的完整配置方案,包括了Konsole呦(就那个初始丑的不像样子的终端)</p><p>… (挖个坑,保证一周内填上去)</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>指针与引用</title>
      <link href="/2018/06/10/C++/pointer_and_reference/"/>
      <url>/2018/06/10/C++/pointer_and_reference/</url>
      <content type="html"><![CDATA[<p><em>最近总算开始正事了,其实C++ primer还是挺好看的,讲道理,真的.</em></p><p><em>不过,需要转换思维的东西有点多,这一系列算是自己看C++ Primer的感想</em></p><p><em>也不能算是系列笔记,有想法的写一写,同时会将C++11 的内容单独列出来,能写C++11 还是写11吧</em></p><h2 id="一-C-中的复合类型"><a href="#一-C-中的复合类型" class="headerlink" title="一, C++中的复合类型"></a>一, C++中的复合类型</h2><p>C++中来分类型,其实就两种内置类型与自定义类型</p><p>内置类型,就算术类型与复合类型.</p><p>算术类型不提,我们重点来说说复合类型之中的指针与引用</p><p><strong>指针: 用修饰符 *来定义声明</strong></p><p><strong>引用: 用修饰符 &amp;来定义声明</strong></p><blockquote><p>指针: 本身是一个对象, 它存储了指向其他对象的地址,所以有指向对象的指针的指针,有多维指针</p></blockquote><blockquote><p>引用: 本身是一个绑定对象的别名,他不是一个对象,所以没有引用的引用,引用的指针</p></blockquote><p>我们着重来说说这两者的区别:</p><ol><li><p>首先是本质上, 指针是对象, 引用并非对象.所以有多维指针,指针的引用.但是没有多维引用,引用指针</p></li><li><p>从是否有初始化的必要上. 指针可以不初始化(但是是随机值,建议初始化), </p><p>引用因为绑定对象不可变,所以必须初始化.而且初始化后绑定对象不可更改,指针则可以任意修改.</p></li></ol><h2 id="二-一些问题的解答"><a href="#二-一些问题的解答" class="headerlink" title="二, 一些问题的解答"></a>二, 一些问题的解答</h2><h3 id="1-引用绑定唯一对象为什么还能赋值"><a href="#1-引用绑定唯一对象为什么还能赋值" class="headerlink" title="1. 引用绑定唯一对象为什么还能赋值?"></a>1. 引用绑定唯一对象为什么还能赋值?</h3><p>上面我们说过,引用绑定的对象是唯一的,仅仅在初始化的时候完成绑定.之后便不能修改.那么下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> &amp;c = a;</span><br><span class="line">c = b;    <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>为什么? 不是绑定对象后,引用不能修改么…</p><p><strong>haha, 实际上是被使用指针的习惯禁锢住了, 使用引用的时候,就已经变成绑定的对象了</strong></p><p><strong>所以, 我们在初始化的步骤以外,并不可能修改引用绑定的对象,这也是为什么使用引用必须初始化的原因</strong></p><p>上面的代码中,使用,引用c变成(int)a, 引用b变成(int)a</p><h3 id="2-指针的四种状态"><a href="#2-指针的四种状态" class="headerlink" title="2. 指针的四种状态"></a>2. 指针的四种状态</h3><p>我们可以定义指针,指针在他的生命周期中可以存在四种状态:</p><ol><li><p>指向某一个对象</p></li><li><p>指向某一个对象的下一个位置</p></li><li><p>指向空(即空指针)</p></li><li><p>无效指针,其他例外情况(一般为野指针)</p></li></ol><p>1, 4不多说,2的情况,可能大家会比较会比较奇怪</p><p>其实2的情况,即使是C中也是保留的.</p><p><strong>C中,保证数组末端下一个位置的指针有效,但是其中的内容不作保证</strong></p><p><strong>C++中,在使用STL中的end()方法时,获取到的就是容器末尾的下一个位置,同样是保证指针有效</strong></p><p>这都是为了处理一些边界情况,或者做一些有效性判断而保证的.</p><h3 id="3-关于空指针-Null-Pointer"><a href="#3-关于空指针-Null-Pointer" class="headerlink" title="3. 关于空指针(Null Pointer)"></a>3. 关于空指针(Null Pointer)</h3><p>空指针,是一个特殊情况,即是为了保证指针不乱指向,出现一线难以调试的Bug存在的,一般用来初始化,</p><p>或者收尾工作使用.</p><p>常用来做空指针的几个值: nullptr, 0, NULL(需要&lt; cstdlib &gt;)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> *q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *r = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>其中,我们强烈建议,使用<code>int *p = nullpter</code>的形式</p><p><code>NULL</code>也只是<code>#include &lt;cstdlib&gt;</code>中的一个<code>#define NULL 0</code></p><p>0 也不能很明确的标识Null Pointer, 故使用C++11标准新规定的nullpter最为恰当</p><h3 id="4-指针比较时的相等情况"><a href="#4-指针比较时的相等情况" class="headerlink" title="4. 指针比较时的相等情况"></a>4. 指针比较时的相等情况</h3><p>一般来讲,我们用指针来做判断,进行比较不会出什么大问题,但是也有例外</p><p>下面的这种情况,没有遇到之前是匪夷所思的,不过理解其中原因也就没问题了</p><p><strong>某一个对象的指针,可能等于某个对象下一个位置的指针</strong></p><p><strong>其中的原因就是: 编译器可能进行了连续的内存分配,将两个变量连续分配,就会出现这种情况</strong></p><h3 id="5-复合类型的声明"><a href="#5-复合类型的声明" class="headerlink" title="5. 复合类型的声明"></a>5. 复合类型的声明</h3><p>类型在复合一点,就是指针的指针,指针的引用了</p><p><strong>因为,引用并非实际对象,只是绑定对象的别名,所以不存在引用的引用,引用的指针,切记</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *&amp;r = b;</span><br><span class="line"><span class="keyword">int</span> **&amp;t = c;</span><br></pre></td></tr></table></figure><p>上面,指针的引用,指针的指针的引用看上去是有点蛋疼.</p><p><strong>我们从最靠近标识符的符号开始分析,一切就比较明了了</strong></p><p>具体可以参见这篇博客<a href="https://evil-crow.github.io/2018/05/23/C/Expert_C_Programming/c_statement/" target="_blank" rel="noopener">传送门&gt;&gt;</a> ,讲道理,没有C声明晦涩,复杂(C++和C恶心声明程度更甚)</p><h2 id="三-事实上-const才是最恶心的"><a href="#三-事实上-const才是最恶心的" class="headerlink" title="三, 事实上,const才是最恶心的"></a>三, 事实上,const才是最恶心的</h2><p>const是一个很有用的关键字,它赋予了变量在一定情况下的只读属性</p><p>那么,指针/引用和const结合起来就比较恶心了</p><h3 id="1-const和指针"><a href="#1-const和指针" class="headerlink" title="1. const和指针"></a>1. const和指针</h3><p>这个其实都是我们在C中玩烂的内容了,</p><p>无非就是两种,指向const的指针和const指针.不过现在我们赋予他们两个新的名字</p><p><strong>顶层const(top-level): 指的是对本身的const</strong></p><p><strong>底层const(low-level): 指的是对指向对象的const</strong></p><p>顶层/底层const于指针之间的关系,在C++中同C,没有啥区别</p><p>我们重点来说说对于引用的问题</p><h3 id="2-对const的引用"><a href="#2-对const的引用" class="headerlink" title="2. 对const的引用"></a>2. 对const的引用</h3><p>在const上,很多人也在说,const的顶层/底层啥的</p><p><strong>其实,我个人觉得引用,就叫对const的引用就好,不要扯上顶层/底层的概念</strong></p><p><strong>为什么? 因为引用本身就不是对象,顶层const失去意义.</strong></p><p><strong>底层cosnt说的是,指向对象,但是引用绑定同一个,没有指向啊</strong></p><p><em>其实,讲道理,也可以说着两种顶层/底层const, 因为引用指向常量(具有const的变量)时,就是底层const</em></p><p><em>而引用,虽然本身并非对象,没有顶层const的概念,但是他初始化绑定后不可变,也可以说时有种”顶层”感觉</em></p><p>所以,我的建议是,对const的引用,说法足矣.别整那些有的没的</p><h3 id="3-拷贝时的const"><a href="#3-拷贝时的const" class="headerlink" title="3. 拷贝时的const"></a>3. 拷贝时的const</h3><p><em>这个才是,const这里的重点,呃喔门进行程序设计的时候,免不了进行赋值操作等各种东西</em></p><p><em>那么,对于含有const的变量,拷贝之时,有什么要注意的吗?</em></p><p><strong>简单的来说,顶层const属性会丢失. (引用不讲顶层const的概念,不多说)</strong></p><p><strong>如果,需要顶层cosnt,手动加上const即可</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> src = &amp;temp;</span><br><span class="line"><span class="keyword">int</span> *des = src;     #=&gt; des, <span class="keyword">int</span>* 顶层<span class="keyword">const</span>丢失</span><br></pre></td></tr></table></figure><p>引用这里的情况,其实是这样,</p><p><strong>指针,会丢失顶层const,但是引用”隐式的”含有顶层const属性,(也因为它没有顶层const的概念)</strong></p><p><strong>所以才说,引用后不再是顶层const了, 但是你引用的const变量,依然是const变量,</strong></p><p><strong>不能因为引用,就使得对外开放,通过引用将const变量修改,所以引用是底层const(也就是对const的引用)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;        <span class="comment">// j #=&gt; int</span></span><br><span class="line"><span class="keyword">int</span> &amp;k = i;       <span class="comment">// Error, 应该改为 const int &amp;k = i;</span></span><br></pre></td></tr></table></figure><p>另外的情况就是: <strong>底层const会进行保留</strong></p><p>用指针来说,若指向对象是const变量,则指针一定要是底层const指针,不然就会被意外修改</p><p>对引用,只能说是另一种形式的”底层”const,引用绑定const变量,</p><p>即是说引用绑定对象不可变,也是一种形式的”底层”const</p><p>而引用,自身绑定的对象不可变,也就是另一种形式的”顶层”const</p><h3 id="4-指针-引用赋值时类型不匹配的情形之一"><a href="#4-指针-引用赋值时类型不匹配的情形之一" class="headerlink" title="4. 指针/引用赋值时类型不匹配的情形之一"></a>4. 指针/引用赋值时类型不匹配的情形之一</h3><p>我们进行数据赋值操作时,常常要注意一个问题: <strong>类型匹配的问题</strong></p><p><em>C/C++中比较弱类型的部分,会自动发生类型转换,C中一般给warning:,C++一般是error:</em></p><p>但是,在指针,引用赋值时,一般情况下要严格遵守类型匹配原则,除了两种情况以外:</p><p><em>首先,必须是不同类型的指针,不同类型的引用之间. 算术类型与指针/引用时无论如何不能进行转换的,</em></p><p><strong>我们的例外情况之一就是: 对于初始化cosnt引用,可以赋予不同类型的引用</strong></p><p><strong>但是,要求是,可以完成类型转换的情况,而且,更甚于使用字面量,非const变量,表达式之类的进行初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;a = db;              <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">3.14</span>;      <span class="comment">// b = 3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">3</span>;               <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;d = <span class="number">3</span>;         <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>首先来说说进行,不同引用/指针类型之间的赋值.</p><p>其实在其中完成了这样的步骤:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = db;</span><br><span class="line">cosnt <span class="keyword">int</span> &amp;b = temp;</span><br></pre></td></tr></table></figure><p>对,没错.实际上他用了一个临时值来进行保存,这个临时值发生了类型准换,当然会丢失精度</p><p>那么<code>int &amp;a = db</code>为什么会失败?</p><p>因为,我们实际上时进行临时值的绑定,修改临时值并不能修改<code>db</code>,但是const变量就不是为了修改的</p><p>而<code>int &amp;a</code>时为了修改的,既然绑定临时值并不能修改,所以,这样的行为自然就是错误的了.</p><p>指针的话,</p><p><strong>指的是,可以使用非常量指针,来进行常量指针(是底层cosnt,顶层const想都不用想)的初始化</strong></p><p><strong>不同指针类型之间,进行初始化,如果不使用强制类型转化(轻则:warning, 重则:error)</strong></p><p><em>至于,为什么可以忽略顶层const, 引用不需要考虑,而指针,即使开放出去,新赋值的指针也只能修改</em></p><p><em>他们指向的对象,而不能修改原指针</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> src = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *des = src;</span><br></pre></td></tr></table></figure><p>即: des只能修改a,修改不到src,所以,src的顶层cosnt属性,不要就不要了.</p><h2 id="四-处理类型"><a href="#四-处理类型" class="headerlink" title="四, 处理类型"></a>四, 处理类型</h2><p>如今C++发展日新月异,越来越牛<del>(gou)</del>皮<del>(pi)</del></p><p>类型也是越写越长,我们逐渐难以推断出,某个变量到底会是什么类型,这就是个十足的问题了</p><p>于是乎,出现了这么几种进行类型推导的好东西:</p><h3 id="1-typedef"><a href="#1-typedef" class="headerlink" title="1. typedef"></a>1. typedef</h3><p>其实C中也用过了,就是类型别名(type alias),这个东西只能你自己起名字</p><p><em>局限性还是很大的,你要是也不认识,不就没办法玩了</em></p><p><strong>所以,我们推荐下面这几种方法</strong></p><h3 id="2-模板类型推导"><a href="#2-模板类型推导" class="headerlink" title="2. 模板类型推导"></a>2. 模板类型推导</h3><p>很牛皮, 不过我现在也用不上,不提了,后面补</p><h3 id="3-auto自动类型推导"><a href="#3-auto自动类型推导" class="headerlink" title="3. auto自动类型推导"></a>3. auto自动类型推导</h3><p>这个是C++11种新出来的好东西</p><p>这东西,当年也是从C中出来的,不过已经废了很多年了(PS: 表示自动变量有个球用)</p><p>所以,C++11对此关键字,继续重写.作为自动类型推导关键字</p><p><strong>auto根据初始值,进行类型推导,所以它必需要进行初始化,不然搞锤子</strong></p><p><strong>另外,auto其实是模板类型推导过来的,所以实际上auto就是个占位符T,不能用做类型</strong></p><p><code>auto i = auto j;</code>这就是错误的,编译会炸的</p><p><em>auto自动类型推导,会根据情况,进行一定程度的修改,使其更符合自动类型推导</em></p><p><strong>也就是说,会出现不一致的情况,它会忽略顶层const,底层cosnt则会保留,如果有需要顶层const,显式声明.</strong></p><p><strong>对于字面量的情况,必须是对cosnt的引用,否则还是编译不通过,很简单,不能为非const引用绑定字面值</strong></p><p><code>auto &amp;i = 42</code>错误, <code>const auto &amp;i = 42</code> 编译通过</p><p>另外,要注意的:<strong>对引用使用时,auto会使用引用绑定的类型进行推导</strong></p><p>也就是说: <strong>一般变量进行类型推导, 变量的顶层const属性会丢失. 而引用则能保留顶层const属性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i;    <span class="comment">// a #=&gt; int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = i;   <span class="comment">// b #=&gt; const int&amp;</span></span><br></pre></td></tr></table></figure><p><em>好吧,我错怪C++ Primer的翻译了,我的错.</em></p><p>来看看下面这些例子,和你想的一样吗?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;      <span class="comment">// i #=&gt; const int</span></span><br><span class="line"><span class="keyword">auto</span> j = i;            <span class="comment">// j #=&gt; int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;k = i;     <span class="comment">// k #=&gt; const int &amp;, 没有const,会error</span></span><br><span class="line"><span class="keyword">auto</span> *p = &amp;i;          <span class="comment">// p #=&gt; const int *, 因为它指向const常量,所以得是底层cosnt指针</span></span><br><span class="line"><span class="keyword">auto</span> p = &amp;i;           <span class="comment">// 结果同上,指针不显式声明可以推导,引用则会被推导为一般类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> j2 = i, &amp;k2 = i; <span class="comment">// j2 #=&gt; const int k2 #=&gt; const int &amp;</span></span><br></pre></td></tr></table></figure><h3 id="4-decltype类型指示符"><a href="#4-decltype类型指示符" class="headerlink" title="4. decltype类型指示符"></a>4. decltype类型指示符</h3><p><em>上面使用auto时,你可能还会抱怨,会出问题,不一定符合,const会丢失之类的</em></p><p>但是,我明确的说,<strong>decltype一定符合你的需求,它会切实进行类型推导</strong></p><p>当然,两个类型推导之间会所不同. 具体来说:</p><ol><li><p><code>auto</code>是根据初始值进行类型推导,所以它一定会发生赋值操作</p><p>而<code>decltype</code>只是根据表达式结果推导,并不实际计算</p></li><li><p><code>auto</code>在对于引用推导时,使用引用绑定类型,<code>decltype</code>则会将其作为引用使用.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> i = a; <span class="comment">// i #=&gt; int ,丢失顶层const, a只是个const int,使用引用绑定类型</span></span><br><span class="line"><span class="keyword">decltype</span>(a) b;  <span class="comment">// Error, 推导出来是引用类型,而引用类型必须初始化</span></span><br></pre></td></tr></table></figure></li></ol><p> <strong>切记: 引用类型,只有在<code>decltype</code>这里是引用,其他时候都使用其绑定类型</strong></p><ol start="3"><li>便是,<code>decltype</code>中奇特的<code>(())</code>了, 他会将变量作为表达式,获取引用类型</li></ol><p><strong><code>decltype</code>中有一个大坑, 当decltype的表达式可以作为赋值语句的左值时,decltype的结果是引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) a = i;       <span class="comment">// a #=&gt; int </span></span><br><span class="line"><span class="keyword">decltype</span>(*p) b;              <span class="comment">// Error, b #=&gt; int &amp;</span></span><br></pre></td></tr></table></figure><p><strong>不要奇怪解引用的结果是引用,因为它可以作为左值</strong></p><p>总结一下: </p><p><strong>1. 使用变量,一定会得到你想要的变量类型,当然,在你不使用<code>decltype((var))</code>的情况下</strong></p><p><strong>2. 使用表达式, 如果可以作为左值,那么,他就是引用,上面的r+0, 并不能做引用,它是int</strong></p><p>讲道理,上面这些还是收货颇丰的.</p><h2 id="X-附C-11使用部分"><a href="#X-附C-11使用部分" class="headerlink" title="X: 附C++11使用部分"></a>X: 附C++11使用部分</h2><p><em>这部分是关于C++11 特性使用的实例,每次补上几个,从一开始就要求自己使用C++11</em></p><h3 id="1-long-long类型"><a href="#1-long-long类型" class="headerlink" title="1. long long类型"></a>1. long long类型</h3><p>其实就是个类型扩展,没啥意思,C中也引入了,C11中</p><h3 id="2-列表初始化"><a href="#2-列表初始化" class="headerlink" title="2. 列表初始化"></a>2. 列表初始化</h3><p>这个之前比较鸡肋,现在C++11全面支持,我们可以这样用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">type a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">type <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">type a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><strong>使用列表初始化,最大的好处就是: 再出现丢失精度风险的时候,会报warning</strong></p><p>当然肯定不止这么一点,我们后面再说</p><h3 id="3-nullptr常量"><a href="#3-nullptr常量" class="headerlink" title="3. nullptr常量"></a>3. nullptr常量</h3><p>这个是为了C++11 全面兼容,0 效果一般,不明显, NULL需要&lt; cstdlib &gt;支持,不如直接使用nullptr </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// declare a null pointer</span></span><br></pre></td></tr></table></figure><h3 id="4-constexpr变量"><a href="#4-constexpr变量" class="headerlink" title="4. constexpr变量"></a>4. constexpr变量</h3><p>在确定会是常量时,我们使用constexpr,来让编译器进行检测,一般只能用静态区变量/表达式初始化.</p><p>因为堆栈上的变量,地址未分配,编译期不能确定.后面还会有constexpr函数出现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">4</span>, b = <span class="number">5</span>;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>要求,必须足够简单,能够在编译期确定值</p><h3 id="5-类型别名说明符-auto自动类型推导-decltype类型指示符"><a href="#5-类型别名说明符-auto自动类型推导-decltype类型指示符" class="headerlink" title="5. 类型别名说明符, auto自动类型推导, decltype类型指示符"></a>5. 类型别名说明符, auto自动类型推导, decltype类型指示符</h3><p>这三个家伙是为了同一目的的.</p><p><code>using</code>只是半个<code>typedef</code>的替代品,完全一致</p><p><code>auto</code>, <code>decltype</code>前面已经详细说过,就看看怎么用吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">using</span> Node = struct node;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.begin(), i != vec.end(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省得写 std::vector&lt;int&gt;::iterator it = vec.begin();</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((a)) b = a;   #=&gt; b#=&gt; <span class="keyword">int</span> &amp;</span><br></pre></td></tr></table></figure><p>最后再给大家两个建议:</p><ol><li><p>多去外面的世界看看,挺好的</p></li><li><p>多用IDE,类型推导不明确时,鼠标放上去就行了,Vim还没有这种功能</p></li><li><p>typeid(var).name(), 输出的结果真的是俄式踏马的瓜皮…</p></li></ol><hr><p>这次我们就先说到这里,C++还是很有意思的,就是内容太多了.</p><p>现在还是要爆肝,一般也就在是在迷糊的时候写博客</p><p>不然,哪有那么多时间,E3期间,就等大法放大招好吧.</p><p>他要是放大招,我就,我就 立马买张25仔:完全版 庆祝一下.</p><p>June 11, 2018 12:20 AM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux x86_64系统调用的实现过程</title>
      <link href="/2018/06/07/TLPI/syscall/"/>
      <url>/2018/06/07/TLPI/syscall/</url>
      <content type="html"><![CDATA[<p><em>由于系统调用的分析实现其中涉及一些内核/OS方面的知识,不是十分重要的,我们不进行详细说明</em></p><p><em>另外, 此分析,基于glibc-2.26以及Linux-Kernel-4.17,可以获取相关源码阅读</em></p><p>从我们以往的理解上来看,系统调用就是使用OS提供的接口,不也就是调用么?</p><p>System Call涉及了用户/内核态的切换,有些是需要进入内核态完成的,所以系统调用的存在就很有必要</p><p>更重要的一点就是: <strong>使用系统调用,仅仅暴露接口,保证了内核不会被无意/恶意破坏</strong></p><p>下面我们开始具体的系统调用实现分析:</p><h2 id="一-从使用一个系统调用开始"><a href="#一-从使用一个系统调用开始" class="headerlink" title="一, 从使用一个系统调用开始"></a>一, 从使用一个系统调用开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/tmp/file"</span>, O_RDONLY, <span class="keyword">mode_t</span> mode);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">do_something(errno);</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面便是一个简单地使用系统调用的例子,使用了open(系统调用)</p><p>那么下一步, <strong>就是,open()函数的实现到底在哪里呢?</strong></p><p>有两种方法查看:</p><h3 id="1-使用GDB单步进入"><a href="#1-使用GDB单步进入" class="headerlink" title="1. 使用GDB单步进入"></a>1. 使用GDB单步进入</h3><p>这个时候,GDB的Step指令就十分重要了,对于open(),函数它可以单步进入啊!</p><p>这不就很明显的看出<code>open()</code>实现在哪里了?</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/gdb_s.png" alt="gdb step指令"></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/locate.png" alt="locate 确定文件位置"></p><p>如上</p><h3 id="2-合理推测-ಡωಡ"><a href="#2-合理推测-ಡωಡ" class="headerlink" title="2. 合理推测(ಡωಡ)"></a>2. 合理推测(ಡωಡ)</h3><p>我们使用的系统调用都是C实现,而在Linux平台下,使用最多的是GNU C,依赖的libc库为glibc</p><p>(PS: 上面是我的本机环境,各位可以根据自己的机器环境去C库进行实现的查找)</p><p>见我们的实现依赖于glibc,那么去C可查找理所当然了</p><p>然后使用查找关键字的方法就定位到open64.c上了</p><p><strong>此处,有一个巨坑,关于/usr/src/debug/, 这个里面glibc不全啊</strong></p><p><strong>只是为了调试需要,所集成的一部分glibc实现,同时需要注意我们使用的C库一般都是发行版提供</strong></p><p><strong>需要去看glibc源码才能真正看清楚</strong></p><h2 id="二-分析一个系统调用的源码"><a href="#二-分析一个系统调用的源码" class="headerlink" title="二, 分析一个系统调用的源码"></a>二, 分析一个系统调用的源码</h2><p>那么,现在就来刺激的了,分析系统调用的源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sysdeps/unix/sysv/linux/open64.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copyright (C) 1991-2018 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">   This file is part of the GNU C Library.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">   modify it under the terms of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License as published by the Free Software Foundation; either</span></span><br><span class="line"><span class="comment">   version 2.1 of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">   Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License along with the GNU C Library; if not, see</span></span><br><span class="line"><span class="comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sysdep-cancel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;not-cancel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OFF_T_MATCHES_OFF64_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTRA_OPEN_FLAGS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTRA_OPEN_FLAGS O_LARGEFILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,</span></span><br><span class="line"><span class="comment">   a third argument is the file protection.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line"> mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strong_alias (__libc_open64, __open64)</span><br><span class="line">libc_hidden_weak (__open64)</span><br><span class="line">weak_alias (__libc_open64, open64)</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !IS_IN (rtld)</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__open64_nocancel (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line">      mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">strong_alias (__libc_open64, __open64_nocancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">libc_hidden_def (__open64_nocancel)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OFF_T_MATCHES_OFF64_T</span></span><br><span class="line">strong_alias (__libc_open64, __libc_open)</span><br><span class="line">strong_alias (__libc_open64, __open)</span><br><span class="line">libc_hidden_weak (__open)</span><br><span class="line">weak_alias (__libc_open64, open)</span><br><span class="line"></span><br><span class="line">strong_alias (__open64_nocancel, __open_nocancel)</span><br><span class="line">libc_hidden_weak (__open_nocancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><em>备注: 在本目录下,其实是有4个于open()有关的文件,分别是open.c,open64.c, openat.c, openat64.c</em></p><p><em>但是,事实上他们是指不同层次,不同平台上的系统调用,剥开之后,最后都是openat()函数</em></p><p><em>但是,我本机是64为,所以是封装的64位openat()函数文件,即open64.c</em></p><p>我们可以一行一行分析这个函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function open() -&gt; __libc_open64()</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">2</span> __libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line"><span class="number">3</span> &#123;</span><br><span class="line"><span class="number">4</span>   <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>   <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line"><span class="number">7</span>     &#123;</span><br><span class="line"><span class="number">8</span>       va_list arg;</span><br><span class="line"><span class="number">9</span>       va_start (arg, oflag);</span><br><span class="line"><span class="number">10</span>      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line"><span class="number">11</span>      va_end (arg);</span><br><span class="line"><span class="number">12</span>    &#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span>  <span class="keyword">return</span> SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line"><span class="number">15</span> mode);</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> strong_alias (__libc_open64, __libc_open)</span><br><span class="line"><span class="number">18</span> strong_alias (__libc_open64, __open)</span><br><span class="line"><span class="number">19</span> libc_hidden_weak (__open)</span><br><span class="line"><span class="number">20</span> weak_alias (__libc_open64, open)</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> strong_alias (__open64_nocancel, __open_nocancel)</span><br><span class="line"><span class="number">23</span> libc_hidden_weak (__open_nocancel)</span><br></pre></td></tr></table></figure><p><em>上面的C是典型的GNU风格,两个空格,看的我想打人,写惯了K&amp;R C的人表示脑子疼</em></p><p>6 ~ 8行就是简单的参数判断,我们可以略过</p><p>其实你可能会奇怪,好端端的<code>open()</code>,系统调用怎么变成了,<code>__libc_open64()</code></p><p><strong>注意17 ~ 23行的宏,他们将别名实现为了宏,事实上,调用open(),就是__libc_open64()</strong></p><p>那么,重心来了,就是14行,它实现了,<code>SYSCALL_CANCEL</code>宏来进行操作</p><p>看到这里,这一部分文件就足够了,我们已经知道了<code>__libc_open64()</code>只是一个warpper function了</p><p>这便是TLPI中第一部分的,Warpper函数</p><h2 id="三-Warpper-Function如何Warpper"><a href="#三-Warpper-Function如何Warpper" class="headerlink" title="三,Warpper Function如何Warpper"></a>三,Warpper Function如何Warpper</h2><p>我们要去看warpper function如何工作,也就是去看它是如何进行封装,并且完成用户/系统态切换的</p><p>首先,Warrpper的过程,各个平台上都应该是一致的,所以我们去看,sysdeps/unix/sysdeps.h</p><p>这个文件中都是宏定义,那么,我们就一步一步来吧,我将宏定义的顺序整理了一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort the macros 已知 SYSCALL_CANCEL</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_CANCEL(...) \</span></span><br><span class="line">  (&#123;     \</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> sc_ret;     \</span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)      \</span><br><span class="line">      sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);      \</span><br><span class="line">    <span class="keyword">else</span>     \</span><br><span class="line">      &#123;     \</span><br><span class="line"><span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC ();     \</span><br><span class="line">sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);     \</span><br><span class="line">        LIBC_CANCEL_RESET (sc_cancel_oldtype);     \</span><br><span class="line">      &#125;     \</span><br><span class="line">    sc_ret;     \</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">(&#123; <span class="keyword">long</span> <span class="keyword">int</span> sc_ret; <span class="keyword">if</span> (SINGLE_THREAD_P) sc_ret = INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); <span class="keyword">else</span> &#123; <span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC (); sc_ret = INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); LIBC_CANCEL_RESET (sc_cancel_oldtype); &#125; sc_ret; &#125;);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_DISP(b,...) \</span></span><br><span class="line">  __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL__INLINE_SYSCALL_NARGS(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode)(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL__INLINE_SYSCALL_NARGS_X (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span></span><br><span class="line"><span class="comment">// 这是最神奇的宏,一个计数宏,计算参数的宏</span></span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL4(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span></span><br></pre></td></tr></table></figure><p>所以,同一处理后,获取到的是<code>__INLINE_SYSCALLn(name, arguments...); [n个参数]</code></p><p>然后用同文件下的宏继续处理后,可以获取到 <code>INLINE_SYSCALL (name, nr, arguments...);</code></p><p>既然我们分析的是x86_64平台上系统调用的实现,那么我们就去x86_64下找东西吧</p><p>下面找得到的就是具体的上述宏平台上的依赖实现了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/unix/sysv/linux/x86_64/sysdeps.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL(name, nr, args...) \</span></span><br><span class="line">  (&#123;      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL (name, , nr, args);      \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))      \</span><br><span class="line">      &#123;      \</span><br><span class="line">__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));      \</span><br><span class="line">resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define a macro with explicit types for arguments, which expands inline</span></span><br><span class="line"><span class="comment">   into the wrapper code for a system call.  It should be used when size</span></span><br><span class="line"><span class="comment">   of any argument &gt; size of long int.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> INLINE_SYSCALL_TYPES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL_TYPES(name, nr, args...) \</span></span><br><span class="line">  (&#123;      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL_TYPES (name, , nr, args);  \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))      \</span><br><span class="line">      &#123;      \</span><br><span class="line">__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));      \</span><br><span class="line">resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INTERNAL_SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL(name, err, nr, args...)\</span></span><br><span class="line">internal_syscall#<span class="meta">#nr (SYS_ify (name), err, args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INTERNAL_SYSCALL_NCS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL_NCS(number, err, nr, args...)\</span></span><br><span class="line">internal_syscall#<span class="meta">#nr (number, err, args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall0(number, err, dummy...)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall1(number, err, arg1)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall2(number, err, arg1, arg2)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall3(number, err, arg1, arg2, arg3)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall4(number, err, arg1, arg2, arg3, arg4)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall5(number, err, arg1, arg2, arg3, arg4, arg5)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg5, __arg5) = ARGIFY (arg5); \</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg5, _a5) <span class="keyword">asm</span> (<span class="string">"r8"</span>) = __arg5;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),\</span><br><span class="line">      <span class="string">"r"</span> (_a5)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall6(number, err, arg1, arg2, arg3, arg4, arg5, arg6) \</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg6, __arg6) = ARGIFY (arg6); \</span><br><span class="line">    TYPEFY (arg5, __arg5) = ARGIFY (arg5); \</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg6, _a6) <span class="keyword">asm</span> (<span class="string">"r9"</span>) = __arg6;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg5, _a5) <span class="keyword">asm</span> (<span class="string">"r8"</span>) = __arg5;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),\</span><br><span class="line">      <span class="string">"r"</span> (_a5), <span class="string">"r"</span> (_a6)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>此文件内容超多,所以我们只截取其中重要的部分</strong></p><p>我们可以看到下面这样的实现流程:</p><p><code>INLINE_SYSCALL(name, nr, args...)</code> -&gt; <code>INTERNAL_SYSCALL(name, ,nr, args)</code> -&gt;</p><p><code>internal_syscall##nr (SYS_ify (name), err, args);</code></p><p>下面就是具体对应不同参数的函数实现了,其中实现了,产生软中断,进入内核态,然后参数入寄存器,传参</p><p>那么,这一些列函数中我们可以看到:</p><p><strong>参数只能是6个,可以传递7个参数,一个是系统调用名,是吗? 错的,传递的参数只是建议范围内为7个</strong></p><p><strong>其余的呢? 入栈, Register参数就7个罢了</strong></p><p>我们来具体看看函数实现,尤其是其中的内联汇编部分(其实我汇编很烂,Intel都不行,ATT就更不多说了)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),\</span><br><span class="line">      <span class="string">"r"</span> (_a5), <span class="string">"r"</span> (_a6)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其他的不多说,其中最重要的就是, <code>&quot;syscall\n\t&quot;</code>这个东西了</p><blockquote><p>在32位机上,使用<code>int 0x80</code> 第128中断号,陷入内核,进行系统调用</p></blockquote><blockquote><p>在ARM上,使用<code>swi</code>执行陷入内核</p></blockquote><blockquote><p>唯独少有人说x86_64平台上的软中断,也就是<code>syscall</code>中断向量</p></blockquote><p>你没有听错,这个B就是叫syscall中断vector,qtmd,看了我半天</p><p><em>不过这也是我内核基础不扎实的恶果,深感惭愧</em></p><p>至此,Warpper function的任务顺利完成,下来就需要切换到内核态处理了.</p><p>我们接下来就得看LinuxKernel的代码了</p><h2 id="四-关于中断的小了解"><a href="#四-关于中断的小了解" class="headerlink" title="四,关于中断的小了解"></a>四,关于中断的小了解</h2><p>中断是在引入保护模式(protect mode)之后很重要的一个特性,以此来陷入内核,进入内核态</p><p><strong>一般的fault,会重复指令,syscall会vector+1, 执行下一条</strong></p><p><em>此处,中断的内容,同样是Kernel重要知识,当然我还是不够清楚,不能清晰地翻出汇编指令解析</em></p><p><em>但是,syscall的流程还是比较清楚的</em></p><p>首先,来看内核的中断处理例程</p><p>既然是64位,肯定看arch/x86/entry/entry_64.S</p><p>简单说一下,entry这几个文件</p><blockquote><p>entry_32.S是32位机使用的</p></blockquote><blockquote><p>entry_64.S是64位机使用的,但是说实话,很像是拼凑的,凌乱不堪,就在32基础上改得,32看着十分清晰</p></blockquote><blockquote><p>entry_64_compat.S 是兼容的,在64位机器上按照32的形式运行,用的是32位的接口</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64_trampoline)</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">movq</span>$entry_SYSCALL_64_stage2, %rdi</span><br><span class="line">JMP_NOSPEC %rdi</span><br><span class="line">END(entry_SYSCALL_64_trampoline)</span><br><span class="line"></span><br><span class="line"><span class="meta">.popsection</span></span><br><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64_stage2)</span><br><span class="line">UNWIND_HINT_EMPTY</span><br><span class="line">popq%rdi</span><br><span class="line"><span class="keyword">jmp</span>entry_SYSCALL_64_after_hwframe</span><br><span class="line">END(entry_SYSCALL_64_stage2)</span><br><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">swapgs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">movq</span>%rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"><span class="keyword">movq</span>PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq$__USER_DS/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">pushqPER_CPU_VAR(rsp_scratch)/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">pushq%r11/* pt_regs-&gt;flags */</span><br><span class="line">pushq$__USER_CS/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">pushq%rcx/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line"><span class="meta">GLOBAL</span>(entry_SYSCALL_64_after_hwframe)</span><br><span class="line">pushq%rax/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line"></span><br><span class="line">TRACE_IRQS_OFF</span><br><span class="line"></span><br><span class="line">/* IRQs are off. */</span><br><span class="line"><span class="keyword">movq</span>%rax, %rdi</span><br><span class="line"><span class="keyword">movq</span>%rsp, %rsi</span><br><span class="line"><span class="keyword">call</span>do_syscall_64/* returns with IRQs disabled */</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line">END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure><p>其中删去了很多内容,但是整个思路是:</p><ol><li><p>去中断向量表查看中断偏移量(很惭愧,没找到),</p></li><li><p>对应的entry_64.S进行section的调用</p></li><li><p>对于syscall就是调用到了(其中还有两个函数被我删掉了,仅保留了核心)<code>entry_SYSCALL_64</code></p><p><em>其中ENTRY(), END(),都是宏用来进符号表中的函数声明</em></p></li><li><p>在<code>entry_SYSCALL_64</code>中调用了<code>do_syscall_64()</code></p></li></ol><p><code>do_syscall_64()</code>这是一个外部函数,在common.c中的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/entry/common.c</span></span><br><span class="line"></span><br><span class="line">__<span class="function">visible <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">enter_from_user_mode();</span><br><span class="line">local_irq_enable();</span><br><span class="line">ti = current_thread_info();</span><br><span class="line"><span class="keyword">if</span> (READ_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY)</span><br><span class="line">nr = syscall_trace_enter(regs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NB: Native and x32 syscalls are dispatched from the same</span></span><br><span class="line"><span class="comment"> * table.  The only functional difference is the x32 bit in</span></span><br><span class="line"><span class="comment"> * regs-&gt;orig_ax, which changes the behavior of some syscalls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nr &amp;= __SYSCALL_MASK;</span><br><span class="line"><span class="keyword">if</span> (likely(nr &lt; NR_syscalls)) &#123;</span><br><span class="line">*nr = array_index_nospec(nr, NR_syscalls);</span><br><span class="line">*regs-&gt;ax = sys_call_table[nr](regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中标上*的两句就是最重要的,它会去sys_call_table[]全局例程调用表中查找我们想要调用的例程</p><p>为什么有这样的机制呢?</p><p>因为中断号页只有255,所有的系统调用共享syscall对应的入口,所以我们需要一个数组</p><p><strong>在都进入内核态之后,根据每个系统调用的唯一编号来进行唯一标识与识别</strong></p><p>这个编号的确定,是有各种各样的宏确定的,<strong>同时要保证LinuxKernel与glibc的编号一致,</strong></p><p>我们可以来看这两个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/include/asm/unistd_64.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line">.........</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>确定好编号后,就可以访问指定函数的地址了</p><h2 id="五-真正的系统调用实现"><a href="#五-真正的系统调用实现" class="headerlink" title="五,真正的系统调用实现"></a>五,真正的系统调用实现</h2><p>我们可以查看此文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /include/linux/syscalls.h</span></span><br><span class="line"><span class="comment">// 此文件实现了所有系统调用的声明以及SYSCALL_DEFINEx宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\</span></span><br><span class="line">asmlinkage <span class="keyword">long</span> sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span></span><br><span class="line">__attribute__((alias(__stringify(__se_sys##name))));\</span><br><span class="line">ALLOW_ERROR_INJECTION(sys##name, ERRNO);\</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line">asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span></span><br><span class="line">asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span></span><br><span class="line">&#123;\</span><br><span class="line"><span class="keyword">long</span> ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="line">__MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="line">__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="line"><span class="keyword">return</span> ret;\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line"><span class="comment">/* fs/eventfd.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_eventfd2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fs/eventpoll.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">struct epoll_event __user *event)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">sigset_t</span> __user *sigmask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> sigsetsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fs/fcntl.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_dup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fildes)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_dup3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> oldfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> newfd, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fcntl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fcntl64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>经常看到其他文档上说到sys_open()是入口,这其实都是早期的说法,实际上,是由宏生成真正的函数定义</p><p>同时我们可以根据,此文件中的注释,找到根本意义上的Syscall定义,比如<code>epoll_ctl()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following function implements the controller interface for</span></span><br><span class="line"><span class="comment"> * the eventpoll file that enables the insertion/removal/change of</span></span><br><span class="line"><span class="comment"> * file descriptors inside the interest set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">int</span> full_check = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">error = -EBADF;</span><br><span class="line">f = fdget(epfd);</span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line">................</span><br></pre></td></tr></table></figure><p><strong>上述即为真真正正最底层,最底层<code>epoll_ctl()</code>的实现</strong></p><p><strong>至此,我们便真正追踪到了,系统调用的实现了,其他系统调用的源码,查看方法同理</strong></p><h2 id="六-扩展阅读"><a href="#六-扩展阅读" class="headerlink" title="六,扩展阅读"></a>六,扩展阅读</h2><p><a href="https://my.oschina.net/fileoptions/blog/908682" target="_blank" rel="noopener">关于ARM实现</a></p><p><a href="https://zhuanlan.zhihu.com/c_144857088" target="_blank" rel="noopener">关系不大,但有价值的glibc分析(脚本Warpper)</a></p><p>书籍推荐: &lt; Linux内设设计与实现 &gt;        (PS: 虽然是基于2.6.32,但还是很有意义)</p><h2 id="其他的一些闲杂事情"><a href="#其他的一些闲杂事情" class="headerlink" title="其他的一些闲杂事情"></a>其他的一些闲杂事情</h2><p>主要还是最近烦,感觉自己要玩了(beibei狗),看TLPI,突发奇想,想看看syscall的真正实现</p><p>但是网上都是ARM,X86是实现(2.6.32),没有X86_64,4版本内核的实现</p><p>于是乎我决定来稿一搞</p><p>但是自身水平又不行,所以也比较磕绊,其实分析也是不完整的</p><p>最后,系统调用的退出,如何添加自己的系统调用这些内容都是不全面的</p><p><strong>还是自己学习不扎实,后面落实后会补充的,起码这两天干的事,还是挺有意义的</strong></p><p><em>接下来,回归主要任务,TLPI作为辅修,是时候C3P就绪了</em></p><p><strong>虽然很烦,但还是那句话:</strong></p><blockquote><p>生命转瞬即逝, 没时间丧,Fighting!</p></blockquote><p>June 8, 2018 2:00 AM</p>]]></content>
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> TLPI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于github绿点的常见问题--邮箱</title>
      <link href="/2018/06/05/Other/git_tool/"/>
      <url>/2018/06/05/Other/git_tool/</url>
      <content type="html"><![CDATA[<p><em>正如前面所说,今天遇到的问题就是github的绿点提交有问题,提交后并没有找到记录,很苦恼(不好装逼)</em></p><p><strong>首先,声明本文只是解决常见的问题,便是邮箱绑定不符的问题</strong></p><p>若是其他的问题, 请参考: <a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/" target="_blank" rel="noopener">传送门</a></p><p>解决方法有以下两种:</p><ol><li><p>进行新的邮箱绑定 如下图:</p><p> <img src="http://p8pmsq2a4.bkt.clouddn.com/git_name_email.png" alt=""></p><p> 先查看本地上进行git-push时的用户名和邮箱</p><p> <img src="http://p8pmsq2a4.bkt.clouddn.com/git_email_addition.png" alt=""></p><p> 可以通过添加多个邮箱的方式来追回记录</p></li><li><p>通过修改提交repo的方式来进行修改</p><p> 参考资料: <a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">git_help</a></p><p> 我们可以按照下面几步来进行操作</p><p> 一, 得到需要修改的commit的repo</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare https://github.com/user/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># user 为用户名</span></span><br><span class="line"><span class="comment"># repo为commit的仓库名</span></span><br></pre></td></tr></table></figure><p> 二, 使用script文件来进行repo的修改</p><p> sh文件内容如下:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git filter-branch --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">OLD_EMAIL="旧的Email地址"</span></span><br><span class="line"><span class="string">CORRECT_NAME="正确的用户名"</span></span><br><span class="line"><span class="string">CORRECT_EMAIL="正确的邮件地址"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">'</span> --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><p> 三, 使用脚本文件修改repo,重新提交</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repo.git</span><br><span class="line">bash script.sh</span><br><span class="line"></span><br><span class="line">git push --force --tags origin <span class="string">'refs/heads/*'</span>   <span class="comment"># 提交新修改的repo</span></span><br></pre></td></tr></table></figure><p> 四, 删除旧repo</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf repo.git</span><br></pre></td></tr></table></figure><p> 至此,便完成了追回提交记录的工作了.</p><p> 我们不得不感叹git作为一个版本控制工具的强大. git需要学习的东西还有很多.</p><p> 好(努)好(力)学(装)习(逼)</p><p> May 14, 2018 4:42 PM</p></li></ol>]]></content>
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_运行时数据结构与内存</title>
      <link href="/2018/06/05/C/Expert_C_Programming/data_mem/"/>
      <url>/2018/06/05/C/Expert_C_Programming/data_mem/</url>
      <content type="html"><![CDATA[<h2 id="一-a-out及其传说"><a href="#一-a-out及其传说" class="headerlink" title="一, a.out及其传说"></a>一, a.out及其传说</h2><p><em>我们大家接触Linux都是从C语言开始,那么每个人第一个可运行程序都是a.out</em></p><p><em>好奇过为什么用这个东西,做缺省名吗? 哈哈,我其实之前也没有仔细考虑过,现在就来聊一聊</em></p><p>a.out指的是汇编器输出文件,<strong>但实际上,a.out不是链接器的结果吗? ? ?</strong></p><p>哈哈,这是个历史遗留问题,PDP-11汇编器输出结果为a.out,而当年最正统的UNIX机器便是PDP-11,所以</p><p>你懂得,又是个历史遗留问题 !</p><h2 id="二-a-out与C文件内容之间的关系"><a href="#二-a-out与C文件内容之间的关系" class="headerlink" title="二, a.out与C文件内容之间的关系"></a>二, a.out与C文件内容之间的关系</h2><p>C文件的内容如何映射到a.out文件中呢? 那部分填充到哪里呢? 来看看下面的图:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/src_aout.png" alt="源文件-&gt;可执行文件"></p><p>如何上图所示,首先我们要强调的是:<strong>段(segement)的概念</strong>, 此段非彼段,与Intel内存模型中的段不同</p><p>此处的段是文件中的段,大小为64KB, 最小的控制单位是section</p><p><strong>另外,对于可执行文件,有许多种格式,COSS, ELF, PE格式,我们此处以GNU使用的x86_64elf为查看对象</strong></p><p>其中a.out中有这样几个段:</p><ol><li><p>a.out的神奇数字, 用来标识a.out文件的,我们可以通过readelf来查看</p></li><li><p>BSS段, 用来存储未初始化的变量,因为未初始化,所以这个段实际上是不占空间的,他只保存了大小</p></li><li><p>数据段, 用来存储初始化的数据,(其中还有只读区等小区,不细说),而BSS段 + 数据段即为数据区</p></li><li><p>文本段, 用来储存代码的,也有叫代码段的说法,一般为.text</p></li></ol><p>这些部分是,<strong>从C源文件 -&gt; 可执行文件的部分(a.out)</strong>,一会儿我们要说到的是:</p><p><strong>从可执行文件 -&gt; 内存映像的问题, 别混淆了呦</strong></p><p>我们在此处可以玩玩这几个命令: size, readelf, objdump ,nm下面我一一来演示:</p><p>首先来看看源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @filename:    1.c</span></span><br><span class="line"><span class="comment"> * @author:      Crow</span></span><br><span class="line"><span class="comment"> * @date:        06/04/2018 21:08:09</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;    <span class="comment">// read_only</span></span><br><span class="line"><span class="keyword">int</span> b;              <span class="comment">// BSS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">4</span>;       <span class="comment">// stack_heap a.out中看不出来(堆栈毕竟是运行时数据结构)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World! %d\n"</span>, c);</span><br><span class="line">    foo();           <span class="comment">// .text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p8uroi1uf.bkt.clouddn.com/size_aout.png" alt="size a.out"></p><p><img src="http://p8uroi1uf.bkt.clouddn.com/readelf_aout.png" alt="readelf -a a.out"></p><p><img src="http://p8uroi1uf.bkt.clouddn.com/objdump_aout.png" alt="odjdump -d a.out"></p><p><img src="http://p8uroi1uf.bkt.clouddn.com/nm_aout.png" alt=""><br><img src="http://p8uroi1uf.bkt.clouddn.com/nm_aout2.png" alt="nm -n --format=sysv a.out"></p><p><strong>注意,我们的图是从高地址-&gt;低地址, 然而我们的试验结果是地址升序排序</strong></p><p><strong>从中,我们可以证明,a.out中的顺序的确是,文本段(.text),数据段(.data),BSS段(.bss)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/<span class="keyword">asm</span>/a.out.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_A_OUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_A_OUT_H</span></span><br><span class="line">                                                                                          </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a_info;    <span class="comment">/* Use macros N_MAGIC, etc for access */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_text;    <span class="comment">/* length of text, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_data;    <span class="comment">/* length of data, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_bss;     <span class="comment">/* length of uninitialized data area for file, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_syms;    <span class="comment">/* length of symbol table data in file, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_entry;   <span class="comment">/* start address */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_trsize;  <span class="comment">/* length of relocation info for text, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_drsize;  <span class="comment">/* length of relocation info for data, in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TRSIZE(a) ((a).a_trsize)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_DRSIZE(a) ((a).a_drsize)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_SYMSIZE(a)    ((a).a_syms)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_A_OUT_H */</span></span></span><br></pre></td></tr></table></figure><h2 id="三-到底为什么要如此组织a-out文件"><a href="#三-到底为什么要如此组织a-out文件" class="headerlink" title="三, 到底为什么要如此组织a.out文件"></a>三, 到底为什么要如此组织a.out文件</h2><p><strong>其实很简单,就是为了可执行文件装入内存中方便</strong>, 来看这张图:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/aout_mem.png" alt="a.out到内存映像"></p><p>对于上面这张图: 我们着重说一下这样几点:</p><p><strong>1. 数据段,文本段直接映射</strong></p><p><strong>2. BSS段,根据它保存的大小进行扩展</strong></p><p><strong>3. BSS段与数据段实际上会进行合并, 统称数据区,而数据区往往就是一个程序中最大的段了</strong></p><p><strong>4. 最后我们再添加上为函数调用准备的堆栈区, 其中具体为stack + heap</strong></p><p><strong>5. 最下面地委映射区域一般是留给程序扩展,防止跑飞的</strong></p><p><strong>6. 如果有动态链接库(共享库)之类的,就直接忘堆栈上面怼</strong></p><h2 id="四-堆栈段有什么用-过程活动记录又是什么"><a href="#四-堆栈段有什么用-过程活动记录又是什么" class="headerlink" title="四, 堆栈段有什么用? 过程活动记录又是什么?"></a>四, 堆栈段有什么用? 过程活动记录又是什么?</h2><p>之前其实和很多学长也都聊过,操作系统中提到的堆栈是栈,数据结构中堆是堆,栈是栈,OK?</p><p>堆栈是一种FILO的数据结构,它很适合用于进行函数调用,为什么?</p><p><strong>尤其是我们进行递归调用的时候,需要同时维持多组函数(多个实例)的存在,同时还要保证他们一定的顺序</strong></p><p><strong>这就很符合堆栈的定义,所以堆栈段的存在很有必要于递归调用</strong></p><p><strong>也就意味着函数递归调用以外的其他作用,并非是堆栈段存在的必要意义,可以通过其他方式实现</strong></p><p>最最核心的作用就是维护了过程活动记录,CSAPP中也提到过这个东西,就是进行函数调用是的必要信息</p><p>以及调用结束之后,我们到底应该如何返回?</p><p>那么,我们就来看看过程活动记录吧</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/process.png" alt="过程活动记录"></p><p><strong>上面这个其实就是一个函数在堆栈中的内容了</strong></p><p><strong>1. 局部变量(local varibales) 即为函数内保存的自动变量(auto)缺省属性</strong></p><p><strong>2. 参数(arguments) 这其实是,形式参数,用于函数调用的</strong></p><p><strong>3. 静态链接(static link) 这个与C无关,其实是Pascal,Ada提供的特性,即函数的嵌套声明</strong></p><p><strong>我们可以通过这个静态链接指针来进行上层函数的访问,从而减少函数之间的通信</strong></p><p><strong>4. 指向先前结构的指针,很明显,就是指向上层函数(非静态链接),是说上一个过程活动记录</strong></p><p><strong>5. 返回地址(return address) 不多说了,就是函数调用结束后,返回的位置</strong></p><p><strong>过程活动记录清晰地阐述了堆栈区的实际意义,以及函数调用的实现</strong></p><p>我们的程序在运行的时候,维护一个指针fp,它指向最靠近堆栈顶端的过程活动记录,之后的全靠指针串起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/.../arch/x86/include/<span class="keyword">asm</span>/frame.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FRAME_POINTER                                                                                                              </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"> </span><br><span class="line">.macro FRAME_BEGIN</span><br><span class="line">    push %_ASM_BP</span><br><span class="line">    _ASM_MOV %_ASM_SP, %_ASM_BP</span><br><span class="line">.endm</span><br><span class="line">   </span><br><span class="line">.macro FRAME_END</span><br><span class="line">    pop %_ASM_BP</span><br><span class="line">.endm</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !__ASSEMBLY__ */</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_BEGIN             \</span></span><br><span class="line">    <span class="string">"push %"</span> _ASM_BP <span class="string">"\n"</span>           \</span><br><span class="line">    _ASM_MOV <span class="string">"%"</span> _ASM_SP <span class="string">", %"</span> _ASM_BP <span class="string">"\n"</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_END <span class="meta-string">"pop %"</span> _ASM_BP <span class="meta-string">"\n"</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_OFFSET __ASM_SEL(4, 8)</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_FRAME_POINTER */</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_BEGIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_END</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_OFFSET 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FRAME_POINTER */</span></span></span><br></pre></td></tr></table></figure><p><strong>另外哦我们要注意的一点就是: 过程活动记录很有可能不在堆栈中</strong></p><p>有两方面的原因:</p><ol><li><p>可能是编译器优化,对于依赖程度不高的,我们将过程活动记录储存在寄存器中</p></li><li><p>对于其他的架构,比如Sun的SPARC,就是使用链表进行过程活动记录的串联,并非存在堆栈中</p></li></ol><p><strong>时刻记住: 虽然我们常用x86_64架构,但是架构不止这么一种,你去看看linux目录下的Arch目录就懂了</strong></p><p>Arch–Architecture 架构</p><h2 id="五-两类内存问题"><a href="#五-两类内存问题" class="headerlink" title="五, 两类内存问题"></a>五, 两类内存问题</h2><p>最后,我们在介绍两种C语言有关却经常会出问题的内存问题:</p><p><strong>首先,说说内存分配的问题,我们可以使用malloc(),free()以及brk(), sbrk()来处理</strong></p><p><strong>具体的内容,大家下来自行进行了解</strong></p><h3 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1. 内存泄漏"></a>1. 内存泄漏</h3><p>再没有GC(垃圾回收机制)的语言实现中,内存泄漏是个永恒的话题,C中需要谨慎的进行处理</p><p>在C++中,有RAII的支持,但是内存泄漏还是个不容忽视的问题</p><p>主要是两类原因:</p><p><strong>释放或者改写正在使用的内存</strong></p><p><strong>未释放不再使用的内存</strong></p><p>我们唯一能做的就是: 慎之又慎的进行内存管理,避免内存泄漏</p><p><strong>另一方面,对于局部对象,我们可以使用alloca()来进行内存分配,这样可以避免退出函数后没有释放内存</strong></p><p><strong>但是, 局限性很大,对,出了这个函数就凉凉,所以还是好好谨慎的玩吧</strong></p><p>那么,既然它这么危险,我们有没有可以检测内存泄漏的方法?</p><p><strong>有,下米诺安就简单地介绍几个工具: swap(好像只有Sun能用), free, vmstat来查看</strong></p><p>这是最基础的方法,而我们着重介绍的就是: </p><p>Valgrind + kcachegrind</p><p>我们使用Valgrind中的工具集- callgrind进行内存泄漏的分析,然后通过kcachegrind进行图形化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_alloc</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_free</span><span class="params">(<span class="keyword">void</span> *mem_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input the size to allocate memory: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;size);</span><br><span class="line">    <span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)mem_alloc(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_alloc</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很明显的内存泄漏,我们通过valgrind的memcheck工具进行检测</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/valgrind--full_check.png" alt="valgrind --tool=memcheck --leak-check=full ./a.out "></p><p>另外我们还可以进行代码分析,如下:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/valgrind_kcachegrind.png" alt="valgrind --tool=callgrind ./a.out &amp;&amp; kcachegrind callgrind.out.*"></p><h3 id="2-总线错误-Bus-Error"><a href="#2-总线错误-Bus-Error" class="headerlink" title="2. 总线错误(Bus Error)"></a>2. 总线错误(Bus Error)</h3><p>这个错误,当时被很多人调侃过,说是”公交车错误”</p><p><em>其实,我也就是在学校的OJ上见过那么一次,</em></p><p>事实上,<strong>这是RISC架构最容易出现的问题,内存的非对齐访问,会造成总线堵塞,进而引发此错误</strong></p><p><strong>然而,沃尔玛能通常是用的都是CISC的x86_64架构,事实上通过修正电路,降低一点效率,避免这个错误</strong></p><p><strong>但是,无论如何,我们都是时刻关心内存对齐,很关键</strong></p><p>在这个之外其实还有一种错误,”Segement fault” #=&gt; “段错误”</p><p>在了解内存管理之前我对这个没有一点映像</p><p><strong>不过,现在看来,还是很关键的,这就是严重缺页错误,在分页机制中有三种映射错误</strong></p><p><strong>次要,严重,以及段错误,另外两种不多说,段错误就是映射失败,访问到不能访问的区域</strong></p><p><strong>不仅仅是TLB中没有要访问的页,内存中也没有,非法访问所造成的就是段错误,会造成程序中断进行</strong></p><p><strong>其实就是这么简单,Haha,多看点书还是有用的</strong></p><hr><p>June 5, 2018 12:43 AM</p><p><em>上面这些之后,就算咸鱼书彻底了结,C也了结了,当然kangkang的Esential C++看的也差不多,</em></p><p><em>就等C++ Primer(PS: 本来想叫C3P的,想像还是算了)就绪了.</em></p><p><em>虽然已经很晚了,不过,我有信心肝下去,干他妈的</em></p><p><em>想想后面的书: 6E, Server + Kernel 哇,脑子疼</em></p><p><em>但是,干他妈的总没错,溜了,溜了</em></p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
            <tag> Exprt_C_Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊C中的异常处理</title>
      <link href="/2018/06/04/C/Expert_C_Programming/error_jmp/"/>
      <url>/2018/06/04/C/Expert_C_Programming/error_jmp/</url>
      <content type="html"><![CDATA[<p><em>所谓异常处理机制,其实就是处理程序可能会发生地错误.</em></p><p><em>那么,我们的主要步骤也就是两个: 抓取异常, 处理异常</em></p><p><em>C++中我们使用throw(抛出异常)以及catch(捕获及处理异常)</em></p><p><em>C中我们使用longjmp()来进行抛出, setjmp()来处理异常</em></p><h2 id="一-setjmp-与longjmp"><a href="#一-setjmp-与longjmp" class="headerlink" title="一, setjmp()与longjmp()"></a>一, setjmp()与longjmp()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数使用来实现非本地跳转的,即”non local gotos”</p><p><em>将执行从一个函数转移到一个函数在另一个函数中的预定位置,setjmp()函数动态的建立将要控制的目标</em></p><p><em>而longjmp()函数执行转移</em></p><p><strong>我们说setjmp()函数用来建立将要控制的目标,那他怎么建立呢?</strong></p><p>通过查看man文档以及 /usr/include/setjmp.h可知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/setjmp.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/setjmp.h&gt;        /* Get '__jmp_buf'.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/types/__sigset_t.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Calling environment, plus possibly a saved signal mask.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> The machine-dependent definitions of `__sigsetjmp'</span></span><br><span class="line"><span class="comment">       assume that a `jmp_buf' begins with a `__jmp_buf' and that</span></span><br><span class="line"><span class="comment">       `__mask_was_saved' follows it.  Do not move these members</span></span><br><span class="line"><span class="comment">       or add others before it.  */</span></span><br><span class="line">    __jmp_buf __jmpbuf;     <span class="comment">/* Calling environment.  */</span></span><br><span class="line">    <span class="keyword">int</span> __mask_was_saved;   <span class="comment">/* Saved the signal mask?  */</span></span><br><span class="line">    <span class="keyword">__sigset_t</span> __saved_mask;    <span class="comment">/* Saved signal mask.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的结构体成员,分别是调用环境(保存堆栈指针, 指令等), 是否保存标志位的标志, 保存的信号掩码</span></span><br><span class="line"><span class="comment">// 而且,注释严重声明: 前两个成员是不能互相交换位置的.</span></span><br><span class="line"><span class="comment">// 如果要详细查看__jmp_buf 可以去看/usr/include/bits/setjmp.h</span></span><br></pre></td></tr></table></figure><p>即: setjmp()的参数,jmp_buf实际上就是保存现场的,而longjmp()就是用来恢复现场的.</p><p><strong>保存现场,就是保存活动记录…</strong></p><p>其中sigsetjmp(), siglongjmp(), 即可以理解为signal-setjmp(), signal-longjmp()</p><p><em>只是额外提供了对进程信号的可预测处理, 在此不表,用法与non-signal版本差不多,不多说</em></p><p><strong>介绍了这么多,那么这两个函数如何使用呢?</strong></p><p>我们可以从他们的返回值入手</p><p><strong>setjmp()直接返回值,也就是第一次调用为0, 之后longjmp()无返回值,但是longjmp()的参数val</strong></p><p><strong>作为setjmp()第二次之后的返回值, 若未指定val,setjmp()之后返回的不是0, 而是1</strong></p><p><strong>但是,setjmp() + longjmp()的严重问题是,他也不能随意跳转,只能是setjmp()保存过活动记录的地方</strong></p><p><em>其实有过C++经验的,可以勉强将setjmp(), 看成try字句</em></p><h2 id="二-Notes"><a href="#二-Notes" class="headerlink" title="二, Notes:"></a>二, Notes:</h2><p>1&gt; 注意</p><p>其中需要注意的是,jmp系列函数是通过保存现场来实现非本地跳转的,其中需要注意的一点就是:</p><p><strong>编译器会将变量优化为寄存器变量,所以在调用longjmp()之后,自动变量的值是未指定的</strong></p><p><strong>为什么这样讲, 因为你使用longjmp()的时候,jmp_buf的内容被销毁</strong></p><p><strong>所以自动变量(存在register中)的就凉凉了</strong></p><p>如果满足下面的条件:</p><ol><li><p>相应的setjmp()函数是局部的</p></li><li><p>自动变量值在setjmp()以及longjmp()之间发生了变化</p></li><li><p>变量没有被声明为volatile (反之,也就是说变量声明为volatile就不会被优化至寄存器)</p></li></ol><p><strong>则我们要求使用siglongjmp()函数</strong></p><p>2&gt; 可读性分析</p><p>关于可读性是一个大问题, 尽管non-local gotos可以被随意使用, 但是相比于local gotos,</p><p><strong>goto字句,起码还有goto语句以及label的提示啊</strong></p><p>但是,jmp函数,甚至多个longjmp()共享同一个jmp_buf变量进行操作</p><p>另外有一点: 甚至setjmp()以及longjmp()不在同一个文件模块中</p><p><strong>所以,我们建议除非迫不得已,请使用其他的替代方案</strong></p><p>3&gt; 警告</p><ol><li><p>如调用一个函数,此函数调用了setjmp(),却在longjmp()之前返回,那么它的行为是未定义的</p></li><li><p>在多线程程序中, 如果一个longjmp()函数使用了不同线程中的jmp_buf,那么它的行为同样是未定义的</p></li></ol><p>此外,讨论的一些,非异步信号安全函数,此处暂时不涉及,不清楚,之后有机会会填坑</p><h2 id="三-non-local-gotos的例子"><a href="#三-non-local-gotos的例子" class="headerlink" title="三, non-local gotos的例子"></a>三, non-local gotos的例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"set.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret_val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret_val = setjmp(jmp)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Back to main.c and ret_val is %d\n"</span>, ret_val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"First time through\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The ret_val: %d\n"</span>, ret_val);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SET_H          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt; </span></span></span><br><span class="line">jmp_buf jmp;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;            </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"set.h"</span>               </span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span>                </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is set.c\n"</span>); </span><br><span class="line">    longjmp(jmp, <span class="number">4</span>);           </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YOu can't get here!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下,大家看了代码基本就懂了:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/jmp.png" alt="./a.out"></p><h2 id="四-Linux内核的错误处理"><a href="#四-Linux内核的错误处理" class="headerlink" title="四, Linux内核的错误处理"></a>四, Linux内核的错误处理</h2><p>大家可以去看看代码,实际上内核的错误处理是使用多重goto来实现的</p><p>比较下面两种形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error1) &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error2) &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_something();</span><br><span class="line"><span class="keyword">if</span> (error1)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (error2)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">do_something();</span><br></pre></td></tr></table></figure><p><strong>很明显的可以看出,第二种的做法着实方便,提高了程序设计的维度,不会影响设计的重心</strong></p><p><strong>将错误处理集中在其他地方</strong></p><p>June 4, 2018 8:57 PM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_链接那点事</title>
      <link href="/2018/05/30/C/Expert_C_Programming/c_link/"/>
      <url>/2018/05/30/C/Expert_C_Programming/c_link/</url>
      <content type="html"><![CDATA[<p><em>编译系统很早就接触了,但是编译系统中到底干了什么?</em></p><p><em>我们今天来着重看一看链接的那点事</em></p><h2 id="1-编译系统"><a href="#1-编译系统" class="headerlink" title="1. 编译系统"></a>1. 编译系统</h2><p>首先,来看那一看编译系统都干了什么:</p><p><img src="http://oz3e8fi42.bkt.clouddn.com/complier_system.png" alt="编译系统"></p><p>而我们今天着重来说的就是: <strong>链接</strong>的过程</p><h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h2><p>链接到底发生了什么?</p><p>我们都知道,在汇编器作用完成后, 汇编文件.s被转化成为目标文件(可重定位的目标文件).o</p><p>.o文件是已经编译,优化二进制文件,只要成功进行装配就可以了.</p><p>软件开发的工程浩大,如果所有的内容都是自己从头开始编写,势必力不从心,难以维系</p><p>所以,我们倡导多使用库,对于一些基础内容,已经编译好的库,我们直接去链接即可.</p><p>这也就是,我们今天来讨论链接内容的原因.</p><p>首先,我们要明确一个概念: <strong>所谓链接,其中重要的有两点: 1.链接方式, 2. 链接时机</strong></p><p>这两点就是链接中最核心的内容.</p><p>我们先来从链接方式说起.</p><h2 id="3-静态链接"><a href="#3-静态链接" class="headerlink" title="3. 静态链接"></a>3. 静态链接</h2><p>C从很早就支持分离式编译,这个特性在C++中也支持,即是说,对于一个大型软件</p><p><strong>只要分块得当,大家完全可以分离式开发,最后进行模块的装配即可</strong></p><p>链接也是这样一个道理, 但是,链接去装拼的是函数库.</p><p>比如我们整天使用的C库,很多C库会默认链接 libc.so -&gt; libc.so.6</p><p><strong>因为是最基础的库,自动链接,而是我们平时不注意这些链接细节</strong></p><p>静态链接: </p><blockquote><p><strong>实际上说的就是, 链接库, 链接时,直接将需要的库一次性装入可执行文件</strong></p></blockquote><blockquote><p><strong>这样装配成功的可执行文件中包含了所需要库中函数实现的所有内容</strong></p></blockquote><blockquote><p><strong>比如说, 我调用printf, 静态链接了C库, 于是我的a.out中便包含了printf实现的所有目标文件</strong></p></blockquote><p> 那么,来分析一下静态链接的优缺点:</p><p> 优点: </p><ol><li><p>静态链接将库中所需要的内容直接装入可执行文件,使得可执行文件脱离静态库,即无需依赖库</p></li><li><p>因为装配的内容全部发生在链接时,所以运行时程序速度快,1% ~ 5% (相比于动态链接链接)</p></li></ol><p>缺点: 尽管静态链接有优秀的地方,但它的缺点也比较严重</p><ol><li><p>静态链接因为直接将每一个.o所需要的库文件装入, 他们相互之间不可见,于是相同的模块</p><p>甚至会悲壮在进入内存多次, 严重消耗了内存空间,举个简单的例子: printf若占0.2K, 一个大型程序</p><p>如果调用printf 2k次, 那么此可执行程序中,printf的内容就占了200KB的内容, 严重浪费内存</p><p>而且,这样的浪费情况,在早期的计算机系统中,甚至是致命的.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/static_link.png" alt="静态链接"></p><p>当然我们在分析后,发现了静态链接可能会造成在可执行文件中出现多份拷贝的问题,</p><p>早期的计算机如何如何处理呢? 是这样干的:</p><p><strong>他们将程序对于函数库的依赖实现在内核中,woc!, 这是个很严重的问题</strong></p><p><strong>会造成可怕的”内核膨胀”,后果不堪设想</strong></p><p>基于上面的问题,静态链接在特殊的历史时期还是比较有用的,但是现在,毫无疑问的过时了</p><p>所以,我们来介绍动态链接</p></li></ol><h2 id="4-动态链接"><a href="#4-动态链接" class="headerlink" title="4. 动态链接"></a>4. 动态链接</h2><p>首先,我们来说说为什么要有动态链接:</p><p><strong>1. 为了解决内存中重复库代码的问题,内核膨胀实际上是很危险的做法</strong></p><p><strong>2. 还是为了实现软件库更新迭代的便捷性</strong></p><p>我们先来说说动态链接,然后具体进行分析,并说说它如何解决上面其中的问题</p><p>动态链接:</p><blockquote><p><strong>首先,要明确的是, 动态链接是为了改进静态链接的.</strong></p></blockquote><blockquote><p><strong>我们首要解决的问题,便是多份库实现的拷贝问题,解法就是,维持一份拷贝</strong></p></blockquote><blockquote><p><strong>只要装入后在内存中维持一份库文件的拷贝,效率要好很多(隐含:链接后,a.out仅仅保留文件名)</strong></p></blockquote><blockquote><p><strong>(库文件的位置,符号表等内容,并未进行装入,推迟到运行时真正链接)</strong></p></blockquote><blockquote><p><strong>即是说,只要是在内存中维系了一份库文件拷贝的链接方式,便是动态链接</strong></p></blockquote><p>其实,我这里的说法和&lt; C专家编程 &gt; (“咸鱼书”) 还是不一样的.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/dynamic_pi.png" alt="动态链接"></p><p>因为下面我们就要说说链接的第二点了: 2. 装入时机</p><p>因为静态库已经过时(这说法也不全面)的问题,我们主要讨论动态链接</p><ol><li><p>装入时动态链接</p><p>如上所说,两种装入时机,第一种便是传统的装入时(Link期间)进行动态链接,</p><p>这个时候,链接器会进行查找,他会将目标文件中的所需要的库文件装入内存</p><p><strong>这就有一个问题了,有些模块的使用程度并不高: 尤其是错误处理模块</strong></p><p>动态链接的方式,可以有效的减少内存压力,但是利用率还是没有明显提升</p><p>错误模块仍然被装入,会导致,多个错误模块的装入但未使用的情况.</p><p><strong>而现在,十分流行的便是运行时动态链接(JIT Just-In-Time)的模式</strong></p></li><li><p>运行时动态链接</p><p>上面说到过,装入时动态链接,它的位置是可变的,可以是内存中任意位置.但是,结构是静态的</p><p><strong>即是说,装入多少模块,模块之间的顺序都是固定的.有的模块如果没有使用还是会浪费</strong></p><p>因此引入了运行时动态链接的方式: 装入时,不进行链接.一直将模块的链接推迟到运行时进行</p><p>(PS: 是不是有一种静态语言和动态语言的感觉,编译时/运行时确定类型,滑稽)</p><p>这样,如果需要错误处理模块,便由OS去寻找模块并装入,可以大大提高效率</p></li></ol><p>好了,常见的链接方式介绍完毕,我们再来比较一下这几种方式:</p><p>静态链接: </p><ul><li>在我们需要摆脱库依赖,而且程序对此库依赖程度小时使用,也就不会造成太多内存拷贝.</li></ul><p>动态链接: </p><ul><li><p>如果我们要经常调用某个库,我们便使用动态链接的形式,虽然说动态链接的运行都会变慢,</p><p>尤其是运行时动态链接,将链接时机推迟,但是另一方面会提高效率,(比其他两种更快的装入速度)</p><p><strong>可以说装入时动态链接基本上已经使用的很少了</strong></p></li></ul><p>上面是综合来讲,其实将链接方式和链接时机分开来说,也不过是这样:</p><ol><li><p>静态链接: 可以摆脱库依赖,重复拷贝多</p></li><li><p>动态链接: 仅维护一份共享拷贝,无法摆脱库依赖</p></li><li><p>静态装入: 位置是静态的,同时会将不一定运行的模块进行装入</p></li><li><p>动态装入: 绝不会装入任何一个不使用的模块,不过运行速度降低(在当今的机器配置下,都不是问题)</p></li></ol><h2 id="5-动态链接的优点"><a href="#5-动态链接的优点" class="headerlink" title="5. 动态链接的优点"></a>5. 动态链接的优点</h2><p>既然动态链接是目前的主流,我们就来看看动态链接的优点:</p><ol><li><p>生成的可执行文件小得多,因为具体模块的实现,并没有装入可执行文件中,是推迟到running是链接</p></li><li><p>因为进行推迟,所以装入速度很快,比起它链接方式都要快,的那是缺点就是理论上运行速度慢</p><p> 不过,这都不是事,在当下的计算机硬件水平下,堆配置就可以了(我游民老哥标配四路泰坦(ಡωಡ))</p></li></ol><blockquote><p>　动态链接重要的目的之一便是：　ABI(Application Binary Interface)应用程序二进制接口<br>　<br>　历史的经验表明: 软件版本的更新迭代,往往会出现严重的问题, 不兼容,各种各样的问题<br>　<br>　而且,每次进行新的库迭代,都要进行重新编译,(对于静态链接)<br>　<br>　这显然是他妈的操蛋,所以动态链接出现了,它要求操作系统提供一套二进制接口<br>　<br>　应用程序进行链接时,不去考虑器具体实现,只使用接口.<br>　<br>　是不是进行库版本的迭代,一下简单多了,我们甚至可以同时维护多个版本的库进行选择<br>　<br>　(PS: 是不是由了一点面向对象的感觉,ABI正是一种中间件,自然的处理了程序与库之间的关系)</p></blockquote><p>一般我们约定,库文件放在指定的位置,编译系统按照默认的规定去进行编译链接.但是,</p><p>我们还可以给编译器传参,(ಡωಡ) -I,-L,-l这些可不能白瞎了,还可以-Wl,-rpath=XXX 给链接器传参</p><p><em>此处,我们建议尽量只使用动态链接,因为这样,我们的版本更新十分方便,并且容错率高</em></p><p>说了这么多,静态链接库,动态链接库实体是什么样的呢?</p><p>静态链接库成为archive,使用ar生成 “XXX.a”</p><p>动态链接库,使用gcc或者ld生成(怀疑?),”libXXX.so.x.y.z”</p><h2 id="6-如何生成链接库"><a href="#6-如何生成链接库" class="headerlink" title="6. 如何生成链接库"></a>6. 如何生成链接库</h2><p><strong>首先,我们要严正声明,咸鱼书中的是基于SPARC上面的cc编译器</strong></p><p><strong>与我们日常在x86_64机器上使用的gcc/clang/msvc有很大不同,命令也是</strong></p><p><strong>我下面的操作是基于gcc x86_64机器进行的操作</strong></p><p>上面我们说过静态链接库,使用ar生成,喜爱面试我们的步骤:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">file: hello.c</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello. I'm a static link test\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: hello.h</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">file: main.c</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我们的测试文件,下面是具体的步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br><span class="line"></span><br><span class="line">ar -rcv -o libhello.a hello.o</span><br><span class="line"></span><br><span class="line">gcc main.c -L . -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment">#=&gt; </span></span><br><span class="line">[Crow@EvilCrow ~]$ ./a.out </span><br><span class="line">Hello. I<span class="string">'m a static link test</span></span><br></pre></td></tr></table></figure><p><img src="http://p8pmsq2a4.bkt.clouddn.com/static_link_ter.png" alt="静态链接"></p><p>其中需要注意的是:</p><ul><li><p>ar中的选项,-rcv ,显示,更新,创建新的archive,即是说,对于一个archive,我们可以进行包的增删改</p></li><li><p>gcc中 -L 指的是链接目录,对于静态,动态都适用</p></li><li><p>-l说明要链接的库名, 一般都是libXXX.so XXX就是要进行链接的名字</p></li></ul><p>下面是,动态链接库的创建,可以使用链接器ld,我们此处使用简单地gcc:</p><p>文件一致.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c hello.c</span><br><span class="line"></span><br><span class="line">gcc -shared -fPIC -o libhello.so hello.o</span><br><span class="line"></span><br><span class="line">gcc main.c -L . -Wl,-rpath=. -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment">#=&gt;</span></span><br><span class="line">[Crow@EvilCrow ~]$ ./a.out </span><br><span class="line">Hello. I<span class="string">'m a dynamic link test</span></span><br></pre></td></tr></table></figure><p><img src="http://p8pmsq2a4.bkt.clouddn.com/dynamic_link.png" alt="动态链接"></p><p>其中需要注意的是:</p><ul><li><p>外面说的共享库和动态库是一个东西Win下DLL(Dynamic Loading Libary)</p><p>Linux下 .so(Shared Object)</p></li><li><p>-fPIC(- file Position Independent Code) 表示与位置无关,很容易对数据进行重定位</p><p>我们的建议是: <strong>函数库应始终使用与位置无关的代码,共享库建议使用PIC</strong></p><p>为什么,因为共享库维护同一份拷贝,我们使用PIC,可以有效的减少换页.可以按需求任意位置装入</p><p>否则就成了静态共享库了(SVR3上一个奇葩玩意,不提)</p></li><li><p>-shared 这个选项一定要有啊,否则,是不能生成共享库的(动态库)</p></li><li><p>-L. 之后,,为什么还要有 -Wl,-rpath=. 动态库因为可以通过同时维护多个,而且运行时必须存在</p><p>所以,我们即需要指定链接目录,也需要运行目录,一般,/usr/lib64下,都是链接指向-&gt;</p><p>-Wl,rpath=XX, 纯属是gcc的命令问题,cc,只即使用-R(running dir),-Wl,…表示向链接器传参</p><p>如果我们不使用这个选项,也是可以的.将我们的共享库放在/usr/lib64, 或者/usr/local/lib64下</p><p>/usr /usr/local区别不用我说了, </p><p>另一种方法在ld.so.conf中添加我们共享库所在目录,然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig 即可(需要sudo)</span><br></pre></td></tr></table></figure></li></ul><p> 之后,动态链接,就不需要指定目录了,静态链接同理</p><p>我们下面列出一些常用库,及其链接方式</p><table><thead><tr><th>#include文件</th><th>库路径名</th><th>选项</th></tr></thead><tbody><tr><td>&lt; math.h &gt;</td><td>/usr/lib64/libm.so</td><td>-lm</td></tr><tr><td>&lt; math.h &gt;</td><td>/usr/lib64/libm.a</td><td>-lm</td></tr><tr><td>&lt; stdio.h &gt;</td><td>/usr/lib6/libc.so</td><td>自动链接</td></tr><tr><td>……</td><td>……</td><td>…..</td></tr></tbody></table><p>提取库中的符号: nm命令(我使用的不太多,大家可以去man一下)</p><h2 id="7-使用静态库提取符号更严格"><a href="#7-使用静态库提取符号更严格" class="headerlink" title="7. 使用静态库提取符号更严格"></a>7. 使用静态库提取符号更严格</h2><p>因为共享库,推迟到运行时链接(我们现在就不考虑装入时链接了)</p><p>所以,链接命令顺序无所谓,运行时统一去链接</p><p>但是,静态库就必须在直接完成链接,所以,一旦有符号为装入,GG</p><p>而且,静态库,<strong>链接时,不是将其装入,而是装入undeference symbol</strong></p><p><strong>也就是说,gcc -lhello main.c -L. ,会提示找不到hello</strong></p><p>因为先链接库, 而库中hello是已经定义了的符号,</p><p><strong>因此,我们强烈建议,-l选项放在最后,虽然这有违, UNIX命令使用顺序,选项放在最后</strong></p><p><strong>不过为了程序顺利运行,这都不是事</strong></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/static_error.png" alt="静态链接顺序"></p><h2 id="8-Interpositioning"><a href="#8-Interpositioning" class="headerlink" title="8. Interpositioning"></a>8. Interpositioning</h2><p>曾经,由很多人都干过,定义与C保留字名相同的函数</p><p>不过C标准是支持这样的行为的,与OOP中对于类成员函数的重写类似</p><p>但是,在C中,如果你重写了某一个函数</p><p><strong>注意,注意,所有使用该保留字函数,都会被你写的函数进行替换,很严重的问题! ! !</strong></p><p><strong>有解吗? 有, 使用static关键字,限制命名空间, 其实OOP也就是限制了命名空间</strong></p><h2 id="9-建议"><a href="#9-建议" class="headerlink" title="9. 建议"></a>9. 建议</h2><p>说了这么多,其实也不是说静态链接就一无是处</p><p>事实上,它没有湮灭在历史长河中,就说明了它的存在性</p><p><strong>比如说,需要给没有函数库的机器上执行,那不得需要静态编译来脱离函数库依赖么,</strong></p><p><strong>而且,以目前的计算机硬件水平,基本可以忽略内存多余拷贝</strong></p><p><strong>多说一句: 一般默认选择动态链接,找不到libXXX.so时去找libXXX.a</strong></p><p>最后,有一个疑问: 现如今,使用的到底是装入时动态链接, 还是运行时动态链接? 可以交流一下呗,</p><p>而且这两种模式,是否可以手动指定?</p><p>最后,此次的链接知识开个小头,等CSAPP中的精华内容吧,甚至C可以直接在程序设计层面调用共享库</p><p>May 25, 2018 2:18 PM</p><hr><p>Update: May 25, 2018 2:18 PM</p><p>更新, 今天在问了老王之后,得到两个概念:</p><ol><li><p>gcc也只是一个driver, 其内部自行调用ccl,cpp,as,ld之类的组件 即Binuntils</p></li><li><p><strong>可以确定的是链接是在运行时进行的,ld-linux-x86_64.so.2实际上可以单独运行</strong></p></li></ol><p><strong>也就是说,在链接完成后,可执行文件中填入了链接器,证明是运行时完成动态链接</strong></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/runtime_dynamic_link.png" alt="strings a.out | grep ld"></p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_数组与指针</title>
      <link href="/2018/05/29/C/Expert_C_Programming/array_pointer/"/>
      <url>/2018/05/29/C/Expert_C_Programming/array_pointer/</url>
      <content type="html"><![CDATA[<p><em>数组与指针, 真的是C中, 甚至于C++中也是让人头大的问题, 脑子疼</em></p><p><em>但是越难的东西就越要去干他一发,不是吗?</em></p><h2 id="一-声明与定义"><a href="#一-声明与定义" class="headerlink" title="一, 声明与定义"></a>一, 声明与定义</h2><p>声明与定义我们之前一直都在说,都是实际上这两个的区别还是很大的.</p><p>主要表现在以下方面:</p><p><strong>定义: 定义实际上是特殊的声明, 他告诉编译器有这个变量及其类型,并且为他分配空间</strong></p><p><strong>声明: 声明则是表明存在这个变量,它的定义在别处.比如extern,表示变量在别处</strong></p><p>我们常见的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> a[];      <span class="comment">// 这是合法的, 表明a数组定义在别处,所以不需要提供数组长度</span></span><br></pre></td></tr></table></figure><h2 id="二-左右值的问题"><a href="#二-左右值的问题" class="headerlink" title="二, 左右值的问题"></a>二, 左右值的问题</h2><p>这其实也是个历史遗留问题, 很多时候我们都说过左右值,但是从没有详细的谈过</p><p>记得最早扯到左右值, 其实是在&lt; C Primer Plus &gt; 中的”=”运算符中,其声明:</p><p>只有可修改的左值,可以放在赋值运算符的左侧,可修改的左值是C中新定义的概念</p><blockquote><p>左值: 指的是可以获取到地址的内容, 所以编译期一定要获取到期内容</p></blockquote><blockquote><p>右值: 只需要获取到它的值即可.只有运行时才能取得值.</p><p>所以全局变量在赋值时,要求是const experssion(常量表达式)</p><p>数组的维数也是这么要求的,不过在C99推出VLA后,这些都是过去式了.</p></blockquote><p><em>那么,C中可修改的左值到底是为了什么呢?</em></p><p><strong>它的存在是为了遏制数组名赋值的滥用,后面会提到,数组名会被编译器改为首元素的地址</strong></p><p><strong>bingo! 数组名也是左值(可以获取到其地址),但它并不是可修改的左值,可修改的左值就是为处理此情况</strong></p><h2 id="三-array与pointer的访问模式"><a href="#三-array与pointer的访问模式" class="headerlink" title="三, array与pointer的访问模式"></a>三, array与pointer的访问模式</h2><p>看下面的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"Linux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *a = <span class="string">"Linux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问模式</span></span><br><span class="line"><span class="keyword">char</span> temp = a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>上面的代码中,两种类型肯定不能同时存在!</p><p>这里,我们只是来说说编译器的思维模式,如何来进行访问:</p><p><strong>对于数组, 取得a的地址, 然后根据下标i以及数据类型,获取偏移量, 直接拿到即可</strong></p><p><strong>对于指针, 其实只有8个字节(64位), 那么,访问时,a[4] #=&gt; *(a+4), 先取出a中的内容</strong></p><p><strong>然后 a中的地址 + sizeof(类型) * 下标 =&gt; 地址, 取出内容</strong></p><p>所以说,指针访问多了一次dereference, 多访问了一次, 在现在来看是无法影响效率的.但是指针更加灵活.</p><h2 id="四-交叉访问会出现什么结果"><a href="#四-交叉访问会出现什么结果" class="headerlink" title="四,交叉访问会出现什么结果?"></a>四,交叉访问会出现什么结果?</h2><p><em>此处的交叉访问是我自己拟出来的一个概念, 主要是下面两种情况:</em></p><h3 id="1-定义为指针-声明为数组"><a href="#1-定义为指针-声明为数组" class="headerlink" title="1. 定义为指针, 声明为数组."></a>1. 定义为指针, 声明为数组.</h3><p>定义为指针,声明为数组,也是不少人干过的事, 会发生什么样的结果.我们先看看这张图:</p><p>上面这幅图就表明了,定义为指针,声明为数组:</p><p>**会导致,访问时, 将地址解释为数据,牛头不对马嘴, 此处将地址部分解释为ASC II 字符,显然是不正确的.</p><p><strong>严重情况下,修改地址, 这个指针的提领内容就永远也访问不到了</strong></p><h3 id="2-定义为数组-声明为指针"><a href="#2-定义为数组-声明为指针" class="headerlink" title="2. 定义为数组, 声明为指针"></a>2. 定义为数组, 声明为指针</h3><p>同上面,先来看看图:</p><p>上面这幅图就表明了,定义为数组,声明为指针:</p><p><strong>会导致, 访问时, 将数组内容解释为地址,然后去这个地址提领操作, 显然也是不正确的,</strong></p><h2 id="五-array与pointer到底何时相同-何时不同"><a href="#五-array与pointer到底何时相同-何时不同" class="headerlink" title="五, array与pointer到底何时相同,何时不同?"></a>五, array与pointer到底何时相同,何时不同?</h2><p>上面说了这么多,我们就直截了当的说清,到底什么时候数组与指针相同,什么时候指针不能等同数组!</p><p>总结如下:</p><p><strong>1. 数组总是可以写为指针的访问形式, 这是基于底层实现的基地址 + 偏移量的原因</strong></p><p><strong>2. 在进行函数传递参数的时候, 数组一律被转化为指针,这是为了效率考虑,而且大多数时候</strong></p><p><strong> 我们真的不需要完整的数组内容可可拷贝, 只是对其中一部分内容感兴趣</strong></p><p><strong>3. 另外一点,就是数组名表示数组首元素地址</strong></p><p>上面这些,就是数组与指针相同的时候,其他时候都是不同的.</p><p><strong>编译器看变量的时候, 一个变量就是地址, 一个指针就是地址的地址</strong></p><h2 id="六-实际上-为什么会发生混淆"><a href="#六-实际上-为什么会发生混淆" class="headerlink" title="六, 实际上,为什么会发生混淆?"></a>六, 实际上,为什么会发生混淆?</h2><p>这个锅,要甩在出版社身上了!</p><p>众所周知, &lt; the C Programming Language &gt; 中提到数组与指针</p><blockquote><p>As format parementers in function definition<br>(翻页)<br>char s[]<br>is same as<br>char *s;</p></blockquote><p>OK, 就是这么简单地一件事, 当然锅不能全甩在出版社身上了,开个玩笑而已.</p><h2 id="七-专门来说一说字符串指针与其他的指针"><a href="#七-专门来说一说字符串指针与其他的指针" class="headerlink" title="七, 专门来说一说字符串指针与其他的指针"></a>七, 专门来说一说字符串指针与其他的指针</h2><p>简单地说,字符指针是个骚东西.</p><p><strong>因为,它可以根据后面的NUL来标识终止.这样的话,就不需要额外的变量来控制边界访问</strong></p><p>比如: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>其中便是直接通过终止字符来标识, 不然一般二维指针,是需要两个变量标识的;</p><p>另外一点就是,使用字符指针,会自动分配空间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"linux"</span>;     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">f</span> = &#123;</span><span class="number">3.14</span>, ...&#125;; <span class="comment">// Error , 需要分配空间</span></span><br></pre></td></tr></table></figure><p>另外对于指针数组进行赋值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str[] = &#123;</span><br><span class="line">    &#123;<span class="string">"Linux"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Xiyou"</span>&#125;,</span><br><span class="line">&#125;;                     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *integer[] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;                    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>其他类型的指针数组赋值, 安心用数组名赋值好吧 (滑稽;</p><p>实际上所谓的字符串,只是一个字符指针,但是其他的类型,可都是需要分配空间的呀! ! !</p><h2 id="八-一段深刻的代码"><a href="#八-一段深刻的代码" class="headerlink" title="八, 一段深刻的代码"></a>八, 一段深刻的代码</h2><p>下面这段代码,可以帮助你搞清楚,数组与指针之间的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"NieR:Automata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_array</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p\n"</span>,&amp;<span class="built_in">array</span>, &amp;(<span class="built_in">array</span>[<span class="number">0</span>]), &amp;(<span class="built_in">array</span>[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p, %p\n"</span>,&amp;ptr, &amp;(ptr[<span class="number">0</span>]), &amp;(ptr[<span class="number">1</span>]), ++ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func_array(str);</span><br><span class="line">    func_pointer(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p\n"</span>,&amp;str[<span class="number">0</span>], &amp;(str[<span class="number">0</span>]), &amp;(str[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#=&gt; </span><br><span class="line"><span class="number">0x7ffdf69e1978</span>, <span class="number">0x400630</span>, <span class="number">0x400631</span></span><br><span class="line"><span class="number">0x7ffdf69e1978</span>, <span class="number">0x400631</span>, <span class="number">0x400632</span>, <span class="number">0x400631</span></span><br><span class="line"><span class="number">0x400630</span>, <span class="number">0x400630</span>, <span class="number">0x400631</span></span><br></pre></td></tr></table></figure><p>我们现在来解释输出结果:</p><p>首先,因为用的是指针,所以第1,2行第1列与后面不同, 后面的地址都是str在静态区的内容</p><p><strong>而前面就是实际上str指针的地址, 这就是提领的意义</strong></p><p>另外后面,的不同,是因为操作的非原子性, 可以让睡一会儿,或者上个锁处理.</p><p><strong>另外,整天说传值, 传址, 实际上哪有传地址,地址其实也是值,函数参数传递就是进行值传递!</strong></p><h2 id="九-多维指针与Iliffc向量-指针数组"><a href="#九-多维指针与Iliffc向量-指针数组" class="headerlink" title="九, 多维指针与Iliffc向量(指针数组)"></a>九, 多维指针与Iliffc向量(指针数组)</h2><p>之前很多人整天说<strong>二维数组与二维指针相同, 头给你打烂</strong></p><p>实际上,,二维指针与二维数组区别很大,另外加上一个Iliffc向量(便是数组指针)</p><p>具体情况是下面这样:</p><ul><li><p>二维数组: int a[4][5]  #=&gt; 20x4 个字节</p></li><li><p>指针数组: int *a[5] #=&gt; 5x8 个字节</p></li><li><p>二维指针: int **a #=&gt; 8个字节</p></li></ul><p>他们进行访问的方法也就不同了:</p><ul><li><p>二维数组直接在基地址上进行偏移量的求取即可.</p></li><li><p>指针数组在一次偏移量上找到对应指针,然后提领到其他内存位置, 在进行一次偏移量求取</p></li><li><p>所以,二维指针进行量此提领,然后去找偏移量找到数据.</p></li></ul><p>那么,在存取效率上,有什么问题?</p><p><strong>推荐使用数组指针, 因为数组指针可以保证字符串个数,但是对于每个字符串不限制长度</strong></p><p><strong>这样就可以大幅度减少系统中的内存开销,节省空间.</strong></p><p><strong>一般情况下,我们尽量能不使用字符串拷贝,就不拷贝,而是引用它的指针,因为拷贝的开销太大了</strong></p><p><strong>但是,从另一方面来说,锯齿状数组,即Iliffc向量,因为大小不同,会将数据存在不同的页面上</strong></p><p><strong>另一方面考虑来说, 不停的换页,会严重降低效率</strong></p><p>说到这里,其实让我想起来了当年小组面试,康康抛出来的一个问题:</p><p><em>如何动态分配二维数组 ?</em></p><p>今天我就再来说一说:</p><p>两种方法:</p><p>一.</p><p>1&gt; 循环两次分配,先分配一维数组的i个指针的空间, </p><p>2&gt; 然后分配二维数组中的j个指针空间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标分配char a[m][n]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **a = <span class="literal">NULL</span>;</span><br><span class="line">a = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    a[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br></pre></td></tr></table></figure><p>二,</p><p>另外一种办法,就是直接分配总大小的空间,然后再去分配一维数组指针,缺点是整个全部分配</p><p>优点是可以分配出连续的内存来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> **a = <span class="literal">NULL</span>;</span><br><span class="line">a = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * m);</span><br><span class="line">a[<span class="number">0</span>] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * m * n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    a[i] = a[<span class="number">0</span>] + n * i * <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br></pre></td></tr></table></figure><p>一次性分配,也只是指最后一步的时候,一次性分配,前面还是一样的</p><p>切记:<strong>多维数组的动态分配类似于递归的形式,一层一层分配进去, 一层一层释放出来,严格按照栈的顺序</strong></p><p>十, 数组转换为指针形式是非递归的</p><p>上面说过,数组是可以转换为指针的,切记,<strong>这是非递归的</strong></p><p><strong>意思便是: 二维数组,会变成指针数组,而非二维指针</strong></p><p>所以,我们可以说,<strong>main()的原型参数是指针数组,而并非函数指针,这样便可以减少空间开销(锯齿形数组</strong></p><hr><p>PS: </p><p>就说点其他的话吧, 最近真的是脑子疼,没一点劲</p><p>各种各样的恶心事,就不说了,康康刚才和我聊了一会儿</p><p>让我感受到了时间的紧迫性,</p><p>然而我整天都是在逃避,哈哈,可笑得很.整天作逼清高,就他妈一个王八蛋</p><p>玩锤子 !</p><p>好了,丧这些就够了,在丧下去就真的完了,已经菜到忘了多维数组的动态内存分配了,靠</p><p>菜菜菜,有什么办法呢?</p><p>干他妈一票大的!</p><p>明天, 不,今天开始吧.</p><p>C的内容到此为止,后面就是C++, 服务器, 内核(按重要性次序)</p><p>反正怎么说,咸鱼书后面的内容,燃我看得很害怕, 大公司面试的问题,是真的可怕,这还是20多年前的问题</p><p>真的是感受到恐惧,唉,以前就是个瓜皮,现在开始尽力弥补吧</p><p>有这样一句话:</p><blockquote><p>生命转瞬即逝, 没时间丧      - 单读</p></blockquote><p>所以,明天,不是今天开始,大干一场!</p><p>May 30, 2018 12:39 AM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
            <tag> Expert_C_Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_一些常见的技巧</title>
      <link href="/2018/05/28/C/Expert_C_Programming/c_technology/"/>
      <url>/2018/05/28/C/Expert_C_Programming/c_technology/</url>
      <content type="html"><![CDATA[<p><em>因为只是一些有选择的编程技巧, 我们同样使用小点来描述</em></p><h2 id="类型提升的问题"><a href="#类型提升的问题" class="headerlink" title="类型提升的问题"></a>类型提升的问题</h2><p> 这是C中至今仍然会出现的问题,就是类型提升的问题.</p><p> 起因是:优化编译器,统一类型,编译器只考虑堆栈区的变量数目,而不考虑其类型大小,</p><p> 但是,计算结束后,要回到原类型, <strong>也就是对于类型提升后的结果进行裁剪,恢复其原类型</strong></p><p> 在最早的编译器实现中,甚至只存在,int,double,指针三种类型(当然在今天看来已经是天方夜谭了)</p><p> 那么,类型提升的规则如下:</p><p> <strong>对于,小于int的类型: char, short, 位段, 枚举统一提升为int(在不损失精度时),否则为unsigned int</strong></p><p> <strong>对于float类型, 统一提升为double类型</strong></p><p> <strong>备注: 如果运算后结果一致, 也可以省略类型提升</strong></p><p> 看个简单地例子:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%zu\n"</span>,<span class="keyword">sizeof</span> <span class="string">'A'</span>); #=&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这就是类型提升的问题所在, ‘A’字符提升为int类型, 得到结果4(PS: 强制类型转换就可以发挥作用了)</p><h2 id="函数原型与函数声明"><a href="#函数原型与函数声明" class="headerlink" title="函数原型与函数声明"></a>函数原型与函数声明</h2><p> 函数声明是K&amp;R C中的概念, 函数原型是ANSI C中的概念, 这个概念是从C++中引进的.</p><p> <strong>我们之前一直强调, 函数原型的引入是为了编译器更房变得进行类型检查</strong></p><p> <strong>同时,它还有一个巨大的作用, 阻止类型检查, 会严格限定函数的参数接收值</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">char a, char b         </span><br><span class="line"><span class="comment">// 这里如果传入的参数是char, 实际上接受到会是int(类型提升),然后函数内部裁剪为char(函数原型)</span></span><br><span class="line">&#123;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span>         <span class="comment">// 此处严格接收char类型的参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>变量进行裁剪,一般情况下问题不大. 主要是溢出的处理, 但是一旦出现问题,就完蛋了</strong></p><h2 id="严格使用统一类型函数原型-声明"><a href="#严格使用统一类型函数原型-声明" class="headerlink" title="严格使用统一类型函数原型/声明"></a>严格使用统一类型函数原型/声明</h2><p> 既然存在函数原型/函数声明.那么,如何选择就成为一个问题了?</p><p> 要求是: <strong>严格使用函数声明, 或者函数原型,严禁混用</strong></p><p> 我们的建议是: <em>统一使用函数原型</em></p><p> 混合使用的时候, 会出现下面的问题:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原型 -&gt; 声明    </span><br><span class="line"></span><br><span class="line">#=结果=&gt; 期望接收类型提升后的类型,实际上接收到的是原类型, 传入<span class="keyword">short</span>,实际一次接收两个<span class="keyword">short</span></span><br><span class="line"></span><br><span class="line">声明 -&gt; 原型</span><br><span class="line"></span><br><span class="line">#=结果=&gt; 传参为类型提升后的值, 是接受到原类型, <span class="keyword">int</span> -&gt; <span class="keyword">short</span>, 丢失精度</span><br></pre></td></tr></table></figure><h2 id="单字符模式"><a href="#单字符模式" class="headerlink" title="单字符模式"></a>单字符模式</h2><p> 通常情况下,我们都是通过回车来获取一个字符这里提供两种方法</p><p> 1.使用stty系统调用</p><p>  是我想起来了,当时暑假聊天室的字符不回显</p><p> 2.使用一些系统编程函数(System Call)–ioctl</p><p> 具体用法可以下来查阅,不细说,以后啃蕨菜的时候,会详尽解释(Linux/UNIX系统编程手册)</p><h2 id="关于强制类型转换的一些事"><a href="#关于强制类型转换的一些事" class="headerlink" title="关于强制类型转换的一些事"></a>关于强制类型转换的一些事</h2><p> 强制类型转换实际上有什么用呢? 实际上有这样两个作用:</p><p> 1&gt; 类型转换 ,完成特定类型的需求</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="string">'A'</span></span><br></pre></td></tr></table></figure><p> 2&gt; 消除类型歧义, 防止不必要的类型提升</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">char</span>)<span class="string">'A'</span>   <span class="comment">// 上面sizeof例子的正确改法</span></span><br></pre></td></tr></table></figure><p> 另外,我们再建议一种进行类型转换的方法:</p><p> <strong>要转换,你肯定是要获取类型的,对吧.所以如何获取函数类型就是个问题</strong></p><p> 去掉标识符,改为* =&gt; 去掉形式参数名 =&gt; 整体加上()</p><p> 即可获取到一个函数的类型转换运算符</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr = func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'A'</span>;</span><br><span class="line">(<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">char</span> *))ptr(<span class="number">3</span>, &amp;ch);        <span class="comment">// 正确的调用方法</span></span><br></pre></td></tr></table></figure><p>上面的便是本次的内容,其中有许多内容是现在可以摒弃掉的(好吧,有的也看的我云里雾里)</p><p>如有问题,可以在评论区进行讨论沟通</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
            <tag> Expert_C_Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binutils の size</title>
      <link href="/2018/05/27/tools/size/"/>
      <url>/2018/05/27/tools/size/</url>
      <content type="html"><![CDATA[<p><em>既然说到size命令,这是一个Linux下,用于查看可执行文件各段size的工具</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">SIZE(1)                          GNU Development Tools                          SIZE(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       size - list section sizes and total size.</span><br><span class="line">    <span class="comment">#size - 列出各section的大小以及总大小</span></span><br><span class="line"></span><br><span class="line">SYNOPSIS        <span class="comment"># 简介 [sɪˈnɒpsɪs]</span></span><br><span class="line">       size [-A|-B|--format=compatibility]</span><br><span class="line">            [--<span class="built_in">help</span>]</span><br><span class="line">            [-d|-o|-x|--radix=number]</span><br><span class="line">            [--common]</span><br><span class="line">            [-t|--totals]</span><br><span class="line">            [--target=bfdname] [-V|--version]</span><br><span class="line">            [objfile...]</span><br><span class="line"></span><br><span class="line">DESCRIPTION           <span class="comment">#命令描述</span></span><br><span class="line">       The GNU size utility lists the section sizes---and the total size---<span class="keyword">for</span> each of</span><br><span class="line">       the object or archive files objfile <span class="keyword">in</span> its argument list.  By default, one line</span><br><span class="line">       of output is generated <span class="keyword">for</span> each object file or each module <span class="keyword">in</span> an archive.</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># GNU size效用是列出section的大小 --- 和总大小---对于每个目标文件 或 静态链接库参数列表       </span></span><br><span class="line"><span class="comment"># 中目标文件. 默认情况下, 每一行的输出被各个目标文件所隔离开,或是静态链接库中的模块</span></span><br><span class="line"></span><br><span class="line">       objfile... are the object files to be examined.  If none are specified, the file</span><br><span class="line">       <span class="string">"a.out"</span> will be used.</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 参数[object...]是要被检测的目标文件(可执行文件). 如果没有被指定, 会使用"a.out"文件</span></span><br><span class="line"></span><br><span class="line">OPTIONS    <span class="comment">#参数: 选项</span></span><br><span class="line">       The <span class="built_in">command</span> line options have the following meanings:</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 命令行选项有以下的含义:</span></span><br><span class="line"></span><br><span class="line">       -A</span><br><span class="line">       -B</span><br><span class="line">       --format=compatibility <span class="comment"># 兼容性 [kəmˌpætəˈbɪləti]</span></span><br><span class="line">           Using one of these options, you can choose whether the output from GNU size</span><br><span class="line">           resembles  <span class="comment"># 与..想像  [rɪˈzembl] </span></span><br><span class="line">   output from System V size (using -A, or --format=sysv), or</span><br><span class="line">           Berkeley size (using -B, or --format=berkeley).  The default is the one-line</span><br><span class="line">           format similar to Berkeley<span class="string">'s.</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string"># 使用这些其中之一的选项, 你可以选择GNU输出是使用UNIX 第五版(使用选项 -A, 或者选项   </span></span><br><span class="line"><span class="string"># --format=sysv), 或者伯克利(即BSD系列)(使用选项-B, 或者选项 --format=berkeley).  # 默认是一行输出的格式与伯克利模式相似 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           Here is an example of the Berkeley (default) format of output from size:</span></span><br><span class="line"><span class="string"># 这里是伯克利格式的输出示例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   $ size --format=Berkeley ranlib size</span></span><br><span class="line"><span class="string">                   text    data    bss     dec     hex     filename</span></span><br><span class="line"><span class="string">                   294880  81920   11592   388392  5ed28   ranlib</span></span><br><span class="line"><span class="string">                   294880  81920   11888   388688  5ee50   size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           This is the same data, but displayed closer to System V conventions:</span></span><br><span class="line"><span class="string"># 这是相同的数据, 但是显示方式更接近于System V 转换:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   $ size --format=SysV ranlib size</span></span><br><span class="line"><span class="string">                   ranlib  :</span></span><br><span class="line"><span class="string">                   section         size         addr</span></span><br><span class="line"><span class="string">                   .text         294880         8192</span></span><br><span class="line"><span class="string">                   .data          81920       303104</span></span><br><span class="line"><span class="string">                   .bss           11592       385024</span></span><br><span class="line"><span class="string">                   Total         388392</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   size  :</span></span><br><span class="line"><span class="string">                   section         size         addr</span></span><br><span class="line"><span class="string">                   .text         294880         8192</span></span><br><span class="line"><span class="string">                   .data          81920       303104</span></span><br><span class="line"><span class="string">                   .bss           11888       385024</span></span><br><span class="line"><span class="string">                   Total         388688</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       --help</span></span><br><span class="line"><span class="string">           Show a summary of acceptable arguments and options.</span></span><br><span class="line"><span class="string"># 显示可接受的参数和选项摘要     summary  [ˈsʌməri] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       -d</span></span><br><span class="line"><span class="string">       -o</span></span><br><span class="line"><span class="string">       -x</span></span><br><span class="line"><span class="string">       --radix=number</span></span><br><span class="line"><span class="string">           Using one of these options, you can control whether the size of each section</span></span><br><span class="line"><span class="string">           is given in decimal (-d, or --radix=10); octal (-o, or --radix=8); or</span></span><br><span class="line"><span class="string">           hexadecimal (-x, or --radix=16).  In --radix=number, only the three values</span></span><br><span class="line"><span class="string">           (8, 10, 16) are supported.  The total size is always given in two radices;</span></span><br><span class="line"><span class="string">           decimal and hexadecimal for -d or -x output, or octal and hexadecimal if</span></span><br><span class="line"><span class="string">           you'</span>re using -o.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 使用下面这些选项, 你可以控制每一个section的大小是以十进制, 八进制, 或者十六进制给</span></span><br><span class="line"><span class="comment"># 出 . 在 --radix=number选项中, 只支持(8, 10, 16)进制三种取值. 总大小总是以两种形</span></span><br><span class="line"><span class="comment"># 式给出 十进制和十六进制 使用 -d 或 -x 输出. 或者八进制和十六进制如果你使用-o选项</span></span><br><span class="line"></span><br><span class="line">       --common</span><br><span class="line">           Print total size of common symbols <span class="keyword">in</span> each file.  When using Berkeley format</span><br><span class="line">           these are included <span class="keyword">in</span> the bss size.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 打引出每个文件中的一般符号, 当使用伯克利格式时(-B选项), 这些是包含在bss的大小中的</span></span><br><span class="line"></span><br><span class="line">       -t</span><br><span class="line">       --totals</span><br><span class="line">           Show totals of all objects listed (Berkeley format listing mode only).</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 显示所有被列出的目标文件的总计 (仅限伯克利格式的模式选择)</span></span><br><span class="line"></span><br><span class="line">       --target=bfdname</span><br><span class="line">           Specify that the object-code format <span class="keyword">for</span> objfile is bfdname.  This option may</span><br><span class="line">           not be necessary; size can automatically recognize many formats.</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify 指定 [ˈspesɪfaɪ], 指定目标文件代码是使用bfdname的格式. 此选项不是必需的;   </span></span><br><span class="line"><span class="comment"># size可以自动分辨许多格式</span></span><br><span class="line">       -V</span><br><span class="line">       --version</span><br><span class="line">           Display the version number of size.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 显示size命令的版本号</span></span><br><span class="line">       @file</span><br><span class="line">           Read <span class="built_in">command</span>-line options from file.  The options <span class="built_in">read</span> are inserted <span class="keyword">in</span> place</span><br><span class="line">           of the original @file option.  If file does not exist, or cannot be <span class="built_in">read</span>,</span><br><span class="line">           <span class="keyword">then</span> the option will be treated literally, and not removed.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 从文件阅读命令行选项. 选项阅读是被嵌入在 @file选项的起源之处的. 如果此文件不存在.   </span></span><br><span class="line"><span class="comment"># 或者不能被读取, 那么选项将被按照字面意思解释, 不会被移除.                         </span></span><br><span class="line"><span class="comment"># literally [ˈlɪtərəli] 逐字地</span></span><br><span class="line">   </span><br><span class="line">           Options <span class="keyword">in</span> file are separated by whitespace.  A whitespace character may be</span><br><span class="line">           included <span class="keyword">in</span> an option by surrounding the entire option <span class="keyword">in</span> either single or</span><br><span class="line">           double quotes.  Any character (including a backslash) may be included by</span><br><span class="line">           prefixing the character to be included with a backslash.  The file may</span><br><span class="line">           itself contain additional @file options; any such options will be processed</span><br><span class="line">           recursively.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 选项在文件中空白分开, (意译: 选项使用时被空格分开). 一个空白字符可以被包含在一个选项中,</span></span><br><span class="line"><span class="comment"># 依靠整个选项周围是单个或双引用(意译: 使用引用时, 可以将空白字符包含在选项中). </span></span><br><span class="line"><span class="comment"># 任何字符(包括反斜线 \ ) 都可能被包含,靠字符的前缀靠使用反斜线. </span></span><br><span class="line"><span class="comment"># 这个文件其自身包含@file选项; 任何这样的选项将会被递归调用</span></span><br><span class="line"><span class="comment"># prefix 前缀的 [ˈpri:fɪks]</span></span><br><span class="line"><span class="comment"># recursive 回归的, 递归的,[rɪˈkɜ:sɪv] </span></span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">       ar(1), objdump(1), readelf(1), and the Info entries <span class="keyword">for</span> binutils.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 推荐查阅, ar, objdump, readelf 同时info binutils(GNU二进制工具集)的细节</span></span><br><span class="line"></span><br><span class="line">COPYRIGHT</span><br><span class="line">       Copyright (c) 1991-2017 Free Software Foundation, Inc.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 1991- 2017 自由软件基金会</span></span><br><span class="line"></span><br><span class="line">       Permission is granted to copy, distribute and/or modify this document under the</span><br><span class="line">       terms of the GNU Free Documentation License, Version 1.3 or any later version</span><br><span class="line">       published by the Free Software Foundation; with no Invariant Sections, with no</span><br><span class="line">       Front-Cover Texts, and with no Back-Cover Texts.  A copy of the license is</span><br><span class="line">       included <span class="keyword">in</span> the section entitled <span class="string">"GNU Free Documentation License"</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这些, 有兴趣,去了解GNU执照, 不多说了</span></span><br><span class="line">binutils-2.29                          2017-07-24   <span class="comment"># size亦属于GNU二进制工具包                              SIZE(1)</span></span><br></pre></td></tr></table></figure><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_A.png" alt="-A Option"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_B.png" alt="-B Option"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_d_x_h.png" alt="--format"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_t.png" alt="-t Option"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_V.png" alt="-V Option"></p><p><em>如有疑问, 或者有任何新发现, 可以随时交流, 此系列不是近仅作翻译, 有值得关注的点会谈谈其他的</em></p><p><em>size直接看man文档已经很足够了, 我们下次再见(ಡωಡ)</em></p>]]></content>
      
      <categories>
          
          <category> Binutils </category>
          
          <category> man </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_C声明问题</title>
      <link href="/2018/05/23/C/Expert_C_Programming/c_statement/"/>
      <url>/2018/05/23/C/Expert_C_Programming/c_statement/</url>
      <content type="html"><![CDATA[<p><em>既然是要撕C语言的声明,那么我们就直接一点吧</em></p><p>但是,开始之前先说说其他的:闲聊</p><h3 id="如果有人说-函数参数从右向左压入堆栈-那你就去把他头打烂"><a href="#如果有人说-函数参数从右向左压入堆栈-那你就去把他头打烂" class="headerlink" title="如果有人说,函数参数从右向左压入堆栈,那你就去把他头打烂"></a>如果有人说,函数参数从右向左压入堆栈,那你就去把他头打烂</h3><p> 参数传递进入函数时,不是一定都在堆栈区的,int型这类数据,是可以进入resigter的,</p><p> 而形如结构这样的,是进入堆栈区的,所以说参数传递首先进入寄存器,不是无脑进入堆栈区的</p><h3 id="聊一聊联合的那点事-union"><a href="#聊一聊联合的那点事-union" class="headerlink" title="聊一聊联合的那点事(union)"></a>聊一聊联合的那点事(union)</h3><p> 联合一般是用在结构体内部,用来进行节省空间的,因为Union中的数据是不可能同时出现的</p><p> 也就是说,union中的数据都是互斥的.联合可以将一个东西解释为两种含义,比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> test &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_edian</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> test temp;</span><br><span class="line">temp.b = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, temp.a); <span class="comment">// 12 Big-endian, 78 little-endian</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于枚举-enum"><a href="#关于枚举-enum" class="headerlink" title="关于枚举(enum)"></a>关于枚举(enum)</h3><p>枚举,其实平时用的是比较少的,但是enum还是有它的好处,#define经常与他混用</p><p>Linux Kernel 2.6X时,伙伴算法中的flags标志位使用#define, 整整15个</p><p>Linux Kernel 3.x后,全部修改为枚举变量,无中生有吗?</p><p>并不是,是因为枚举相对于#define有这样一个巨大的好处:</p><p>#define在预编译阶段结束之后,便丢弃.而枚举依然能够保存在符号表中,之后方便调试</p><p>也即是说,#define就在符号表中找不到了,这样就简单了</p><p>C声明的那点事</p><p>下面进入我们的正题,如何来看C语言的声明优先级</p><p>首先看看这张图:</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/C_statement.png" alt="如何解析C语言声明"> </p><p>神图!,我来给大家解释一下.</p><ol><li><p>从标识符看起</p></li><li><p>首先向右看,如果是方括号,则为数组.如果是括号,就是函数,再去看参数(方括与括号不可能同级出现)</p></li><li><p>之后向左看,如果是一个左括号,则此部分声明已经被组合到一起,去找此括号,对应的右括号</p></li><li><p>之后回到第2步,继续</p></li><li><p>再次到第3步,如果是const, volatile *之一,就重复继续看是否有左括号</p></li><li><p>直到最后,遇到基本类型可以一次读完.</p></li></ol><p>光说不练假把式,来分析三个实例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> *(*next)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *(* c[<span class="number">10</span>])(<span class="keyword">int</span> **p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> sig, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>第一个实例:<br>-&gt; 标识符为next -&gt; 右看没有 -&gt; 左看是”*” -&gt; 得到: next时一个指针,指向XXX</p><p>-&gt; 左看是左括号,找到匹配右括号,之后向右看,括号,即为函数,所以next是一个函数指针</p><p>-&gt; 左看,*, 指向…的指针 -&gt; 继续, 只读属性 -&gt; 继续, 指向…的指针 -&gt; 继续, char类型,结束</p><p>#=&gt; 得到结果: next是一个函数指针, 他指向一个参数为void, 返回值是指向只读字符串的指针</p><p>第二个实例:</p><p>-&gt; 标识符为c</p><p>-&gt; 右看,[],c是一个数组</p><p>-&gt; 右括号,向左看, *,则数组元素为指针,c[10]里面存了, 10个 指向XXX的指针</p><p>-&gt; 出来,向右看,括号,函数,参数就那样,结束</p><p>-&gt; 向左看, char * 为返回值</p><p>#=&gt; 得到结果: c是一个数组,里面放了10个指针,10个指针指向了函数,char (*)(int **)类型 c即为函数指针数组</p><p>第三个实例:</p><p>-&gt; 标识符为signal,右看( ),即为函数</p><p>-&gt; 函数参数为(…int及函数指针)</p><p>-&gt; 右括号, 则向左看, *,为signal函数的返回值,是一个指针</p><p>-&gt; 指针指向void (*)(int)</p><p>这个就比较复杂,但是我们可以这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfn)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signal #=&gt; pfn signal(<span class="keyword">int</span>, pfn);</span><br></pre></td></tr></table></figure><p> 从这里我们就可以看出,我们使用typedef可以将函数指针类型左为返回值剥离出来</p><p> C这种类似于递归理解的声明语法确是看的人眼花缭乱,一切还是因为他晦涩的语法的原因</p><h3 id="typedef的前身后事"><a href="#typedef的前身后事" class="headerlink" title="typedef的前身后事"></a>typedef的前身后事</h3><p>既然这样,我们就再来说说typedef: typedef原名存储类型说明符</p><p>他常用的地方在于: 对已存在数据类型进行重新命名(别名), 方便大型程序的开发</p><p>用法: 像平常的变量声明一般,加上typedef即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pd)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>即可完成,当然了,需要加上分号( ; )</p><p>同一个代码块中,typedef不能引入和其他标识符重名的名字</p><p>typedef有两个重要的问题:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">typedef</span> <span class="keyword">int</span> *ptr, (*fun)(), arr[<span class="number">5</span>];  <span class="comment">//分别为int指针, int(*)()函数指针, size=5的int数组</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">unsigned</span> <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">volatile</span> *kumquat; <span class="comment">// 不要在中间使用&lt;/span&gt;</span></span><br></pre></td></tr></table></figure><p>至于typedef与#define的区别:</p><p>1.mtypedef是彻底的”封装”, 可以使用#define进行类型扩展, typedef无效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * cstring;</span><br><span class="line">define <span class="keyword">char</span> * CSTRING</span><br><span class="line"><span class="keyword">const</span> cstring str;   <span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> CSTRING STR;   <span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>2.连续几个变量声明,typedef可保证变量类型一致性,#define无法保证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define INT_PTR <span class="keyword">int</span> *</span><br><span class="line">INT_PTR a, b;    #=&gt; a = <span class="keyword">int</span> *, b = <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">typedef</span> int_ptr <span class="keyword">int</span> *;</span><br><span class="line">int_ptr c, d;       #=&gt; a = <span class="keyword">int</span> *, b = <span class="keyword">int</span> *</span><br></pre></td></tr></table></figure><p>C声明是个恶心的东西,到了C++也不一定能够完全跳脱, 但是多理解,配上typedef,可以事半功倍</p><hr><p>update: </p><p>另外我要喷一下垃圾js,劳资这篇文档就是因为它的评论系统搞死了,</p><p>让我从git commit中把HTML改回来,累死我了,靠!</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
            <tag> Expert_C_Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_C中的一些小细节</title>
      <link href="/2018/05/23/C/Expert_C_Programming/little_thing_of_C/"/>
      <url>/2018/05/23/C/Expert_C_Programming/little_thing_of_C/</url>
      <content type="html"><![CDATA[<p><em>正如概述所言,第二章没啥意思,所以我决定改名,挑出其中核心的部分,没错就是这样,就有了C中的小细节</em></p><p>为了方便表述,下面的内容我用点来表示:</p><ol><li><p>fall-through    的特性,这个是switch-case语句设计的问题,注意切换case时,很少有”没有break”</p><p>关于break,我们常见的一个错误就是,break到底跳出了什么?</p><p>答: 实际上跳出的是,最近的一层循环或者switch-case语句</p></li><li><p>core dump的错误,实际上就是段错误,也就是在支持虚拟内存的机器上,如果访问到非法内存,缺页中</p><p>断后,不能正确的页面置换,就发生了这样的错误,而不支持虚拟内存的机器,就没法这样,如MS-Dos</p><p>不过,MS-Dos有它的一套进行非法内存访问的判断措施</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/core_dump.png" alt="core dump"></p></li><li><p>缺省可见性,语言实现起来十分复杂,况且C/C++还支持分离式编译,所以文件内容的可见性十分重要</p><p>而在C中,只能这样: 所有缺省的可见性是extern, 而且只有extern,static两种可见性要么可见,</p><p>要么不可见.所以在C++中才提供了其他的一些可见性限定符.</p></li><li><p>一般情况下,,彻底使用fgets()替代gets()</p></li><li><p>C中表达式求值是未定义行为,求值顺序不定. 是为了可以让编译器选择最适合的求值顺序,提高效率</p></li><li><p>关于返回局部变量的问题</p></li></ol><p>来看一段代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">local_time</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_clock</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    stat(filename, &amp;stat_clock);</span><br><span class="line"></span><br><span class="line">    tm_ptr = localtime(&amp;stat_clock.st_time);</span><br><span class="line"></span><br><span class="line">    strftime(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有什么问题吗?</p><p><strong>对,没错.返回局部变量会造成大问题,已经释放的变量,返回野指针,进行操作和访问就会出错</strong></p><p>我们提供下面这些可考虑的解决方式:</p><ol><li><p>返回指向字符串的指针.</p><p> <strong>强调一下,一定是指向字符串常量,一般的字符串也没啥大变化</strong></p></li><li><p>使用全局变量数组 (不多说了)</p></li><li><p>使用静态数组</p><p> 函数结束也不会轻易释放,可以返回此指针</p></li><li><p>显式分配内存,保存返回值,即分配得到的内存首地址</p></li><li><p>手动控控制分配和释放, malloc, free建议在一个块中操作,是最简单的内存管理策略</p></li></ol><p>小细节就这么多,下一章将讨论一下,如何看C的声明 (滑稽</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
            <tag> Expert_C_Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&lt;咸鱼书&gt;_C的本源</title>
      <link href="/2018/05/17/C/Expert_C_Programming/C_origin/"/>
      <url>/2018/05/17/C/Expert_C_Programming/C_origin/</url>
      <content type="html"><![CDATA[<p><em>C++打击有点大, 再翻回C看两眼, 当然只是闲着看, C++还是正事</em></p><p><strong>经常有人说UNIX/Linux的发展历史, C也只是这个时期的一个附属产物, 但是我们今天就来看看C的起源</strong></p><h2 id="1-C的起源"><a href="#1-C的起源" class="headerlink" title="1. C的起源"></a>1. C的起源</h2><p><img src="http://p8uroi1uf.bkt.clouddn.com/C_develop.png" alt=""></p><p>首先,在这里致敬C,UNIX伟大的发明者Dennis Ritchie 及 Kenneth Thompson</p><p>两位计算机先驱提出了KISS的原则(Keep it simple stupid)</p><p>我们在这里也用简洁的语言来组织C的发展历史:</p><p>1&gt; C的发展与UNIX息息相关,同期发明,相互依赖</p><p>2&gt; 一切的开始是因为Mutics操作系统</p><p>3&gt; Mutics失败后, Kenneth想要写一个个人的操作系统, 为了玩游戏,在PDP-7上</p><p>4&gt; Ritchie入伙后, 他们为PDP-7编写了可以使用的操作系统UNIX,基于PDP-7 汇编</p><p>5&gt; 因为PDP-7 只有8KB内存, Kenneth初始版本是基于解释器的,效率一般</p><p>6&gt; 之后Kenneth又写了PDP-11版的UNIX</p><p>7&gt; 创造UNIX时, 基于KISS的原则, 所有的软件都由小而简单的组件组成, 吸取了Mutics的教训</p><p>8&gt; Ritchie因为解释器效率低, 实现了从BCPL而来的B得进化版,”New B” 基于编译系统, 提高效率</p><p>9&gt; 很快, “New B”变成为了, 早期版本的C</p><p>C的基础历史就这样,但是他在发展过程中经历了许许多多的问题与困难</p><p>同时C引入了类型的概念, 不过是为了支持PDP-11的特性: 支持不同类型字长的数据</p><h2 id="2-早期C体验"><a href="#2-早期C体验" class="headerlink" title="2. 早期C体验"></a>2. 早期C体验</h2><blockquote><p>C诡异离奇, 缺陷重重, 确取得了巨大成功   –Dennis Ritchie</p></blockquote><p>早期C的体验并不是很好, 它更多的是作为面向编译器设计者的语言, 操作系统设计的语言.</p><p>即系统编程语言, 即使到了今天, C在系统编程方面的地位也不是能够轻易被撼动的 !</p><p>为了支持系统编程, C支持了一下特性:</p><ol><li><p>数组下标从0开始, 为了支持偏移量的概念</p></li><li><p>C语言的基本数据类型与底层硬件对应, 不像Pascal, C11开始才支持复数类型, 浮点数类型也是硬</p><p> 件支持后,才加入支持的</p></li><li><p>auto关键字是摆设, 与静态区, 动态堆区想对应, 栈区的内存是对象缺省内存分配模式, </p></li><li><p>表达式数组名可以看作指针, 方便了系统编程者, 然而这个坑点, 这么多年死了多少人 !</p></li><li><p>float自动扩展为double, 这个没啥意思, 当年扩展, 现在不扩展, 不过从C++的经验来看, </p><p> 一般建议直接写double, 两个开销差不了少, 而且double的精度也比较大</p></li><li><p>register关键字, 摆设, 编译器就不鸟你</p></li></ol><p>&lt; C专家编程 &gt;是本好书，　不过要有自己的观点和看法，上面是基于我自己的看法.</p><h2 id="3-标准I-O库与函数库"><a href="#3-标准I-O库与函数库" class="headerlink" title="3. 标准I/O库与函数库"></a>3. 标准I/O库与函数库</h2><p>C语言本身不提供文件I/O, 都是基于标准函数库的</p><p>此处略过</p><p>但是, 切记 <strong>千万不要使用C预处理器,来修改程序已有结构</strong></p><h2 id="4-K-amp-R-C"><a href="#4-K-amp-R-C" class="headerlink" title="4. K&amp;R C"></a>4. K&amp;R C</h2><p>&lt; the C Programming Language &gt; 在计算机历史上留下了浓墨重彩的一笔,</p><p>不过K&amp;R C 指的是布莱恩.柯尼汉 + 丹尼斯.里奇 (而非是肯.汤普逊)</p><p>K&amp;R C的代码风格以及思想很重要, 可以拜读以下大作,</p><p>但是, K&amp;R C中有许多已经被修改掉的特性, 这些特性是时代的眼泪, 被删除也无可厚非</p><p><strong>所以, 无论怎么说, 我们如果要研究学习,便是ANSI C (C89)</strong></p><h2 id="5-ANSI-C"><a href="#5-ANSI-C" class="headerlink" title="5. ANSI C"></a>5. ANSI C</h2><p><strong>任何一门语言, 在发展过程中都会衍生出许多的变体, 如果不加控制, 就会使得这门语言松散</strong></p><p>e.g.: Lisp, Basic就是这样凉凉的</p><p>所以, ANSI C 作为标准C就出现了</p><p>ANSI C标准对于K&amp;R C做了一定程度上的修改, 在进行语言修改, 细节修订的同时, 保持语言特性及思想</p><p>不发生重大变化,维护了K&amp;R C的核心思想,ANSI C 也即C89</p><p>而所谓的C90是ISO C</p><p>垃圾!</p><blockquote><p>不要添乱—–立即解散ISO工作小组          – 匿名人士</p></blockquote><h2 id="6-K-amp-R-C与ANSI-C的区别"><a href="#6-K-amp-R-C与ANSI-C的区别" class="headerlink" title="6. K&amp;R C与ANSI C的区别"></a>6. K&amp;R C与ANSI C的区别</h2><p>既然K&amp;R C和ANSI C是的两个重要版本, 那么就说说这两个版本的区别吧, 主要体现在下面四个方面上:</p><ol><li><p>本质上改变, 就只有原型一个特性</p></li><li><p>新的关键字 , 区别不大, 只是添加了一定类型的支持</p></li><li><p>“Silent Change” 保持原有语言特性不变, 只改变其中一些小细节的实现,</p></li><li><p>其他区别, 这些基本上是一般编程者触碰不到的</p></li></ol><p>那么, 我们就来说说上面三个重大区别</p><h3 id="6-1-函数原型"><a href="#6-1-函数原型" class="headerlink" title="6.1 函数原型"></a>6.1 函数原型</h3><p>函数原型, 在ANSI C之前是没有的, 之前的都叫作, 函数声明, 这个特性是从C++学习过来的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">()</span></span>;           <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;       <span class="comment">// 函数原型</span></span><br></pre></td></tr></table></figure><p>这是一个重大变化, 主要是用于<strong>前置声明</strong></p><p>K&amp;R C时,对于函数参数的检查,<strong>一直推迟到链接时</strong></p><p>而ANSI C使用函数原型, 将<strong>参数检查提前到编译时期</strong></p><p>同时,进行函数定义时,是这样的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">()</span></span></span><br><span class="line">char *dest, const char *src;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dext, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外,我们说<strong>函数原型的引入主要是针对前置声明</strong></p><p><strong>但是, C11之后,C语言风格也发生转变, 与时俱进, 逐渐向C++/Java等面向对象靠拢</strong></p><p><strong>事实上, 不刻意强调, 写前置声明的机会已经很少了, Linux4.x版本后的实现可见一斑</strong></p><h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6.2 关键字"></a>6.2 关键字</h3><p>关键字其实就那么一回事, const, volatile, signed, void其中常用到的也不多</p><p>C11后还加入了 _Generic, _Bool(真正意义上实现内置类型Boolen)</p><p><strong>但是,说实话,意义不大(摊手), 一般写个C99就歇菜了</strong></p><h3 id="6-3-Silent-Change"><a href="#6-3-Silent-Change" class="headerlink" title="6.3 Silent Change"></a>6.3 Silent Change</h3><p>这一处的改变说大不大, 说小不小.不过还是很有意思的</p><h4 id="6-3-1-类型转换"><a href="#6-3-1-类型转换" class="headerlink" title="6.3.1 类型转换"></a>6.3.1 类型转换</h4><p>举个例子:</p><p><strong>关于类型转换的问题, 众所周知, C是强类型,可以进行自动/强制类型转换</strong></p><p>然而, 进行数值运算时, 会进行类型转换, 这里ANSI C与K&amp;R C的区别就体现出来了</p><p><strong>对于&lt;=int类型的, K&amp;R C转换为无符号类型, ANSI转换为有符号类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> &lt; i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ANSI C\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"K&amp;R C\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,出现了复杂类型的时候, 比如,int和unsigned int 肯定是符合下述规则的:</p><p>执行算术运算时, 如果类型不同, 就会发生转换, 数据类型一般朝着浮点精度更高, 长度更长的方向转换</p><p>整型数如果转换为signed不会丢失信息, 就转换为signed, 不然就转换为unsigned</p><p><strong>对于, 无符号数和有符号数混用</strong></p><p><strong>需要十分注意: 切记不能混用,要不直接不定义无符号,要不全部使用强制类型转换, 否则翻车!</strong></p><p>比如下面常见的程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">34</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt; (<span class="keyword">int</span>)j)               <span class="comment">// 否则,等着翻车吧!</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;\n"</span>);</span><br></pre></td></tr></table></figure><h4 id="6-3-2-相容性"><a href="#6-3-2-相容性" class="headerlink" title="6.3.2 相容性"></a>6.3.2 相容性</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'r'</span>;</span><br><span class="line"></span><br><span class="line">str = &amp;c;</span><br><span class="line">*str = <span class="string">'a'</span>;    <span class="comment">// error</span></span><br><span class="line">c = <span class="string">'a'</span>;       <span class="comment">// correct</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test(argv);        <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的测试函数, 就是典型的相容性问题</p><p>对于,str形式参数以及argv实际参数, 他们之间的关系还是类似于赋值的</p><p>str与argv是可以传参的, 他们都是char ** ,相容</p><p>他们指向的, *str, *argv也是相容的, </p><p>但是 **str, **argv(是const的对象) 不相容, </p><p>也即是说,*str与*argv本身相容, 但是指向对象不相容,</p><p>因此传参操作出现错误.</p><p><strong>相容性不能传递</strong></p><p><strong>注: 此处的对象,指的是操作的数据,具名内存,并非OOP中的对象</strong></p><h2 id="7-pragma"><a href="#7-pragma" class="headerlink" title="7. #pragma"></a>7. #pragma</h2><p>最后,说个好玩的:</p><p>GNU C Complier (GCC)在1.34版本实现中,因为设计师讨厌pragma</p><p>所以在有pragma的代码时,做了如操作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">do_pragma()</span><br><span class="line">&#123;</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">"/dev/tty"</span>,O_RDONLY, <span class="number">0666</span>) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> nope;</span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">"/dev/tty"</span>, O_WRONLY, <span class="number">0666</span>) != <span class="number">1</span>)</span><br><span class="line"><span class="keyword">goto</span> nope;</span><br><span class="line"></span><br><span class="line">exel(<span class="string">"/usr/games/hack"</span>, <span class="string">"#pragma"</span>, <span class="number">0</span>);</span><br><span class="line">exel(<span class="string">"/usr/games/rogue"</span>, <span class="string">"#pragam"</span>, <span class="number">0</span>);</span><br><span class="line">exel(<span class="string">"/usr/new/emacs"</span>, <span class="string">"-f"</span>, <span class="string">"hanoi"</span>, <span class="string">"9"</span>, <span class="string">"-kill"</span>, <span class="number">0</span>);</span><br><span class="line">exel(<span class="string">"/usr/local/emacs"</span>, <span class="string">"-f"</span>, <span class="string">"hanoi"</span>, <span class="string">"9"</span>, <span class="string">"-kill"</span>, <span class="number">0</span>);</span><br><span class="line">nope:</span><br><span class="line">fatal(<span class="string">"you are in a maze of twisty complier features, all different"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之, 这位设计师, 就是不想你使用pragma与编译指令, 实际上pragma还是很好用的,它可以给编译器</p><p>完成指定操作,比如: 取消结构体对齐, 要求函数内联等等操作, 多使用, 挺好的.</p><p><strong>闲了, C看着还是很有意思, 当然主线不能忘了, 不说了, 又要去板砖了</strong></p><p>May 17, 2018 12:25 PM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
            <tag> Expert_C_Programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++ char *与char [ ]</title>
      <link href="/2018/05/16/C/c_string_array/"/>
      <url>/2018/05/16/C/c_string_array/</url>
      <content type="html"><![CDATA[<p><em>学C++并没有那么舒服, 怪不得是太阳系最复杂的语言,脑子疼</em></p><p>来说说今天被教育的吧.</p><p>先从这样一条语句开始:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"XiyouLinuxGroup"</span>;</span><br></pre></td></tr></table></figure><p>看上去稀松平常, 对没错, 实际上就是稀松平常</p><p>在C语言中有这样要注意的:</p><p><strong>1. str真的只是指向一个字符的指针, 只是X字符的指针, sizeof结果也只是8(字长)</strong></p><p><strong>2. char str[ ]的形式就是正常的数组, 包含了整个字符串, sizeof的结果就是字符串长度 + 1</strong></p><p>那么,到了C++中就是这样的:</p><p><strong>1. 类型推导</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str &lt;= <span class="keyword">char</span> *</span><br><span class="line"><span class="string">"XiyouLinuxGroup"</span> &lt;= <span class="keyword">const</span> <span class="keyword">char</span> *</span><br></pre></td></tr></table></figure><p>这样一来,只要编译就会有警告</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</span><br></pre></td></tr></table></figure><p><strong>甚至在C++11之后编译不能通过</strong></p><p>那么, 有什么办法呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">char</span> str[] = <span class="string">"XiyouLinuxGroup"</span>;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">const</span> <span class="keyword">char</span> *ptr = <span class="string">"..."</span>;</span><br></pre></td></tr></table></figure><p><strong>而且, 一般在使用时,不想进行修改, 就加上const了</strong></p><p><strong>最后, 一般在对于字符串的操作, C++中可以尽量避免C-String出现,</strong></p><p><strong>但是因为开销小, 适当情况下, 还是要使用的</strong></p><p>再来说说delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> str;    <span class="comment">// 释放一个字节的空间</span></span><br><span class="line"><span class="keyword">delete</span> []str;  <span class="comment">// 释放str一系列的空间</span></span><br></pre></td></tr></table></figure><p><strong>最后, 关于释放空间的事, 栈上的不用手动处理, 分清何时需要分配, 何时需要释放还是很重要的</strong></p><p><strong>C++学起来, 真的不轻松, 还是继续努力吧 ! </strong></p><p>May 16, 2018 11:02 PM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从链表排序说起</title>
      <link href="/2018/05/14/C/function_pointer/"/>
      <url>/2018/05/14/C/function_pointer/</url>
      <content type="html"><![CDATA[<p><em>如何使得自己的代码写的华丽而优雅, 如何提高代码复用程度, 如何提高我们的设计能力,需要长期的磨练</em></p><p><em>这里抛砖引玉,说说我自己的学习经历</em></p><p>首先, 这个小Demo基本上4个多月前写的,当时hepangda看过之后就说过: </p><p>你链表的排序可以借用qsort()的实现思想,来时代码写的更优雅一点,之前一直也没管, 这两天才想起来</p><p>那么改一改吧!</p><p><strong>首先,是需求,要求完成地址升序,地址降序,尺寸升序,尺寸降序这四种排序需求</strong></p><p><strong>不假思索的,我们可以将address,size封装成成员, 然后直接写四个排序函数, 但是这样有很大的弊端</strong></p><p><strong>四个函数,基本上只有一句话不同,这样的代码有什么意思,丑的一批(虽然之前为了省事,我可喜欢这样写了)</strong></p><p>所以,初版的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort_ascending_address</span><span class="params">(Node *block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block_node *temp, *cur, *loop;</span><br><span class="line">    temp = block-&gt;head;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error,the block is NULL!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block-&gt;node_num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(temp = block-&gt;head; temp-&gt;next-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;next-&gt;block_address &gt; temp-&gt;next-&gt;next-&gt;block_address) &#123;</span><br><span class="line">                cur = temp-&gt;next;</span><br><span class="line">                loop = temp-&gt;next-&gt;next;</span><br><span class="line">                cur-&gt;next = loop-&gt;next;</span><br><span class="line">                temp-&gt;next = loop;</span><br><span class="line">                loop-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort_ascending_size</span><span class="params">(Node *block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block_node *temp, *cur, *loop;</span><br><span class="line">    temp = block-&gt;head;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error,the block is NULL!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block-&gt;node_num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(temp = block-&gt;head; temp-&gt;next-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;next-&gt;block_size &gt; temp-&gt;next-&gt;next-&gt;block_size) &#123;</span><br><span class="line">                cur = temp-&gt;next;</span><br><span class="line">                loop = temp-&gt;next-&gt;next;</span><br><span class="line">                cur-&gt;next = loop-&gt;next;</span><br><span class="line">                temp-&gt;next = loop;</span><br><span class="line">                loop-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort_descending_address</span><span class="params">(Node *block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block_node *temp, *cur, *loop;</span><br><span class="line">    temp = block-&gt;head;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error,the block is NULL!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block-&gt;node_num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(temp = block-&gt;head; temp-&gt;next-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;next-&gt;block_address &lt; temp-&gt;next-&gt;next-&gt;block_address) &#123;</span><br><span class="line">                cur = temp-&gt;next;</span><br><span class="line">                loop = temp-&gt;next-&gt;next;</span><br><span class="line">                cur-&gt;next = loop-&gt;next;</span><br><span class="line">                temp-&gt;next = loop;</span><br><span class="line">                loop-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort_descending_size</span><span class="params">(Node *block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block_node *temp, *cur, *loop;</span><br><span class="line">    temp = block-&gt;head;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error,the block is NULL!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block-&gt;node_num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(temp = block-&gt;head; temp-&gt;next-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;next-&gt;block_size &lt; temp-&gt;next-&gt;next-&gt;block_size) &#123;</span><br><span class="line">                cur = temp-&gt;next;</span><br><span class="line">                loop = temp-&gt;next-&gt;next;</span><br><span class="line">                cur-&gt;next = loop-&gt;next;</span><br><span class="line">                temp-&gt;next = loop;</span><br><span class="line">                loop-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这四段代码,我写的时候,就是复制粘贴的,好丢人...</span></span><br></pre></td></tr></table></figure><p>但是,听了hepangda的建议后,我们可以修改代码,这样写.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(block_node **temp, block_node **cur, block_node **loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *cur = (*temp)-&gt;next;</span><br><span class="line">    *loop = (*temp)-&gt;next-&gt;next;</span><br><span class="line">    (*cur)-&gt;next = (*loop)-&gt;next;</span><br><span class="line">    (*temp)-&gt;next = *loop;</span><br><span class="line">    (*loop)-&gt;next = *cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bubble_sort(Node *block, bool (*compare)(block_node *, block_node *))</span><br><span class="line">&#123;</span><br><span class="line">    block_node *temp, *cur, *loop;</span><br><span class="line">    temp = block-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error,the block is NULL!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block-&gt;node_num; ++i)</span><br><span class="line">        <span class="keyword">for</span> (temp = block-&gt;head; temp-&gt;next-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next)</span><br><span class="line">            <span class="keyword">if</span> (compare(temp-&gt;next, temp-&gt;next-&gt;next))</span><br><span class="line">                exchange(&amp;temp, &amp;cur, &amp;loop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">address_ascend</span><span class="params">(block_node *a, block_node *b)</span>         <span class="comment">// 地址升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_address &gt; b-&gt;block_address ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">address_descend</span><span class="params">(block_node *a, block_node *b)</span>        <span class="comment">// 地址降序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_address &lt; b-&gt;block_address ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">size_ascend</span><span class="params">(block_node *a, block_node *b)</span>            <span class="comment">// 尺寸升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_size &gt; b-&gt;block_size ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">size_descend</span><span class="params">(block_node *a, block_node *b)</span>           <span class="comment">// 尺寸降序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_size &lt; b-&gt;block_size ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>此时,上面的写法就相对优雅许多了,不是那么的无脑且垃圾.</em></p><p><em>主要使用函数指针的方式,将比较那一步抽出来,写了几个比较函数,然后bubble_sort()变成为通用函数</em></p><p><strong>其中 bool类型时 #include &lt; stdbool.h &gt; 实现的,是为假实现,而_Bool则是真正意义上的boolen类型</strong></p><p><strong>不过,_Bool都是C11的特性了,话又说回来,如果写C11,那么这几个比较函数,直接写到.h文件</strong></p><p><strong>而且是inline函数呦</strong></p><p>如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">file: block_node.h</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">address_ascend</span><span class="params">(block_node *a, block_node *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_address &gt; b-&gt;block_address ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">address_descend</span><span class="params">(block_node *a, block_node *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_address &lt; b-&gt;block_address ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">size_ascend</span><span class="params">(block_node *a, block_node *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_size &gt; b-&gt;block_size ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">size_descend</span><span class="params">(block_node *a, block_node *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;block_size &lt; b-&gt;block_size ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另外,其中注意的是,C使用函数指针,函数原型中,返回类型直接写,不需要括号</strong></p><p><strong>C++中,一般就使用function object了,函数指针效率一般,当然C中就使用函数指针了</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结 :"></a>总结 :</h3><p>关于程序的设计,实际上就是一门艺术,我们如何设计好的程序,如何写出优雅的代码,都是值得思考的问题</p><p>就目前而言,多写,多练,无疑是一个重要的手段,是加上多看别人好的实现代码,意义更大</p><p><strong>比如,此处的qsort()思想,还是很有意义的</strong></p><p>多写,多练.所以说,写写C with STL 还是很有必要的.</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个简单的shell脚本</title>
      <link href="/2018/05/13/ShellScript/sh5/"/>
      <url>/2018/05/13/ShellScript/sh5/</url>
      <content type="html"><![CDATA[<p><em>前言: 好久没写博客,而且shell也忘的差不多了, 今天下午刚好需要写个shell脚本,不如就来分析一下</em></p><p>内容需求如下:</p><ol><li><p>完成指定内容的拷贝</p></li><li><p>判断源目录与目的目录的存在性</p></li><li><p>进行比对判断, 不要覆盖原有文件.</p></li></ol><p>此脚本用到了以下几点:</p><ol><li><p>if-else-fi 的选择结构</p></li><li><p>for的循环结构</p></li><li><p>函数</p></li><li><p>全局变量</p></li><li><p>命令引用</p></li></ol><p>那么,话不多说, 直接看代码吧:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># -"- coding: utf-8 -"-</span></span><br><span class="line"><span class="comment"># @filename:copy.sh</span></span><br><span class="line"><span class="comment"># @date: 05/13/2018 17:47:46</span></span><br><span class="line"><span class="comment"># @author: Crow</span></span><br><span class="line"><span class="comment"># @description:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> judge_res             <span class="comment"># 标识判断结果</span></span><br><span class="line"><span class="built_in">declare</span> dir_src=<span class="variable">$1</span>            <span class="comment"># 用变量dir_src保存命令行参数</span></span><br><span class="line"><span class="built_in">declare</span> dir_dest=<span class="variable">$2</span>           <span class="comment"># 用变量dir_dest保存命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断目录是否存在的函数</span></span><br><span class="line"><span class="keyword">function</span> judge()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$1</span> ] &amp;&amp; [ -d <span class="variable">$2</span> ]; <span class="keyword">then</span>            <span class="comment"># 发起两个测试,同时判断两个目录是否存在</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Dir exist"</span></span><br><span class="line">        judge_res=1                            <span class="comment"># 标识目录存在</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Error, dir doesn't exist"</span></span><br><span class="line">        judge_res=-1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> file_src=`ls <span class="variable">$1</span> | sort`                <span class="comment"># 读出指定目录内容并使用命令引用保存 $file_src</span></span><br><span class="line"><span class="built_in">declare</span> file_dest=`ls <span class="variable">$2</span> | sort`               <span class="comment"># 读出指定目录内容并使用命令引用保存 $file_dest</span></span><br><span class="line"><span class="built_in">declare</span> record </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> diff_copy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$dir_src</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$file_src</span>                         <span class="comment"># 一重循环 src 文件</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        record=0</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="variable">$file_dest</span>                    <span class="comment"># 二重循环 dest 文件</span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">            <span class="keyword">if</span> [ <span class="variable">$i</span> = <span class="variable">$j</span> ]; <span class="keyword">then</span></span><br><span class="line">                record=1                       <span class="comment"># 标识找到了</span></span><br><span class="line">                <span class="built_in">break</span> 1                        <span class="comment"># 进入下一轮外层循环</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">continue</span> 1                     <span class="comment"># 测试下一个 dest 文件</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$record</span> -eq 0 ]; <span class="keyword">then</span>             <span class="comment"># 确定该目录下没有 src 文件</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">            cp <span class="variable">$i</span> <span class="variable">$dir_dest</span>                    <span class="comment"># 进行文件拷贝</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    judge </span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$judge_res</span> -eq 1 ]; <span class="keyword">then</span>              <span class="comment"># 目录存在的情况下进行diff_copy()</span></span><br><span class="line">        diff_copy</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main                                           <span class="comment"># 调用函数</span></span><br></pre></td></tr></table></figure><p>那么,通过这个例子,我们能学习到什么呢?</p><p>有以下几点:</p><ol><li><p>shell中若非使用local关键字, 声明的便全部都是全局变量, 有利有弊, 慎重抉择</p></li><li><p>函数一般是没有参数的, 调用时, 直接函数名即可, <strong>切记, 不要干出写了函数不掉用的笑话</strong></p></li><li><p>shell中进行测试的时候, [] 两边各要留空, 切记不要忘了.</p></li><li><p>一般命令行参数不稳妥, 进入程序后便用变量进行保存</p></li><li><p>活用unset, set, 还是有必要的.</p></li></ol><p>shell的内容就这么多, <strong>建议是,有兴趣学完了之后, 没事写的时候在翻翻就行了,是真的容易忘</strong></p><p><strong>最后, 要不是劳资Ruby扔的时间更长, 我才不用这个有缺显的玩意…</strong></p><p><strong>这个sh能够完善的地方还是有很多的, 大家有兴趣了, 后面可以继续玩一玩(滑稽)</strong></p><p>May 13, 2018 8:34 PM</p>]]></content>
      
      <categories>
          
          <category> shellscript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>II 变量和基本类型</title>
      <link href="/2018/04/08/C++/cpp1/"/>
      <url>/2018/04/08/C++/cpp1/</url>
      <content type="html"><![CDATA[<p>一, 内置类型</p><p>C++的内置类型分为算术类型与空类型</p><p>内置类型又分为算术类型和浮点型</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32</td></tr><tr><td>short</td><td>短整型</td><td>16</td></tr><tr><td>int</td><td>整型</td><td>16</td></tr><tr><td>long</td><td>长整型</td><td>32</td></tr><tr><td>long long</td><td>长整型</td><td>64</td></tr><tr><td>float</td><td>单精度</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度</td><td>10位有效数字</td></tr></tbody></table><p>选择类型的建议:</p><ol><li><p>明确不可能为负值时,使用unsigned</p></li><li><p>一般使用int,short太小不满足需求,long又和int差不多,一旦int不满足,直接使用long long</p></li><li><p>算术表达式,不要使用char,bool.因为char在不同的机器上,有无符号.bool则始终是1/0(强转之后)</p></li><li><p>浮点运算使用double, float经常精度不满足,同时因为float继续运算的代价与double差不多</p></li></ol><p><strong>不同类型之间进行类型转换时的规则:</strong></p><ol><li><p>integer-&gt;bool</p><p> 非0为1,其余为0</p></li><li><p>bool-&gt;integer</p><p> 只有1/0,所以不能使用bool在算术表达式中</p></li><li><p>浮点数-&gt;integer</p><p> 会丢失精度,去掉小数点后的内容</p></li><li><p>integer-&gt;浮点</p><p> 小数点补0</p></li><li><p>无符号数 (补码表示)</p><p> 对无符号数,赋值出现溢出时,进行取模运算</p></li><li><p>有符号数 (补码表示)</p><p> 出现溢出,即为未定义行为,具体看编译器实现,UB行为</p></li></ol><p><strong>常用建议: 切勿混用有符号数和无符号数,不然会出现许多意料之外的Bug</strong></p><p>二, 变量</p><p>1&gt;. <strong>初始化与赋值</strong></p><p><em>在很多程序设计语言中,初始化与赋值,是经常混淆的概念,在C++的某些场合中也是不加以区分的</em></p><p><em>但是,这两个概念实际上还是有很大区别的</em></p><p><strong>C++中,初始化指的是创建变量,同时赋予其一个初始值.而赋值则是擦出变量当前的值,然后赋以新值</strong></p><p>2&gt;. 列表初始化</p><p>初始化有很多的形式,这也是造成C++初始化复杂的原因之一.</p><p>比如下面都是成立的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>现在比较推荐的是,使用列表初始化的方法(C11全面支持)</p><p>重要的原因就是: <strong>如果我们使用列表初始化,但初始化值存在丢失信息的风险时,编译器会报错</strong></p><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">int</span> a = &#123;<span class="number">1L</span>&#125;, b = &#123;ld&#125;;</span><br><span class="line">    <span class="keyword">int</span> c = &#123;<span class="number">1L</span>&#125;, d = ld;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g++ x.cpp</span><br><span class="line">#=&gt;</span><br><span class="line">warning: narrowing conversion of ‘ld’ from ‘<span class="keyword">long</span> <span class="keyword">double</span>’ to ‘<span class="keyword">int</span>’ inside &#123; &#125; [-Wnarrowing]</span><br><span class="line">     <span class="keyword">int</span> a = &#123;<span class="number">1L</span>&#125;, b = &#123;ld&#125;;</span><br><span class="line">                          ^</span><br></pre></td></tr></table></figure><p>3&gt; 默认初始化</p><p>默认初始化,指的是定义变量,但是并未显示初始化的情况:</p><ol><li><p>内置类型看位置</p></li><li><p>类类型看类实现</p></li></ol><p>对于内置变量: <strong>函数体外,初始化为0,即全局变量.函数体内,不初始化,为未定义的值</strong></p><p>对于类变量(对象): <strong>是否初始化,看类实现,显式要求初始化的,若不初始化,直接报错</strong></p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ShellScipt拾遗</title>
      <link href="/2018/03/15/ShellScript/sh4/"/>
      <url>/2018/03/15/ShellScript/sh4/</url>
      <content type="html"><![CDATA[<h3 id="echo的妙用"><a href="#echo的妙用" class="headerlink" title="echo的妙用"></a>echo的妙用</h3><p>使用echo进行颜色的打印, 语法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;xm   string  \e[0m"</span></span><br><span class="line"></span><br><span class="line">其中x是颜色代码,string为字符串</span><br></pre></td></tr></table></figure><p>颜色列表如下:</p><table><tr><td colspan="2">font_color</td><td colspan="2">backgroud_color</td></tr><tr><td>num</td><td>color</td><td>num</td><td>color</td></tr><tr><td>0</td><td>reset</td><td>0</td><td>reset</td></tr><tr><td>30</td><td>black</td><td>40</td><td>black</td></tr><tr><td>31</td><td>red</td><td>41</td><td>red</td></tr><tr><td>32</td><td>green</td><td>42</td><td>green</td></tr><tr><td>33</td><td>yellow</td><td>43</td><td>yellow</td></tr><tr><td>34</td><td>blue</td><td>44</td><td>blue</td></tr><tr><td>35</td><td>fuchsin</td><td>45</td><td>fuchsin</td>/tr&gt;</tr><tr><td>36</td><td>cyan</td><td>46</td><td>cyan</td></tr><tr><td>37</td><td>white</td><td>47</td><td>white</td></tr></table><p>根据上表,我们可以这样写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"\e[1;32m green ,\e[0m reset"</span></span><br></pre></td></tr></table></figure><p>其中切记,-e 选项,才能进行转义,使shell进行打印颜色的设置</p><h3 id="env的一些内容"><a href="#env的一些内容" class="headerlink" title="env的一些内容"></a>env的一些内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pgrep [process]  <span class="comment">#=&gt; PID</span></span><br><span class="line"></span><br><span class="line">cat /proc/<span class="variable">$PID</span>/environ | tr <span class="string">'\0'</span> <span class="string">'\n'</span>   <span class="comment">#=&gt; get the env of process</span></span><br></pre></td></tr></table></figure><h3 id="修改添加PATH"><a href="#修改添加PATH" class="headerlink" title="修改添加PATH"></a>修改添加PATH</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">prepend</span></span>( ) &#123; [ -d <span class="variable">$2</span> ] &amp;&amp; evel <span class="variable">$1</span>=\<span class="string">"<span class="variable">$2</span>':'\$<span class="variable">$1</span>\" &amp;&amp; export <span class="variable">$1</span>; &#125;</span></span><br></pre></td></tr></table></figure><p>evel 可以进行两次扫描,来处理其中的变量.</p>]]></content>
      
      <categories>
          
          <category> Shellscript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby学习笔记(三)</title>
      <link href="/2018/02/06/Ruby/Ruby3/"/>
      <url>/2018/02/06/Ruby/Ruby3/</url>
      <content type="html"><![CDATA[<p><em>类是Ruby作为面向对象语言的特征之一,模块又是Ruby的特色花样之一,就来聊聊这两方面内容吧</em></p><h2 id="一-类-class"><a href="#一-类-class" class="headerlink" title="一 类 (class)"></a>一 类 (class)</h2><p>类是面向对象中,定义对象的数据与行为的结构</p><p>类就像是对象的雏形或设计图,决定了对象的行为</p><h3 id="常见类方法"><a href="#常见类方法" class="headerlink" title=" 常见类方法"></a><1> 常见类方法</1></h3><p>下面介绍几个常用的方法:</p><ol><li><p>类方法: new方法</p><p> 既然对象是类的实例,那么,类便提供了,创建对象的方法,即为new方法</p><p> 同时,数值类,字符串类,数组可以使用字面量来进行初始化</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = Array.new</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">"asa"</span>]</span><br><span class="line">c = <span class="number">123</span></span><br><span class="line">d = hash.new</span><br><span class="line">p d <span class="comment">#=&gt; &#123;&#125;</span></span><br><span class="line">p a <span class="comment">#=&gt; []</span></span><br></pre></td></tr></table></figure></li><li><p>实例方法: class方法</p><p> 既然每个对象都是类的实例,那么如何判断改对象的类,使用class方法,可以判断出对象的类</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [ ]</span><br><span class="line">hash = &#123; &#125;</span><br><span class="line">p hash.<span class="keyword">class</span> <span class="comment">#=&gt; "Hash"</span></span><br><span class="line">p array.<span class="keyword">class</span> <span class="comment">#=&gt; "Array"</span></span><br></pre></td></tr></table></figure></li><li><p>实例方法: instance_of?</p><p> 用于判断某个对象是否属于某方法,和以前的约定一样返回值为真假的以”?”结尾</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = []</span><br><span class="line">p array.instance_of?(Array)   <span class="comment">#=&gt; true</span></span><br><span class="line">p array.instance_of?(String)  <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title=" 继承"></a><2> 继承</2></h3><p>继承是类中很重要一个概念</p><p><strong>继承 : 通过扩展已定义的类来创建新的类</strong></p><p>那么,继承有什么作用呢?</p><ol><li><p>再不影响原有类功能的前提下,追加新的功能</p></li><li><p>可以重定义父类中的功能,使名称相同的方法产生不同的结果</p></li><li><p>在已有的功能上,追加新的处理,扩展已有功能</p></li></ol><p><strong>新创建的类叫子类(subclass),被继承的类叫父类(superclass)</strong></p><p><strong>注意: Ruby不支持父类的多重继承,即一个类只能继承一次,只能有一个父类,Ruby保证了单一继承关系</strong></p><p><strong>那么,有时候就是需要多个类的功能该怎么办,后面自有办法,使用模块(module)</strong></p><p><strong>Basicobject类shiRuby中最最基础的类,仅仅包含了作为一个类最低限度的方法</strong></p><p><strong>所以,Ruby中一般默认的继承类是Object类,我们可以看看这两个类中方法的比较</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p BasicObject.instance_methods</span><br><span class="line"><span class="comment">#=&gt; [:!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]</span></span><br><span class="line"></span><br><span class="line">p Object.instance_methods</span><br><span class="line"><span class="comment">#=&gt; [:remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :public_send, :instance_variable_defined?, :singleton_method, :instance_variable_set, :method, :public_method, :extend, :define_singleton_method, :to_enum, :enum_for, :&lt;=&gt;, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :object_id, :send, :display, :to_s, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variable_get, :instance_variables, :!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]</span></span><br></pre></td></tr></table></figure><p><strong>而我们一般创建类时,默认的继承类是Object类,所以,这个类就不能再继承其他类了,</strong></p><p><strong>违背单一继承的规则,会抛出异常</strong></p><p>下面是一张Ruby中常见类的继承关系图</p><p><img src="http://owzoakbc5.bkt.clouddn.com/Screenshot_20180207_182032.png" alt=""></p><p>现在,再介绍一种方法,用来辨别继承关系</p><p>4.is_a?方法</p><p>is_a? 方法用来辨别接收者是否是参数的子类</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p Array.is_a?(Object)  <span class="comment">#=&gt; true</span></span><br><span class="line">p Array.is_a?(String)  <span class="comment">#=&gt; false</span></span><br><span class="line">p Array.is_a?(Array)   <span class="comment">#=&gt; false</span></span><br><span class="line">a = []</span><br><span class="line">p a.is_a?(Array)       <span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="类的创建"><a href="#类的创建" class="headerlink" title=" 类的创建"></a><3> 类的创建</3></h3><p>上面说了那么多,类的创建是怎么做的呢?</p><p>类定义的语法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_name</span></span></span><br><span class="line">  class_definition</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中需要介绍的一个是,<strong>initialize方法</strong></p><p>类创建一个对象的new方法,就是以initialize方法进行定义的</p><p><strong>虽然调用的是new方法,但是再类的定义中就是用的initialize方法</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name = <span class="string">"Ruby"</span>)</span></span></span><br><span class="line">    @name = name   </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"Hello I'm <span class="subst">#&#123;@name&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = HelloWorld.new(<span class="string">"SinCrow"</span>)</span><br><span class="line">n = HelloWorld.new</span><br><span class="line">m.hello   <span class="comment">#=&gt; Hello I'm SinCrow</span></span><br><span class="line">n.hello   <span class="comment">#=&gt; Hello I'm Ruby</span></span><br></pre></td></tr></table></figure><p>上面的例子中,new方法便是由initialize方法定义的,传参也是同一道理</p><h4 id="3-1-实例变量与实例方法"><a href="#3-1-实例变量与实例方法" class="headerlink" title="3.1 实例变量与实例方法"></a>3.1 实例变量与实例方法</h4><p>之前总是说实例变量,实例方法.到底是怎么使用的呢?</p><p><strong>1.实例变量,就是在类的定义中,@var形式的变量,可以在类的实例方法中通用</strong></p><p><strong>算是类中实例方法间的全局变量,只要在同一个实例中,就可以超越方法的局限,任意引用,修改实例变量</strong></p><p><strong>2.实例方法,顾名思义,实例才能调用的方法,即对象的方法</strong></p><p><strong>备注: 不同的实例的实例变量值是可以不同的,而且这些实例变量都是存在的,只要实例存在,就不会消失</strong></p><p><strong>反观,局部变量的作用域,生命周期都是在方法中,只能在方法内部使用,方法调用结束,局部变量释放</strong></p><h4 id="3-2-存取器"><a href="#3-2-存取器" class="headerlink" title="3.2 存取器"></a>3.2 存取器</h4><p>那么,现在就有一个问题,关于在实例方法中的实例变量,既然是在类中定义的,随着实例存在</p><p>如果,需要使用实例变量怎么办呢?</p><p>很容易就可以构建下面的两个实例方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(myname = <span class="string">"Ruby"</span>)</span></span></span><br><span class="line">    @name = myname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span></span><br><span class="line">    @name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name=</span><span class="params">(modify_name)</span></span></span><br><span class="line">    @name = modify_name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中需要注意的是,<strong>name=方法,一定是紧紧相连的,不然就不能定义为方法名</strong></p><p>但是,很没意思啊,整天都要些存取器的内容,每个实例变量都要写,所以Ruby提供了定义方法</p><table><thead><tr><th>存取器</th><th>作用</th></tr></thead><tbody><tr><td>attr_reader</td><td>读方法(name方法)</td></tr><tr><td>attr_writer</td><td>写方法(name=方法)</td></tr><tr><td>attr_accessor</td><td>皆有</td></tr></tbody></table><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:a</span></span><br><span class="line"><span class="keyword">attr_writer</span> <span class="symbol">:b</span></span><br><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:c</span>, <span class="symbol">:d</span></span><br></pre></td></tr></table></figure><p>这样定义就可以了,用法相当于直接调用name方法与name=方法</p><h4 id="3-3-self变量"><a href="#3-3-self变量" class="headerlink" title="3.3 self变量"></a>3.3 self变量</h4><p>介绍一个十分特殊的变量,<strong>self变量</strong></p><p>以前就提到过,Ruby是完全的面向对象,</p><p>实际上,在顶部,是main对象,平时调用的函数式方法也是有接收者的</p><p>只不过是不在意接收者的信息,实际上函数式方法的接收者,就是self</p><p><strong>我不清楚Java的this指针与self有何区别</strong></p><p><strong>但是,Ruby是解释性语言,所以,他的self严格的与上下文息息相关</strong></p><p><strong>self变量,其实就是指当前的层次</strong></p><p>来看看,下面的例子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">self</span>    <span class="comment">#=&gt; main</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfTest</span></span></span><br><span class="line">  p <span class="keyword">self</span>    <span class="comment">#=&gt; SelfTest</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_test</span></span></span><br><span class="line">    p <span class="keyword">self</span>   <span class="comment">#=&gt; #&lt;SelfTest:0x0000000001c48500&gt;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = SelfTest.new</span><br><span class="line">m.method_test</span><br></pre></td></tr></table></figure><p><strong>对于最外层顶部来讲,就是main,</strong></p><p><strong>对于类来讲,就是类名</strong></p><p><strong>对于实例方法来讲,就是本实例,而本实例是存在于内存上的,所以就是地址了</strong></p><p>那么,self变量有什么用呢?</p><p><strong>可以进行变量自身的调用,而且,可以隐式调用,Ruby缺省条件下,接收者就是self</strong></p><p>看下面这个例子:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(myname)</span></span></span><br><span class="line">    @name = myname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"Hello ,My name is <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>实例方法中的hello,获取到,name变量的值,但是,name并不是传进来的参数</p><p><strong>而且,这个方法是没有Bug的!</strong></p><p><strong>其实这个name是 #{self.name},换成{@name}也是可以的</strong></p><p>那么,平时调用函数式方法,是不是也可以加上self呢?</p><p><strong>答案是,不行!,函数式方法,多为private(私有)方法,必须是隐式调用</strong></p><p><strong>注意: 调用写方法的时候,不能隐式调用,必须显式调用,不然会有很诡异的事情发生呦,来看下面的例子</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"hello"</span>   <span class="comment">#=&gt; name视为变量</span></span><br><span class="line"><span class="keyword">self</span>.name = <span class="string">"hello"</span>  <span class="comment">#=&gt; name= 视为写方法</span></span><br></pre></td></tr></table></figure><p>这样懂了吧? (滑稽)</p><h4 id="3-4-类方法"><a href="#3-4-类方法" class="headerlink" title="3.4 类方法"></a>3.4 类方法</h4><p>我们在这里就不多纠缠了,类方法就是给类对象使用的方法</p><p><strong>对,实际上我们区分方法按照接收者去区分</strong></p><p><strong>但是,实际上,Ruby所有的方法都应该叫做实例方法,每一个对象都有类</strong></p><p><strong>类方法调用者(接收者)是类,各个类,都是Class类的实例对象</strong></p><p>下面介绍4种Ruby类方法的定义形式</p><ol><li><p>单例方法形式</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在<span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span>已存在条件下</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; Hello</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">puts <span class="string">"I'm Class method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>class上下文中,引用self形式</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">  puts <span class="string">"Class method"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>显式标明类名,进行实例方法形式的定义</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>.<span class="title">name</span><span class="params">(myname)</span></span></span><br><span class="line">puts <span class="string">"my name is <span class="subst">#&#123;myname&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>等效于3,类名可以用self变量取代,但是,self切记不能省略,<strong>不然会视为实例方法</strong></p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">name</span></span></span><br><span class="line">puts <span class="string">"My name is Ruby"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><p>虽然提到了四种定义的形式,准确的来讲应该是三种,其中<strong>第四种用的最多,单例方法的形式,重复量太大</strong></p><p><strong>而将,类方法以实例方法的形式定义,很方便</strong></p><p><strong>后面还会有通过模块的方法进行类方法定义,也是很方便的方法</strong></p><p><strong>备注: class &lt;&lt; 类名 ~ end 的写法为单例类定义,其中的方法是单例方法,后面会详解</strong></p><h4 id="3-5-常量"><a href="#3-5-常量" class="headerlink" title="3.5 常量"></a>3.5 常量</h4><p>类中肯定也是可以定义常量的,一般常量为大写,通过”::”进行访问,类似于类方法的访问</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">VERSION = <span class="string">"v1.0"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p Hello::VERSION <span class="comment">#=&gt; "v1.0"</span></span><br></pre></td></tr></table></figure><h4 id="3-6-类变量"><a href="#3-6-类变量" class="headerlink" title="3.6 类变量"></a>3.6 类变量</h4><p>类变量,类似于实例变量,是在整个类的实例方法间都可以任意引用,修改的变量</p><p><strong>但是,区别于实例变量,类变量是子类继承后仍然能够存在的变量,存储期更长</strong></p><p><strong>实例变量,是随着实例对象存在而存在.那么,类变量就是随着类对象存在而存在</strong></p><p><strong>@@class_var是存在于类中的,所以几个实例对象,是共享这个类变量的</strong></p><p><strong>,但是,类变量定义存取器,不能使用attr系列方法,attr系列只能给实例变量使用</strong></p><p>可以看看下面的例子:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line">  @@hello_count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(myname = <span class="string">"Ruby"</span>)</span></span></span><br><span class="line">    @name = myname</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"my name is <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line">    @@hello_count += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">count</span></span></span><br><span class="line">    @@hello_count</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = Hello.new</span><br><span class="line">b = Hello.new(<span class="string">"NIOH"</span>)</span><br><span class="line">c = Hello.new(<span class="string">"Uncharted"</span>)</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 0</span></span><br><span class="line">a.hello</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 1</span></span><br><span class="line">b.hello</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 2</span></span><br><span class="line">c.hello</span><br><span class="line">p Hello::count   <span class="comment">#=&gt; 3</span></span><br></pre></td></tr></table></figure><h4 id="3-7-修饰方法的关键字"><a href="#3-7-修饰方法的关键字" class="headerlink" title="3.7 修饰方法的关键字"></a>3.7 修饰方法的关键字</h4><p>曾经看过C,C种存在着,static关键字,可以用来修饰函数,使函数只能在本文件中调用,常说的:</p><p><strong>具有内部链接的静态类型函数,链接,存储期,作用域是C中进行控制的几个关键点</strong></p><p><strong>随着代码组织的不同,相应的关键字发生变化(hepangda说的,不是我说的)</strong></p><p>在,Ruby中有这样三个修饰方法的关键字:<strong>public, private, protected</strong></p><p>之前被国内的概念误导了很长时间,</p><p><strong>他们死要纠缠访问与调用这两个概念, , ,</strong></p><p>其实,这三个关键字分得很清楚,可以用下面几句话概括:</p><p><strong>1. public以外的两类方法,都不能被显式的实例对象调用</strong></p><p><strong>2. public方法为默认属性,可以任意访问调用,无论是类还是实例对象,或是同父类的实例对象</strong></p><p><strong>3. protected方法相当于类之内的public方法,可以被随意调用,即所谓的被同父类的实例对象访问</strong></p><p><strong>接上一条,也就是指可以在其他的方法中,调用protected方法,其他方法的实例对象是self</strong></p><p><strong>4. private方法就更好说了,只能进行隐式的调用,即自身调用(self)</strong></p><p><strong>即private是这个类进行私有实现所使用的,只能隐式的被self调用,不能显示地指定接收者</strong></p><p><strong>要写,只能 private_method_test,不能obj.private_method_test</strong></p><p><strong>有一句话,挺恰当的,private私有方法是内部实现所使用的,对其他的类(非同父类),实例都是不可见的</strong></p><p>在Ruby社区提问,得到了这样比较好的答案</p><p><del>访问和调用扯半天,真的是拖裤子放P</del></p><h3 id="扩展类"><a href="#扩展类" class="headerlink" title=" 扩展类"></a><4> 扩展类</4></h3><h4 id="4-1-给原有类添加方法"><a href="#4-1-给原有类添加方法" class="headerlink" title="4.1 给原有类添加方法"></a>4.1 给原有类添加方法</h4><p>很简单,就是定义和类名相同的类,如果是已存在的类,则会追加方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">count_word</span></span></span><br><span class="line">    array = split(<span class="regexp">/\s+/</span>)    <span class="comment">#=&gt; array = self.spilt(/\s+/)</span></span><br><span class="line">    <span class="keyword">return</span> array.size</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">"hello world"</span></span><br><span class="line">p str.count_word <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure><h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2 继承"></a>4.2 继承</h4><p>前面说了很多次继承了,下面是继承的语法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> &lt; SuperClass</span></span><br><span class="line">  class_definition</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>还是要提醒一点,Ruby缺省继承为Object类</strong></p><h4 id="4-3-alias与undef"><a href="#4-3-alias与undef" class="headerlink" title="4.3 alias与undef"></a>4.3 alias与undef</h4><p>这两个关键字在其他语言中可能也用过</p><p><strong>alias就是Linux中命令别名的命令,这里同义</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alias</span>  new_name    old_name</span><br><span class="line"><span class="keyword">alias</span> <span class="symbol">:new_symbol</span> <span class="symbol">:old_symbol</span></span><br></pre></td></tr></table></figure><p><strong>undef在C中应该也是使用过的,用来取消命令别名</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">undef</span> 方法名</span><br><span class="line"><span class="keyword">undef</span> <span class="symbol">:</span>方法名</span><br></pre></td></tr></table></figure><p>用来删除方法定义的,例如:我们可以在子类中删除不需要的父类方法定义,并且重新定义</p><h3 id="聊一聊”单例类”"><a href="#聊一聊”单例类”" class="headerlink" title="聊一聊”单例类”"></a>聊一聊”单例类”</h3><p>之前,进行类方法的定义时说过,使用单例类的形式进行类方法的定义</p><p>什么叫单例类?</p><p><strong>单例类,指的就是,并非对类定义进行修改,只是针对这一个实例进行方法等的修改,只对这一个实例有效</strong></p><p><strong>所以叫单例类,单例类中的方法叫单例方法</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">"world"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; str1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"I'm hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str1.hello <span class="comment">#=&gt; "I'm hello"</span></span><br><span class="line">str2.hello <span class="comment">#=&gt; undefined method `hello' for "world":String (NoMethodError)</span></span><br></pre></td></tr></table></figure><p>上面的例子即可说明hello方法对于同类实例str1与str2而言,只对str1有效,所以叫做单例方法</p><p>那么,我们定义类方法,与单例(实例)又有什么关系呢?</p><p><strong>这里就可以清晰地说明: Ruby中一切皆对象,类都是Class类的实例,所以使用单例方法,就是添加类方法</strong></p><p>前面说过,Ruby部支持父类多重继承(没有Java diao,对吧?(滑稽))</p><p>但是,Ruby却很好的处理了一定情况下的需求,靠得就是模块(module)</p><p>下面,我们来仔细看看模块(module)</p><h2 id="二-模块-module"><a href="#二-模块-module" class="headerlink" title="二 模块 (module)"></a>二 模块 (module)</h2><h3 id="模块的作用与意义"><a href="#模块的作用与意义" class="headerlink" title=" 模块的作用与意义"></a><1> 模块的作用与意义</1></h3><p>模块为什么存在,从下面两点来说明:</p><h4 id="1-1-提供命名空间"><a href="#1-1-提供命名空间" class="headerlink" title="1.1 提供命名空间"></a>1.1 提供命名空间</h4><p>之前其实一直没有注意过,但是,一旦工程量比较大的时候,命名空间就十分重要了.</p><p>系统的讲,命名空间就是指<strong>对方法,常量,类的名称进行区分和管理的单位</strong></p><p><strong>使用模块(module),天生进行命名空间的区分,互相不污染</strong></p><p>举个简单的例子:</p><p>很火爆的网络Web服务器Nginx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_kqueue_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_eventport_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_devpoll_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_epoll_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span> ngx_select_module;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_init_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_event_module_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_event_process_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_events_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_connections</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_use</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_debug_connection</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ngx_event_core_create_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_event_core_init_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf)</span></span>;</span><br></pre></td></tr></table></figure><p>使用ngx作为统一的命名空间,当然这里只是举例子,实际上Ruby中使用模块可以避免命名空间冲突的问题</p><p><strong>A模块中的foo方法,与B模块中的foo方法完全是两个方法</strong></p><p>我们使用类似于<strong>调用类中的方法的放法来调用模块方法,模块名.方法名,也叫模块函数</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileTest.exist?(<span class="string">"/usr?bin/ruby"</span>)</span><br><span class="line">FileTest.size(<span class="string">"/usr?bin/ruby"</span>)</span><br></pre></td></tr></table></figure><p>如果,在当前命名空间中不与模块函数冲突,那么,可以使用include来省略模块名</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> Math</span><br><span class="line">sin(<span class="number">30</span>)</span><br><span class="line">sqrt(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><strong>注意,一定是不发生命名空间冲突的时候,可以使用include进行命名空间的合并,反之,抛出异常</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sin</span></span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> Math</span><br><span class="line">p sin(<span class="number">5</span>)   </span><br><span class="line"><span class="comment">#&gt; in `sin': wrong number of arguments (given 1, expected 0) (ArgumentError)from test.rb:6:in `&lt;main&gt;'</span></span><br></pre></td></tr></table></figure><p><strong>这个错误,会在继承机制中进行解答,见下</strong></p><h4 id="1-2-利用Mix-in进行扩展"><a href="#1-2-利用Mix-in进行扩展" class="headerlink" title="1.2 利用Mix-in进行扩展"></a>1.2 利用Mix-in进行扩展</h4><p><strong>前面提到过,Ruby只支持单一父类继承,那么问题来了,如果碰到需要继承多个类的功能时怎么办?</strong></p><p>答案是,<strong>使用模块来进行类功能的扩展</strong></p><p>可以将模块作为通用功能的实现,来完成多个功能类似的类的扩展</p><p><strong>Mix-in指的就是,将通用功能设计在模块中实现,之后include,则module的变量,方法都可以在类中使用</strong></p><p>那么,套用前人总结的经验,一般Mix-in解决这两种问题:</p><p><strong>1. 虽然两个类拥有相似的功能,但是不惜望将他们作为相同的类来考虑时</strong></p><p><strong>2. Ruby不支持父类的多重继承,因此无法对已继承的类添加共通的功能的时候</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mix-<span class="keyword">in</span> Example</span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></span><br><span class="line">  module_difinition</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span></span></span><br><span class="line">  <span class="keyword">include</span> MyModule</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span></span></span><br><span class="line">  <span class="keyword">include</span> MyModule</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="创建模块"><a href="#创建模块" class="headerlink" title=" 创建模块"></a><2> 创建模块</2></h3><p>上面说了这么多,下面说说模块的用法吧</p><p>首先,使用<strong>module</strong>关键字</p><p>至于语法,与class是一致的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">module_name</span></span></span><br><span class="line">  module_difination</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面是一个模块的使用示范</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Hello</span></span></span><br><span class="line">  Version = <span class="string">"v1.0"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  module_function <span class="symbol">:hello</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p Hello::Version    <span class="comment">#=&gt; "v1.0</span></span><br><span class="line">Hello.hello         <span class="comment">#=&gt; "Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> Hello</span><br><span class="line">p Version           <span class="comment">#=&gt; "v1.0"</span></span><br><span class="line">hello               <span class="comment">#=&gt; "Hello"</span></span><br></pre></td></tr></table></figure><p>现在来说说上面中的一些之前没有见到过的东西</p><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><p>常量的用法同类中的常量(并非类变量)</p><p><strong>模块中,不能出现类变量,实例变量(如有不懂,看前面)</strong></p><h4 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h4><p>模块中的方法,定义是同类方法的</p><p>但是,需要注意的是:</p><p><strong>如果要想使模块函数对外可见,使其可以使用”模块名.方法名”的形式调用</strong></p><p><strong>这里指的是,使用模块进行模块函数的调用,任何包含此模块的上下文都可以直接调用模块函数</strong></p><p><strong>那么,一定要使用module_function方法,进行模块函数的声明,使其对外可见,参数是模块函数的符号名</strong></p><p>另外,</p><p><strong>模块方法中的self,是当前模块对象</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">HelloName</span></span></span><br><span class="line">  p <span class="keyword">self</span>              <span class="comment">#=&gt; "HelloName"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    p <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  module_function <span class="symbol">:hello</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">HelloName.hello       <span class="comment">#=&gt; "HelloName"</span></span><br></pre></td></tr></table></figure><p><strong>区别于类的不同之处：类中的实例方法，self只当前的对象(实例,有实体)</strong></p><p><strong>而模块函数中的self指模块对象,因为模块不具有实例</strong></p><p><strong>但是,模块中的self一旦Mix-in之后,便表示类对象,所以,Mix-in一般不建议模块使用self</strong></p><h3 id="Mix-in"><a href="#Mix-in" class="headerlink" title=" Mix-in"></a><3> Mix-in</3></h3><p>聊聊Mix-in及其相关</p><p>首当其冲的是,判断一个类是否Mix-in了某模块,使用include? 方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ClassName.<span class="keyword">include</span>?(kernel)   <span class="comment">#=&gt; "true"</span></span><br></pre></td></tr></table></figure><p>现在,就来说说一个很关键的,类的继承机制</p><p><img src="http://owzoakbc5.bkt.clouddn.com/Screenshot_20180215_033346.png" alt=""></p><p><strong>在类中include的模块会做为虚拟的父类进行方法的继承,以及方法的查找</strong></p><p>来看一个例子:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">TestModule</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line">  <span class="keyword">include</span> TestModule</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p TestClass.ancestors   <span class="comment">#=&gt; "[TestClass, TestModule, Object, Kernel, BasicObject]"</span></span><br><span class="line">p TestClass.superclass  <span class="comment">#=&gt; "Object"</span></span><br></pre></td></tr></table></figure><p>如上所示,TestModule模块作为虚拟的”父类”进入了TestClass的继承顺序列表中</p><p>但是,TestClass的直接父类还是Object类</p><p><strong>就像这样,我们可以使用模块功能来实现构建多个功能类似的扩展类的需求</strong></p><h3 id="来聊聊模块方法查找规则"><a href="#来聊聊模块方法查找规则" class="headerlink" title=" 来聊聊模块方法查找规则"></a><4> 来聊聊模块方法查找规则</4></h3><ol><li><p>原类中定义了同名方法时,优先使用类中的方法</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">puts <span class="string">"M#hello"</span>      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">puts <span class="string">"C#hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.new.hello <span class="comment">#=&gt; "C#合理咯"</span></span><br></pre></td></tr></table></figure><p> 原因就是: <strong>p C.ancestors #=&gt; [C, M, Object, Kernel, BasicObject]</strong></p><p> <strong>类的继承顺序上,C类在M模块之前</strong></p></li><li><p>在同一个类中,优先使用最后一个包含的模块</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">puts <span class="string">"M1#hello"</span>      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">puts <span class="string">"M2#hello"</span>      </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line">  <span class="keyword">include</span> M2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.new.hello  <span class="comment">#=&gt; "M2#hello"</span></span><br></pre></td></tr></table></figure><p> <strong>同理,看继承顺序: [C, M2, M1, Object, Kernel, BasicObject]</strong></p></li><li><p>嵌套模块和类时,继承也是线性的</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M3</span></span></span><br><span class="line">  <span class="keyword">include</span> M2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line">  <span class="keyword">include</span> M3</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p C.ancestors <span class="comment">#=&gt; "[C, M3, M2, M1, Object, Kernel, BasicObject]"</span></span><br></pre></td></tr></table></figure></li><li><p>多次使用include嵌套同一模块,忽略已经包含的模块</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M1</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M2</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line">  <span class="keyword">include</span> M2</span><br><span class="line">  <span class="keyword">include</span> M1</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p C.ancestors  <span class="comment">#=&gt; "[C, M2, M1, Object, Kernel, BasicObject]"</span></span><br></pre></td></tr></table></figure></li></ol><p>之前提到单例方法时,都是使用 “ class &lt;&lt; 实例 ~ end “ 的形式定义单例方法</p><p>对于类(Class类的实例)来讲,就是进行类方法的定义</p><p>出了使用这种形式以外,我们还可以灵活使用模块,来实现单例方法</p><p><strong>同之前的例子,看一下这个例子</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"hello"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="comment">#module_function :hello</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">"world"</span></span><br><span class="line">str1.extend(Hello)</span><br><span class="line">p str1.hello    <span class="comment">#=&gt; "hello"</span></span><br><span class="line">p str2.hello    <span class="comment">#=&gt; "nil"in `&lt;main&gt;': undefined method `hello' for   "world":String (NoMethodError)</span></span><br></pre></td></tr></table></figure><p><strong>将单例方法,定义成为模块函数,之后对单例使用Object#extend方法,进行单例方法的扩展即可</strong></p><p><strong>注意: 其中的module_funcation是不能有的,他会将模块函数定义为某唉进行调用的外部函数</strong></p><p><strong>如果将类作为实例,那自然就是类方法了,</strong></p><p>现在,我们可以系统的来说:</p><p><strong>使用模块,一方面可以利用Mix-in特性来,扩展类.另一方面,可以使用Object#extend方法来扩展单例</strong></p><p><strong>即,使用include可以帮助我们突破继承的限制.extend可以跨过类,使用模块来扩展对象</strong></p><h3 id="类与Mix-in"><a href="#类与Mix-in" class="headerlink" title=" 类与Mix-in"></a><5> 类与Mix-in</5></h3><p>之前说过很多次类方法</p><p>我们可以这样理解类方法:</p><p><strong>1. Class类的实例方法 (任何类都是Class类的实例)</strong></p><p><strong>2. 类对象的单例方法(只对此类适用,对其他类不适用,这些类都作为对象来考虑)</strong></p><p>所以,在扩展类的方面,我们这样综合类与模块</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Hello</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"hello,method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Bye</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bye</span></span></span><br><span class="line">    puts <span class="string">"Bye,method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">  <span class="keyword">include</span> Hello         <span class="comment">#=&gt; include将Hello模块扩展为类的实例方法</span></span><br><span class="line">  extend Bye            <span class="comment">#=&gt; extend将Bye扩展为类的类方法</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = Test.new</span><br><span class="line">p m.hello</span><br><span class="line">p Test.bye</span><br></pre></td></tr></table></figure><p>又扯到之前提到过的: <strong>其实Ruby中一切皆对象,所谓的类方法其实也是实例方法</strong></p><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>这部分,我也不时啃的十分清楚,说说下面几个问题:</p><ol><li><p>什么是对象</p></li><li><p>封装与多态</p></li><li><p>鸭子类型</p></li></ol><hr><p><em>来说点其他的吧,寒假学习,确实容易放松,这篇博客拖了很长时间</em></p><p><em>一方面是理解起面向对象,走了一点弯路,另一方面还是太皮了</em></p><p><em>不过现在搞得差不多了,Ruby整个语法框架差不多了</em></p><p><em>后面也就是运算符,异常处理,块的内容,理解消化挺快的</em></p><p><em>接下来,就是一系列Ruby默认类的内容了,很方便,有各种黑魔法(可能就拖起来看了,唉~)</em></p><p><em>之前逛得太多了,下来改回归Kernel的任务了</em></p><p><em>驱动,CS:APP还是要好好对待,估计到开学勉强差不多</em></p><p><em>对了,还有算法题,那就好好写写BFS与DFS吧,写的深入一点</em></p><p>February 15, 2018 3:41 AM</p>]]></content>
      
      <categories>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby学习笔记(二)</title>
      <link href="/2018/02/06/Ruby/Ruby2/"/>
      <url>/2018/02/06/Ruby/Ruby2/</url>
      <content type="html"><![CDATA[<p><em>之前一直不清楚OOP,对OOP最深的印象就是,所有的函数直接” . “进行调用</em></p><p><em>那么,今天就来看看所谓的”函数”,即方法的相关内容</em></p><h2 id="一-方法"><a href="#一-方法" class="headerlink" title="一 方法"></a>一 方法</h2><p>什么是方法?</p><p><strong>由对象定义的与对象有关的操作,Ruby中将对对象的操作封装成为方法</strong></p><p>从smartalk沿承下来的一个概念:<strong>发送消息</strong></p><p>将对象作为消息的接收者,通过调用方法的形式,将消息(方法)发送给对象,</p><p><strong>把参数和消息一起发送给对象的过程,叫方法的调用</strong></p><p><strong>切记: Ruby中方法的调用,可以省略括号,(必要时刻避免不必要的理解错误)</strong></p><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title=" 方法的调用"></a><1> 方法的调用</1></h3><p>分为以下三种:</p><ol><li><p>简单方法的调用</p></li><li><p>带块方法的调用</p></li><li><p>运算符形式的方法调用</p></li></ol><p>此处仅为了解,之后会详解三种方法调用</p><p>注意:</p><p><strong>1. 带块的方法,像之前说的,do ~ end 与 { ~ }可以替换,但是,do ~ end可以省略参数列表的括号</strong></p><p><strong>反之,{ ~ }只有在没有参数时,才可以省略括号,有一个以上都不能省略括号</strong></p><p><strong>2. 运算符形式的方法可以重定义,有的可以,有的则不行</strong></p><h3 id="方法的分类"><a href="#方法的分类" class="headerlink" title=" 方法的分类"></a><2> 方法的分类</2></h3><p>方法同时也可以根据接收对象来进行分类:</p><ol><li><p>实例方法</p></li><li><p>类方法</p></li><li><p>函数式方法</p></li></ol><p><strong>实例方法: 就像表面含义一样,是给类的实例对象进行调用的方法,就是常见的函数调用</strong></p><p><strong>类方法: 给类进行使用的方法</strong></p><p>例如,我们常见的创建对象的方法,就是类方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.new</span><br><span class="line">File.open(filename)</span><br></pre></td></tr></table></figure><p>同时,不直接对实例操作,而是通过所属的类进行属性的改变时,也使用类方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.rename(old_name, new_name)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实例方法:</span></span><br><span class="line">filename = ARGV[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># file = File.open(filename)</span></span><br><span class="line">text = file.read</span><br><span class="line">file.close</span><br><span class="line"></span><br><span class="line"><span class="comment">#类方法:</span></span><br><span class="line">text = File.read(filename)</span><br></pre></td></tr></table></figure><p><strong>同时,切记,类方法也可以这样调用 “::”,省得以后概念看不懂</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = File::read(filename)</span><br></pre></td></tr></table></figure><p><strong>函数式方法: 没有接受者的方法即为函数式方法,(其实到后面就知道,接受者是self)</strong></p><p><strong>叫函数式方法,是因为此类方法不关心接受者是谁,反过来,就是没有接收者的方法为函数式方法</strong></p><blockquote><p>另外解释一个情况: Array#new, 这是Ruby文档中对方法名的标记形式</p></blockquote><h2 id="二-方法的定义"><a href="#二-方法的定义" class="headerlink" title="二 方法的定义"></a>二 方法的定义</h2><p><em>上面说了这么多,也该说说方法的定义了</em></p><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title=" 方法的定义"></a><1> 方法的定义</1></h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 方法名<span class="params">(参数列表)</span></span></span><br><span class="line">  进行的处理</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>方法名可有下划线,字母,数字组成,不能以数字开头</strong></p><p>下面看几个例子:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span></span></span><br><span class="line">  puts <span class="string">"my name is <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name = <span class="string">"ruby"</span>)</span></span>    <span class="comment"># 指定无参数时的默认值</span></span><br><span class="line">  pust <span class="string">"my name is <span class="subst">#&#123;name&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>带块的方法,类方法,会在介绍了类之后进行接受到介绍</em></p><h3 id="方法的返回值"><a href="#方法的返回值" class="headerlink" title=" 方法的返回值"></a><2> 方法的返回值</2></h3><p>下面有几条方法返回值的规则:</p><p><strong>有return时:</strong></p><ol><li><p>reutrn的值即为返回值,且立刻返回</p></li><li><p>return后无从参数,则返回 nil 例如print返回值就为nil</p></li></ol><p><strong>无return时</strong></p><ol><li><p>方法的最后一个表达式,即为返回值</p></li><li><p>上一条规则不一定正确,程序流结束处为返回值,</p></li></ol><h3 id="参数个数不确定时"><a href="#参数个数不确定时" class="headerlink" title=" 参数个数不确定时"></a><3> 参数个数不确定时</3></h3><p>在C中,实现可变从参数,使用的便是&lt; stdarg.h &gt;中的宏,Ruby就没这么复杂了</p><p>在参数列表中,<strong>*var(变量名)</strong>,则方法会把所有的参数封装为数组,</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">math</span><span class="params">(arg, *args)</span></span></span><br><span class="line">  [arg, args]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p math(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#=&gt; [1, [2, 3, 4]]</span></span><br></pre></td></tr></table></figure><p><strong>切记: 每个方法的参数列表中,不定参数列表,只能出现出现一次! ! !</strong></p><p><strong>类似于多重赋值的用法</strong></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title=" 关键字参数"></a><4> 关键字参数</4></h3><p>之前,提到了,Ruby方法中<strong>需要参数按顺序指定类型值进行调用</strong></p><p>所以,有了关键字参数的用法(ruby2.0的新特性)</p><p><strong>关键字参数: 将变量名与变量值,成对的传进方法中</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method_name</span><span class="params">(<span class="symbol">arg1:</span> value1, <span class="symbol">arg2:</span> value2, ...)</span></span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>关键字从参数的好处: 参数可以不按照默认顺序调用, 而且可以省略其中的任意参数</strong></p><p><strong>但是,将未定义的参数名传给方法时,会报错</strong></p><p>因为上面提到了,未定义的参数名,所以我们有一个处理未定义参数名的方法: <strong>**args参数</strong></p><p><strong>在方法定义中,使用此参数,用于回收未定义的参数名以及变量值,并以hash的形式保存</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">meth</span><span class="params">(<span class="symbol">x:</span> <span class="number">1</span>, <span class="symbol">y:</span> <span class="number">2</span>, **args)</span></span></span><br><span class="line">  [x, y, args]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p meth(<span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">9</span>, <span class="symbol">z:</span> <span class="number">0</span>) <span class="comment">#=&gt; [5, 9, &#123;:z=&gt;0&#125;]</span></span><br></pre></td></tr></table></figure><p><strong>同时,可以直接将hash作为参数传递,会使用与关键字参数匹配的方法进行参数,变量名的核对</strong></p><p><strong>因为,关键字参数的实现,就是参考传递hash作为参数而来的</strong></p><p><strong>最后,建议大家,多多使用关键字参数,很方便</strong></p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title=" 小技巧"></a><5> 小技巧</5></h3><h4 id="1-将数组作为参数传递"><a href="#1-将数组作为参数传递" class="headerlink" title="1. 将数组作为参数传递"></a>1. 将数组作为参数传递</h4><p>之前,看到过,hash作为参数,我们也使用了,*args的形式,进行不定参数的封装</p><p>所以,我们可以使用<strong>*args的形式</strong>,将数组作为参数传递</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x, y, z)</span></span></span><br><span class="line">  x + y + z</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">foo(<span class="number">1</span>, *a)</span><br></pre></td></tr></table></figure><p><strong>但是,数组与参数列表的数目一定要核实,相等</strong></p><blockquote><p>区分: *args的不同用法</p></blockquote><blockquote><p>在方法调用时,*args,表示将数组中的参数一一传递</p></blockquote><blockquote><p>方法定义时,*args,表示接收不定参数</p></blockquote><h2 id="三-聊聊Ruby的格式"><a href="#三-聊聊Ruby的格式" class="headerlink" title="三 聊聊Ruby的格式"></a>三 聊聊Ruby的格式</h2><h3 id="换行"><a href="#换行" class="headerlink" title=" 换行"></a><1> 换行</1></h3><p>Ruby中以一行结束作为语句结束的标识</p><p><strong>它也可以使用 ; 作为结束的标识</strong></p><p>一般不建议用; ,用一行结束来表示语句的结束,简洁明了</p><h3 id="缩进"><a href="#缩进" class="headerlink" title=" 缩进"></a><2> 缩进</2></h3><p>Ruby也有缩进,但是,使用的是软缩进(2个空格的Tab)</p><p>同时,搭配上do ~ end使得程序结构清晰明了</p><h3 id="空白"><a href="#空白" class="headerlink" title=" 空白"></a><3> 空白</3></h3><p>Ruby中针对于空白要求比较严格</p><p>不能乱空白</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a + b   O</span><br><span class="line">a+b     O</span><br><span class="line">a +b    X</span><br><span class="line">a+ b    X</span><br></pre></td></tr></table></figure><p><strong>上面第三种写法的问题很严重,意思时,调用名为+,参为b的方法 ！！！</strong></p><p>最后，要想写出好看，优雅的代码，离不开参考别人的代码，推荐Rails的学习！</p><p>(当然,我离那一步还有点距离)</p><p><em>方法很重要,定义了对象的行为,下一篇的类与模块,可以说是Ruby的精华之一了</em></p><p>February 6, 2018 2:58 PM</p>]]></content>
      
      <categories>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby学习笔记(一)</title>
      <link href="/2018/02/01/Ruby/Ruby1/"/>
      <url>/2018/02/01/Ruby/Ruby1/</url>
      <content type="html"><![CDATA[<p>[TOC]<br><em>之前写博客太作逼了,说到底,博客还是给自己看的,所以,以后的博客可能不是那么的说人话</em></p><h2 id="一-杂项"><a href="#一-杂项" class="headerlink" title="一. 杂项"></a>一. 杂项</h2><ol><li><p>Ruby中可以子符串中获取到变量的值,不同于C中的”%”控制符,也不同于VimScript中的${}</p><p> <strong>Ruby中使用的是#{var},在子符串中获取到变量的值</strong></p></li><li><p>调用类时,需要写类名,当然也可以 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> Math</span><br></pre></td></tr></table></figure><p>之后就可以随便使用Math中的方法</p></li><li><p>“string”,会进行转义, ‘string’不会进行转义</p></li><li><p>Ruby中的数组是动态数组,会自动根据需求调整数组大小,所以要写具有Ruby风格的数组操作代码</p><p> 比如</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = []</span><br><span class="line">array[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">p array <span class="comment">#=&gt; [nil, nil, 3]</span></span><br><span class="line">   p array.szie <span class="comment">#=&gt; 3</span></span><br></pre></td></tr></table></figure><p> 总之,在符合标准的条件下,自由进行代码组织,Ruby是非常灵活的,给”人”写的语言</p></li><li><p>散列的两种组织方法</p><p> 由于散利的键一般是符号/字符串,我们倾向于使用符号,<strong>因为只是判断相等与否,符号的开销小</strong></p><p> 那么,就有两种散利的创建方法,一种是转换为符号(符号化),一种是直接操作符号</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">:foo</span> =&gt; <span class="string">"1"</span>, <span class="symbol">:soo</span> =&gt; <span class="string">"2"</span>&#125;</span><br><span class="line">hash_test = &#123;<span class="symbol">foo:</span> <span class="string">"1"</span>, <span class="symbol">soo:</span> <span class="string">"2"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>正则表达式的用法</p><p> 既然是脚本语言,那么正则的使用是必不可少的,Ruby使用正则时是这样的</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/ =~ string</span><br></pre></td></tr></table></figure><p> 就是这样进行匹配的,其中的pattern为模式串,即常写的正则表达式</p></li><li><p>从命令行获取输入使用的是预定义数组(伪变量),切记,<strong>ARGV[x]中取出的是字符串,需要to_?方法</strong></p></li><li><p>区分<strong>类</strong>与<strong>库</strong>,刚接触,还混淆过,require用来引用库,就像include之于C一般</p></li></ol><h2 id="二-对象-变量-常量"><a href="#二-对象-变量-常量" class="headerlink" title="二, 对象,变量,常量"></a>二, 对象,变量,常量</h2><p>来捋一捋概念:</p><p><strong>Ruby中数据的基本单位是对象,对象有很多种</strong></p><p><strong>对象的特征,可以进行的操作,全部由类进行封装,</strong></p><p><strong>实例就是对象,实例的说法是对类而言的,类就像是一类东西,实例就是其中一个具象的表达,即为对象</strong></p><p><strong>所以,在Ruby中,实例即为对象</strong></p><p><strong>另外,还有容器这个名词,那么,什么是容器,array,hash就是容器,因为他们是存放对象的对象</strong></p><h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1. 变量的类型"></a>1. 变量的类型</h3><p>Ruby也不复杂,变量类型就四种:</p><p><strong>局部变量(英语字母或_开头),全局变量($),实例变量(@),类变量(@@)</strong></p><p>另外,注意伪变量,<strong>false, true, ARGV, nil</strong>,这些即使赋值了,值也不会改变的</p><p><strong>同其他编程语言(C),变量未经初始化,不能进行使用,会抛出异常</strong></p><h3 id="2-常量"><a href="#2-常量" class="headerlink" title="2. 常量"></a>2. 常量</h3><p>常量要注意两点:</p><p><strong><1>.常量不能重复赋值,会抛异常</1></strong></p><p><strong><2>.Ruby中的常量都是大写字母</2></strong></p><h3 id="3-灵活的使用多重赋值"><a href="#3-灵活的使用多重赋值" class="headerlink" title="3. 灵活的使用多重赋值"></a>3. 灵活的使用多重赋值</h3><h3 id="4-变量的命名方法"><a href="#4-变量的命名方法" class="headerlink" title="4. 变量的命名方法"></a>4. 变量的命名方法</h3><p>简单地来说,就三点:</p><p><strong><1>.使用含义清晰,不冗杂的命名</1></strong></p><p><strong><2>.变量和方法使用下划线命名法</2></strong></p><p><strong><3>.类名和模块名使用驼峰命名法</3></strong></p><h2 id="三-条件判断"><a href="#三-条件判断" class="headerlink" title="三, 条件判断"></a>三, 条件判断</h2><p>条件判断,其中重要的是:<strong>Ruby中何为真假值</strong></p><table><thead><tr><th>真假</th><th>类型</th></tr></thead><tbody><tr><td>真</td><td>false/nil以外所有值</td></tr><tr><td>假</td><td>fasle, nil</td></tr></tbody></table><p><strong>从C转过来的,要十分注意这里</strong></p><p>语句,看一下下面的例子就懂了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">elsif</span> condtion <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unless</span> condtion <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> object <span class="keyword">then</span></span><br><span class="line"><span class="keyword">when</span> value1 <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">when</span> value2 <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">do</span> something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>ruby的条件判断就上面三种语句,</p><p><strong>从静态语言到脚本语言,是有点不适应,语法太过于灵活自由</strong></p><p><strong>方法调用,可以不给参数加括号,</strong></p><p><strong>上面三种于语句的条件(condtion)都不需要括号,同时then也都也可以省略</strong></p><p><strong>但是,虽然语法自由,要写出自己的风格</strong></p><p>既然语法自由,所以,可以将if/unless作为修饰符</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">"a &gt; b"</span> <span class="keyword">if</span> a &gt; b</span><br><span class="line">puts <span class="string">"a &gt; b"</span> <span class="keyword">unless</span> a &lt;= b</span><br></pre></td></tr></table></figure><p>语句处理比较简单地时候,可以这样写,写得更加优雅,而不是在if ~ then ~ end 块中就只有一条语句</p><h3 id="2-聊聊对象的同一性"><a href="#2-聊聊对象的同一性" class="headerlink" title="2. 聊聊对象的同一性"></a>2. 聊聊对象的同一性</h3><p>既然Ruby中数据的基本单位是对象,那么,如何区分看上去相同的对象呢?</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">str1 == str2 ? ? ?</span><br></pre></td></tr></table></figure><p>上面使用”==”不太恰当,是为了说是否相等</p><p>答案是:<strong>值相等,但并非是同一对象</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p str1.object_id <span class="comment">#=&gt; 10476400</span></span><br><span class="line">p str2.object_id <span class="comment">#=&gt; 10437580</span></span><br></pre></td></tr></table></figure><p>很显然,并不相同</p><p>所以我们,可以使用方法来进行判断,下面提到两个极易混淆的方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.equal?(str2) <span class="comment">#=&gt; false    检查是否为同一对象</span></span><br><span class="line">str1.eql?(str2) <span class="comment">#=&gt; true       检查是否相等</span></span><br></pre></td></tr></table></figure><p>但是,eql?方法,进行检查是否相等时,内部实现,相对于 == 更为严谨</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.eql?(<span class="number">1.0</span>) <span class="comment">#=&gt; false</span></span><br><span class="line">p <span class="number">1</span> == <span class="number">1.0</span> <span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure><p>尤其是在散列值得获取时,要十分注意,散列的内部实现是eql?方法</p><p><strong>同时,我们自己在构建方法,是,也要遵守返回值为真假时,以?结尾的方法名</strong></p><h3 id="3-nil是什么"><a href="#3-nil是什么" class="headerlink" title="3, nil是什么"></a>3, nil是什么</h3><p>之前说过,Ruby中真假值的判断与C有所不同,C中,NULL是什么?</p><p><strong>NULL指空指针,实际上是啥?</strong></p><p><strong>就是这个,(void *)0</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL (void *)0</span></span><br></pre></td></tr></table></figure><p>所以,NULL可以所谓假的判断条件,</p><p><strong>而nil指的是对象不存在,这样一想,所以nil也可以作为假的判断条件</strong></p><h2 id="四-循环控制"><a href="#四-循环控制" class="headerlink" title="四, 循环控制"></a>四, 循环控制</h2><p><strong>循环的部分,有着这些注意的</strong></p><p>for语句的用法</p><p>与C中稍有不同</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> object <span class="keyword">do</span></span><br><span class="line">  loop something</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">这个对象还可以是,动态生成的(x..y)</span><br></pre></td></tr></table></figure><p>来看看Ruby中循环控制符</p><table><thead><tr><th>控制符</th><th>作用</th></tr></thead><tbody><tr><td>break</td><td>跳出循环</td></tr><tr><td>next</td><td>结束此次循环,进入下次,类似于continue</td></tr><tr><td>redo</td><td>重复上一次的行为</td></tr></tbody></table><p>关于redo:</p><p><strong>这是一个比较神油的关键字,看下面这个例子</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">"Ruby"</span>, <span class="string">"Python"</span>, <span class="string">"C++"</span>, <span class="string">"Java"</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">name.each <span class="keyword">do</span> <span class="params">|lang|</span></span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">  <span class="keyword">redo</span> <span class="keyword">if</span> i == <span class="number">2</span></span><br><span class="line">  print [i,lang],<span class="string">"\n"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=&gt; </span></span><br><span class="line">[<span class="number">1</span>, <span class="string">"Ruby"</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="string">"Python"</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="string">"C++"</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="string">"Java"</span>]</span><br></pre></td></tr></table></figure><p><strong>当 i == 2 时,执行redo</strong></p><p>程序回到这个块首,重新执行<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>因此,才能跳出循环,否则会变成死循环</p><p><strong>一般情况下,ruby仅提供此关键词,即使是Ruby类库中,一般也不会用到此关键字</strong></p><p><strong>一般,break, next便可以处理大部分情况,即使要用redo,也要十分谨慎</strong></p><p>来看看循环语句的区分,毕竟ruby<strong>提供了6方式来进行循环</strong></p><table><thead><tr><th>不同方式</th><th>主要用途</th></tr></thead><tbody><tr><td>times 方法</td><td>确定循环次数时使用</td></tr><tr><td>for 语句</td><td>从对象中取出元素时使用(each的语法糖)</td></tr><tr><td>while 语句</td><td>自由制定循环条件时</td></tr><tr><td>until 语句</td><td>while比较难懂时,反其道行之</td></tr><tr><td>each 方法</td><td>从对象中取出元素时使用</td></tr><tr><td>loop 方法</td><td>不限制循环次数时使用</td></tr></tbody></table><p><strong>到这里,糖多的语言,写的是真的舒服</strong></p><p><strong>for的内部实现,就是使用each方法</strong></p><h2 id="五-do-end-与"><a href="#五-do-end-与" class="headerlink" title="五, do ~ end 与{ ~ }"></a>五, do ~ end 与{ ~ }</h2><p>这是两种块的写法,</p><p>我们通常有以下的约定:</p><p><strong><1>. 程序跨行时,使用do ~ end的写法</1></strong></p><p><strong><2>. 程序在一行时,使用{ ~ }的写法</2></strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>.times <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">  puts i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=&gt; 10.times &#123;|i| puts i&#125;</span></span><br></pre></td></tr></table></figure><p>这些都是些基础内容,下一次就是些OOP的知识了</p><p>让我吹一句,<strong>人中之龙天下第一 (滑稽)</strong></p><p>February 1, 2018 9:41 PM</p>]]></content>
      
      <categories>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>语法陷阱与词法陷阱</title>
      <link href="/2018/01/21/C/C_Traps_Pitfalls/trap1/"/>
      <url>/2018/01/21/C/C_Traps_Pitfalls/trap1/</url>
      <content type="html"><![CDATA[<p><em>最近重装了系统,/挂载在固态里面是真的快,但是,KDE的中文字体现在搞得我想吃shi,楷体是真的难受</em></p><p>(upate:适应了几天,还不错,谁的Linux有我的楷体sao(滑稽));)</p><p><em>不扯了,不扯了,C陷阱与缺陷是很好的一本书,这一篇是词法与语法中的陷阱</em></p><p><em>其中有几个是很多人整天苦恼地问题呢</em></p><h1 id="词法陷阱"><a href="#词法陷阱" class="headerlink" title="词法陷阱"></a>词法陷阱</h1><h2 id="1-不同于"><a href="#1-不同于" class="headerlink" title="1. = 不同于 =="></a>1. = 不同于 ==</h2><p>这个问题,基本上只要是使用过C语言的都是知道的,赋值运算符与比较运算符是不能混淆的</p><p>尤其是在,选择或者循环控制语句中,混淆使用会导致不可预料的后果</p><p>但是,平时应该如何规避这样的错误呢?</p><p>显式的使用括号进行判别</p><p><strong>一般情况下,在if while等控制语句中需要的是 == 运算符,但是遇到必要的使用 = 进行判断的时候呢?</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*检查新值是否为0*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a = b)</span><br><span class="line">foo( );</span><br><span class="line"></span><br><span class="line">可以写作:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a = b) != <span class="number">0</span>)    <span class="comment">//显式的表示更加明确</span></span><br><span class="line">foo( );</span><br></pre></td></tr></table></figure><h2 id="2-amp-和-不同于-amp-amp-和"><a href="#2-amp-和-不同于-amp-amp-和" class="headerlink" title="2. &amp; 和 | 不同于 &amp;&amp; 和 ||"></a>2. &amp; 和 | 不同于 &amp;&amp; 和 ||</h2><p>在之前看C的书籍与CS:APP都提到了这个问题</p><p>只有在限定数值范围的情况下,才能得到相同的结果</p><h2 id="3-词法分析中的”贪心法”"><a href="#3-词法分析中的”贪心法”" class="headerlink" title="3. 词法分析中的”贪心法”"></a>3. 词法分析中的”贪心法”</h2><p>其实只要了解过,正则表达式的人,就可以很方便的理解贪心法</p><p>即是指:<strong>进行词法分析时,尽可能多的进行运算符的匹配</strong></p><p>比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a---b #=&gt; a -- - b</span><br><span class="line"></span><br><span class="line">y = x<span class="comment">/*p #=&gt; y = x /* p                            */</span></span><br><span class="line"></span><br><span class="line">二义性,应该这样写:</span><br><span class="line"></span><br><span class="line">y = x/(*p)</span><br></pre></td></tr></table></figure><p>而且,在ASCI标准没有出现之前,会有许许多多尴尬的情况</p><p><strong>准确得讲,因为其中不标准的规范,才会有上古时期很难阅读的代码</strong></p><p><strong>而在现在,基本上都支持ASCI标准,所以,好用多了</strong></p><h2 id="4-整型常量"><a href="#4-整型常量" class="headerlink" title="4. 整型常量"></a>4. 整型常量</h2><p>众所周知,在C中支持,二进制,八进制,十进制,十六进制,<strong>采用不同的书写方式</strong></p><p>所以,会出现下面这样的情况,<strong>将十进制误写成其他进制</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> part_number;</span><br><span class="line"><span class="keyword">char</span> *description;</span><br><span class="line">&#125;parttab[] = &#123;</span><br><span class="line"><span class="number">046</span>, <span class="string">"left-handed weight"</span>,</span><br><span class="line"><span class="number">047</span>, <span class="string">"right-handed weight"</span>,</span><br><span class="line"><span class="number">125</span>, <span class="string">"frammis"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面便出现了将十进制误写成八进制的情况,需要严加防范</p><h2 id="5-字符与字符串"><a href="#5-字符与字符串" class="headerlink" title="5. 字符与字符串"></a>5. 字符与字符串</h2><p>…</p><h1 id="语法陷阱"><a href="#语法陷阱" class="headerlink" title="语法陷阱"></a>语法陷阱</h1><h2 id="1-理解函数声明"><a href="#1-理解函数声明" class="headerlink" title="1. 理解函数声明"></a>1. 理解函数声明</h2><p>函数声明,是C中进行程序设计所必不可少的,</p><p>有难度吗?</p><p><strong>有,当你遇到,函数指针,返回值为指针的函数,嵌套时,有你好受的 ! </strong></p><p>来看一个例子,这是选自 &lt; C陷阱与缺陷 &gt; 的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="keyword">void</span>(*)( ))<span class="number">0</span>)( );</span><br></pre></td></tr></table></figure><p>上面这个东西是真的看的人头疼!</p><p>那么,我们拆开来看吧!</p><p>首先,是这一部分,</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(...)<span class="number">0</span>)( );</span><br></pre></td></tr></table></figure><p>可以清楚的看到,</p><p><strong>如果没有后面的0,那么便是进行函数指针的调用,比如 (*fp)( );</strong></p><p><strong>但是,加上0,就不能解释为简单地函数指针调用了,而是进行强制类型转换!</strong></p><p><strong>即,此处是将0,转换成为一个函数指针,这样才能实现需要:调用0位置的子例程</strong></p><p>再来看,括号内的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>(*)( ))</span><br></pre></td></tr></table></figure><p>这里就要介绍一种技巧了,<strong>即是获取到类型转换符的方法</strong></p><p>很简单:<strong>将标识符,分号,去掉之后.用括号封装剩下的内容即可</strong></p><p>来举个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*fp)(ARGV);      <span class="comment">/*其中括号是必要的,因为优先级*/</span></span><br></pre></td></tr></table></figure><p>上面的例子,便是一个返回类型为void的函数指针,函数指针标识符为fp,</p><p>那么,0便是要接受这样的类型转换,将上面的式子转换为类型转换运算符即为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>(*)())</span><br></pre></td></tr></table></figure><p>这样便可以作为0的类型转换符来使用了</p><p>表示含义为”返回值为void类型的函数指针的强制类型转换”</p><p>现在回过头来,我们再整体分析一遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*(<span class="keyword">void</span>(*)( ))<span class="number">0</span>)( );</span><br><span class="line"></span><br><span class="line">(*(强制类型转换为指针,返回值为<span class="keyword">void</span>)调用地址<span class="number">0</span>处)(函数参数);</span><br></pre></td></tr></table></figure><p>上面因为直接进行对0地址处的进程调用,所以写出来的是,强制类型转换为指针类型,</p><p>同时也是因为,此处要操作的是函数指针的缘故.</p><p>这样的形式是真的复杂,所以我们可以使用typedef来进行别名命名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*fp)</span><span class="params">( )</span></span>;</span><br><span class="line"></span><br><span class="line">(*(fp)<span class="number">0</span>)( );</span><br></pre></td></tr></table></figure><p>同时,<strong>也让我更深刻的理解了,typedef的内容,不仅仅命名结构体,还可以命名函数指针</strong></p><p>上面是一个简单地例子,下面我们来看一个更, , ,的例子,库函数中,signal函数的实现</p><p><strong>首先来说说需求: 传参为int型的信号值,另一个参数,值用户制定的函数指针</strong></p><p>首先,我们来设计一个基础的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalfunc</span><span class="params">(<span class="keyword">int</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>很简单对吧,就是一个返回值为空,传参为int值即可</p><p>我们现在需要完成一个需求,声明一个指向signalfunc的函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*sfp)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>没错对吧,sfp即为指向signalfunc的函数指针</p><p>所以,我们的signal函数则可以这样写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(ARGV))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>其中ARGV是signal的参数,那么signal函数的参数是什么呢?</p><p>一个int型的信号值,一个用户自定义的函数</p><p>那么,这就简单了,ARGV可以展开写成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> ,<span class="keyword">void</span> (*)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>所以,现在来看,我们可以这样理解:</p><p><strong>使用函数指针,是为了进行简单的函数调用设计,的那是因为C语言特性</strong></p><p><strong>一直以来使得,C函数原型(过去叫函数声明)理解晦涩,实质上,可以使用递归德斯向来理解(Pangda)</strong></p><p><strong>即,将多层函数指针嵌套的函数原型,进行按层拆封,由内向外,一层一层的进行划分</strong></p><p><strong>其中比较麻烦的就是,函数的参都不一致,所以看起来难以辨别,这种时候使用typedef就清晰明了了</strong></p><p>比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HANDLER)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span>, <span class="keyword">void</span> (*)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">#=&gt; HANDLER signal(<span class="keyword">int</span>, HANDLER);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*k(<span class="keyword">int</span> p, <span class="keyword">int</span>(*l)(<span class="keyword">int</span>, <span class="keyword">void</span>(*m)(<span class="keyword">int</span>))))(<span class="keyword">int</span> o);</span><br></pre></td></tr></table></figure><p>上面这样的形式,一般是比较迷惑人的,</p><p>仔细划分,函数名就是k,就是第一层,<strong>其他全部是调用的函数指针的形式参数名</strong></p><p><strong>这一部分,十分重要,可以让你以后设计出,厉(ri)害(gou)的函数</strong></p><h2 id="2-运算符的优先级"><a href="#2-运算符的优先级" class="headerlink" title="2. 运算符的优先级"></a>2. 运算符的优先级</h2><table><thead><tr><th>运算符</th><th>结合型</th></tr></thead><tbody><tr><td>( ) [ ] -&gt; .</td><td>自左向右</td></tr><tr><td>! ~ ++ – - (type) * &amp; sizeof</td><td>自右至左</td></tr><tr><td>* / %</td><td>自左向右</td></tr><tr><td>+ -</td><td>自左向右</td></tr><tr><td>&lt;&lt; &gt;&gt;</td><td>自左向右</td></tr><tr><td>&lt; &lt;= =&gt; &gt;</td><td>自左向右</td></tr><tr><td>== !=</td><td>自左向右</td></tr><tr><td>&amp;</td><td>自左向右</td></tr><tr><td>^</td><td>自左向右</td></tr><tr><td>｜</td><td>自左向右</td></tr><tr><td>&amp;&amp;</td><td>自左向右</td></tr><tr><td>｜｜</td><td>自左向右</td></tr><tr><td>?:</td><td>自右向左</td></tr><tr><td>assignments</td><td>自右向左</td></tr><tr><td>,</td><td>自左向右</td></tr></tbody></table><p>上面的便是,运算符优先级表,</p><p><strong>反正我觉得不会好记</strong>,一般有两种办法处理优先级问题</p><p><strong>1. 加括号, 2. 背表</strong></p><h2 id="3-注意语句结束标志的分号"><a href="#3-注意语句结束标志的分号" class="headerlink" title="3. 注意语句结束标志的分号"></a>3. 注意语句结束标志的分号</h2><p>C中使用” ; “作为语句的结尾,让人又爱又恨</p><p>好的地方在于:<strong>清晰的标志了语句地结束</strong></p><p>不好的地方在于: <strong>用错的时候,会出现爆炸般的错误</strong></p><p>来看下面这几个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b);</span><br><span class="line">func( );</span><br><span class="line"></span><br><span class="line">等价:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123; &#125;</span><br><span class="line">func( );</span><br></pre></td></tr></table></figure><p>相信很多人都出过这样的错,提前结束判断/循环语句,导致程序出现不可控的错误</p><p><strong>当然,有时候,有必要的话应该这样写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">;</span><br><span class="line">func( );</span><br></pre></td></tr></table></figure><p>写空语句的形式,更加清晰明了,</p><p><strong>想要以格式来进行程序的逻辑控制,在C中是痴心妄想,游标卡尺倒是还可以</strong></p><p><strong>多分号,很危险.同理,少了分号也不得了,来看下面的例子</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">a.one = <span class="number">1</span>;</span><br><span class="line">a.two = <span class="number">2</span>;</span><br><span class="line">a.three = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">等价:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line"><span class="keyword">return</span> a.one = <span class="number">1</span>;</span><br><span class="line">a.two = <span class="number">2</span>;</span><br><span class="line">a.three = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">则指定了main函数的返回值为test结构体,在一定的情况下,会出现爆炸现象的,(此处不会使用缺省类型<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h2 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4. switch语句"></a>4. switch语句</h2><p>关于switch语句,需要注意的点在于:</p><p><strong>关于逻辑控制的break语句</strong></p><p><strong>切记,没有break,则会顺序执行</strong></p><p><del>小组面试也考过的</del></p><p>当然没有绝对的错</p><p>比如在写一个运算器的时候:</p><p><strong>减法也可以转换成为加法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:operation = -operation;</span><br><span class="line"><span class="comment">//此处没有break;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:....</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这种时候加上注释,效果更好呦</span><br></pre></td></tr></table></figure><h2 id="5-函数调用与else"><a href="#5-函数调用与else" class="headerlink" title="5. 函数调用与else"></a>5. 函数调用与else</h2><p><del>其实就是意思一下,大家都懂得</del></p><p><strong>C中函数调用,必须有括号,不然只是计算函数的地址,并不调用,一般linter都会报错</strong></p><p><strong>else,与最紧密相联的if构成一对(在括号不清晰时),还是那句话,不要妄图在C中间加入py那种玩艺(滑稽</strong></p><p>这本书,怎么说,还是因为放假回来,一开始看不进入其他的书</p><p>不过,怎么说,这本书,<strong>还挺好看的,<del>(虽然买的是盗版,不过也是钱啊0)</del></strong></p><p>下一章开始就好玩了</p><p><strong><del>另外,我也想像瑞神一样,分析一波C标准库,起码看完,C自身的特性就都懂了</del></strong></p><p><strong>像Pangda那种OOP的C,我还是不想玩了,dan teng,不如直接rb</strong></p><p>January 23, 2018 11:41 AM</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> CTrapsAndPitfalls </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CS:APP(二)信息的表示与处理</title>
      <link href="/2017/12/30/CSAPP/CSAPP(2)/"/>
      <url>/2017/12/30/CSAPP/CSAPP(2)/</url>
      <content type="html"><![CDATA[<p><em>这一章开始的内容可就是实打实的计算机底层系统知识了,首先,系统信息的表示</em></p><p><em>首先约定,从这一章开始,CSAPP每篇博客,是以两部分组成,一部分是知识总结,另一部分是编码相关</em></p><p><em>语言的描述,仍然以C语言为主,系统基于x86_64的Linux平台</em></p><p><em>同时对于这一章的学习,是从数学原理入手的,不过不用担心,只要拥有高中代数的知识即可</em></p><p><em>PS: 美国高中代数的知识, 中国初中数学知识</em></p><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>首先介绍了信息存储基于的几种进制方式,(2,8,16)</p><p>了解计算机的,基本上都懂,我就不赘述了</p><p>下面来看看<strong>字</strong>数据大小:</p><p><strong>字(word):1 word = 2 bytes = 16 bits 1个字 = 2 个字节 = 16位</strong></p><p><strong>OK,上面这句话其实是错的,他指的是16位机的情况,字其实就是指计算机一次处理数据的字节数,</strong></p><p><strong>视具体的处理器而言,32位机,就是(4字节/字).64位机就是(8字节/字)</strong></p><p><strong>字长(word size): 指明指针数据的标称大小,是进行内存地址编码的描述,简单的讲,就是1个字的字节数</strong></p><p>举个例子: W位字长的操作系统,即是可以访问的内存范围为 0 ~ $2^w-1$</p><p>近年来,32位过渡到64位的趋势越来越明显,内存可访问区域也从4GB扩展到16EB</p><p>而进行编译时,我们可以指定类型,<strong>程序如何运行,不决定于机器,而决定于它是如何编译的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -m32 prog.c     可以运行于32/64位</span><br><span class="line">linux&gt; gcc -m64 prog.c     运行于64位机</span><br></pre></td></tr></table></figure><p>下面来看看C规定的数据类型大小</p><table><tr><td colspan="2">C声明</td><td colspan="2">字节数</td></tr><tr><td>有符号</td><td>无符号</td><td>32位</td><td>64位</td></tr><tr><td>[signed] char</td><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>unsigned short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>unsigned</td><td>4</td><td>4</td></tr><tr><td>long</td><td>unsigned</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>uint32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>uint64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td>\</td><td>4</td><td>4</td></tr><tr><td>float</td><td>\</td><td>4</td><td>4</td></tr><tr><td>double</td><td>\</td><td>8</td><td>8</td></tr></table><p>从上表可以看出,字,是计算机处理数据的单位(基本单位是字节)</p><p><strong>字是地址编码的标称值,所以,C指针的数据类型大小与字长保持一致,我们常说指针4字节,实际上是32位</strong></p><p><strong>而对于64位 sizeof(pointer) = 8</strong></p><h2 id="寻址与字节顺序"><a href="#寻址与字节顺序" class="headerlink" title="寻址与字节顺序"></a>寻址与字节顺序</h2><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>寻址的问题上,我们需要讨论的是,<strong>址,到底指的是什么 ? </strong></p><p><strong>实际上,地址指的是,该变量/数据首字节地址,为什么,多字节存储数据时,不可能表示出所有地址</strong></p><p><strong>所以,使用首字节地址进行表示即可.计算机知道每种数据类型的大小,最后进行切割获取即可</strong></p><p><strong>所以,就有 char *str = “abcd” 的用法, str指这个字符串的首地址</strong></p><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><p>既然提到字节顺序的问题,那么就有一个不得不讨论的问题了</p><blockquote><p>　在之前，数据较小的时候，需要多个字节进行存储时，　直接存储即可</p></blockquote><blockquote><p>　但随着时代的进步，对于一个数据需要进行多个字节存储时，如何安排顺序就是一个问题了！</p></blockquote><p>对于字节顺序的问题，有两种解决方法，可以概括为：</p><p>１. 大端法</p><p><strong>高字节，低地址的存储,与阅读习惯相同</strong></p><p>２. 小端法</p><p><strong>低字节,低地址的存储,与阅读习惯相反</strong></p><p>看下面这个例子:</p><p>对于数字0x01234567编码</p><table><tr><td colspan="6">大端法</td></tr><tr><td></td><td>0x100</td><td>0x101</td><td>0x102</td><td>0x103</td><td></td></tr><tr><td>…</td><td>01</td><td>23</td><td>45</td><td>67</td><td>…</td></tr><tr><td colspan="6">小端法</td></tr><tr><td></td><td>0x100</td><td>0x101</td><td>0x102</td><td>0x103</td><td></td></tr><tr><td>…</td><td>67</td><td>45</td><td>23</td><td>01</td><td>…</td></tr></table><p><strong>大端与小端法并没有优劣性得差异,根据情况去使用即可</strong></p><p>但是,需要注意的是,只要使用了一种编码方式,就必须保持下来</p><p><strong>选择任何字节顺序并没有技术上的差异.只要选择了一种规则,并且始终如一的坚持下去,对于哪种字节排序都是任意的</strong></p><p>在以下三种情况下,字节顺序是十分重要的:</p><ol><li><p>进行网络编程时,需要规定好Client/Server的字节顺序,否则,接受方收到的是反序数据</p></li><li><p>在阅读时,需要指定顺序,最常见的一种情况就是,在阅读反汇编器生成的代码时,若不清楚字节顺序很烦恼</p></li><li><p>编写规避正常的程序时,举个例子,进行C语言强制类型转换时,</p></li></ol><p>下面是一个,查看当前机器时大端还是小端的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2x\n"</span>,*(<span class="keyword">char</span> *)&amp;x);    <span class="string">"78"</span>为小端,<span class="string">"12"</span> 为大端</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释: 取X地址指向的首地址,并打印其值,至于为什么不用10进制,因为中间的数值转换不够清晰明了</p><p>而且从上面可以看出:</p><p><strong>所谓强制类型转换,并没有改变位模式中的内容,只是改变了解读的方式</strong></p><p><strong>从侧面也验证了:信息 = 位 + 上下文,单纯的位数据是没有意义的</strong></p><h2 id="C语言的位运算"><a href="#C语言的位运算" class="headerlink" title="C语言的位运算"></a>C语言的位运算</h2><p>首先,需要介绍的是布尔代数.</p><p>C中的位运算是基于布尔代数的.</p><p>主要介绍,<strong>位级运算,移位运算,逻辑运算</strong></p><h3 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h3><p>主要由<strong> &amp; , | , ^ , ~</strong>等运算符组成</p><p> &amp; 与 | 按位与或已经很常用了</p><p> 重点介绍一下,^, 异或</p><p> <strong>异或,相当于位级运算中的逆元,异或一个重要的性质是:</strong></p><p><strong> ( a ^ b ) ^ a = b </strong></p><p>那么,就可以处理一个很实际的问题,对于100w+1个数,其中50w对数是相同的,如何找出唯一不同的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">res ^= <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是利用异或的性质来处理这个问题 ! </p><p>而位运算常用的最重要的性质,就是求 <strong>掩码</strong></p><p>而掩码的求解,其中需要用到 ~ 取反运算符</p><p>这个时候,使用~0 要比0xFF的可移植性更高</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>C中的逻辑运算,就是 &amp;&amp;, || , ! 与或非,三种</p><p>不管是从符号上,还是从使用上,都很容易与位运算混淆</p><p><strong>区分位运算与逻辑运算:</strong></p><p><strong>1.位运算只有在特殊的情况下,或者被限制在0~1之间,才会与逻辑运算有相同的行为</strong></p><p><strong>2,另一个重要的区别就是,逻辑运算的中断/短路原则,p&amp;&amp;*p++ 并不会导致空指针的访问</strong></p><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>移位运算中,具体概念不再赘述</p><p>更重要的是谈一谈两种移位方式以及对编程影响:</p><p><strong>左移: 都是逻辑的,补0</strong></p><p><strong>右移: 分为算术右移,逻辑右移.unsigned为逻辑右移,补码为算术右移,要保证正负性</strong></p><p>然而,问题来了,对于不同的编辑器与机器,右移到底是逻辑的,还是算术的,界定并不是很清楚,是情况而定</p><p><strong>一般情况下,假定机器对于有符号数,算术右移.同时,对于无符号数,右移必须是逻辑的</strong></p><blockquote><p>在Java中,对于右移的类型界定十分清楚</p></blockquote><blockquote><p>“&gt;&gt;” 表示逻辑右移</p></blockquote><blockquote><p>“&gt;&gt;&gt;” 表示算术右移</p></blockquote><h2 id="整数编码"><a href="#整数编码" class="headerlink" title="整数编码"></a>整数编码</h2><p><em>接下来的内容,可谓是本章的精华了,计算机如何存储数制与信息 ? 如何规避错误而写出正确的代码 ? </em></p><p><em>一一,都会的到解答</em></p><p><em>简述本节: 介绍以无符号数(Unsigned)与补码(有符号数)T为主</em></p><p><em>接下来,会先引入一系列的数学术语</em></p><table><thead><tr><th>符号</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>$B2T_w$</td><td>函数</td><td>二进制转补码</td></tr><tr><td>$B2U_w$</td><td>函数</td><td>二进制转无符号数</td></tr><tr><td>$U2B_w$</td><td>函数</td><td>无符号数转二进制</td></tr><tr><td>$U2T_w$</td><td>函数</td><td>无符号数转补码</td></tr><tr><td>$T2B_w$</td><td>函数</td><td>补码转二进制</td></tr><tr><td>$T2U_w$</td><td>函数</td><td>补码转无符号数</td></tr><tr><td>$TMin_w$</td><td>常数</td><td>最小补码</td></tr><tr><td>$TMax_w$</td><td>常数</td><td>最大补码</td></tr><tr><td>$UMax_w$</td><td>常数</td><td>最大无符号数</td></tr><tr><td>$+_w^t$</td><td>操作</td><td>补码加法</td></tr><tr><td>$+_w^u$</td><td>操作</td><td>无符号数加法</td></tr><tr><td>$*_w^t$</td><td>操作</td><td>补码乘法</td></tr><tr><td>$*_w^u$</td><td>操作</td><td>无符号数乘法</td></tr><tr><td>$-_w^t$</td><td>操作</td><td>补码减法</td></tr><tr><td>$-_w^u$</td><td>操作</td><td>无符号数减法</td></tr></tbody></table><p>32位机器与64位机器夹杂,是目前的趋势,下面看一看C语言要求的数据类型最低标准</p><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>[signed] char</td><td>-127</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned</td><td>0</td><td>6555</td></tr><tr><td>long</td><td>-2147483647</td><td>2147483647</td></tr><tr><td>unsigned long</td><td>0</td><td>4294967295</td></tr><tr><td>int32_t</td><td>-2147483647</td><td>2147483647</td></tr><tr><td>uint32_t</td><td>0</td><td>4294967295</td></tr><tr><td>int64_t</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td>uint64_t</td><td>0</td><td>18446744073709551615</td></tr></tbody></table><p><em>C/C++支持有/无符号数,Java只支持无符号数(更想学Java了,滑稽)</em></p><h3 id="无符号数-U-与补码-T-的编码"><a href="#无符号数-U-与补码-T-的编码" class="headerlink" title="无符号数(U)与补码(T)的编码"></a>无符号数(U)与补码(T)的编码</h3><p>先来上数学原理:</p><p>$$<br>B2U_w(\vec x) \dot = \sum_{i=0}^{w-1}x_i2^i<br>$$</p><p>$$<br>B2T_w(\vec x) \dot = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i<br>$$</p><p>由上面两式可以看出,不管是二进制位向量转无符号数还是补码,都是权值码</p><p>进行指定位权的赋值即可</p><p>补码的编码规则则是:</p><p><strong>最高位位权为负权重,其余位权为正值,进行位权累加即可,</strong></p><p><em>PS:这里想起了,<del>刘建元</del>发哥,大一讲计导的时候,补码的概念其实解释的不是很清晰,讲的是补码的求法</em></p><p><strong>那么,为什么重点讲补码呢 ? ,这是因为现今的计算机基本上都是采用补码的,原因在下面:</strong></p><table><tr><td rowspan="2"> 数</td><td colspan="4">字长w</td></tr><tr><td>8</td><td>16</td><td>32</td><td>64</td></tr><tr><td rowspan="2">$UMax_w$</td><td>0xFF</td><td>0xFFFF</td><td>0xFFFFFFFF</td><td>0xFFFFFFFFFFFFFFFF</td></tr><tr><td>255</td><td>65535</td><td>4294967295</td><td>18446744073709551615</td></tr><tr><td rowspan="2">$TMin_w$</td><td>0x80</td><td>0x8000</td><td>0x80000000</td><td>0x8000000000000000</td></tr><tr><td>-128</td><td>-32768</td><td>-2147483648</td><td>-9223372036854775808</td></tr><tr><td rowspan="2">$TMax_w$</td><td>0x7F</td><td>0x7FFF</td><td>0x7FFFFFFF</td><td>0x7FFFFFFFFFFFFFFF</td></tr><tr><td>127</td><td>32767</td><td>2147483647</td><td>9223372036854775807</td></tr><tr><td>-1</td><td>0xFF</td><td>0xFFFF</td><td>0xFFFFFFFF</td><td>0xFFFFFFFFFFFFFFFF</td></tr><tr><td>0</td><td>0x00</td><td>0x0000</td><td>0x00000000</td><td>0x000000000000000</td></tr></table><p>从上面可以看出 $|TMin_w|  = TMax_w + 1$</p><p>显而易见,稍不注意,便会产生因此而生的Bug,那么,为什么会有这样的情况出现</p><p><strong>因为,补码表示的一半是负数,另一部分是非负数,占用了一个正数的位置,所以可表示的正数少1</strong></p><p><strong>那么,这与为什么采取补码有关系吗 ? 有 ! ,正因此,数字编码没有浪费,同时规避了一些问题</strong></p><p><strong>所以才采用了补码,而原码,反码的编码方式,存在+/-0,浪费了数字编码</strong></p><p><em>PS:在java中,标准十分明确,而且只允许存在有符号数(Java越来越吸引我了,滑稽)</em></p><h3 id="无符号数与补码转换"><a href="#无符号数与补码转换" class="headerlink" title="无符号数与补码转换"></a>无符号数与补码转换</h3><p>既然存在有两种编码方式,那么这两种方式,总归有需要进行相互转换的时候</p><p>补码转无符号数由下面的两个函数来实现:</p><p>$$<br>T2U_w(x) = x + 2^w ,(x &lt; 0)<br>$$</p><p>$$<br>T2U_w(x) = x ,(x \ge 0)<br>$$</p><p>结合可得:</p><p>$$<br>T2U_w(x) = x + x_{w-1}2^w<br>$$</p><p>当x为负数时,则最高为定为负权值,$-x_{w-1}2^{w-1}$</p><p>而在无符号数中,对于此得解释是正权值,从负到正加上$2^w$,而$x\ge0$,相同</p><p>同上理,无符号数转补码就有下面两个函数实现:</p><p>$$<br>U2T_w(x) = x - 2^w (x \ge TMax_w)<br>$$</p><p>$$<br>U2T_w(x) = x (x &lt; 0)<br>$$</p><p>结合,可得:</p><p>$$<br>U2T_w(x) = -x_{w-1}2^w + x<br>$$</p><p>同上理,不再赘述.</p><p>那么,无符号数与补码的转换,语言是如何实现的?</p><p><strong>不清楚Java的实现机理.但是,在C/C++中,依靠的是强制类型转换</strong></p><p>使用强制类型转换,可以进行不同类型间的转换</p><p><strong>实质:对位的解释改变,不改变位中的值.解释后,位不变,表示的值可能会改变.具体实现,就是上面的函数</strong></p><p><strong>(注:目前讨论的还仅是相同位数的情况)</strong></p><h3 id="数位扩展与截断"><a href="#数位扩展与截断" class="headerlink" title="数位扩展与截断"></a>数位扩展与截断</h3><p>数位扩展/截断有什么用呢?</p><p>这样和你讲吧,作用还是很大的!</p><p><strong>在不同数位间,进行数的转换时,用到的就是数位的扩展(低位到高位)</strong></p><p><strong>那么,同理,(高位到低位)就是数位得截断了</strong></p><p>先来说无符号的扩展</p><p><strong>很简单,给左边加上要求数位的0即可,称为0扩展</strong></p><p>那么,补码的扩展呢?</p><p>来看个公式:</p><p>$$<br>B2T_{w+1}([x_{w-1},x_{w-1},\dots,x_{w-2},\dots,x_0]) = B2T_w([x_{w-1},\dots,x_0])<br>$$</p><p>这种扩展称为,<strong>符号扩展</strong></p><p><strong>符号扩展的原理是,应用 : $2^w - 2^{w-1} = 2^{w-1}$这个属性的,推理略</strong></p><p>上面这两种扩展,<strong>都会保证原数值不改变</strong></p><p>下面来看看,数字的截断.</p><p><strong>数字的截断遵循: 由低位开始截断,对于无符号数这这样</strong></p><p><strong>对于补码,先将补码视为无符号数,之后进行截断,最后转回补码</strong></p><p>$$<br>x’ = x \ mod \ 2^w<br>$$</p><p>原理是$2^{w+t} \ mod \ 2^w = 0 \ (t \ge 1)$</p><h3 id="有符号数与无符号数的建议"><a href="#有符号数与无符号数的建议" class="headerlink" title="有符号数与无符号数的建议"></a>有符号数与无符号数的建议</h3><p><strong>因为程序中经常会使用显式的强制类型转换,或者隐式的自动类型转换,导致了某些非直观的错误</strong></p><p><strong>而这些非直观的细微错误,经常会导致程序的崩溃</strong></p><p>看下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_length</span><span class="params">(<span class="keyword">float</span> a[ ], <span class="keyword">unsigned</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">operation(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环中,如果有不怀好意的人,传入TMax,之类的数,便使程序进入死循环</p><p>实例:</p><p>在FreeBSD开源项目的getpeername()函数的实现上,出现了重大错误</p><p><strong>实际问题出现在传递参数位负值,而memcpy()函数中,len为size_t无符号类型,会导致内存月越界</strong></p><h2 id="数位运算"><a href="#数位运算" class="headerlink" title="数位运算"></a>数位运算</h2><p>前面讨论完了数字的表示,那么后面自然要谈谈数字的运算了</p><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>首先,根据数学知识,易得,两个w位的无符号数相加,可能会溢出为(w+1)位,</p><p>但是,只有w位来表示,所以就要进行<strong>数字的截断</strong>了</p><p>当未溢出时,即为原结果.溢出时,丢弃最高位,即求mod运算即可</p><p>整理后的公式为:</p><p>$$<br>x +_w^u y = (x+y) \ mod \ 2^w<br>$$</p><p>那么,我们很容易知道无符号加法溢出的条件:<strong>当x + y = s, 且 x &gt; s </strong>时,则发生了溢出</p><p>同时,既然知道了加法,那么就可以用此加法来求反</p><p>$$<br>-x_w^u = 2^w -x (x &gt; 0)<br>$$</p><p>$$<br>-x_w^u = x (x = 0)<br>$$</p><p>推理:即为加法求逆,即可</p><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>补码加法,是一项很重要的内容.</p><p><strong>常见的溢出问题,都是由此而生的</strong></p><p>同理,有数学知识,易得,:<strong>补码加法,会发生上下溢出,</strong></p><p><strong>同理,还是进行数位的截断</strong></p><p>正数,少1,表示少了$2^w$</p><p>负数,少1,表示多了$2^w$</p><p>中间值,并不会溢出</p><p>可以通过下面的公式表示:</p><p>$$<br>x +_w^t y = x + y -2^w (x+y\ge TMax_w)<br>$$</p><p>$$<br>x +_w^t y = x+y \ (TMin_w &lt; x+y \leq TMax_w)<br>$$</p><p>$$<br>x +_w^t y = x+y+2^w (x+y &lt; TMin_w)<br>$$</p><p>但是,实际上机器加法的实现,是这样:<strong>先进行补码转无符号数,之后进行加法运算,最后又转回无符号数</strong></p><p>$$<br>x+_w^ty = U2T_w[(x+y)\ mod\ 2^w]<br>$$</p><p>实际实现方式如上</p><p>同理,我们可获取到,检查补码加法溢出的方法:</p><p><strong>x &gt; 0,y &gt; 0, s &lt;= 0 ,发生了正溢出</strong></p><p><strong>x &lt; 0, y &lt; 0, s &gt; 0, 发生了负溢出</strong></p><p>还可以得到补码的非:</p><p>$$<br>-x_w^t = TMin_w (x = TMin_w)<br>$$</p><p>$$<br>-x_w^t = -x (x &gt; TMin_w)<br>$$</p><p>需要十分注意的是,TMin非是自身</p><p>推理:补码加法的逆</p><h3 id="数字乘法"><a href="#数字乘法" class="headerlink" title="数字乘法"></a>数字乘法</h3><p>对于,乘法的内容,没有什么要谈得</p><p>对于无符号数:</p><p>乘法,便是对乘积取模即可</p><p>对于补码而言:</p><p><strong>虽然乘积与无符号数是不同的,但是可以保证其低位等价性</strong></p><p><strong>所以,同加法实现,借助于无符号数的加法实现</strong></p><p>公式如下:</p><p>$$<br>x*_w^u = (x\cdot y)\ mod \ 2^w<br>$$</p><p>$$<br>x*_w^ty = U2T_w[(x\cdot y)\ mod \ 2^w]<br>$$</p><h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><p>下面要谈得是很好玩的东西了,乘法.</p><p>在计算机中,乘法不同与加减法和移位运算.</p><p><strong>乘法的开销十分大,达到10个左右的时钟周期,加减法为1个.即使是Intel Core i7乘法也得3个周期</strong></p><p>所以,计算机,一般情况下是不想做乘法的,更倾向于做加减法和移位</p><p><strong>那么,用加减法和移位运算来优化乘法,不就好了么</strong></p><p>先来看看,移位运算的实质</p><p>$$<br>x &lt;&lt; k = x \cdot 2^k<br>$$</p><p>推导:</p><p>$$<br>  B2U_{w+k}[x_{w-1+k},x_{x-2+k},\cdots,x_{0+k}]<br>$$</p><p>$$<br> = \sum_{i=0}^{w}x_i2^{i+k}<br>$$</p><p>$$<br> = 2^k\sum x_i2^i<br>$$</p><p>$$<br>=2^k\cdot x<br>$$</p><p>有上述推理,可得,移位运算的实质</p><p>那么,我们就可以如此优化乘法:</p><p><strong>将乘数,拆开称为2的幂之和,在分开进行加法运算即可</strong></p><p>举个例子:</p><p>$$<br>x \cdot 13 = x \cdot (2^2+2^3+2^0) = (x&lt;&lt;2)+(x&lt;&lt;3)+x<br>$$</p><p>如此,在一定情况下,可以加速乘法运算.至于实际,取决于机器的指令,与其高度相关</p><p>乘法如此优化,那么除法呢?</p><p><strong>除法相对于乘法更慢,需要30个左右的周期</strong></p><p><strong>举一反三,我们此时应该使用的是右移,逻辑/算术右移具体视情况而定</strong></p><p><strong>而且,除法不能像乘法一样进行累加,只能除以2的幂(移位加速时)</strong></p><p><strong>在无符号数优化除法时,会得到向0舍入的值,而补码除法会视情况而定,正数向下舍入,负数向上舍入</strong></p><p><strong>这便不能保证统一,所以,需要设置”偏置’量,来进行优化调整</strong></p><p>即对于,负值,进行偏置,然后进行移位运算</p><p>偏置值为<strong>x/y,则为 (y-1),推理见CS:APP(P73)</strong></p><p>C语言表达式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &lt; <span class="number">0</span> ? x+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure><p>最后,总结一下,对于正数的运算,都是基于”模运算”的</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>相对于,整数.对于浮点数的介绍,就不是那么多了.</p><p><strong>计算机对于浮点数计算速度的需求 &gt; 准确程度</strong></p><p>首先,需要了解,负数的二进制表示–<strong>使用负幂,与十进制也是类似的</strong></p><h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>IEEE浮点表示,是这里的重点</p><p>IEEE浮点表示,基于这样的形式:</p><p>$$<br>V = (-1)^s \cdot M \cdot 2^E<br>$$</p><p>介绍一下各个符号的含义:</p><p>V: 表示浮点值</p><p>s: 表示符号位</p><p>M: 表示尾数,默认个位是1的</p><p>E: 阶码,即为2的幂</p><p>其中需要注意的是不同位数,M,E的数目不同</p><p><strong>32位: s = 1 , k = 8 , n = 23</strong></p><p><strong>64位: s = 1 , k = 11 , n = 52</strong></p><p><strong>偏置量: $2^{w-1}-1$, 这里的偏置量是为阶码设置的,为了将阶码映射到正数范围</strong></p><p><strong>全部是使用无符号数表示,使用时,减去偏置值,即可获得真正的阶码值</strong></p><p><strong>非规格化值 偏置为$\ 1-Bias$,规格化偏置值为$\ e-Bias$</strong></p><h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>表示的方法限制了浮点数的范围和精度,浮点数只能近似的进行计算,于是如何找到最近的匹配值成为问题</p><p>这就是<strong>舍入</strong>存在的意义了</p><p>一般情况下,舍入:有四种</p><p><strong>向偶数舍入, 向0舍入, 向下舍入, 向上舍入</strong></p><p><strong>默认一般是先偶数舍入</strong></p><p><strong>因为目前对舍入要求不多,暂时掠过</strong></p><h2 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h2><h3 id="合适的数据类型"><a href="#合适的数据类型" class="headerlink" title="合适的数据类型"></a>合适的数据类型</h3><p>从数据类型上可以看出,在不同位数处理器上,对于数据类型的大小界定是不同的</p><p>为此,在ISO99的C标准,即C99中提供了两个新的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int32_t</span><br><span class="line">int64_t</span><br></pre></td></tr></table></figure><p>指定了处理器类型的int数据类型</p><p><strong>显式的使用对应机器上的数据类型,可以避免一些意想不到的错误</strong></p><p><strong>同时,兼容性/可移植性 与 准确性,向来是相悖的,在某些情况下,准确的代码比可移植性更为重要</strong></p><h3 id="提高程序的可移植性"><a href="#提高程序的可移植性" class="headerlink" title="提高程序的可移植性"></a>提高程序的可移植性</h3><p>上面提到了使用准确的,对应于机器的数据类型,但同时,随着计算机的发展</p><p><strong>编写可移植性高的代码,也是众望所归</strong></p><p>那么,提高可移植性有哪些办法呢?</p><p>1.使用运行时确定数据类型的方法</p><p>比如,<strong>sizeof(elemtype)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * byte_pointer</span><br><span class="line">void show_bytes((byte_pointer)start, size_t len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2x"</span>,start[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">show_bytes(byte_pointer(&amp;x),sizefo(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中便使用sizeof(int)提高程序可移植性</p><h3 id="进行标准的编码"><a href="#进行标准的编码" class="headerlink" title="进行标准的编码"></a>进行标准的编码</h3><p>C/C++优化能多的内容是未定义的,需要根据实际情况去界定</p><p>而对于Java,反而是十分稳定的,对于任何的标准,都是一板一眼,(PS:搞的我都想学Java了)</p><p><strong>进行标准规范的编码时,很有用的一个办法是,使用括号,尤其是在你对优先级不是很清楚时,</strong></p><p><strong>不要为了自己的代码优雅,而写出Bug代码</strong></p><p>举个例子: <strong>*process_list-&gt;data ,就是错误的用法</strong></p><p>而<strong>(*process_list)-&gt;data</strong>才是正确的用法,优先级的问题,需要十分注意</p><h3 id="从数字编码中学习"><a href="#从数字编码中学习" class="headerlink" title="从数字编码中学习"></a>从数字编码中学习</h3><p>上面提到了,U,T两类数字编码,那么,就有一个常见的问题了</p><p>当算式中使用的是不同的数字编码时,那么就需要进行强制类型转换,</p><p><strong>在程序员不手动处理的时候,会自动类型转换</strong></p><p>看下面的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; a)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Haha!\n);</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">printf("</span>OK!<span class="string">"\n);</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>你认为结果会是什么?</p><p>实际上结果是,Haha,<strong>给个提示,类型转换的优先级,unsigned &gt; int</strong></p><p>从上面的例子,可以得出,我们要进行正确类型的编码(系统编程的特殊情形除外)</p><p><strong>对于这一处,规定统一的数据类型即可规避这项错误</strong></p><p><strong>准确的了解不同数制的转换,十分重要</strong></p><p><strong>可以参考 CS:APP(P53) 图2-19的进制升级表来理解</strong></p><h3 id="数位的扩展与截断"><a href="#数位的扩展与截断" class="headerlink" title="数位的扩展与截断"></a>数位的扩展与截断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> sx = <span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> uy = sx;</span><br></pre></td></tr></table></figure><p>此处发生的是:<strong>(unsigned int)(int)sx</strong>而不是<strong>(unsigned int)(unsigned short)sx</strong></p><p><strong>所以,对于强制类型转换时,需要十分注意运算符的顺序</strong></p><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>这是这部分第二个重点的内容,</p><p><strong>首先,强调,浮点运算不具有结合性,满足单调性</strong></p><p>举个例子:</p><p>$$<br>(3.14 + \ln10)-\ln10 = 0<br>$$</p><p>$$<br>3.14 + (\ln 10 - \ln10) \neq 0<br>$$</p><p><strong>这便是浮点加法的不可结合性,其他同理</strong></p><p><strong>也告诫我们,进行浮点运算时,需要十分小心</strong></p><h3 id="C语言中的浮点数"><a href="#C语言中的浮点数" class="headerlink" title="C语言中的浮点数"></a>C语言中的浮点数</h3><p>既然谈到了,浮点数,那么正数与浮点数之间的强制类型转换,就不得不提了</p><p><strong>int –&gt; float ,不会溢出,可能被舍入</strong></p><p><strong>int/float  –&gt; double , 能够保证准确的精度</strong></p><p><strong>double –&gt; float , 因为表示范围,精度的减小,可能能够溢出或舍入,丢失精度</strong></p><p><strong>float/double  –&gt; int , 值会向0舍入,而且C标准对于这种情况是未定义的.</strong></p><p><strong>上面这些内容,是作为一个合格程序员,所必须要掌握的,不然是没办法处理好各种各样情况的</strong></p><p><strong>虽然,从理论上讲,应该使用相同的数据类型,但是,那毕竟是痴心妄想,除了某些奇葩语言 (Lisp)滑稽</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSAPP–信息的表示和处理,是内容十分丰富的一章,也是看的我想shi的一章</p><p>因为,浮点数的内容并不是重点,所以并不是很详细,抱歉</p><p>另外,课后习题有时间也可做做,十分有用.</p><p>下一章可就是程序机器级表示了,也不是什么好啃的内容, . . .</p><p>December, 2017 5:17 AM</p>]]></content>
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力量的源泉 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CS:APP(一)计算机系统概述</title>
      <link href="/2017/12/28/CSAPP/CSAPP(1)/"/>
      <url>/2017/12/28/CSAPP/CSAPP(1)/</url>
      <content type="html"><![CDATA[<p><em>一直以来想要了解一下计算机,自己又作死说要先打基础.当然不可否认的是,CSAPP是一本很好看的书</em></p><p><em>但是,一点都不好看.</em></p><p><em>那现在还能怎么办呢 ? 啃吧 ! </em></p><p>首先约定本书的环境 :</p><p>1.Linux操作系统</p><p>2.X86_64架构</p><p>3.C语言描述为主 , 会用到一些C++/Java例子</p><p>从下面的一个简单的程序入手,来讲述整个计算机中的系统流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是任何C语言的初学者,都会接触到的例子,现在已经是任何一门编程语言都会用到的例子了.</p><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>从程序到可执行程序,所经历的过程是我们必须了解的</p><p>它经历了下面这几个过程:</p><h3 id="1-预处理阶段"><a href="#1-预处理阶段" class="headerlink" title="1.预处理阶段"></a>1.预处理阶段</h3><p>预处理器(cpp),根据”#”字符,将指定的 &lt; * . h &gt; 文件替换到此处,同时消去注释之类,生成一个 . i 文件</p><h3 id="2-编译阶段"><a href="#2-编译阶段" class="headerlink" title="2.编译阶段"></a>2.编译阶段</h3><p>编译器(ccl),将文本文件hello.i翻译成为hello.s , 为一个汇编程序 , 代码如下:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">  subq<span class="number">$8</span>, %rsp</span><br><span class="line">  movl$.LCO, %edi</span><br><span class="line">  <span class="keyword">call</span>  puts</span><br><span class="line">  movl  <span class="number">$0</span>, %eax</span><br><span class="line">  addq  <span class="number">$8</span>, %rsp</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>汇编语言可以理解为任何高级语言与底层之间的通用语言接口</p><h3 id="3-汇编阶段"><a href="#3-汇编阶段" class="headerlink" title="3.汇编阶段"></a>3.汇编阶段</h3><p>汇编器(as)将hello.s,翻译成为机器语言,并将其打包成为<strong>可重定位目标程序</strong>,名为hello.o</p><p>用文本编辑器打开,即为乱码</p><h3 id="4-链接阶段"><a href="#4-链接阶段" class="headerlink" title="4.链接阶段"></a>4.链接阶段</h3><p>此阶段链接器(ld)将所有的编译好的.o文件, 与我们的hello.o进行链接, 生成目标程序</p><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p>计算机是软硬结合的,所以了解硬件也是很有必要的</p><h3 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h3><p>总线是一组电子管道, 携带信息字节,并且在各个部件之间进行传递.设定为携带固定的字节数</p><h3 id="2-I-O设备"><a href="#2-I-O设备" class="headerlink" title="2.I/O设备"></a>2.I/O设备</h3><p>input/output设备也是十分必要的.是计算机和外接连接的通道.</p><p>每个I/O设备都通过,控制器/适配器与I/O总线进行连接.</p><blockquote><p>控制器: I/O设备本身或系统的主板上的芯片组</p></blockquote><blockquote><p>适配器: 插在主板槽上的一块卡</p></blockquote><blockquote><p>区别: 在于封装的方式不同</p></blockquote><h3 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h3><p>临时的一个存储设备.</p><p>物理上,靠一堆DRAM实现,即各种各样的随机存储器组成,内存,显存, . . . .</p><p>逻辑上,计算机将这一系列的RAM抽象成为,内存地址空间(详见 &lt; 汇编语言(一) &gt; )</p><p>对每个字节,进行地址编码,使其可以进行访问使用.</p><h3 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h3><p>中央处理器,其中也包含了许多组件.,寄存器,程序计数器,地址加法器等</p><p>常见的操作:</p><ul><li>加载</li><li>存储</li><li>操作</li><li>跳转</li></ul><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>高速缓存的技术,是十分重要的.</p><p>随着计算机发展,存储读取的问题很严峻,有木桶效应可知: 计算机数据处理运行的速度取决于最慢的部分</p><p>计算机中的组件,存储容量更小,更快,每字节造价越高,越贵.</p><p>存储容量更大,更慢,每字节造价越小,越便宜.</p><p>因此,计算机的存储器采取<strong>层次结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L0: 寄存器</span><br><span class="line">L1: L1高速缓存  (SRAM)</span><br><span class="line">L2: L2高速缓存  (SRAM)</span><br><span class="line">L3: L3高速缓存  (SRAM)</span><br><span class="line">L4: 主存       (DRAM)</span><br><span class="line">L5: 本地二级存储 (本地磁盘)</span><br><span class="line">L6: 远程二级存储 (分布式文件系统,Web服务器)</span><br></pre></td></tr></table></figure><p><strong>存储器层次结构主要思想是,从上到下,上一层都是下一层的高速缓存,加速了程序/计算机的速度</strong></p><h2 id="操作系统的抽象"><a href="#操作系统的抽象" class="headerlink" title="操作系统的抽象"></a>操作系统的抽象</h2><p>操作系统,算是计算机应用程序与底层硬件之间的中间件,通过操作系统提供的服务</p><p>使用户可以更好地调用硬件,同时提供了统一的接口进行操作</p><p>那么,操作系统在实现功能的时候,进行了下面的抽象:</p><p><strong>I/O设备 –&gt; 文件</strong><br><strong><br>主存 + I/O设备  –&gt; 虚拟内存</strong><br><strong><br>主存 + I/O设备 + 处理器 –&gt; 进程</strong></p><p>这三个基本抽象概念十分重要!</p><p>由于这三中抽象概念是以后的学习重点,现在就不多赘述了.</p><p>简单阐述一个概念: <strong>信息</strong></p><p>所谓信息是什么? 只是<strong>位</strong>的信息了吗?</p><p>并不是,之前在汇编语言的学习时,就清楚的了解到,位中的数据在不同的地方含义是不同的</p><p><strong>可以是代码,数据,或者指令</strong></p><p>所以,位中的信息,需要结合<strong>上下文</strong>来理解!</p><p><strong>即: 信息 = 位 + 上下文</strong></p><h2 id="系统之间的网络通信"><a href="#系统之间的网络通信" class="headerlink" title="系统之间的网络通信"></a>系统之间的网络通信</h2><p>网络编程,之前也稍微了解过.</p><p><strong>网络,从一方面上来讲,其实也是一个I/O设备</strong></p><p><strong>网络只是扩展了计算机的I/O范围</strong></p><h2 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h2><p>这里介绍三个重要的内容</p><h3 id="1-Amdahl定律"><a href="#1-Amdahl定律" class="headerlink" title="1.Amdahl定律"></a>1.Amdahl定律</h3><p>在计算机科学里,进行计算机性能分析,依靠的是Amdahl定律 :</p><p>$$<br>S = \frac{1}{(1-\alpha) + \alpha/k}<br>$$</p><p><strong>Amdahl定律清晰的说明了:要提高一个系统的性能,必须要提供大部分的性能才可以.</strong></p><h3 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h3><p>计算机中,很重要得两类编程: 并发编程 与 网络编程</p><p>计算机的发展中,有两个需求:</p><ol><li><p>计算的更多</p></li><li><p>计算的更快</p></li></ol><p>并发与并行就是为了处理计算的更快的需求的</p><p>并发(concurrency) : 置一个系统上同时有多个程序</p><p>并行(parallelism) : 表示通过<em>并行</em>来加速计算机的速度</p><p>主要有以下三个层次的概念:</p><p>1.线程级并发</p><p>2.指令级并行</p><p>3.单指令,多数据并行</p><h3 id="3-抽象"><a href="#3-抽象" class="headerlink" title="3.抽象"></a>3.抽象</h3><p><strong>抽象</strong>的概念是在计算机学习中,必不可少的.</p><p>Pangda曾经说过: 递归,抽象,数学归纳法.是很重要得三个东西</p><p>我认为抽象,是能够将实际的例子进行归类为模板/类型.简单的讲,就是能够归类问题,找出解决问题的方法</p><p>前面,也介绍了<strong>文件,虚拟内存,进程</strong>这三个抽象的概念,那么,现在再加上一个:</p><p><strong>虚拟机 = 操作系统 +　处理器 + 主存 + I/O设备</strong></p><hr><h2 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h2><p>因为第一章是全局概括,所以在编程的学习上并没有多少.</p><p>December 31, 2017 4:21 PM</p>]]></content>
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力量的源泉 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ShellScript(三)</title>
      <link href="/2017/12/10/ShellScript/sh3/"/>
      <url>/2017/12/10/ShellScript/sh3/</url>
      <content type="html"><![CDATA[<p><em>比赛将近,sh当然也学的差不多了,学到后面,感觉这门语言,,,活该值只能做脚本语言</em></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在程序设计中,有一些东西是不能缺少的:</p><ol><li><p>顺序语句</p></li><li><p>判断语句</p></li><li><p>循环语句</p></li><li><p>异常语句 (不是所有语言都有)</p></li></ol><p>顺序语句自不必多说,选择判断语句,在sh中简直是,,,</p><p>来看看就知道了.</p><p>之前我们曾经提到过查看命令返回值的方式,</p><p>查看变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$?                     --即可查看命令的返回值</span><br></pre></td></tr></table></figure></p><p><strong>在shellscript中,如果返回值为0即为成功执行,非0值为失败</strong></p><p>在shell中实现测试有这样两种方式:</p><ol><li><p>使用test命令进行测试</p></li><li><p>使用[ ]运算符进行测试</p></li></ol><p>test命令实际意义不大,不必多说.</p><p>使用[ ]来启动一个测试,[ ]的要求就多了,</p><p><strong>首先[(空格) 测试内容 (空格)],两侧必须有空格,中间写测试内容</strong></p><p>至于,测试的结果,那就需要考虑多种多样的测试符了:</p><p>1.文件测试符</p><table><thead><tr><th>文件测试</th><th>说明</th></tr></thead><tbody><tr><td>-b FILE</td><td>当文件存在且是块文件时,返回真,否则为假</td></tr><tr><td>-c FILE</td><td>当文件存在且是字符设备时,返回真,否则为假</td></tr><tr><td>-d FILE</td><td>当文件存在且是个目录时,返回真,否则为假</td></tr><tr><td>-e FILE</td><td>当文件或者目录存在时,返回真,否则为假</td></tr><tr><td>-f FILE</td><td>当文件存在且为普通文件,返回真,否则为假</td></tr><tr><td>-x FILE</td><td>当文件存在且为可执行文件时,返回真,否则为假</td></tr><tr><td>-w FILE</td><td>当文件存在且为可写文件时,返回真,否则为假</td></tr><tr><td>-r FILE</td><td>当文件存在且为可读文件时,返回真,否则为假</td></tr><tr><td>-l FILE</td><td>当文件存在且为连接文件时,返回真,否则为假</td></tr><tr><td>-p FILE</td><td>当文件存在且为管道文件时,返回真,否则为假</td></tr><tr><td>-s FILE</td><td>当文件存在且大小不为0时,返回真,否则为假</td></tr><tr><td>-S FILE</td><td>当文件存在且为Socket文件时,返回真,否则为假</td></tr><tr><td>-g FILE</td><td>当文件存在且设置了SGID时,返回真,否则为假</td></tr><tr><td>-u FILE</td><td>当文件存在且设置了SUID时,返回真,否则为假</td></tr><tr><td>-k FILE</td><td>当文件存在且设置了sticky属性时,返回真,否则为假</td></tr><tr><td>-G FILE</td><td>当文件存在且为有效用户组时,返回真,否则为假</td></tr><tr><td>-O FILE</td><td>当文件存在且为有效用户组时,返回真,否则为假</td></tr><tr><td>FILE1 -nt FILE2</td><td>当文件FILE1比FILE2新时,返回真,否则为假</td></tr><tr><td>FILE1 -ot FILE2</td><td>当文件FILE1比FILE2旧时,返回真,否则为假</td></tr></tbody></table><p>2.字符串测试</p><table><thead><tr><th>字符串测试</th><th>　说明</th></tr></thead><tbody><tr><td>-z “string”</td><td>如果string为空,则返回真,否则为假</td></tr><tr><td>-n “string”</td><td>如果string非空,返回真,否则为假</td></tr><tr><td>“string1” = “string2”</td><td>如果两个串相等,则返回真,否则为假</td></tr><tr><td>“string1” != “string2”</td><td>如果两个串不相等,则返回真,否则为假</td></tr><tr><td>“string1” &gt; “string2”</td><td>字典序,若string1 在string2 前,则为真,否则为假</td></tr><tr><td>“string1” &lt; “string2”</td><td>字典序,若string1 在string2 后,则为真,否则为假</td></tr></tbody></table><p>来说说怎么使用吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmd=`systemctl status sshd | grep running`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$cmd</span>"</span> ];<span class="keyword">then</span>                     -- [ ] 用来启动测试,进行测试时,一定加上引用</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"srevice GG,restart'</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure><p><strong>数字测试,可以不加上引号,但是字符串必须加上引号,所以,统一一下,建议加上引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">"ABCD"</span></span><br><span class="line">str2=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$str1</span>"</span> = <span class="string">"<span class="variable">$str2</span>"</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"相等"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"不相等"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>同时注意,对于字符串序列的比较,需要对 &gt; 以及 &lt; 进行转义</strong></p><p><strong>或者使用 [ [ ] ] 来进行运算</strong></p><p>3.整数测试符</p><table><thead><tr><th>测试符</th><th>说明</th></tr></thead><tbody><tr><td>“num1” -eq “num2”</td><td>-equal</td></tr><tr><td>“num1” -gt “num2”</td><td>-great than</td></tr><tr><td>“num1” -lt “num2”</td><td>-less than</td></tr><tr><td>“num1” -ge “num2”</td><td>-great equal</td></tr><tr><td>“num1” -le “num2”</td><td>-less equal</td></tr><tr><td>“num1” -ne “num2”</td><td>-not equal</td></tr></tbody></table><p>用法同上</p><p>4.逻辑测试符与逻辑运算符</p><p>对,你没有看错,关于逻辑测试的问题,既可以使用逻辑测试符,也可以使用逻辑运算符.</p><p>逻辑测试符</p><table><thead><tr><th>测试符</th><th>说明</th></tr></thead><tbody><tr><td>!expression</td><td>取反</td></tr><tr><td>expression1 -a expression2</td><td>与运算</td></tr><tr><td>expression1 -o expression2</td><td>或运算</td></tr></tbody></table><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>!</td><td>取反</td></tr><tr><td>&amp;&amp;</td><td>与运算</td></tr><tr><td>｜｜</td><td>或运算</td></tr></tbody></table><p>这两个有什么区别呢?</p><p><strong>测试符,是对一个式子进行测试,而运算符起码是对两个运算式的运算</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ -e /var/<span class="built_in">log</span>/1 -a -e /var/<span class="built_in">log</span>/2 ]</span><br><span class="line"></span><br><span class="line">[ -e /var/<span class="built_in">log</span>/1 ] &amp;&amp; [ -e /var/<span class="built_in">log</span>/2 ]</span><br></pre></td></tr></table></figure><p><strong>测试符就这么多内容,现在说说返回值 : </strong></p><p><strong>sh的返回值是比较恶心的,条件测试的返回值与 echo $? 的结果</strong></p><p><strong>$? 是表示上一条命令的结果/返回值 ,说明条件测试的结果,如果为真,则返回值为0.否则为非0</strong></p><p><strong>与C-family或者其他语言有很大的不同…</strong></p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p><strong>sh中有这几种判断的结构</strong></p><p><strong>1. if</strong></p><p><strong>2. if-else</strong></p><p><strong>3. if-elif-else</strong></p><p><strong>4. case语句</strong></p><p>可以用if ~ elif ~ else统一介绍这几种语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="built_in">test</span> ]; <span class="keyword">then</span></span><br><span class="line">command1</span><br><span class="line"><span class="keyword">elif</span> [ <span class="built_in">test</span> ]; <span class="keyword">then</span></span><br><span class="line">command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">command3</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>注意在sh中if的选择判断语句是不使用括号的..,当然也没有py的游标卡尺那么恶心</strong></p><p><strong>下面来看看case语句时怎样使用的 ?</strong></p><p>sh中的case与C中的case区别还是很大的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> VAR <span class="keyword">in</span></span><br><span class="line">var1) command1.1 ; command1.2 ;;</span><br><span class="line">var2) command2.1 ; command2.2 ;;</span><br><span class="line">var3) command3.1 ; command3.2 ;;</span><br><span class="line">*) <span class="built_in">command</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>使用 <strong>;;</strong> case选择的结束</p><p>最后,留有 * 表示 其他选项,即 default选项</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>循环语句也是程序设计语言中所不可缺少的部分</p><p>在sh中有下面这几种循环:</p><p><strong>1. for 循环 </strong></p><p><strong>2. while 循环</strong></p><p><strong>3. until 循环</strong></p><p><strong>4. select 循环</strong></p><p>for循环,在很多语言中都提供支持</p><p>sh中的for也是多种多样,基本上有以下三种形式:</p><p>1.使用列表进行循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> FRUIT <span class="keyword">in</span> <span class="string">"apple banana pair peach"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$FRUIT</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>像这样进行循环即可,但是,列表终归是有限的,</p><p>所以有了第二种,动态生成列表的写法(<strong>不过必须是有规律的内容</strong>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;                    --循环1-5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 5`                 --动态生成列表1-5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 2 5`               --生成列表&#123;1 3 5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后一种,就是C风格的for循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=1 ;  i&lt;10 ; i++))               --循环打印1-10</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>sh的脚本编写,经常需要写一些监测系统服务的程序</p><p><strong>那么,死循环就显得尤为重要了</strong></p><p>for的死循环写法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((; 1 :))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>2.while循环</p><p><strong>其实,客观的讲,while循环应用的场景更多</strong></p><p>来看一看语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面是一个while按行读取文件的程序,可以学习一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> LINE</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> LINE | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line"><span class="built_in">echo</span> LINE | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line"><span class="keyword">done</span> &lt; test.txt</span><br></pre></td></tr></table></figure><p>那么while的无限循环又该怎么写呢?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((1))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">cone</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>以上三种都属于while的永真循环</p><p>最后,还有一种until/select循环,因为应用场景并不是很多</p><p>而且可以使用,for,while替代就不说了(懒得不想写)</p><p><strong>最后,看看其中的循环控制语句</strong></p><p><strong>break continue 与C如出一辙</strong></p><p><strong>但是,这两种控制语句,与C中基本用法一致</strong></p><p>但是,有一个更人性化的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> 1/2/3                 ---数字可以指定跳出循环的次数</span><br><span class="line"></span><br><span class="line"><span class="built_in">continue</span> 1/2/3</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数,是一门程序设计语言中不可缺少的特性.</p><p>函数的使用,提高了程序的<strong>复用性</strong>和<strong>易用性</strong></p><p>来看看sh的函数(中规中矩)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> function_name( )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>[ <span class="built_in">test</span> ];<span class="keyword">then</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> expression</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">command3</span><br><span class="line">command4</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">command</span> x</span><br><span class="line"></span><br><span class="line">(<span class="built_in">return</span> value)          --可选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面便是一个标准的函数模板</p><p>emmmmmmmmmmmmmmmmm</p><p>感觉,sh函数要谈得没多少….</p><p><del>辣鸡得很</del></p><p>捡些重点的说吧:</p><p><strong>1.函数的返回值</strong></p><p>sh中的函数返回值,一定会有返回值</p><p><strong>如果,显示指定return,则返回return后的值</strong></p><p><strong>否则,返回最后一条命令的执行返回值  即为 $?</strong></p><p><strong>2. 函数参数</strong></p><p>sh的函数之间并不能传递参数</p><p><strong>可以调用,命令行参数 $1 $2 $3 $4…</strong></p><p><strong>或者,使用set显式指定参数,则将所有参数覆盖</strong></p><p><strong>3. 函数库的问题</strong></p><p>一般语言,起码会有不少的函数库,</p><p>sh也想用吗?</p><p><strong>告诉你,没有 , 滚</strong></p><p>一般都是自行开发函数库</p><p>不过在/etc/init.d/functions中勉强有27个函数</p><p><strong>使用 source 命令加载自行开发的函数库</strong></p><p><strong>4. 递归</strong></p><p>emmm,这个我不想讲,我也讲不清….</p><p><strong>sh的学习就这么结束吧</strong></p><p><strong>自己的感悟,sh肯定是适合运维的同学去学习,我当时学习sh,一方面是一个比赛需求(TM最后shell命令)</strong></p><p><strong>sh的熟练编写需要基于熟练的Linux系统操作,以及Linux常用命令的熟练使用上</strong></p><p><strong>最后,是因为我觉得sh <del>辣鸡</del>,没什么很有意思的特性</strong></p><p><strong>草草了之,但是,shellscript中的基本特性说的差不多了</strong></p><p><strong>讲个道理,如果不是运维人员,相比与书写shell,看懂shell更为重要</strong></p><p>接下来,就该回归主线了,不能浪了</p><p>December 10, 2017 11:38 PM</p>]]></content>
      
      <categories>
          
          <category> Shellscript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ShellScript(二)</title>
      <link href="/2017/12/05/ShellScript/sh2/"/>
      <url>/2017/12/05/ShellScript/sh2/</url>
      <content type="html"><![CDATA[<p><em>开始学shell挺有意思的,弱类型的语言再也没有写C的时候,那么多繁文缛节了,真特么爽,不过有爽的地方</em></p><p><em>就有扣脚的地方…</em></p><h2 id="shell中的变量"><a href="#shell中的变量" class="headerlink" title="shell中的变量"></a>shell中的变量</h2><p>首先,shell中的变量分为两类,<strong>局部变量和环境变量(全局变量)</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>是每一个shell中可以使用的变量,在不同的shell中,是不能进行使用的</p><p>那么,如何界定一个shell呢?</p><p><strong>bash shell是根据进程号进行界定的,对于每一个进程号,视为一个shell</strong></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在学习Bash中提到过,环境变量,就是指在父shell以下的shell中都可以使用的变量</p><p><strong>shell的环境变量是传下不传上,即向下的子shell,孙shell都可以继承该环境变量</strong></p><p><strong>而向上,父shell的父shell是不能使用的.</strong></p><p><strong>来举个实际的例子,Linux操作系统,登录时就是一个shell.</strong></p><p><strong>所以在他下面的所有子/孙shell的都可以继承环境变量</strong></p><h2 id="预设的环境变量"><a href="#预设的环境变量" class="headerlink" title="预设的环境变量"></a>预设的环境变量</h2><p>在shell中还预设了许多环境变量,这些变量可以直接使用,在shell脚本或者console交互界面</p><p><strong>想让我给你详解吗,做梦,自己看去,</strong></p><h2 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h2><p>在shellscript中,变量的赋值,取值与C中还是有与很大的不同的</p><p><strong>1. 定义变量</strong></p><p>不需要进行类型的声明,弱类型,直接 “变量名=变量值”即可</p><p>注意,变量名与值之间仅仅相连,不允许有空格</p><p>当变量值中需要空格的时候,使用单/双引号括起来,不然会出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Crow@EvilCrow ~]$ var=5</span><br><span class="line">[Crow@EvilCrow ~]$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">5</span><br><span class="line">[Crow@EvilCrow ~]$ var = 6</span><br><span class="line">bash: var: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p><strong>2. 变量取值</strong></p><p>使用变量的值的时候,可以使用 <strong>“$变量名”</strong>,进行值的获取</p><p>严谨一点的写法: <strong>${变量名}</strong></p><p>看下面的例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Crow@EvilCrow ~]$ var=Crow</span><br><span class="line">[Crow@EvilCrow ~]$ <span class="built_in">echo</span> Crow</span><br><span class="line">Crow</span><br><span class="line">[Crow@EvilCrow ~]$ <span class="built_in">echo</span> <span class="variable">$varhello</span>           --bash将varhello视为一个变量</span><br><span class="line"></span><br><span class="line">[Crow@EvilCrow ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span>hello         --bash可以识别var为变量,并非是varhello</span><br><span class="line">Crowhello</span><br></pre></td></tr></table></figure><p>同时,如果需要引用其他变量,必须使用<strong>部分引用(弱引用)” “</strong>  如果使用<strong>强引用 ‘ ‘ </strong></p><p>则并不会进行变量的引用,会将一切视为普通字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Crow@EvilCrow ~]$ var=5</span><br><span class="line">[Crow@EvilCrow ~]$ str=<span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line">[Crow@EvilCrow ~]$ <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">5</span><br><span class="line">[Crow@EvilCrow ~]$ str=<span class="string">'$var'</span></span><br><span class="line">[Crow@EvilCrow ~]$ <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"><span class="variable">$var</span></span><br></pre></td></tr></table></figure><p><strong>3.取消变量</strong></p><p>变量,可以设置,但是有的时候,我们就是想取消变量,那怎么办呢?</p><p><strong>使用unset命令可以取消命令,也可以取消函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> var</span><br><span class="line">var=5</span><br><span class="line"></span><br><span class="line">func_1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"In func_1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"var = <span class="variable">$var</span>"</span></span><br><span class="line">func_1</span><br><span class="line"><span class="built_in">unset</span> var</span><br><span class="line"><span class="built_in">unset</span> func_1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"After unset"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"var = <span class="variable">$var</span>"</span></span><br><span class="line">func_1</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/Screenshot_20171205_222229.png" alt=""></p><p><strong>4. 特殊变量</strong></p><p>常用的特殊变量有以下两类:</p><p><strong>位置变量: $0,$1,$2,$3,$#,$@,$*</strong> ,之前已经提过,不再赘述</p><p><strong>脚本/命令的返回值: $?  ,仅能表示上一个命令的返回值,成功为0,反之为非0</strong></p><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><p>数组,一直是个神奇的东西,很多语言都对其支持,而且合理使用数组,可以方便进行程序设计</p><p>在shellscript中数组,虽然没有其他地方强大,不过也差不到哪里去</p><p><strong>首先,看看与其他语言数组的不同之处:</strong></p><p><strong>1&gt; 区别于C/C++/Java这些编译型语言,sh为弱类型,所以,数组的元素是不会考虑类型的</strong></p><p><strong>2&gt; 在大多数语言中,都是支持高维数组的,但是,sh中仅仅支持到一维数组</strong></p><p><strong>1.定义数组</strong></p><p>定义数组很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array      --即定义了一个数组</span><br><span class="line"></span><br><span class="line">array[0]=0            --对数组中元素进行赋值</span><br><span class="line">array[1]=1</span><br></pre></td></tr></table></figure><p>数组使用起来还是比较像其他语言的,同时可以使用<strong>下标</strong>进行访问</p><p>同时,声明数组,也可以不使用declare关键字,不过就需要声明的同时进行初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a name=(<span class="string">"Crow"</span> <span class="string">"Sue"</span>)</span><br><span class="line">name=(<span class="string">"Crow"</span> <span class="string">"Sue"</span>)</span><br></pre></td></tr></table></figure><p>sh中进行数组元素的增加是很简单的,声明数组后,进行赋值即可</p><p><strong>未定义的下标,可以直接使用进行赋值</strong></p><p><strong>sh中数组用空格进行元素得分隔,不是使用逗号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array=(1 2)</span><br><span class="line"></span><br><span class="line">array[2]=3</span><br><span class="line">array[4]=6</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[*]&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/Screenshot_20171205_235138.png" alt=""></p><p><strong>2.数组操作</strong></p><p>数组操作,在以往的语言中,都是基于函数,方法来进行操作的,毕竟OOP</p><p>但是,在sh中会带给你一种全新的方式进行数组的操作</p><p><strong>1&gt; 数组取值操作</strong></p><p>数组进行取值时,直接使用下标,<strong>*进行索引取值即可</strong>,即 <strong> $ { 数组名 [ 索引 ] } </strong></p><p>同时,@,* 进行整个数组元素的索引方式,还是可以用的,</p><p>比如: <strong>${array[@]} ,${array[*]}</strong></p><p>不过,使用@,元素时列表的形式,但是,使用*,元素是字符串的形式</p><p><strong>2&gt; 求取数组的长度</strong></p><p>在C中使用strlen( )函数</p><p>在Ruby中使用String.length方法获取字符串长度</p><p>在sh中使用 类似于VimScript的方式,进行数组的操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#array[@]&#125;</span>,<span class="variable">$&#123;#array[*]&#125;</span>,即可获取到数组的长度</span><br><span class="line"></span><br><span class="line">使用,(下标为N),<span class="variable">$&#123;#array[N]&#125;</span>,获取字符串的长度</span><br></pre></td></tr></table></figure><p><strong>3&gt; 数组截取</strong></p><p>数组,还可以截取吗?</p><p><strong>答案是肯定的</strong></p><p>数组进行截取的时候,遵循这样的操作规范</p><p>${array[X]:m:n}:　　ｍ表示下标/索引/index</p><p><strong>当Ｘ = */@ 时，表示，截取到从ｍ个元素开始的ｎ个元素</strong></p><p><strong>反之，表示，截取Ｘ元素从ｍ开始的ｎ个字符</strong></p><p><strong>这里，切不可理解为ｍ～ｎ个字符</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">"helloworld"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0:2&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:5:2&#125;</span></span><br><span class="line">var=(<span class="string">'Crow'</span> <span class="string">'Sue'</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var[@]:0:2&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var[@]:0:1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var[@]:1:1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var[1]:1:1&#125;</span></span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/Screenshot_20171206_000836.png" alt=""></p><p><strong>４&gt; 连接数组(拼接数组)</strong></p><p>在其他语言中,合并数组,需要重新分配内存,使用for循环进行赋值,很是麻烦</p><p>在sh中,如下即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name=(<span class="string">"Crow"</span> <span class="string">"Sue"</span>)</span><br><span class="line">address=(<span class="string">"Xi'an"</span> <span class="string">"Shanghai"</span>)</span><br><span class="line">other=(<span class="variable">$&#123;name[@]&#125;</span> <span class="variable">$&#123;address[@]&#125;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;other[@]&#125;</span>    <span class="comment">#=&gt; Crow Sue Xi'an Shanghai</span></span><br></pre></td></tr></table></figure><p>所以,很是方便吧?</p><p><strong>5&gt; 替换元素</strong></p><p>即改变数组中某个元素的值</p><p>讲道理,其实,直接进行赋值即可,但是,sh提供的方法,姑且看看吧.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array=(<span class="variable">$&#123;array[@]/Crow/Evil&#125;</span>)</span><br></pre></td></tr></table></figure><p>即在数组全局中进行替换,这个特性,我不是很苟同</p><p><strong>6&gt; 取消数组/元素</strong></p><p>同上理,使用unset可以取消,数组,变量,函数,全部可以取消</p><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>这一部分也是很简单的</p><p>用法:将变量声明为只读属性,变成常量,避免滥用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -r a=5       --a,已经具有<span class="built_in">readonly</span>属性</span><br></pre></td></tr></table></figure><p>更简单地理解方式,const变量,,,</p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>这一部分内容,其实之前也是提到了很多次</p><p>作用域,即变量的有效作用范围,可以使用,被声明,被分配内存,可以访问的区域</p><p>在sh中,默认是全局变量(环境变量),<strong>这个全局指的是,这一个shell</strong></p><p><strong>在交互界面,就是这一个终端窗口,在脚本里,就是这一个脚本文件,都是有效范围</strong></p><p><strong>而C,是作为auto属性的自动变量,一般是函数中的局部变量,无链接</strong></p><p><strong>sh中的环境变量,有好有坏,进行程序设计时,各个函数间传参数很方便,很容易操纵,但同时</strong></p><p><strong>也有不小的弊端,,比如一些基本的临时变量,循环变量,这些i,j,k,如果进行模块化的开发</strong></p><p><strong>十分危险! ! !</strong></p><p>有以下两种方法进行处理:</p><p>1.进行变量命名时,谨慎命名,命名为不易重复,含义明确的变量名</p><p>2.<strong>使用local命令,可以使变量的作用域局限在函数内部</strong></p><p>看下面这个例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> var</span><br><span class="line">var=5</span><br><span class="line">func_1()</span><br><span class="line">&#123;</span><br><span class="line">    var=6</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"var = <span class="variable">$var</span> in func_1"</span></span><br><span class="line">&#125;</span><br><span class="line">func_2()</span><br><span class="line">&#123;</span><br><span class="line">    var=8</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"var = <span class="variable">$var</span> in func_2"</span></span><br><span class="line">&#125;</span><br><span class="line">func_3()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> var=1000</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"local var = <span class="variable">$var</span> in func_3"</span></span><br><span class="line">&#125;</span><br><span class="line">func_1 </span><br><span class="line">func_2 </span><br><span class="line">func_3</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/Screenshot_20171206_002834.png" alt=""></p><h2 id="转义和引用"><a href="#转义和引用" class="headerlink" title="转义和引用"></a>转义和引用</h2><p>其实转义和引用两个概念,我们平时已经很习惯的用了.</p><p><strong>转义: </strong> 因为一些预留的元字符,不能做为普通字符使用,所以进行转义,转义方法,就是使用 “ \ “</p><p><strong>引用: </strong> 引用是很常用的方法,转义时特殊的引用.</p><p><strong>在sh中,引用,时为了防止字符串被解释为其他含义,常用的引用,双引号,单引号,反引号,反斜杠</strong></p><p><strong>1.双引号为部分引用</strong></p><p>双引号,除了 $,`,\ 这是那种字符以外,都会被解释为普通字符</p><p><strong>2.单引号为强引用</strong></p><p>单引号,可以将一切解释为普通字符,但是单引号,最大的问题是,<strong>单引号,不能嵌套,否则会报错</strong></p><p><strong>3.反引号为命令替换</strong></p><p><strong>命令替换时十分重要的东西</strong></p><p>命令替换,有什么用呢?</p><p><strong>命令替换,可以将命令的结果保存至变量中,使用反引号即可,经常使用</strong></p><p>同时,还另外一种命令替换 <strong> “ $ ( ) “ </strong></p><p><strong>区别:反引号不清晰,且不能嵌套,所以建议使用$()的形式</strong></p><p>同时,需要注意的一点:</p><p><strong>在命令替换后,变量中保存的标准输出是没有换行符的,需要引用才能合理的显示</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>作为一门编程语言,怎么能少的了处理数据的内容呢?</p><p>sh中运算符,主要用于比较整数.所以这些运算符,也是以处理整数的运算为主</p><p>运算符,不多赘述,位运算符同理</p><p><strong>sh中算术运算时基于let命令的</strong></p><p><strong>而且,一般情况下,运算符,数字是要紧紧相连的</strong></p><p><strong>要是不会,就是你特喵的C没学好,自己想办法补</strong></p><h2 id="其他的算术运算符"><a href="#其他的算术运算符" class="headerlink" title="其他的算术运算符"></a>其他的算术运算符</h2><p><strong>1. 使用 $ [ ] </strong></p><p>$ [ ] 可以进行简单的算术运算</p><p>$ [ 1 + 1 ], $ [ 3 / 2 ]</p><p><strong>2. 使用expr</strong></p><p>expr时shell命令,可以进行算术运算,<strong>但是,运算符,数字不能紧紧相连的</strong></p><p>否则会视为,字符串</p><p><strong>3. 使用内建命令 declare</strong></p><p>很多次看见这个命令了,同时它还可以进行算术运算</p><p>declare进行算术运算,其实是显示声明变量为整数, -i参数</p><p><strong>还是要,紧紧相连,同时引用的变量不需要$,至直接使用</strong></p><h2 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h2><p><strong>1. $ ( ( ) )</strong></p><p>使用算术扩展符,<strong>可以进行变量和运算符的结合运算,不需要使用declare -i 声明</strong></p><p>同时,如若其中的变量未初始化,则会将其视为0对待,但是,并不会真的赋值0</p><p><img src="http://oww4cv296.bkt.clouddn.com/Screenshot_20171206_010423.png" alt=""></p><p><strong>2. 使用bc运算</strong></p><p>自行查看man文档,,(可以进行浮点运算的呦!)</p><hr><p>我是华丽的分割线</p><hr><p>分享在写Markdown时,千万不要 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#array[@]&#125;</span>,  <span class="variable">$&#123;#array[N]&#125;</span></span><br></pre></td></tr></table></figure><p>这样的东西写在文本里,不然会把你逼疯得</p><p><strong>转义,不存在的 !</strong></p><p>December 6, 2017 1:06 AM</p>]]></content>
      
      <categories>
          
          <category> Shellscript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ShellScript(一)</title>
      <link href="/2017/12/05/ShellScript/sh1/"/>
      <url>/2017/12/05/ShellScript/sh1/</url>
      <content type="html"><![CDATA[<p><em>shell脚本作为必须要掌握的内容,已经被扔了好久了,没去学习了</em></p><p><em>现在趁此机会,好好学习一波</em></p><p><em>同时,也改变一下,学习语言时的博客风格</em></p><p><em>捡有意义,值得进行记录得点进行记录,不然最后博客写的就像,抄书一样…</em></p><h2 id="shell脚本的准备"><a href="#shell脚本的准备" class="headerlink" title="shell脚本的准备"></a>shell脚本的准备</h2><p>#!/bin/bash   表示使用的解释器</p><p>是注释开始的标志,多写注释,便于程序的理解</p><p>最简单的shell脚本就是命令的罗列</p><p>脚本执行的两种方法:</p><ol><li><p>使用 “ bash xxx.sh “ 运行脚本 ,同理,可以使用,zsh,sh,之类的解释器都可以</p></li><li><p>“ chmod + x xxx.sh “ 加上执行的权限,然后,./xx.sh运行脚本 </p></li><li><p>将此脚本放在任何系统path下,都有可以变成默认的系统命令,可以直接进行使用</p></li></ol><h2 id="shell脚本的排错"><a href="#shell脚本的排错" class="headerlink" title="shell脚本的排错"></a>shell脚本的排错</h2><p>有以下三种方法:</p><ol><li><p>使用echo进行排错</p><p> 此方法类似于C语言中的printf排错法</p></li><li><p>使用 bash -x 选项</p><p> 这样可以打印出每一步的结果,可以查看执行的代码,从而进行变量的排错</p></li><li><p>使用第三方工具,bashdb ,类似于GDB的排错程序</p></li></ol><h2 id="shell的内建命令"><a href="#shell的内建命令" class="headerlink" title="shell的内建命令"></a>shell的内建命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span>, <span class="built_in">bg</span>, <span class="built_in">bind</span>, <span class="built_in">break</span>, <span class="built_in">builtin</span>, <span class="built_in">caller</span>, <span class="built_in">cd</span>, <span class="built_in">command</span>, compgen, complete, compopt, <span class="built_in">continue</span>, <span class="built_in">declare</span>, <span class="built_in">dirs</span>,  <span class="built_in">disown</span>,  <span class="built_in">echo</span>,  <span class="built_in">enable</span>,  <span class="built_in">eval</span>,  <span class="built_in">exec</span>,  <span class="built_in">exit</span>,</span><br><span class="line"><span class="built_in">export</span>,  <span class="literal">false</span>,  <span class="built_in">fc</span>, <span class="built_in">fg</span>, <span class="built_in">getopts</span>, <span class="built_in">hash</span>, <span class="built_in">help</span>, <span class="built_in">history</span>, <span class="built_in">jobs</span>, <span class="built_in">kill</span>, <span class="built_in">let</span>, <span class="built_in">local</span>, <span class="built_in">logout</span>,</span><br><span class="line"><span class="built_in">mapfile</span>, <span class="built_in">popd</span>, <span class="built_in">printf</span>, <span class="built_in">pushd</span>, <span class="built_in">pwd</span>, <span class="built_in">read</span>, <span class="built_in">readonly</span>, <span class="built_in">return</span>, <span class="built_in">set</span>, <span class="built_in">shift</span>, <span class="built_in">shopt</span>,  <span class="built_in">source</span>,</span><br><span class="line"><span class="built_in">suspend</span>, <span class="built_in">test</span>, <span class="built_in">times</span>, <span class="built_in">trap</span>, <span class="literal">true</span>, <span class="built_in">type</span>, <span class="built_in">typeset</span>, <span class="built_in">ulimit</span>, <span class="built_in">umask</span>, <span class="built_in">unalias</span>, <span class="built_in">unset</span>, <span class="built_in">wait</span> -</span><br></pre></td></tr></table></figure><p>这些都属于内建命令,bash-built-in</p><p>凡是用which命令查不到程序文件所在位置的命令都是内建命令</p><p>内建命令没有单独的man手册，要在man手册中查看内建命令，应该man bash-builtins</p><p>内建命令虽然不创建新的进程，也会有返回值，通常用0表示成功非零表示失败，可以用特殊变量$?读出</p><p><strong>内建命令,相当于shell的函数,并不会创建新的进程,而外建命令是新的进程</strong></p><p>其中一些有意思的命令:</p><p><strong>1. type: 查看命令是否是内建命令</strong></p><p><strong>2. .: 表示执行程序</strong></p><p><strong>3. alias: 命令别名</strong></p><p><strong>4. unalias:　取消命令别名</strong></p><p><strong>5. fg,bg,jobs: jobs查看当前任务,fg将后台任务调至前台运行,bg将任务调职前台</strong></p><p><strong>6. cd: 改变工作目录</strong></p><p><strong>7. declare,typeset: shell属于弱类型的语言,对于变量的类型界定不是很明确,</strong></p><p>declare,typeset效果完全相同,可以-i声明整型,-r声明只读变量</p><p>在这里需要分想给大家的是,shellscript写起来,和使用命令是很像的</p><p>比如: </p><p>declare -F 显示脚本中的函数名</p><p>declare -f 显示脚本中的函数体</p><p>而在bash中使用,则是显示整个系统中的函数和函数体 (在shell脚本中的)</p><p><strong>8. echo: 很常见的内建命令,类似于printf,可以进行信息的打印,缺省打印换行符,-n可以取消</strong></p><p><strong>9. break: 根据shell提示,只能用于,for,while,loop的循环中,用于跳出循环</strong></p><p><strong>10. continue: 同理的,跳出当前循环,进入其他层的循环</strong></p><p>*break,contiune,后都可以跟上数字,表示跳出指定层数的循环</p><p><strong>11. eval: 将其后的参数作为shell的输入,并产生新的命令</strong></p><p><strong>12. exec: 表示用exec后的程序进行shell的替换,在命令执行完成之后,现在的shell会被清理掉</strong></p><p>因为他的任务只是执行这一条命令,,,</p><p>为了避免这种情况,所以一般将exec的命令放到shell脚本中,exec会替换子脚本进程,而像source</p><p>. 之类的命令,并不会替换子进程,而是将命令放在当前的shell中执行</p><p><strong>13. exit: 退出shell</strong></p><p><strong>14. export: 使变量能够被shell识别,export属于变量输出,使得父shell中的变量能够被子shell识别</strong></p><p>即使得多的不同的shell,可以相互识别变量,export,我认为比较像C中的extern*</p><p>但是,不同的是,改变shell中的变量的值,互不影响,仅为同名的局部变量,而C中,是同一变量..</p><p><strong>15. kill: 这是一个相常用的命令,用于杀死进程,向内核传递一个进程号以及处理的序号</strong></p><p>备注:在Linux操作系统中,一般有三种进程,交互式进程,批处理进程,系统进程(包括守护进程)</p><p><strong>16. let: 进行整数运算的命令,同时也支持C类的运算</strong></p><p><strong>17. pwd: 显示当前工作目录</strong></p><p>同时,使用 $OLDPWD, $PWD变量可以获取当前工作目录,以及之前的工作目录变量</p><p><strong>18. local: 声明局部变量,仅能在函数内部使用,在外使用会爆炸</strong></p><p><strong>19. read: 从标准输入读取一行输入给变量,即为scanf</strong></p><p>read从标准输入获取到的内容默认放在 $REPLAY中,可以使用<strong> echo $REPLY </strong> 查看</p><p><strong>20. return: 类似于其他语言,再函数中进行返回值的传递,不使用return,默认以最后一行的状态作为返回值</strong></p><p>可以使用 <strong>“echo $? 查看返回值” </strong></p><p><strong>21. shift:　进行为位置参数的移动，类似于，argc一样，</strong></p><p>shell中的变量，依次记作，＄１，＄２，＄３，＄４．．＄０是脚本本身，</p><p>其中还有几个比较有意思的变量，＄＠／＄＊　表示所有变量，＄＃表示变量总个数</p><p><strong>所以，shift的作用是，进行参数的左移．</strong></p><p><strong>２２．　unlimit: 不做多余赘述</strong></p><p><strong>23. test: 用于测试expression的值，很方便</strong></p><p><strong>以上就是，进行shellscript脚本学习的Linux命令基础，暂时没有截图</strong></p><p><strong>后面关于正式的shellscript会有相关的截图来进行说明</strong></p><p>December 4, 2017 11:56 PM</p>]]></content>
      
      <categories>
          
          <category> Shellscript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2017/12/03/Linux/Regx/"/>
      <url>/2017/12/03/Linux/Regx/</url>
      <content type="html"><![CDATA[<p><em>的确是很强大的东西,之前也没有系统的学习过,在学习shell script前是必经之路,那么就系统的搞一搞吧</em></p><p><strong>本节,所有的正则表达式的演示都是以grep为主</strong></p><p><strong>而正则表达式在大多数语言中,都有者不同的实现,我们可以进行微调来适应语言的需要</strong></p><h3 id="基础的正则表达式"><a href="#基础的正则表达式" class="headerlink" title="基础的正则表达式"></a>基础的正则表达式</h3><ul><li><p>“ . “ 符号</p><p>  “ . “ 表示匹配换行符外的任意一个字符,举个例子, ‘ r . t ‘ 可以匹配,rot,rut,ret等</p></li><li><p>“ * “ 符号</p><p>  “ <em> “ 符号用于匹配前一个字符 0 ~ 任意 次. 比如 “r</em>t” 可以匹配,rt,rtt,rttt…</p><p>  而” * “ 与 “ . “ 是经常在一起套用的, 比如</p><p>  “ r . * t “ 表示匹配 “ r + 任意多个除换行符外的任意字符 + t “ 的文本内容</p><p>  而 “ r * . t “ 表示匹配 “ 任意多个r + 任意除换行符外的字符 + t “ 的文本内容</p></li><li><p>“ \ { \ } “符号</p><p>  虽然 “ * “ 很方便,但是并不能控制匹配的次数,也不是很好用,所以,使用 “ \ { \ } “ 控制匹配次数</p><p>  常见用法有以下三种:</p><ol><li><p>\ { n \ } 表示匹配之前的字符n次</p></li><li><p>\ { n ,\ } 表示匹配之前的字符至少n次,包含n次</p></li><li><p>\ { n , m \ } 表示匹配之前的字符n~m次</p></li></ol></li><li><p>“ ^ “ 符号</p><p>  这个符号,很好理解,就是用来匹配开头的,</p><p>  如 ‘^root’ 表示匹配以root开头的行</p></li><li><p>“ $ “ 符号</p><p>  既然有匹配开头的元字符,那么一定有用来匹配行尾的字符,那便是 “ $ “</p><p>  如: ‘^$’便可以匹配空行</p></li><li><p>“[ ]” 符号</p><p>  一对方括号,用于匹配出现在方括号中的任一字符 (<strong>并非任意字符</strong>)</p><p>  同时,联动 “ ^ “ 在[ ] 中,尖角号表示取反,比如 [^ABCD] 表示不匹配ABCD任一字符</p><p>  通过以上这些元字符,我们现在可以开始匹配电话号码了</p><p>  ‘^1[38][0-9]{9}‘.即可进行匹配,(但是,一定是从行首开始的,如非行首,可以去掉尖角号)</p></li><li><p>“ \ “ 符号</p><p>  这个符号,其实可以不用多介绍了,就是转义字符.</p><p>  在将元字符作为一般的文本字符使用时,必须使用转义字符,否则是会造成歧义的.</p></li><li><p>“ \ &lt; \ &gt; “ 符号</p><p>  emmmmmmmmmmm,</p><p>  有的时候,我们固定要匹配某一个单词,比如要hello,而不要helloworld ,就要使用单词界定符</p><p>  他会固定匹配指定的单词,不会造成误匹配</p></li></ul><p>以上是8种常用的元字符,下面是一些一般用的元字符,都可以使用上面的常用元字符实现</p><ul><li><p>“ \ d “ 字符</p><p>  是进行数字匹配的元字符 即: [0-9]</p><p>  但是,是Perl兼容模式,所以在grep中使用时,必须加上 “ - P “ 才能成功匹配</p></li><li><p>“ \ b “ 字符</p><p>  匹配单词的边界 boderland 即 “\ &lt; \ &gt; “</p></li><li><p>“ \ B, \ W,” 这些,我都觉得有点废…</p></li><li><p>“\ n , \ r , \ t , \ f , \ s , \S “ 便是匹配各种各样的 转义字符</p></li></ul><h3 id="扩展的正则表达式"><a href="#扩展的正则表达式" class="headerlink" title="扩展的正则表达式"></a>扩展的正则表达式</h3><p>上面属于基础的元字符,以足够强大了,但是,还是不能满足某些需求,所以才有了扩展的正则表达式</p><ul><li><p>“ ? “ 匹配前一个字符 0 ~ 1 次</p></li><li><p>“ + “ 匹配前一个字符1次以上</p></li><li><p>“ | “ 或的关系,表示不同分支,用于多种不同情况的并列</p></li><li><p>“ ( )” 表示罗列多种可以进行替换的情况</p></li></ul><p><strong>使用 “ ( ) “ + “ | “ 可以替换 “ [ ] “ ,实现同等效果</strong></p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p><strong>通配符并不是正则表达式的内容,通配符是用来匹配文件名的,正则表达式是用来匹配文本内容的</strong></p><ul><li><p>“ * “ 表示任意个任意字符</p></li><li><p>“ ? “ 表示任一个,任意字符</p></li><li><p>“｛　｝＂表示匹配花括号内，所有以逗号隔开的字符</p></li></ul><p>-　＂＾与 ! “ 一般与［　］　同时使用，表示取反</p><h3 id="正则表达式的模式"><a href="#正则表达式的模式" class="headerlink" title="正则表达式的模式"></a>正则表达式的模式</h3><p><del><em>主要进行贪婪模式和非贪婪模式的解析</em></del></p><p><del>说到贪婪模式,就不得不提到三种量词,贪婪量词,逐步量词,独吐量词</del></p><p><del>1.贪婪量词</del>~~</p><p><del>即为<strong> “ . * “ </strong> ,表示匹配任意长度的任意字符,(换行符除外)</del></p><p><del>贪婪量词的工作原理: 遇到贪婪量词,先将剩余的串吃干净,然后往出吐,遇到规则表达式即结束</del></p><p><del><strong>即,贪婪量词,可以匹配到最长的符合要求的字串</strong></del></p><p><del>看图</del></p><p><del>2.逐步量词</del></p><p><del>用起来很简单,即在贪婪量词后加上 “ ? “ 即可,表示逐步进行匹配.或者说,懒惰模式,尽可能少的匹配</del></p><p><del>遇到逐步量词后,不会立即吞掉所有字符,而是会,一边吞入字符,一边进行匹配,一旦符合规则表达式,便停止</del></p><p><del>看图</del></p><p><strong>好吧,上面的东西基本废了,都是Java中规则表达式的内容,</strong></p><p><strong>所以,各种语言的实现方式都是略有不同的,需要根据具体情况进行界定</strong></p><h3 id="正则表达式的练习"><a href="#正则表达式的练习" class="headerlink" title="正则表达式的练习"></a>正则表达式的练习</h3><p><em>使用grep进行练习</em></p><h3 id="Sed与Awk"><a href="#Sed与Awk" class="headerlink" title="Sed与Awk"></a>Sed与Awk</h3><p>这是两个很好用的命令行处理文本的工具,因为使用上按照 – help提示很方便</p><p>所以,不再赘述</p><p>December 4, 2017 9:07 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegExpression </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编语言(二)_寄存器</title>
      <link href="/2017/11/21/Assembly/assembly(2)/"/>
      <url>/2017/11/21/Assembly/assembly(2)/</url>
      <content type="html"><![CDATA[<p><em>上一章介绍了汇编语言的基本知识，这一章开始我们深入的理解汇编语言最常操作的寄存器</em></p><h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1. 寄存器"></a>1. 寄存器</h2><p>接着上一章的内容,我们现在来剖析一下CPU中所包含的内容:</p><ul><li><p>运算器: 进行信息处理</p></li><li><p>寄存器: 进行信息的存储</p></li><li><p>控制器: 控制这个各个器件进行工作</p></li><li><p>内部总线,连接内部的部件.外部总线,连接CPU与主板上的其他部件,并且进行数据之间的传送</p></li></ul><p>而对于汇编语言来讲,我们最常操作的就是寄存器(Register)了</p><p><strong>8086CPU总共有14个寄存器,AX,BX,CX,DX,CS,DS,SS,ES,IP,SP,BP,SI,DI,PSW</strong></p><h3 id="1-1-通用寄存器"><a href="#1-1-通用寄存器" class="headerlink" title="1.1 通用寄存器"></a>1.1 通用寄存器</h3><p><strong>8086CPU中所有的寄存器都是16位的,AX,BX,CX,DX为通用寄存器</strong></p><p><strong>同时,为了处理兼容的问题,8086CPU的所有寄存器都可以拆成2个8位寄存器来进行使用</strong></p><blockquote><p>Tips: 8086CPU的寄存器可以拆成两个8位寄存器使用</p></blockquote><blockquote><p>因为8086CPU的上一代产品(具体叫什么忘了)的原因,8086相对于上一代产品,仅仅做了</p></blockquote><blockquote><p>寄存器位数上的升级,指令基本没有变化.</p></blockquote><blockquote><p>所以为了兼容的问题,8086每个寄存器可以拆成两个8位使用</p></blockquote><p>即:</p><ul><li><p>AX = AH + AL</p></li><li><p>BX = BH + Bl</p></li><li><p>CX = CH + CL</p></li><li><p>DX = DH + DL</p></li></ul><p><em>CPU名称的记法,可以根据位的高低,AH(High),高8位.AL(low),低8位</em></p><blockquote><p>Tips:在汇编语言中的进制</p></blockquote><blockquote><p>汇编中,我们经常要操作的是寄存器,而寄存器基本都是8位和16位.</p></blockquote><blockquote><p>所以,我们常用的进制是二进制和十六进制,B表示二进制,H表示十六进制,例: 1001B,02E3H</p></blockquote><h3 id="1-2-寄存器中存储的数据"><a href="#1-2-寄存器中存储的数据" class="headerlink" title="1.2 寄存器中存储的数据"></a>1.2 寄存器中存储的数据</h3><p>在计算机的进制单位中,经常操作的是字节与字,之前也进行过相关进制的描述</p><p>字节:1 Byte,一次可以由一个8位寄存器进行控制</p><p>字: word,为两个字节,每次可以由1个16位寄存器进行控制</p><p>那么,问题来了,对于一个字,在16位仅存其中是如何存储的?</p><p><em>在计算机的发展史上,关于数据如何在元件中存储也是一个经典问题</em></p><p><em>随着,存储器的规模越来越大,这成为了一个不得不考虑的问题</em></p><p><em>对于少字节的数据,如何在计算机中存储</em></p><p><strong>大端,小端</strong>两种模式应运而生</p><p><strong>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中 </strong></p><p><strong>大端模式和我们的阅读习惯一致。</strong></p><p><strong>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中 </strong></p><p><strong>这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</strong></p><p>很显然的,8086CPU属于<strong> 小端模式 </strong></p><h3 id="1-3-汇编指令"><a href="#1-3-汇编指令" class="headerlink" title="1.3 汇编指令"></a>1.3 汇编指令</h3><p>说了这么久,终于看到直观的汇编指令了</p><table><thead><tr><th>汇编指令</th><th>控制操作</th><th>高级语言语法描述</th></tr></thead><tbody><tr><td>mov ax,18</td><td>将18送入寄存器ax</td><td>AX=18</td></tr><tr><td>add ax,8</td><td>寄存器AX中的内容加上8</td><td>AX += 8</td></tr><tr><td>mov ax,bx</td><td>寄存器BX中的内容送入寄存器AX</td><td>AX = BX</td></tr><tr><td>add ax,bx</td><td>寄存器AX中的内容加上BX中的内容</td><td>AX += BX</td></tr></tbody></table><p><strong>在汇编指令中,大小写不进行区分,效果相同</strong></p><p>下面提到两个在进行进制计算的重要问题:</p><p>1.在出现数据溢出时:</p><p>如上例,AX,BX的求和结果,应该是1044CH,但是16位寄存器只能存储4位16进制数</p><p>所以,AX最后的值位044CH,而不是1044CH,</p><p>2.在进行8位寄存器操作时</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">85H</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">93H</span></span><br></pre></td></tr></table></figure><p>上面两条指令的结果是什么呢?</p><p>根据进制计算,al的结果是108H,</p><p><strong>但是,实质上,最后在寄存器AL中存储的是08H</strong></p><p>那么这是为什么呢?</p><p><strong>因为AL是AX的低8位,所以AL只是一个8位的寄存器,不能存储3位的16进制数据</strong></p><p><strong>能进位吗? 不能,因为AL与AX并无直接关系,这一条add指令进行的是8位运算,不能进位到AH中</strong></p><p><strong>所以,进行数据传送或者运算时,注意指令的两个操作对象是一致的 ! </strong></p><p><strong>8位都是8位,16位都是16位</strong></p><h2 id="2-物理地址"><a href="#2-物理地址" class="headerlink" title="2. 物理地址"></a>2. 物理地址</h2><p>正如之谈到的一样,计算机所有的RAM与ROM抽想成为内存地址空间</p><p><strong>所以,我们可以进行访问的内存实际上是线性的,即每个内存单元都有其唯一的物理地址</strong></p><p>下面就来看看8086CPU如何生成16位的物理地址</p><blockquote><p>Tips: 16位结构(16位机,字长为16)</p></blockquote><blockquote><p>16这个数字,在这里描述的是1个CPU的结构特性:</p></blockquote><blockquote><ul><li>运算器一次性可以处理16位的数据</li></ul></blockquote><blockquote><ul><li>寄存器的最大宽度为16位</li></ul></blockquote><blockquote><ul><li>寄存器与运算器之间的通路是16位</li></ul></blockquote><blockquote><p>总结一下:在8086CPU的内部,一次性可以传输,存储,计算的数据为16位</p></blockquote><blockquote><p>同时,16一般指CPU通用寄存器的宽度</p></blockquote><p><strong>8086CPU有20位地址总线,</strong>,理论上是1MB的寻址空间</p><p>但是,8086实际上是16位CPU,所以能生成的寻址宽度,只有64KB</p><p>那么,如何实现1MB的寻址空间呢?</p><p><strong>伟大创造:使用两个16位寄存器,生成20位的物理地址</strong></p><p>来看一张图:</p><p>我们来看一看在8086CPU中,当要读写内存时:</p><ol><li><p>CPU中的相关部件提供两个地址,一个CS段地址(Code),一个IP偏移地址(instrument)</p></li><li><p>段地址与偏移地址通过,内部总线送入地址加法器中,</p></li><li><p>地址加法器将两个16位地址合并成为一个20位的物理地址</p></li><li><p>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</p></li><li><p>输入输出控制电路将物理地址送上地址总线(外部总线)</p></li><li><p>20位物理地址被地址总线送往存储器,之后进行数据的操作</p></li></ol><p><strong>地址加法器: 物理地址 = 段地址 x 16 + 偏移地址</strong></p><p>为什么乘16,因为地址是16进制,即为扩大一个数量级,之后进行偏移</p><p>即可理解段地址与偏移地址的含义</p><h3 id="2-1-“段地址-x-16-偏移地址-物理地址”-的本质含义"><a href="#2-1-“段地址-x-16-偏移地址-物理地址”-的本质含义" class="headerlink" title="2.1 “段地址 x 16 + 偏移地址 = 物理地址” 的本质含义"></a>2.1 “段地址 x 16 + 偏移地址 = 物理地址” 的本质含义</h3><p>套用王爽老师,进行解释的例子,</p><p>使用这种段地址 + 偏移地址进行寻址的方法 原因就是:</p><p><strong>因为手头只有16位的寄存器,但是为了更高效率的寻址</strong></p><p><strong>同时,还要保证每一个内存单元都可以寻址到,就是用了这样的一种方法</strong></p><p>在基础地址上进行偏移,可以实现访问尽可能多的地址空间,<strong>而且,每一个内存单元,都要保证能访问到</strong></p><h3 id="2-2-段的含义"><a href="#2-2-段的含义" class="headerlink" title="2.2 段的含义"></a>2.2 段的含义</h3><p>上面说了很多的,段的概念,需要注意的是:</p><p><strong>实质上,内存中是没有进行分段的 ! </strong></p><p><strong>所谓的段,是有程序员进行程序设计,操作内存时,自行进行分段的</strong></p><p>来看一个例子:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Physical Address       <span class="built_in">CS</span>         <span class="built_in">IP</span></span><br><span class="line"><span class="number">21F60H</span><span class="number">2000H</span>      <span class="number">1F60H</span></span><br><span class="line">  <span class="number">2100H</span>      <span class="number">0F60H</span></span><br><span class="line">  <span class="number">21F0H</span>      <span class="number">0060H</span></span><br><span class="line">  <span class="number">21F6H</span>      <span class="number">0000H</span></span><br><span class="line">  <span class="number">1F00H</span>      <span class="number">2F60H</span></span><br></pre></td></tr></table></figure><p>上面的例子便可以看出,实质上每一个物理地址,可以有多组段地址 + 偏移地址实现访问同一物理地址</p><p><strong>所以,段并非是处理器CPU自己进行划分的,实质上是程序员根据程序设计的需要,进行段的划分</strong></p><p>所以,在进行编程时,我们可以根据需要进行段的划分</p><p>但是,需要注意的是:</p><p><strong>1. 段地址一定是16的倍数,因为 X 16</strong></p><p><strong>2. 偏移地址只能达到64KB的寻址能力,因为偏移地址,也是一个16位寄存器存储的值,寻址能力只有64KB</strong></p><p><strong>寻址范围: 0000H ~ FFFFH</strong></p><p><strong>可以将地址连续,起始地址为16倍数的一组内存单元,视为一个段</strong></p><h3 id="2-3-段寄存器"><a href="#2-3-段寄存器" class="headerlink" title="2.3 段寄存器"></a>2.3 段寄存器</h3><p><em>现在开始,来介绍另外一类十分重要的寄存器,段寄存器</em></p><p><em>之前我们介绍的都是通用寄存器,而这些段寄存器,都有着其重要的作用</em></p><p><strong>既然名为段寄存器,那么,这些寄存器中存储的都是段地址的信息,</strong></p><p><strong>DS: 数据段地址 (Data)</strong></p><p><strong>CS: 指令/代码段地址 (Code)</strong></p><p><strong>SS: 栈端段地址 (Stack)</strong></p><p>目前常用的是这三个. . . (另外还有一个ES)</p><hr><p><strong>CS 与 IP这两个寄存器是8086CPU中最为重要的寄存器之二,CS为代码段寄存器,IP为指令指针寄存器</strong></p><p>我们经常要表示当前CPU要执行的指令,就是使用CS,IP进行指向的</p><p><strong>常用表述方法 : </strong></p><p><strong>1.执行CS:IP地址单元开始的指令,</strong></p><p><strong>2.或者代码存在CS段中的IP单元中</strong></p><p>具体CPU如何读取和执行指令的流程,参考 &lt; 汇编语言 &gt;  ( 王爽 ) P26 ~ P31</p><blockquote><p>Tips: CPU如何将内存中的数据视为指令</p></blockquote><blockquote><p>之前我们曾经说过,CPU将内存中的数据,可以视为代码,数据,或是栈内数据</p></blockquote><blockquote><p>那么这一切都是如何进行界定的?</p></blockquote><blockquote><p>很简单:依靠段寄存器,进行识别,数据在内存中没有指令,数据之分,一切都是依靠CPU中的段寄存器</p></blockquote><blockquote><p>CPU通过修改CS,DS,SS,IP,SP这些寄存器中的内容,使得</p></blockquote><blockquote><p>CS:IP 内存单元中的数据被视为指令</p></blockquote><blockquote><p>DS:[x] 内存单元中的数据视为数据</p></blockquote><blockquote><p>SS:SP 内存单元中的内容视为栈内数据</p></blockquote><blockquote><p><strong>内存中都是数据,没有指令,数据之分.划分是依靠处理器CPU如何进行代码段的读取界定的</strong></p></blockquote><h3 id="2-4-修改CS-IP的指令"><a href="#2-4-修改CS-IP的指令" class="headerlink" title="2.4 修改CS,IP的指令"></a>2.4 修改CS,IP的指令</h3><p>程序员对于处理器唯一能够进行操作的就是寄存器,</p><p>而我们通常进行寄存器内容修改的指令便是 <strong>mov指令</strong></p><p><strong>mov 指令 可以进行寄存器中指的修改.</strong></p><p><strong>但是,8086CPU中不能使用mov指令进行段寄存器的修改,因为处理器设计时,就没有提供这样的功能</strong></p><p>其中提供了,除传送指令(mov)外的另外一类指令,转移指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">CS</span>:<span class="built_in">IP</span>           使当前指令跳转至<span class="built_in">CS</span>:<span class="built_in">IP</span>处</span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">ax</span>              使当前<span class="built_in">IP</span>跳转至<span class="built_in">ax</span>处</span><br></pre></td></tr></table></figure><p>最后还是要强调一个概念:<strong>内存中,所有的东西,都是数据.到底是指令,还是数据,由CPU来定</strong></p><p>使用Debug进行汇编语言的学习,这里的Debug并非是改Bug的意思,实际上是指进行交互式的程序</p><p>可以查看内存中的情况,同时还可以查看CPU寄存器中的内容</p><p>常见命令:</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>-R</td><td>查看,改变CPU中寄存器的内容</td></tr><tr><td>-D</td><td>查看内存中的内容</td></tr><tr><td>-E</td><td>改写内存中的内容</td></tr><tr><td>-U</td><td>翻译机器指令</td></tr><tr><td>-T</td><td>单步执行指令</td></tr><tr><td>-A</td><td>以汇编指令进行指令的输入</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编码风格</title>
      <link href="/2017/11/20/Other/CodeStyle/"/>
      <url>/2017/11/20/Other/CodeStyle/</url>
      <content type="html"><![CDATA[<h4 id="参考-Nginx-以及-K-amp-R-C"><a href="#参考-Nginx-以及-K-amp-R-C" class="headerlink" title="( 参考 Nginx 以及 K&amp;R C )"></a><em>( 参考 Nginx 以及 K&amp;R C )</em></h4><h3 id="基础风格"><a href="#基础风格" class="headerlink" title="基础风格"></a>基础风格</h3><p><strong>K&amp;R编码风格 (偏BSD子类)</strong></p><p><strong>每行不能超过80列</strong></p><p><strong>不用TAB对齐,用空格.</strong></p><p><strong>默认对齐单元是4个空格.</strong></p><p><strong>除宏定义外,字母均为小写,单词间用下划线 _ 间隔.</strong></p><p><strong>使用C方式的注释，不得使用//形式注释.</strong></p><p><strong>中缀运算符的前后须空一格,如3 + 2以及a &gt; 3.</strong></p><p><strong>逗号后须空一格,如 foo(a, b, c);</strong></p><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><p><strong>UNIX/LINUX的风格,采用下划线命名法,当然驼峰命名法也很好,不建议匈牙利命名法…</strong></p><h4 id="函数的命名"><a href="#函数的命名" class="headerlink" title="函数的命名"></a>函数的命名</h4><p>函数名使用下划线分割小写字母的方式命名：</p><p><strong>设备名_操作名()</strong></p><p><strong>操作名一般采用：谓语（此时设备名作为宾语或者标明操作所属的模块）</strong></p><p>或者</p><p><strong>谓语+宾语/表语（此时设备名作为主语或者标明操作所属的模块） 等形式，如：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tic_init()</span><br><span class="line"></span><br><span class="line">adc_is_busy()</span><br><span class="line"></span><br><span class="line">uart_tx_char()</span><br></pre></td></tr></table></figure></p><p><strong>中断函数的命名直接使用 设备名_isr() 的形式命名，如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer2_isr()</span><br></pre></td></tr></table></figure><h4 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h4><p><strong>变量的命名也采用下划线分割小写字母的方式命名</strong></p><p>命名应当准确，不引起歧义，且长度适中,如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">uint32 test_offset;</span><br></pre></td></tr></table></figure><p><strong>单字符的名字也是常用的，如i, j, k等，它们通常可用作函数内的局部变量</strong></p><p><strong>tmp常用做临时变量名</strong></p><p><strong>局部静态变量，应加s_词冠（表示static），如：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_lastw;</span><br></pre></td></tr></table></figure></p><p><strong>全局变量（尤其是供外部访问的全局变量），应加g_词冠（表示global），如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* g_capture_hook)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h4 id="常量及宏的命名"><a href="#常量及宏的命名" class="headerlink" title="常量及宏的命名"></a>常量及宏的命名</h4><p><strong>采用下划线分割大写字母的方式命名，一般应以设备名作为前缀，</strong></p><p><strong>防止模块间命名的重复。如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER0_MODE_RELOAD 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER2_COUNT_RETRIEVE(val) ((uint16)(65536 - (val)))</span></span><br></pre></td></tr></table></figure><p>当然，看作接口的宏可以按照函数的命名方法命名，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timer2_clear() (TF2 = 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timer0_is_expired() (TF0)</span></span><br></pre></td></tr></table></figure><p>5 常用缩写词</p><table><thead><tr><th>原词</th><th>缩写</th><th>含义</th></tr></thead><tbody><tr><td>addition</td><td>add</td><td>加</td></tr><tr><td>subtraction</td><td>sub</td><td>减</td></tr><tr><td>multiplication</td><td>mul</td><td>乘法</td></tr><tr><td>division</td><td>div</td><td>除法</td></tr><tr><td>answer</td><td>ans</td><td>响应、回答</td></tr><tr><td>array</td><td>arr</td><td>数组、集合</td></tr><tr><td>average</td><td>avg</td><td>平均</td></tr><tr><td>buffer</td><td>buf或buff</td><td>缓冲区</td></tr><tr><td>capture</td><td>cap或capt</td><td>捕获</td></tr><tr><td>check</td><td>chk</td><td>检查</td></tr><tr><td>count</td><td>cnt</td><td>计数器</td></tr><tr><td>column</td><td>col</td><td>列</td></tr><tr><td>control</td><td>ctrl</td><td>控制</td></tr><tr><td>decode</td><td>dec</td><td>解码、译码</td></tr><tr><td>define</td><td>def</td><td>定义</td></tr><tr><td>delete</td><td>del</td><td>删除</td></tr><tr><td>destination</td><td>dst或dest</td><td>目的</td></tr><tr><td>display</td><td>disp</td><td>显示</td></tr><tr><td>encode</td><td>enc</td><td>编码</td></tr><tr><td>environment</td><td>env</td><td>环境</td></tr><tr><td>error</td><td>err</td><td>错误</td></tr><tr><td>float</td><td>flt</td><td>浮动、浮点</td></tr><tr><td>frequency</td><td>freq</td><td>频率</td></tr><tr><td>header</td><td>hdr</td><td>开始、开头</td></tr><tr><td>index</td><td>idx</td><td>索引、指示、</td></tr><tr><td>image</td><td>img</td><td>影像、镜像</td></tr><tr><td>increment</td><td>inc</td><td>增加、增量</td></tr><tr><td>initalize</td><td>init</td><td>初始化</td></tr><tr><td>iteration</td><td>itr</td><td>循环、迭代</td></tr><tr><td>length</td><td>len</td><td>长度</td></tr><tr><td>memory</td><td>mem</td><td>内存</td></tr><tr><td>middle</td><td>mid</td><td>中值</td></tr><tr><td>make</td><td>mk</td><td>制造、形成</td></tr><tr><td>message</td><td>msg</td><td>消息</td></tr><tr><td>number</td><td>num</td><td>数量、编号</td></tr><tr><td>operand</td><td>opnd</td><td>操作数</td></tr><tr><td>optimization</td><td>opt</td><td>最优</td></tr><tr><td>operator</td><td>optr</td><td>操作</td></tr><tr><td>packet</td><td>pkt</td><td>消息包</td></tr><tr><td>positon</td><td>pos</td><td>位置</td></tr><tr><td>previous</td><td>pre或prev</td><td>以前的</td></tr><tr><td>pointer</td><td>ptr</td><td>指针</td></tr><tr><td>record</td><td>rcd</td><td>记录</td></tr><tr><td>receive</td><td>recv</td><td>收到、接收</td></tr><tr><td>result</td><td>res</td><td>结果</td></tr><tr><td>return</td><td>ret</td><td>返回</td></tr><tr><td>source</td><td>src</td><td>源头</td></tr><tr><td>stack</td><td>stk</td><td>栈</td></tr><tr><td>string</td><td>str</td><td>字符串</td></tr><tr><td>table</td><td>tab</td><td>表</td></tr><tr><td>temporary</td><td>tmp或temp</td><td>临时</td></tr><tr><td>total</td><td>tot</td><td>全部的</td></tr><tr><td>time stamp</td><td>ts</td><td>时间戳</td></tr><tr><td>value</td><td>val</td><td>值</td></tr></tbody></table><h3 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h3><p>使用标准的<em> K&amp;R C风格 </em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (x == y) &#123;</span><br><span class="line">        something();</span><br><span class="line">        somethingelse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (some_error)</span><br><span class="line">            do_correct();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            continue_as_usual();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finalthing();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>if / while / for / switch 语句的左花括号和关键字在同一行上，和括号之间空一个空格</strong></p><p>注: <em>K&amp;R C</em>中 对于函数的括号是进行换行的,方便进行 Code Review</p><p>对于函数体中的if, while等逻辑控制语句,括号是在同一行,不进行换行</p><p>若对于if, while等控制语句,其中只有一条语句时,不使用大括号</p><h3 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                              ------ <span class="number">0</span></span><br><span class="line"><span class="comment">/*                            ------ 1</span></span><br><span class="line"><span class="comment"> * This is somthing</span></span><br><span class="line"><span class="comment"> * This is also something</span></span><br><span class="line"><span class="comment"> * This still is something</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is for a line */</span>      ------<span class="number">-2</span></span><br></pre></td></tr></table></figure><p><strong>0.文件开始的注释空一行</strong></p><p><strong>1.多行注释</strong></p><p><strong>2.单行注释</strong></p><hr><h3 id="布局规划"><a href="#布局规划" class="headerlink" title="布局规划"></a>布局规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) Igor Sysoev</span></span><br><span class="line"><span class="comment"> * Copyright (C) Nginx, Inc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                                              ------ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nginx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_show_version_info</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_add_inherited_sockets</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_cleanup_environment</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_get_options</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> *argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_process_options</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_save_argv</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> *argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ngx_core_module_create_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_core_module_init_conf</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_set_user</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_set_env</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_set_priority</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_set_cpu_affinity</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *conf)</span></span>;                              ------ <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_set_worker_processes</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_load_module</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_DLOPEN)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_unload_module</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_conf_enum_t</span>  ngx_debug_points[] = &#123;</span><br><span class="line">    &#123; ngx_string(<span class="string">"stop"</span>), NGX_DEBUG_POINTS_STOP &#125;,    ------ <span class="number">3</span></span><br><span class="line">    &#123; ngx_string(<span class="string">"abort"</span>), NGX_DEBUG_POINTS_ABORT &#125;,</span><br><span class="line">    &#123; ngx_null_string, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>1.较为完整的代码块间的距离为空两行。如函数声明、函数定义之间等</strong></p><p>即,代码块之间,</p><p>e.g. :#include预处理命令,多行注释块,函数原型,函数定义</p><p><strong>2.函数声明或定义若一行显示不下，则函数原型空4个空格</strong></p><p><strong>3.结构体数组的花括号和内容之间空一个空格</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span>  ngx_epoll_commands[] = &#123;          ------- <span class="number">4</span></span><br><span class="line">                                                        ------- <span class="number">5</span></span><br><span class="line">    &#123; ngx_string(<span class="string">"epoll_events"</span>),</span><br><span class="line">      NGX_EVENT_CONF|NGX_CONF_TAKE1,</span><br><span class="line">      ngx_conf_set_num_slot,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      offsetof(<span class="keyword">ngx_epoll_conf_t</span>, events),</span><br><span class="line">      <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; ngx_string(<span class="string">"worker_aio_requests"</span>),</span><br><span class="line">      NGX_EVENT_CONF|NGX_CONF_TAKE1,</span><br><span class="line">      ngx_conf_set_num_slot,</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">      offsetof(<span class="keyword">ngx_epoll_conf_t</span>, aio_requests),         -------- <span class="number">6</span></span><br><span class="line">      <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">      ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4. 结构体数组的左花括号放在同一行上 </strong></p><p><strong>5. 较大的结构体数组元素最开始空一行。</strong></p><p><strong>6. 元素内容上下对齐 </strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_module_t</span>  ngx_epoll_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_epoll_module_ctx,               <span class="comment">/* module context */</span>      ------- <span class="number">9</span></span><br><span class="line">    ngx_epoll_commands,                  <span class="comment">/* module directives */</span></span><br><span class="line">    NGX_EVENT_MODULE,                    <span class="comment">/* module type */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* init master */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* init module */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* init process */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* init thread */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* exit thread */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* exit process */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                <span class="comment">/* exit master */</span></span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>7. 元素内容上下对齐</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span></span><br><span class="line">ngx_event_del_timer(<span class="keyword">ngx_event_t</span> *ev)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="built_in">log</span>, <span class="number">0</span>,           ----- <span class="number">8</span></span><br><span class="line">                   <span class="string">"event timer del: %d: %M"</span>,</span><br><span class="line">                    ngx_event_ident(ev-&gt;data), ev-&gt;timer.key);</span><br><span class="line"></span><br><span class="line">    ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);</span><br></pre></td></tr></table></figure><p><strong>8. 函数调用折行时,按照左括号对齐,或者说,参数上下对齐</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                                       ------ <span class="number">11</span></span><br><span class="line">    <span class="keyword">ngx_str_t</span>                        name;             ------ <span class="number">9</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">ngx_addr_t</span>                      *addrs;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       naddrs;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       weight;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       max_conns;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       max_fails;</span><br><span class="line">    <span class="keyword">time_t</span>                           fail_timeout;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       slow_start;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       down;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>                         backup:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    NGX_COMPAT_BEGIN(<span class="number">6</span>)</span><br><span class="line">    NGX_COMPAT_END</span><br><span class="line">&#125; <span class="keyword">ngx_http_upstream_server_t</span>;</span><br></pre></td></tr></table></figure><p><strong>9. 变量声明的类型上下排列按照从短到长的顺序。注意，最下面的变量的类型和名称间的空格为2-3个</strong></p><p><strong>10. 变量名称上下对齐——字母对齐，不包括指针的*号,</strong></p><p><strong>11. 结构体,使用typedef进行命名</strong></p><p><strong>在函数中,相同类型的声明,放在同一行.结构体,则不然</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ccf-&gt;pid.len != old_ccf-&gt;pid.len</span><br><span class="line">    || ngx_strcmp(ccf-&gt;pid.data, old_ccf-&gt;pid.data) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p><strong>当条件表达式过长需要折行时，关系运算符须位于下一行的行首</strong></p><p><strong>并与上一行的条件表达式的第一个字符对齐，同时右花括号须位于单独的一行</strong></p><p><strong>并与if/while等关键字对齐</strong></p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编语言(一)_基础知识</title>
      <link href="/2017/11/07/Assembly/assembly(1)/"/>
      <url>/2017/11/07/Assembly/assembly(1)/</url>
      <content type="html"><![CDATA[<p><em>汇编语言,没想到有一天我也要将重心放在汇编上进行学习.以前,都是进行调侃,说用汇编写”Hello World”</em></p><p><em>不过,作为一门语言来讲,汇编还是很有意思的,在这里可以清楚的明白pointer到底为何物 ? </em></p><p><em>先从基础知识开始积累</em></p><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h2><p>计算机的发展仅仅只有不到一百年的历史,发展十分迅速.但是,在最初的阶段,计算机的发展也是步履维艰的</p><p><strong>计算机是电子设备,所以其中进行信息的表示都是使用高低电平的.</strong></p><p><strong>那么表示高低电平这两种状态最简单的就是使用0,1两种状态.</strong></p><p><strong>常用的机器指令,就是一列二进制数,而计算机就将这一列二进制数转换成为高低电平来表示指令</strong></p><blockquote><p>Tips: 计算机与PC机</p></blockquote><blockquote><p>来区分一个容易混淆的概念,计算机与PC机.从广义的角度上来讲,这两者是一致的.</p></blockquote><blockquote><p>但是,实际上计算机指的是可以执行机器指令,进行运算的机器,这是早期的计算机的概念</p></blockquote><blockquote><p>而PC机则是现代意义上的计算机,有一个芯片就可以完成上面所有的任务,即CPU</p></blockquote><blockquote><p>那么,PC机是什么?,CPU与其他直接或者间接受CPU控制的芯片,器件,设备组成的计算机系统,即是PC机</p></blockquote><p>而每一种微处理器,由于硬件设计,内部结构的不同.造成其需要不同的电平脉冲进行指令操作</p><p><strong>每一种微处理器都有其自身的机器指令集,即机器语言,这也是造成汇编语言基本没有可移植性的原因</strong></p><p>早期的程序员,真的是十分辛苦的,因为机器语言的缘故,使得要使用纸带以及卡片机进行编程</p><p>这样有两个致命缺点:</p><p><strong>1.编程时难度大,极易出错</strong></p><p><strong>2.后期的维护很不方便,出错后,进行Debug也是十分的麻烦</strong></p><p>所以,才有了汇编语言的诞生,以至于之后还衍生出了许多更高级的语言</p><h2 id="1-2-汇编语言"><a href="#1-2-汇编语言" class="headerlink" title="1.2 汇编语言"></a>1.2 汇编语言</h2><p>由以上可知,<strong>机器语言,晦涩,难懂,不便于维护</strong>,所以就出现了汇编语言</p><p>什么是汇编语言呢?</p><p><strong>汇编语言,主体是汇编指令,汇编指令就是机器语言(机器指令)的助记符,实质是相同的</strong></p><p><strong>汇编指令仅仅只是机器指令便于记忆的格式</strong></p><p>来举个例子:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作:寄存器<span class="built_in">BX</span>的内容送到<span class="built_in">AX</span>中</span><br><span class="line"></span><br><span class="line">机器指令:<span class="number">1000100111011000</span></span><br><span class="line"></span><br><span class="line">汇编指令:<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br></pre></td></tr></table></figure><p>由上面的这个例子,可以很清楚的看出汇编指令的作用了吧,</p><p><strong>对,没错,使用汇编指令可以大幅提高程序开发的效率和后期维护的方便</strong></p><p>所以,程序员的开发模式由:</p><p>程序员 -&gt; 机器语言 -&gt; 计算机</p><p>程序员 -&gt; 汇编语言 -&gt; 编译器 -&gt;机器语言 -&gt; 计算机</p><p>大大得体高了程序设计的效率</p><blockquote><p>Tips: 汇编代码大小写的问题</p></blockquote><blockquote><p>汇编代码的大小写并无差异，对于汇编指令而言</p></blockquote><blockquote><p>但是，对于程序员所定义的变量之类而言，是要严格区分大小写的</p></blockquote><blockquote><p>即{MOV,PUSH,ADD,LOOP…} == {mov,push,add,loop}</p></blockquote><h2 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h2><p>汇编语言主要由三种内容组成:</p><table><thead><tr><th>序号</th><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>汇编指令</td><td>机器码的助记符,有对应的机器码</td></tr><tr><td>2</td><td>伪指令</td><td>由编译器执行,计算机不执行,没有机器码</td></tr><tr><td>3</td><td>其他符号</td><td>如+,-,/,*等,由编译器识别,没有对应的机器码</td></tr></tbody></table><h2 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h2><p>存储器是在计算机科学中常提到的一个词,实际上,就是我们平时所说到的内存</p><p>内存有什么用呢?</p><p><strong>内存可以暂时存储CPU需要进行处理的数据,需要操作的指令</strong></p><p><strong>所以说,性能再强的CPU脱离了内存也是无法工作的</strong></p><p><strong>内存不同于硬盘,硬盘的数据需要读入内存中才能被CPU使用</strong></p><p>我们想要学好汇编语言,就必须对计算机的内从优一定程度上的了解与熟悉</p><h2 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h2><p>在计算机中,对于指令和数据是不加区分的(在内存中)</p><p><strong>在内存中,指令和数据都是以二进制的形式存储的,系统不会区分是指令还是数据</strong></p><p>如:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000100111011000</span> -&gt; <span class="number">89D8H</span> (数据)</span><br><span class="line"><span class="number">1000100111011000</span> -&gt; <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span> (指令)</span><br></pre></td></tr></table></figure><p>同样的二进制数字,可以是数据,也可以是指令,具体作为指令还是数据处理,在从内存中取出时进行区分</p><h2 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h2><p>前面说了很多,汇编语言是直接操控硬件,主要的是进行计算机内存的处理.</p><p>那么,关于存储单元的知识就需要好好理解了</p><p>之前提到过,存储器指的是内存,我们使用内存总不可能一次直接将它都使用了,对吧</p><p>所以,为了更好地利用内存,才会有存储单元的概念.</p><p><strong>所谓,存储单元,指的是将存储器进行划分，一个存储单元所能存储的信息为1byte</strong></p><p>所以如果一个存储器有128个存储单元，那么他所能存储的信息就有128byte</p><p>对于微机存储器来讲，我们可以说他的容量就是128字节</p><blockquote><p>Tips: 关于存储单位</p></blockquote><blockquote><p>字：word＝２Byte＝16Bit</p></blockquote><blockquote><p>字节：1 Byte= 8 Bit</p></blockquote><blockquote><p>位：计算机中最小的存储单位</p></blockquote><blockquote><p>B=Byte=byte</p></blockquote><blockquote><p>b=bit=Bit</p></blockquote><h2 id="1-7-CPU对于存储器的读写"><a href="#1-7-CPU对于存储器的读写" class="headerlink" title="1.7 CPU对于存储器的读写"></a>1.7 CPU对于存储器的读写</h2><p>存储器在计算机中被分成了多个存储单元,那么计算机(PC机中的CPU)如何对其进行访问,操作呢?</p><p>CPU(计算机)对存储器的读写是依靠总线的,</p><blockquote><p>Tips: 总线</p></blockquote><blockquote><p>由导线组成的传输线束,是计算机的内部结构.</p></blockquote><blockquote><p>CPU,内存,输入/出设备的公用通道,主机部件由总线连接</p></blockquote><blockquote><p>外部设备通过相应的接口电路与总线连接</p></blockquote><blockquote><p>系统总线,包括,数据总线,地址总线,控制总线,这三种即为通常意义上的总线</p></blockquote><blockquote><p>另外还有,扩展总线,局部总线.注意在某些硬件上,Data,Address总线是可以进行复用的</p></blockquote><p>CPU要对存储器进行操作,分析可得,它需要三种总线:</p><p>1.地址总线:用来对存储单元进行寻址,要知道操作的存储单元的地址</p><p>2.控制总线:对存储单元那个进行操作,进行何种操作,即对存储单元的控制</p><p>3.数据总线:获取到地址以及操作后,就需要数据总线来进行数据的传输</p><p>CPU对存储器进行操作,总共有一下的三种信息交互:</p><ul><li><p>存储单元的地址(地址信息)</p></li><li><p>器件的选择,读或写命令(控制信息)</p></li><li><p>读或写的数据(数据信息)</p></li></ul><p>下面来看一张图,明白CPU如何进行操作</p><p><img src="http://oz3e8fi42.bkt.clouddn.com/1.png" alt=""></p><p>上图中的过程是这样的:</p><p>1.CPU通过地址线将寻址信息发出</p><p>2.CPU通过控制总线发出内存读命令,选中存储器芯片,并且通知它,将要从中读取数据</p><p>3.使用数据总线,将数据8送入CPU</p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p><strong>地址总线决定了CPU的寻址能力</strong></p><p>地址总线是用来寻址的,那么地址的寻址范围有多少呢?</p><p>每一根导线上由高低电平之分,即一根导线可以表示两种状态,我们来抽象一下</p><p>一根导线可以表示,0,1两种信息,设地址总线共有N根导线组成,</p><p><strong>地址总线的寻址单元有, 2 ^ N ,范围为 0 ~ 2^N - 1 </strong></p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>CPU与内存或者其他器件之间的数据传送是通过数据总线来进行的.</p><p><strong>数据总线的宽度决定了CPU和外界数据的传送速度</strong></p><p>8根数据总线一次可以传送一个字节的数据,16根总线一次可以传送两个字节的数据</p><p>8086CPU以及8088CPU的数据总线宽度分别为16和8</p><p>所以对于两个字节的数据,8086CPU一次即可传输完毕,而8088CPU需要两次才能将数据输送完毕</p><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p><strong>控制总线决定了CPU对系统中其他器件的控制能力</strong></p><p>控制总线,并不是一条总线,实际上是很多控制线的集合.比如上面进行从内存中进行数据读写的操作</p><p>既有”读输出信号”的控制总线,用来从CPU中输出信号</p><p>又有”写输出信号”的控制总线,负责传送写信号</p><blockquote><p>Tips:关于总线能力的描述</p></blockquote><blockquote><p>地址总线: 依靠所能访问到的存储单元总量来描述,比如,有13根地址总线的CPU,</p></blockquote><blockquote><p>它的寻址能力就是2^13 = 8KB,即我们用该CPU的寻址能力是8KB来描述它</p></blockquote><blockquote><p>数据总线: 便可以通数据总线的宽度来描述,总线越宽,一次能传输的数据越多</p></blockquote><blockquote><p>控制总线: 所集成的控制总线越多,所能控制的CPU器件就越多,控制能就越强</p></blockquote><h2 id="1-8-内存地址空间"><a href="#1-8-内存地址空间" class="headerlink" title="1.8 内存地址空间"></a>1.8 内存地址空间</h2><p>我们使用汇编语言,而汇编语言更多的操作基本上是集中在内存,寄存器这些存储空间中的.</p><p>所以认识内存地址空间是很有必要的</p><p>首先来看两个概念:<strong>主板</strong>与<strong>接口卡</strong></p><h4 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h4><p>每一台PC机上面都是存在主板的,随着计算机的发展,计算机已经不仅仅是计算机(指CPU)</p><p>主板上有着各种各样的器件,这些器件通过总线相连</p><p>举一个例子,如果说计算机是一座城市,那么主板便是城市中川流不息的汽车</p><p><strong>CPU,存储器,外围芯片组,扩展插槽等,扩展插槽上一般插有RAM内存条,以及各种各样的接口卡</strong></p><h4 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h4><p>为什么会有接口卡?</p><p>CPU对于计算机所有的部件都要有绝对的控制,但是对于一些外部设备</p><p>比如,鼠标,键盘,音响设备这些,都不能进行直接的控制,这些设备是平时接在接口卡上的</p><p>接口之后再通过总线CPU相连,即CPU通过直接控制接口卡,实现间接控制外部设备</p><h4 id="各类存储器芯片"><a href="#各类存储器芯片" class="headerlink" title="各类存储器芯片"></a>各类存储器芯片</h4><p>PC机中有许多的存储器芯片,根据读写属性来分,为RAM(随机存储器)与ROM(只读存储器)</p><p>RAM,随机存储器:</p><p>此类存储器,可读可写,但是必须带电存储,没电的时候,一切GG</p><p>ROM,只读存储器:</p><p>此类存储器,可读不可写,及时断电之后也可以保存数据</p><p>从连接与功能上来分:</p><ul><li>随机存储器</li></ul><p>用于存放供CPU上绝大部分的程序和数据,主随机存储器一般由两个位置上的RAM组成</p><p><strong>装在主板上的RAM以及插在扩展插槽上的RAM</strong></p><ul><li>装有BIOS的ROM</li></ul><p>BIOS,即为(Basic Input/Output System),BIOS不单指在主板上的BIOS,其实BIOS指的是主板</p><p>以及各类接口卡厂商提供的软件系统,可以通过这样使硬件进行基本的输入输出</p><p><strong>在主板即各类接口卡上插有存储BIOS的ROM</strong></p><blockquote><p>TIps: 联系日常</p></blockquote><blockquote><p>通常,我们说的BIOS指的是主板BIOS,即系统BIOS</p></blockquote><blockquote><p>而且,RAM,ROM并不是单指其中一个存储器,它指的是一类存储器,在PC机的各个位置都会有其存在</p></blockquote><blockquote><p>另外有关RAM,ROM的概念,详情参考&lt;计算机科学导论&gt;</p></blockquote><ul><li>接口卡上的RAM</li></ul><p>对于接口卡,在处理大批量数据时,也是需要进行暂时存储的,就需要用到RAM</p><p>典型的是,插在显卡上的RAM,俗称显存,我们只要将想要显示的内容写在显存中,屏幕上就会出现内容</p><p><img src="http://oz3e8fi42.bkt.clouddn.com/Screenshot_20171108_164917.png" alt=""></p><h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p>现在有了知识积累后,在来看看内存地址空间的内容</p><p>CPU在进行计算机控制时,将上面这么多的存储器都作为内存对待,不仔细的进行区分.</p><p><strong>把它们看成总的一个由多个存储单元组成的逻辑存储器,而这个逻辑存储器就是我们说的内存地址空间</strong></p><p><strong>在汇编中,我们操控的便是内存地址空间</strong></p><p><img src="http://oz3e8fi42.bkt.clouddn.com/Screenshot_20171108_164933.png" alt=""></p><p>上面的逻辑存储器占有一个地址段,这个地址段即为CPU的地址总线所能访问到的所有存储单元</p><p><strong>内存地址空间的大小受CPU总线宽度的限制</strong></p><p>我们在基于计算机硬件进行编程的时候必须知道其第一个单元的地址和最后一个单元的地址</p><p><strong>即我们必须知道内存得分配情况</strong></p><p><strong>至于为什么要了解内存地址空间,因为我们汇编程序的代码最后都是由CPU执行</strong></p><p><strong>所以我们就要从CPU的角度考虑问题,对CPU来讲所有存储器单元都是处于一个统一的逻辑存储器中</strong></p><p><strong>他的容量受到CPU地址总线(寻址能力)的限制</strong></p><blockquote><p>Tips: 内存地址空间相关</p></blockquote><blockquote><p>首先,来谈一些总线的事,</p></blockquote><blockquote><p>1.地址总线,数据总线之间并无必然的相等关系,可以不相等</p></blockquote><blockquote><p>2.常常谈到的CPU位数指的是数据通路的位数,即数据总线的宽度</p></blockquote><blockquote><p>3.而操作系统的位数指的便是操作系统寻址能力,所以才有XP支持到4G的说法</p></blockquote><blockquote><p>而上面说到的,也只是以前的理论知识,到了现在,随着计算机的发展,已经大变样了</p></blockquote><blockquote><p>XP只支持到4G,也不是绝对的,还可以使用虚拟内存,扩展的…之类的</p></blockquote><blockquote><p>另外有一点,便是理论值也并不是实际的情况,因为实际上就没有那么大的需求</p></blockquote><blockquote><p>理论上操作系统的支持内存XXXXXGB,实际上目前支持到约192GB(Win10)</p></blockquote><blockquote><p>64位处理器的总线基本上也就在39左右浮动,比如我的机子</p></blockquote><blockquote><p>39物理总线,48虚拟总线</p></blockquote><blockquote><p><img src="http://oz3e8fi42.bkt.clouddn.com/Screenshot_20171108_173040.png" alt=""></p></blockquote><p>最后,说一点学习的感受吧:</p><p>学习汇编,感觉一般都是学习硬件知识,与之前的高级语言学习完全不一样</p><p>知识在不断更新,而且网上鱼龙混杂,很麻烦</p><p>好累,果然学习内核方向需要耐得住寂寞…</p><p>November 8, 2017 5:32 PM</p>]]></content>
      
      <categories>
          
          <category> Assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VimScript的学习(五)</title>
      <link href="/2017/10/24/VimScript/VimScript(V)/"/>
      <url>/2017/10/24/VimScript/VimScript(V)/</url>
      <content type="html"><![CDATA[<p><em>程序是用来操控数据的</em></p><p><em>现在开始,我们来介绍VimScript中进行操作的6种变量类型</em></p><p><em>数字,浮点型,字符串,列表,字典,函数引用(不做讨论)</em></p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>在程序中操纵数据是再平常不过的事情了</p><p>而数值类型则是一种很常见的变量类型,VimScript中有两种数值类型:数字与浮点型</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo 100</span><br><span class="line">echo 0xff</span><br><span class="line">echo 017</span><br><span class="line">echo 019</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_number.png" alt=""><br>VimScript中支持使用八进制,十六进制进行数字的设定</p><p>上面的示例中,显示了</p><p>为什么最后一个是19</p><p><strong>因为八进制没有9,按10进制处理,Vim会自动处理掉这个错误,所以建议一般写十进制为好</strong></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型,可以使用多种形式进行表示</p><p>但是,<strong>不能使用echom,echom不接受浮点型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 100.1    #=&gt; 100.1</span><br><span class="line">echo 5.45e+3  #=&gt; 5450.0</span><br><span class="line">echo 5e10     #=&gt; Error!   并非是浮点型</span><br></pre></td></tr></table></figure><p><strong>当使用数值与浮点型混用时,Vim会强制转换类型,将所有的数值转换为浮点型</strong></p><p><strong>以Float形式作为结果</strong></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串,是一个很大的类型,为什么这么说呢?</p><p><strong>因为VimScript就是用来处理文本的,所以字符串是一个很大的类型,Ruby,Perl也是如此</strong></p><h3 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h3><p><code>echo &quot;Hello,&quot; + &quot;World&quot;</code></p><p>是不会生效的,因为”+”运算符只适用与数值类型与列表类型,对于字符串是不适用的</p><p><strong>强行使用,会将字符串强转为数值类型,(转换规则之前已经提到过了)</strong></p><p>对于字符串,使用<strong>连接运算符</strong>进行字符串的的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello ,&quot; . &quot;World&quot;    #=&gt; &quot;Hello,World&quot;</span><br><span class="line">echo 10 . &quot;abc&quot;             #=&gt; &quot;10abc&quot;</span><br><span class="line">echo 10.1 . &quot;foo&quot;           #=&gt; Error!   Float不能转换为字符串</span><br></pre></td></tr></table></figure><p><strong>这就是VimScript不善解人意的地方 : </strong></p><p><strong>可以在进行 “ + “ 运算时,将String转为数值</strong></p><p><strong>但是, “ . “ 运算时不能将Float转换为String</strong></p><p><strong>所以,建议在VimScript书写时,如果需要即进行变量类型的转换时,请显式的进行类型准换</strong></p><p><strong>不要依赖于Vim自身的类型转换,不靠谱,出来混迟早是要还的</strong></p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>同其他的编程语言一样,对于不能进行输入的字符,可以使用转义字符来进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;foo\&quot;bar\&quot;&quot;   #=&gt; foo&quot;bar&quot;</span><br><span class="line">echo &quot;foo\nbar&quot;     #=&gt; foo&lt;换行&gt;bar</span><br><span class="line">echom &quot;foo\nbar&quot;    #=&gt; foo^@bar   echom 会将一些特殊字符进行输出,而不是进行功能性输出</span><br></pre></td></tr></table></figure><p>对于这种echom诡异的情况,就要使用字符串字面量,来进行处理</p><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>为了上面的转义字符滥用的情况,所以我们使用字符串字面量来进行处理</p><p><strong>字符串字面量:所见即所得,几乎没有转义的情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echom &apos;foo\nbar&apos;  #=&gt; &quot;foo\nbar&quot;</span><br><span class="line">echo &apos;that&apos;&apos;s&apos;   #=&gt; &quot;that&apos;s&quot;</span><br></pre></td></tr></table></figure><p><strong> ‘ ‘ 即是唯一的例外,进行转义,其余所有的字符串都是不会进行转义的</strong></p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>前面提到了这么多的字符串,那么其进行处理的字符串函数也是有很多的</p><ul><li>长度</li></ul><p>类似于C语言,使用strlen(string-length)来进行字符串长度的求解</p><p>len函数也是可以使用的,但是len函数也用在列表求解时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo strlrn(&quot;foo&quot;)</span><br><span class="line">echo len(&quot;foo&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_strlen.png" alt=""></p><ul><li>切割</li></ul><p>可以按照指定的字符将字符串切割成列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo split(&quot;abc&quot;)</span><br><span class="line">echo split(&quot;a,b,c&quot;,&quot;,&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_split.png" alt=""><br><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_split,,,.png" alt=""></p><ul><li>连接</li></ul><p>对于字符串的连接处理,是类似于列表的,好吧,其实就是列表</p><p>使用join函数,将字符串使用指定的连接符进行连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo join([&quot;abc&quot;,&quot;def&quot;],&quot;--&quot;)</span><br><span class="line">echo join([&quot;abc,&quot;def&quot;])</span><br></pre></td></tr></table></figure><p><strong>第三个参数缺省的情况下,使用空格进行字符串符的连接</strong></p><p><strong>split函数与join函数合作十分密切</strong></p><ul><li>大小写的转换</li></ul><p>这个可就真的是类似于C了</p><p>使用tolower( )以及toupper( )函数进行大小写转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo tolower(&quot;Foo&quot;)</span><br><span class="line">echo toupper(&quot;Foo&quot;)</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_lower.png" alt=""><br><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_upper.png" alt=""></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表,也可以叫做有序链表.</p><p>对Python,我基本没学过,从Ruby的角度来讲,基本同Array</p><p>(不多说了,毕竟什么语言就是什么语言,不能整天在类比)</p><p><strong>VimScript的列表是有序的,异质的元素集合</strong></p><p><strong>列表中可以嵌套列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo [1,2,3]  #=&gt; [1,2,3]</span><br><span class="line">echo [[1,2],3] #=&gt; [[1,2],3]</span><br></pre></td></tr></table></figure><h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h3><p>列表,是有序的集合,所以输出列表需要依靠索引</p><p>索引,简单地来讲,就是下标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo [1,2,3][0] #=&gt; 1</span><br><span class="line">echo [1,[2,3]][1] #=&gt; [2,3]</span><br></pre></td></tr></table></figure><p>同时,VimScript还可以进行反向索引,反向索引的时候,</p><p><strong>-1为最后一个元素,-2为倒数第二个元素,以此类推</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo [1,2,3][-1]  #=&gt; 3</span><br><span class="line">echo [[1,2],3][-2]  #=&gt; [1,2]</span><br></pre></td></tr></table></figure><h3 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h3><p>切割即将列表中的元素按照需要的顺序进行切割并显示</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo [1,2,3,4][1:2]   #=&gt; [2,3]</span><br><span class="line">echo [1,2,3,4][-2:-1] #=&gt; [3,4]</span><br><span class="line">echo [1,2,3,4][:2]    #=&gt; [1,2,3]</span><br><span class="line">echo [1,2,3,4][3:]    #=&gt; [4]</span><br></pre></td></tr></table></figure><p>有上面的例子可以看出,切割需要注意的点有:</p><ul><li><p>切割时的索引也是从0开始</p></li><li><p>切割必须遵守列表顺序,否则为空</p></li><li><p>切割可以反向索引,但是必须遵守第二条</p></li><li><p>切割时,左缺省置为0,右缺省值为最大值</p></li></ul><p><strong>可以使用负数索引列表,但是不能使用负数索引字符串!</strong></p><p>这个例子,直观又贴切</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;abcd&quot;[-1] . &quot;abcd&quot;[-2:-1]</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%28V%29_cd.png" alt=""></p><p><strong>第一个字符串索引值为空,得到一个空的字符串.</strong></p><p><strong>第二个字符串进行切割,获得的结果cd, “ . “ 连接运算符的结果是”cd”</strong></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>想要连接Vim中的列表,直接 “+”就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [&apos;a&apos;,&apos;b&apos;] + [&apos;c&apos;]   #=&gt; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br></pre></td></tr></table></figure><h3 id="列表函数"><a href="#列表函数" class="headerlink" title="列表函数"></a>列表函数</h3><p>上面这些都是些正常的列表操作,当然列表也是有很多的函数的</p><ul><li>add( )函数</li></ul><p><strong>用于进行列表的扩展使用,即给列表后添加内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo = [&apos;a&apos;]</span><br><span class="line">call add(foo,&apos;b&apos;)</span><br><span class="line">echo foo            #=&gt; [&apos;a&apos;,&apos;b&apos;]</span><br></pre></td></tr></table></figure><ul><li>get( )函数</li></ul><p>用于进行列表值的获取,基本用法</p><p><code>get(List,index,&#39;default&#39;)</code></p><p><strong>获取List列表中,索引为index的元素,若元素不存在,则将’default’作为结果,default缺省值为0</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">let a = get(foo,1,&apos;default&apos;)</span><br><span class="line">let b = get9foo,2,&apos;default&apos;)</span><br><span class="line">echo a         #=&gt; &apos;b&apos;</span><br><span class="line">echo b         #=&gt; &apos;default&apos;</span><br></pre></td></tr></table></figure><ul><li>index( )函数</li></ul><p><strong>用于返回List中元素的索引,若元素不存在,则返回-1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo index([1,2,3],1)       #=&gt; 0</span><br><span class="line">echo index([1,2,3],&quot;1&quot;)     #=&gt; -1</span><br></pre></td></tr></table></figure><ul><li>join( )函数</li></ul><p>其实这个函数,之前在字符串的部分已经见过了.</p><p>但是,当时只是为了进行字符串的连接使用</p><p>实际上,join( )函数,是进行列表元素的连接使用</p><p><strong>将列表元素按照给定的连接字符进行连接成为字符串,若非字符串的项,强转为字符串</strong></p><p><strong>连接符的缺省值为空格</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo = [1,2,3]</span><br><span class="line">echo join(foo,&quot;,&quot;)    #=&gt; 1,2,3</span><br><span class="line">echo join(foo)        #=&gt; 1 2 3</span><br><span class="line">echo join(foo,&quot;&quot;)     #=&gt; 123</span><br></pre></td></tr></table></figure></p><ul><li>reverse( )函数</li></ul><p><strong>不需要多说,很简单的就地转置函数,将列表进行转置</strong></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>最后的一种数据类型了,字典这种数据类型在很多语言中都是存在的</p><p><strong>Python中的dict,Ruby中的hash,JavaScript中的Object,都是类似的key-value键值对</strong></p><p>字典用花括号创建,值是异质的,但是会被强转为字符串</p><p><strong>因为value只能是字符串啊 ! </strong></p><p>Vim将value强转为字符串,但是保持值不变</p><p><strong>同时,VimScript改进了JavaScript中的蠢笨之处,字典末尾是可以保留逗号的</strong></p><p><strong>建议在字典末尾保留 , (逗号),便于字典元素换行时,可以保证不会出现添加元素缺少逗号的问题</strong></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>既然数据类型相似,那么语言之间进行字典的索引基本都是相同的,对没错,使用键进行访问即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = &#123;&apos;a&apos;:&quot;1&quot;,&apos;b&apos;:&quot;2&quot;&#125;</span><br><span class="line">echo foo[&apos;a&apos;]          #=&gt; 1</span><br><span class="line">echo foo[b]            #=&gt; 2</span><br></pre></td></tr></table></figure><p>同时,<strong>如果,键key仅由字母/下划线组成时,VimScript也支持JavaScript风格的 ‘ . ‘查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo foo.a    #=&gt; 1</span><br><span class="line">echo foo.b    #=&gt; 2</span><br></pre></td></tr></table></figure><h3 id="赋值与添加"><a href="#赋值与添加" class="headerlink" title="赋值与添加"></a>赋值与添加</h3><p>赋值与添加新项的操作是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;1:&quot;a&quot;,2:&quot;b&quot;,&#125;</span><br><span class="line">let foo.1 = &quot;c&quot;</span><br><span class="line">let foo.3 = &quot;d&quot;</span><br><span class="line">echo foo          #=&gt; &#123;&apos;1&apos;:&apos;c&apos;,&apos;2&apos;:&apos;b&apos;,&apos;3&apos;:&apos;d&apos;&#125;</span><br></pre></td></tr></table></figure><h3 id="移除项"><a href="#移除项" class="headerlink" title="移除项"></a>移除项</h3><p>进行字典项的移除时,有两种方法</p><ol><li><p>使用remove函数</p></li><li><p>使用unlet命令</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unlet foo.3</span><br><span class="line">echo foo           #=&gt; &#123;&apos;1&apos;:&apos;c&apos;,&apos;2&apos;:&apos;b&apos;,&#125;</span><br><span class="line">let test = remove(foo,2)</span><br><span class="line">echo foo           #=&gt; &#123;&apos;1&apos;:&apos;c&apos;&#125;</span><br><span class="line">echo test          #=&gt; b</span><br></pre></td></tr></table></figure><p><strong>remove函数可以移除项,并且返回被移除的项值,unlet函数能做的,remove都可以</strong></p><p><strong>所以,建议使用remove函数,同时,你不能移除不存在的项,会抛出异常</strong></p><h3 id="字典函数"><a href="#字典函数" class="headerlink" title="字典函数"></a>字典函数</h3><p>同理于列表,字典也是存在许多的字典函数的</p><p>存在着类似的get( )函数</p><ul><li>get( )函数</li></ul><p><code>get(Dict,index(key),default)</code>类似于List的get函数</p><ul><li>has_key( )函数</li></ul><p><strong>用于判断Dict是否存在改建值对,返回1/0</strong></p><p><strong>可以用此来判断真假</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo has_key(&#123;&apos;a&apos;:100&#125;,&apos;a&apos;)  #=&gt; 1</span><br><span class="line">echo has_key(&#123;&apos;a&apos;:100&#125;,&apos;a&apos;)  #=&gt; 0</span><br></pre></td></tr></table></figure><ul><li>items( )函数</li></ul><p>可以使用items( )函数查看该Dict中所有的键值对,<strong>获取结果为嵌套列表</strong></p><p><strong>但是,切记items( )中的键值对是无序的</strong></p><p><strong>同时,使用keys,values可以获得,键,值的所有值</strong></p><p>至此,所有的VimScript的数据类型已经介绍完毕了</p><p>在理接的过程中,我也是觉得,使用help命令十分的重要,可以帮助你学习很多注意不到地方</p><p>同时,也请注意进行规范的操作,</p><p><strong>Vim会自动的将一些错误进行抹除,严重的影响程序设计</strong></p><p>目前关于VimScript的学习暂时到此,下面我会进行一段时间插件开发的学习,之后再进行总结</p><p>October 25, 2017 9:41 PM</p>]]></content>
      
      <categories>
          
          <category> VimScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VimScript的学习(四)</title>
      <link href="/2017/10/19/VimScript/VimScript(IV)/"/>
      <url>/2017/10/19/VimScript/VimScript(IV)/</url>
      <content type="html"><![CDATA[<p><em>说在前面</em></p><p><em>选择VimScript学习,真的是一腔热血,其实这门语言的局限型</em></p><p><em>比想象中还要小,不只是只能用于Vim插件的开发</em></p><p><em>而且,是只能跑在Vim平台上的,<code>:source</code>,执行脚本,以<code>.vim</code>为文件扩展名</em></p><p><em>而且,因为小众,历史原因的问题,语法也有点混乱,算是微型PHP</em></p><p><em>其中有着各种各样的奇奇怪怪的问题,很烦人的</em></p><p><em>但是,兴趣既是导向,学吧,Fighting!</em></p><p><strong>也感谢@kang,让我明白.想做就去做</strong></p><h2 id="关于VimScript"><a href="#关于VimScript" class="headerlink" title="关于VimScript"></a>关于VimScript</h2><p><strong>这是一门将脚本语言 + Vim设置 混搭的语言</strong></p><p><strong>只能运行在Vim平台上的</strong></p><p><strong>在Vim中 : source  * . vim 即可运行VimScript程序</strong></p><p><strong>文件扩展名为 .vim </strong></p><p><strong>另外注明 : 在VimScript中进行书写的时候,是不需要 : 的,而含有”:”的都是在Vim中的命令操作</strong></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>VimScript作为一门脚本语言,其中也是可以使用变量的</p><p>来看一个简单地例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:let foo = &quot;bar&quot;</span><br><span class="line">echo foo  #=&gt; &quot;bar&quot;</span><br><span class="line">:let foo = 5</span><br><span class="line">echo foo  #=&gt; 5</span><br></pre></td></tr></table></figure><p>从上面可以看出,VimScript貌似是动态语言,但是,我只能说你太年轻了</p><p>后面的东西会告诉你,VimScript,<strong>只能算是半动态语言</strong></p><h3 id="作为变量的选项"><a href="#作为变量的选项" class="headerlink" title="作为变量的选项"></a>作为变量的选项</h3><p>VimScript是一门用于Vim脚本开发的脚本语言,所以,VimScript中既有脚本语言的内容,同时也嵌套着Vim命令</p><p>那么,Vim中作为设置选项的,可以作为变量使用吗?</p><p><strong>答案是肯定的</strong></p><p>对于作为变量设定的选项,也是可以作为变量使用,同时可以藉此进行选项的修改,利用脚本操作Vim</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:echo &amp;numberwidth</span><br><span class="line">:let &amp;numberwidth=10</span><br><span class="line">:echo &amp;numberwidth</span><br></pre></td></tr></table></figure><p>同时,我们不仅可以设置数值型选项</p><p>布尔型选项也可以设置</p><p><strong>truthy = 所有非0值 , false = 0</strong></p><p>那么为什么要使用let呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set textwidth=100</span><br><span class="line">:let &amp;numberwidth=&amp;textwidsth-90</span><br><span class="line">:echo &amp;numberwidth</span><br></pre></td></tr></table></figure><p><strong>即可看出,let是可以操作变量的.但是,set是只能操作数值型选项的,不能进行变量值的设定</strong></p><p><strong>在脚本语言中,使用let是更为方便的</strong></p><p><strong>但是,更为实际的建议是,能用set的时候就用set,因为let会使语法变得复杂</strong></p><h3 id="本地选项"><a href="#本地选项" class="headerlink" title="本地选项"></a>本地选项</h3><p>和之前提到过的进行设置是一样的,变量也是有作用域的,可以进行本地的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:let &amp;l:number = 1</span><br><span class="line">:echo &amp;l:number</span><br><span class="line"></span><br><span class="line">切换窗口</span><br><span class="line">:let &amp;1:number = 0</span><br><span class="line">(第一个窗口无效)</span><br></pre></td></tr></table></figure><p>联想之前进行的操作,相信你很容易理解,作为本地选项的含义和意义</p><h3 id="将变量作为寄存器"><a href="#将变量作为寄存器" class="headerlink" title="将变量作为寄存器"></a>将变量作为寄存器</h3><p>VimScript一个强大的地方在于:<strong>可以将寄存器作为变量使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:let @a = &quot;hello&quot;</span><br><span class="line">:echo @a</span><br></pre></td></tr></table></figure><p>同时,<code>&quot;ap</code>可以将寄存器中的内容进行粘贴</p><p>有的寄存器是匿名的,”用来表示没有进行命名的寄存器</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;@</span><br></pre></td></tr></table></figure><p>在文件中选中一个单词并且进行复制,之后再进行输出</p><p>则这个寄存器就是未命名的</p><p>可以使用<code>echo @&quot;</code>进行输出</p><p><strong>即使用@表明是使用寄存器,之后为寄存器名</strong></p><p><strong>:help registers中显示了可以使用的寄存器名</strong></p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p><em>了解过Python以及Ruby之后,会大体了解变量作用域的问题</em></p><p><em>我们再来看看Ruby作用域</em></p><ul><li>局部变量</li><li><strong>$</strong>全局变量</li><li><strong>@@</strong>类变量</li><li><strong>@</strong>实例变量</li></ul><p><strong>目前,当变量是一个字母与一个冒号开头的时候,它就是一个作用域变量</strong></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>VimScript中的条件语句,类似于Ruby,但是其中没有<strong>unless</strong></p><p>if语句的语法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件1</span><br><span class="line">  处理1</span><br><span class="line">elseif 条件2</span><br><span class="line">  处理2</span><br><span class="line">else</span><br><span class="line">  处理</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>VimScript使用以上语法进行分支操作</p><p>同时,if语句的判断条件支持表达式expr</p><p>下来我们来看三个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:echo &quot;hello&quot; + 10</span><br><span class="line">:echo &quot;10hello&quot; + 10</span><br><span class="line">:echo &quot;hello10&quot; + 10</span><br></pre></td></tr></table></figure><p>结果依次是:10,20,10</p><p>很奇妙,对吗?这就是VimScrript比较恶心的地方了</p><p><strong>1. 字符串在进行 + 运算时,会强转为数值类型</strong></p><p><strong>2. 字符串强转时,以数字开头的字符串被强转为数值,否则为’0”</strong></p><h2 id="比较-条件表达式"><a href="#比较-条件表达式" class="headerlink" title="比较(条件表达式)"></a>比较(条件表达式)</h2><p><strong>比较是很重要的一个东西</strong></p><p><strong>比较的结果,决定了条件语句,循环语句等等的结果,所以,比较语句是必须的</strong></p><p><strong>而在VimScript中,比较语句也是十分的恶心</strong></p><p>VimScript中,比较随处可见的,但是因为与Vim命令混用</p><p>所以,其中不乏会出现这样的东西:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set ignorecase              &quot; 设置大小写不敏感</span><br><span class="line">:set noignorecase            &quot; 设置大小写敏感</span><br></pre></td></tr></table></figure><p>而这样,就给我们的比较带来了问题</p><p><strong>进行字符串的比较时,到底是大写,还是小写,怎么选择?这不就是糊弄人么!</strong></p><p><strong>所以,VimScript中提供了另外两个比较运算符</strong></p><p><strong> ==? 与 ==# 分别表示比较敏感与不敏感</strong></p><p><strong>这样的话,就不会出现比较前,需要注意一下,是否被人设置了敏感大小写与否</strong></p><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数(function)"></a>函数(function)</h2><p>作为一门编程语言,是一定要支持函数的,没错吧?</p><p>VimScript中的函数写法是类似于Ruby,Golang的,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Hello( )</span><br><span class="line">  echo &quot;This is an function that is used for testing!\n&quot;</span><br><span class="line">  echo &quot;Succeed!\n&quot;</span><br><span class="line">endfunction</span><br><span class="line">call Hello( )</span><br></pre></td></tr></table></figure><p>但是,他是没有Ruby中~ { ~ } ~ 块的写法的</p><p>其中严格要求使用</p><p>function ~ endfunction的形式进行函数的定义</p><p>而且,注意了!</p><p><strong>VimScript中没有函数作用域型限制的func建议使用大写字母开头</strong></p><p>上面我们则愉快的定义了一个名为Test的无作用域限制的函数</p><p>同时,我们在看看这个函数运行的结果</p><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%284%29hello%28%29.png" alt=""><br><img src="http://oww4cv296.bkt.clouddn.com/VimScript%284%29hello_result.png" alt=""></p><p>此处有一个深坑,就是进行这些函数测试的时候,一般都是写在Vim中的,</p><p><strong>因为写在.vim文件中,无法进行执行,source文件也并不能直接执行,source只是进行代码的运行</strong></p><p><strong>即,要使用命令行写,就写到底.或者在.vim文件中直接进行调用,不然在Vim中是不能直接调用的</strong></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>在VimScript中,调用函数有两种方式,</p><p><strong>一,使用call 进行函数的调用,但是这个函数只能显示函数的副作用,所以对于没有副作用的函数,无效果</strong></p><p><strong>二,在表达式中进行函数的调用,不需要使用call,只要是使用函数的名字即可,同时传递函数的返回值</strong></p><p>举个例子,上面的Hello( )函数</p><p>可以使用<code>echom Hello( )</code>调用</p><p><strong>这会调用Hello( ),并将Hello( )的返回值传递给<code>echom</code>,但是Hello( )无返回值</strong></p><h3 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h3><p>VimScript中,使用表达式进行函数的调用时,会有<strong>返回值</strong>,对于没有显示设定返回值的函数,会隐式返回0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Hello( )</span><br><span class="line">  echo &quot;This is an function that is used for testing!\n&quot;</span><br><span class="line">  echo &quot;Succeed!\n&quot;</span><br><span class="line">endfunction</span><br><span class="line">echom Hello( )</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%284%29_shadow_value.png" alt=""><br>例如,上面的代码执行后,会有一行为0</p><p>而进行这样的修改后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Hello( )</span><br><span class="line">  echo &quot;This is an function that is used for testing!\n&quot;</span><br><span class="line">  echo &quot;Succeed!\n&quot;</span><br><span class="line"></span><br><span class="line">  return &quot;Return_Value&quot;</span><br><span class="line">endfunction</span><br><span class="line">echom Hello( )</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%284%29_result.png" alt=""></p><p>如果有C语言的编程经验,对于返回值的问题还是比较容易理解的</p><p><strong>如果VimScript函数不返回一个值,则它会隐式返回0</strong></p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>作为编程语言中的函数,<strong>一定是可以接受参数的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcation DisplayName(name)</span><br><span class="line">  echo &quot;hello,my name is&quot;</span><br><span class="line">  echo a:name</span><br><span class="line">endfunction</span><br><span class="line">call DisplayName(&quot;Crow&quot;)</span><br></pre></td></tr></table></figure><p>即可将字符串传入函数DisplayName(name)中,从而显示输入的字符串</p><p><strong>谨记:name在该函数中,是具有函数作用域的.所以,我们需要在前面加上 a: 来进行变量作用域的限制</strong></p><p><strong>如果,没有作用域限制,会变成全局作用域,VimScript会报错,无法找到变量</strong></p><p><strong>所以,在写需要变量的VimScript函数时,请总在变量前加上<code>a:</code>来显示变量的作用域</strong></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>有的时候,不想规定参数个数,根据需要进行参数个数限定</p><p>可以使用可变参数进行函数的设计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function! Varg(...)</span><br><span class="line">  echo a:0</span><br><span class="line">  echo a:1</span><br><span class="line">  echo b:2</span><br><span class="line">  echo a:000</span><br><span class="line">endfunction</span><br><span class="line">call Varg(1,2)</span><br></pre></td></tr></table></figure><p><strong>首先注意一点,我们从这里开始使用<code>function!</code>来进行函数的定义,为什么?</strong></p><p><strong>使用function! 可以覆盖之前进行加载过的函数,对于重名函数进行覆盖,所以,建议加上 ! 更为安全</strong></p><p><strong>否则,有时对于重名函数会进行报错,同时也建议使用 ! 的时候,不要使用重名函数,会进行覆盖.</strong></p><p>现在,我们来看看可变参数如何使用</p><p><strong>echo a:0 显示了可变参数的个数</strong></p><p><strong>echo a:1 显示了第一个参数</strong></p><p><strong>echo a:2 显示了第二个参数</strong></p><p><strong>echo a:000 则将可变参数转换成为列表</strong></p><p><strong>列表,同Python的列表,Ruby的数组</strong></p><p>同时,我们还可以将可变参数与普通参数一起使用,可以写出下面这样的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function! A(a,...)</span><br><span class="line">  echo a:a</span><br><span class="line">  echo a:0</span><br><span class="line">  echo a:1</span><br><span class="line">  echo a:000</span><br><span class="line">endfunction</span><br><span class="line">call A(&quot;Crow&quot;,1)</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/VimScript%284%29_varg.png" alt=""></p><p>VimScript会自行进行判断,处理好可变参数和具名参数的赋值</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>三(四)大语句中,循环可是占了不小的分量.</p><p>但是,为什么不进行循环的介绍呢?</p><p>因为VimScript中,对于循环的需求是很小的,但是还是有了解的必要</p><p><strong>循环有:for循环,2 while循环两种</strong></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>类似于Ruby中的for循环,从C转换过来,可能不是很适应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo = [1,2,3,4,5]</span><br><span class="line">for i in foo do</span><br><span class="line">  echo i</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><p>上面的循环,逐次遍历输出foo列表中的元素</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while的循环是与其他语言大同小异的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let foo = [1,2,3]</span><br><span class="line">let i = 0</span><br><span class="line">while i &lt;= 2</span><br><span class="line">  echo foo[i]</span><br><span class="line">  let i = i + 1</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure><p><strong>需要注意,endwhile,endfunction,endfor不能写错</strong></p><p><strong>同时,对于进行值改变时,一定要加上let,进行操作</strong></p><hr><p>最后,来谈谈echo与echom的区别吧</p><p>echo系的的函数有很多,的那是我们常用的就是echo与echom</p><p>其区别在于:</p><p><strong>echo: 会将结果进行结算,并且显示完后结束</strong></p><p><strong>echom: 将内容作为一个真正的消息进行显示并存储,所有消息必须时数值/字符串</strong></p><p><strong>列表,字典,浮点数这些都是不被允许的</strong></p><p>一般情况下,如果不是为了进行消息的存储,<strong>建议使用 echo </strong></p><p>October 24, 2017 10:11 PM</p>]]></content>
      
      <categories>
          
          <category> VimScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VimScript的学习(三)</title>
      <link href="/2017/10/18/VimScript/Vimscript(III)/"/>
      <url>/2017/10/18/VimScript/Vimscript(III)/</url>
      <content type="html"><![CDATA[<h2 id="自动命令组"><a href="#自动命令组" class="headerlink" title="自动命令组"></a>自动命令组</h2><p>VimScript中多次使用自动命令,会进行重载,</p><p>并且将命令进行多次使用,叠加,会严重影响Vim的速度</p><p>所以,使用自动命令组,进行合理配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">augroup testgroup</span><br><span class="line">  autocmd BufWrite * :echom &quot;hello&quot;</span><br><span class="line">  autocmd BufWrite * :echom &quot;Vim&quot;</span><br><span class="line">augroup END</span><br></pre></td></tr></table></figure><p>但是,使用自动命令组,还是会进行命令的叠加</p><p>肯定有办法解决</p><p>使用 autocmd! 清除自动命令组</p><p><strong>可以避免进行自动命令组的重载</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">augroup testgroup</span><br><span class="line">  autocmd!</span><br><span class="line">  autocmd BufWrite * :echom &quot;hello&quot;</span><br><span class="line">  autocmd BufWrite * :echom &quot;Vim&quot;</span><br><span class="line">augroup END</span><br></pre></td></tr></table></figure><p>这样可以定义多组自动命令,且不会重复加载</p><h2 id="Opearate-Pending"><a href="#Opearate-Pending" class="headerlink" title="Opearate-Pending"></a>Opearate-Pending</h2><p>mapping 是我们之前提到过,VimScript功能强大的一个很重要的原因</p><p>之前提到了,<code>map</code>,<code>imap</code>,<code>vmap</code>,<code>nmap</code> 以及用<code>nore</code>表示非递归</p><p>但是,还有一种十分重要的mapping</p><p><strong>Operate-Pending</strong> 表示<strong>在一个操作之后,跟着进行移动的命令,</strong></p><p><strong>此操作会从开始的位置,一直到移动结束的位置为止</strong></p><p>常用的操作符及常见的移动命令</p><table><thead><tr><th>按键</th><th>操作</th><th>移动</th></tr></thead><tbody><tr><td>dw</td><td>删除</td><td>直到下一个单词</td></tr><tr><td>ci(</td><td>修改</td><td>在括号内</td></tr><tr><td>yt,</td><td>复制</td><td>到逗号</td></tr></tbody></table><p>这一部分,我们要进行的不是修改操作的映射,而是修改移动的映射</p><p>即<strong>Movement的映射</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap p i(</span><br></pre></td></tr></table></figure><p>即将p键映射到在括号内修改</p><p>再来看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap b /return&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>b键现在映射为,搜索到的所有的return</p><p>例如执行<code>db</code> 则会删除所有的<code>return</code></p><p>当然,Vim这种可定制化程度高的编辑器</p><p>一定是可以<strong>修改光标开始的位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap in( :&lt;c-u&gt;normal! f(vi(&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>将<code>in(</code>映射为,<code>f(vi(&lt;cr&gt;</code></p><p><strong>其中的&lt; c-u &gt;与normal!,会在之后解释,但是目前与映射的功能无关</strong></p><p><strong>f( -&gt; 向下寻找并移动到括号</strong></p><p><strong>v i ( 进入可视化模式,并且选中括号内所有内容</strong></p><p>所以,这条映射的作用是,向下寻找并且选中括号内所有内容</p><p>同理,向上寻找为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap il( :&lt;c-u&gt;normal! F)vi(&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>这两个命令,可以理解为<code>i(</code>的强化与拓展</p><p>一般规则如下,可以更清晰的明白如何进行<strong>Operate-Pending</strong>如何工作</p><p><strong>1. 如果你的Operator-pending映射在可视化模式下选中文本结束,Vim会操纵这些文本</strong></p><p><strong>2. 否则Vim会操作从光标的原始位置到一个新位置的文本</strong></p><h2 id="更多-强大的Operator-Pending映射"><a href="#更多-强大的Operator-Pending映射" class="headerlink" title="更多,强大的Operator-Pending映射"></a>更多,强大的Operator-Pending映射</h2><p>现在开始,我们进行更为强大的Vim的映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap ih :&lt;c-u&gt;excuate &quot;normal! ?^==\\+$\r:nohlsearch\rkvg_&quot;&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>第一眼看上去,这个映射也使我头大,那么有什么办法呢?</p><p>继续进行拆分</p><p><strong>excuate 表示执行后面作为Vim脚本字符串部分的命令</strong></p><p><strong>那么,excuate,normal!都可以表示执行,有什么区别,</strong></p><p><strong>实质上,normal!,是不能识别转义字符的,反之excuate是可以的</strong></p><p><strong>当excuate遇到想要执行的脚本字符串的时候,首先会替换特殊字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;noamal! ?^== \ +$ &lt;换行&gt; :nohlsearch &lt;换行&gt; kvg_&quot; &lt;cr&gt;</span><br></pre></td></tr></table></figure><p><strong>?^==+$,表示搜索任何以2个以上== ,且只有’=’的行,并且切换到行首</strong></p><p><strong>:nohlserach,取消搜索的语法高亮</strong></p><p><strong>kvg_ ,移动到上一行,可视化模式,移动到本行最后一个非空字符上,不使用$,是因为不需要选中’\0’</strong></p><p><strong>这一个Operate-Pending的作用就是选中,向后的一个,标题行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:onoremap an :&lt;c-u&gt;execute &quot;normal! ?^==\\+\r:nohlserach\rg_vk0&quot;&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>相比与上一条,改变之处在于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\rg_vk0&quot;&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>选中到最后一个非空字符,之后进入可视化模式,向上移动一行,再将光标移动至行首,</p><p><strong>实现了选中,上下两行的功能</strong></p><h2 id="状态条"><a href="#状态条" class="headerlink" title="状态条"></a>状态条</h2><p>平时经常看见,下面的状态条,那么,这也能定制化吗? ? ?</p><p><strong>当然可以</strong></p><p>使用<code>statusline</code>来进行定制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set statusline=%f   查看编辑路径</span><br><span class="line">:set statusline=%f\ - \ FileType:\ %y</span><br></pre></td></tr></table></figure><p>VimScript在此处,空格需要进行转义</p><p>这其中的格式化字符串,是类似于C以及Python的</p><p>但是,上面那样的写法,可读性是十分垃圾的,所以我们建议:</p><p><strong>使用叠加的方式来写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:set statusline=%f          &quot; 文件名即及路径</span><br><span class="line">:set statusline+=\ -\       &quot; 空格</span><br><span class="line">:set statusline+=FileType:  &quot; 标签</span><br><span class="line">:set statusline+=%y         &quot; 类型名</span><br></pre></td></tr></table></figure><p>statusline的设定可以使用各式各样的,修饰符,如何操作,由使用者自行决定</p><h2 id="负责任的编码"><a href="#负责任的编码" class="headerlink" title="负责任的编码"></a>负责任的编码</h2><p>VimScript作为一门十分小众的语言,但是他也存在程序员必须遵守的编程准则</p><p><strong>注释</strong></p><p><strong>分组</strong></p><p><em>使用其中的代码折叠功能,使得你的配置可以清晰的展现出来</em></p><p><strong>简写</strong></p><p><strong>强烈要求:不要使用简写,会使你的代码混乱不堪</strong></p><p><strong>至此,第一部分进行Vimrc的基础配置到此结束,下面开始,会将VimScript作为一门真正的编程语言来学习</strong></p><p>October 19, 2017 2:31 AM</p>]]></content>
      
      <categories>
          
          <category> VimScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VimScript的学习(二)</title>
      <link href="/2017/10/18/VimScript/VimScript(II)/"/>
      <url>/2017/10/18/VimScript/VimScript(II)/</url>
      <content type="html"><![CDATA[<h2 id="编辑Vimrc配置文件"><a href="#编辑Vimrc配置文件" class="headerlink" title="编辑Vimrc配置文件"></a>编辑Vimrc配置文件</h2><p>有的时候会发现一些很容易提高效率的技巧</p><p>但是,且切来切去的打开Vimrc会打断你的思路</p><p>那么,怎么办呢?</p><p>设置特殊映射即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mapleader=&quot;,&quot;</span><br><span class="line">nmap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt;</span><br><span class="line">name &lt;leader&gt;sv :source $MYVIMRC&lt;cr&gt;</span><br></pre></td></tr></table></figure><p>即可通过使用简短的快捷键完成<strong>修改</strong>并且<strong>重新加载</strong>vim的配置文件的功能</p><p>使用变编辑的这两个映射</p><p>可以快速完成,映射,加载的功能</p><h1 id="Abbreviations-缩写"><a href="#Abbreviations-缩写" class="headerlink" title="Abbreviations(缩写)"></a>Abbreviations(缩写)</h1><p>在Vim这么强大的编辑器面前,有着各种各样的方便特性</p><p>比如说,我们现在要谈到的缩写,</p><p><strong>缩写</strong>,这个特性的作用类似于<strong>映射</strong></p><p>但是,与映射又不尽相同,</p><p><strong>因为映射逐一扫描,不会考虑上下文环境,直接替换</strong></p><p><strong>但是,缩写会考虑上下文环境,进行合理的处理</strong></p><p>一般情况下,缩写用于:</p><ul><li><p>解决平时一些经常出现的小问题,比如我自己经常写incldue</p></li><li><p>处理一些,因为键位的问题,比如@fujie的:Q</p></li></ul><p>而且,缩写有三种模式,替换模式暂不讨论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iabbrev 关键词 替换内容 (insert mode)</span><br><span class="line">cabbrev 关键词 替换内容 (command mode)</span><br></pre></td></tr></table></figure><p>输入要替换的内容后,直接空格就会进行替换</p><p>或者,输入 &lt; cr &gt; 也是可以进行缩写替换的</p><p>更多的时候,我们还可以使用”缩写替换”的功能来进行文本标签的书写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iabbrev @@ Evilcrow486@gmail.com</span><br><span class="line">iabbrev ccopy Copyright.....</span><br></pre></td></tr></table></figure><p>很方便的功能,不是吗?</p><h3 id="更强大的Mappings"><a href="#更强大的Mappings" class="headerlink" title="更强大的Mappings"></a>更强大的Mappings</h3><hr><p>如果要使自己进步就需要做出一些改变</p><p>首先,从改掉之前的快捷键开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;esc&gt; &lt;nop&gt;</span><br><span class="line">nnoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure><p>首先从禁止掉&lt; Esc &gt;及一系列的方向键开始</p><p>强迫自己习惯新的,高效的,工作习惯</p><h1 id="本地缓冲区及设置"><a href="#本地缓冲区及设置" class="headerlink" title="本地缓冲区及设置"></a>本地缓冲区及设置</h1><p>这里,要钱车道的一个概念就是:本地缓冲区</p><p>即之前常用到的local</p><p><strong>在,Mappings,Abbreviations,Options中可以使用&lt; buffer &gt;来指定缓冲区</strong></p><p><strong>在leader中,可以使用&lt; localleader &gt;*,简单来讲,就是一个本地的,局部变量的问题</strong></p><p><strong>第三点,某些布尔选项也是支持setlocal的</strong></p><p><strong>最后强调一点,相对而言,本地的设置会覆盖全局的,因为本地的更为具体</strong></p><h2 id="自动命令-Auto-command"><a href="#自动命令-Auto-command" class="headerlink" title="自动命令(Auto-command"></a>自动命令(Auto-command</h2><p><strong>映射,缩写,自动命令是使Vim可以高度定制化必不可少的强力工具</strong></p><p>自动命令简单的讲:<strong>在Vim中触发某种事件的时候,让Vim去执行提前规定好的内容</strong></p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile * :write</span><br></pre></td></tr></table></figure><p>这个例子,可以这样解释:</p><p>当Vim中<strong>新文件创建</strong>的事件触发时,执行 :w进行保存</p><p>(这些文件是任意文件,*进行匹配)</p><p>总结一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd + 事件 + 匹配 + 操作处理</span><br></pre></td></tr></table></figure><p><strong>这解决了,我们经常处理到的,Vim在第一次保存前,并没有实际创建文件的问题</strong></p><p>同时,autocmd可监控多个事件</p><p><strong>多个事件使用 , 进行分隔</strong></p><p>同时,Vim中有个不成文的规定,</p><p>所有的文件应该用<strong>BufRead与BufNewFile</strong>一起打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile,BufRead *.c setlocal nowrap</span><br></pre></td></tr></table></figure><p>这样,不论何时,打开的C文件,都不能自动卷曲换行</p><p><strong>而在所有的事件中,最有用的就莫过于FilType文件了</strong></p><p>FilType文件会自动识别文件类型,然后执行autocmd</p><p><strong>结合FilType事件与&lt; buffer &gt;,或者local的设定,就很棒,可以针对不同的缓冲区进行不同的配置,Perfect!</strong></p><p><strong>切记,切记,使用FileType事件时,一定不要大写,一定要时小写! ! ! </strong></p>]]></content>
      
      <categories>
          
          <category> VimScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VimScript的学习(一)</title>
      <link href="/2017/10/17/VimScript/VimScript(I)/"/>
      <url>/2017/10/17/VimScript/VimScript(I)/</url>
      <content type="html"><![CDATA[<h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><hr><p>VimScript是一门十分小众的语言,基本上只能用于Vim配置的书写以及Vim插件的开发</p><p>其只能写入.vimrc中生效</p><p><strong>写在前面,VimScript中,=左右不要预留空格,C语言的风格会使VimScript的语法出错</strong></p><p><strong>Vim的命令是在vim中及vimrc中可以通用的</strong></p><p><strong>vimrc中的命令,是不需要加上:的,而且有些vim的命令是与shell命令相同的.在vim中使用的命令记得加上:,不然是无法输入的</strong></p><h2 id="1-打印信息"><a href="#1-打印信息" class="headerlink" title="1. 打印信息:"></a>1. 打印信息:</h2><p><code>:echo</code>  显示信息</p><p><code>:echom(sg)</code> 同样显示信息,但是会将信息保存,可以调用:message显示</p><p><code>:message</code> 显示那些保存的信息</p><h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释:"></a>2. 注释:</h2><p>使用 <code>&quot;</code> 进行注释  (本句话已经变成一条注释了),同理其他脚本语言,到行尾都是注释</p><h2 id="3-设置选项"><a href="#3-设置选项" class="headerlink" title="3. 设置选项:"></a>3. 设置选项:</h2><p>主要依靠<strong>布尔选项</strong>以及<strong>键值选项</strong></p><ul><li><strong>布尔选项</strong></li></ul><p>举个例子: number选项为布尔选项,可以on也可以off</p><p><code>:set number</code>  命令打开(on)</p><p><code>:set nonumber</code>  命令关闭(off)</p><p>所有的布尔选项都是这样使用</p><p><code>:set &lt;name&gt;</code> 打开选项</p><p><code>:set no&lt;name&gt;</code> 关闭选项</p><ul><li><strong>切换布尔选项</strong></li></ul><p>在布尔选项后面添加”!”即可实现对布尔选项的切换</p><p><code>:set number!</code> 打开-&gt;关闭/关闭-&gt;打开</p><ul><li><strong>查看选项当前值</strong></li></ul><p>之前提到布尔选项,那么如何查看当前布尔选项的值.</p><p><code>:set number?</code>  即可查看当前的选项值</p><ul><li><strong>键值选项</strong></li></ul><p>有的选项并不是仅仅只有on/off两个值,还存在其他的值,这个时候就需要进行值的设定了</p><p>比如:行号的列宽</p><p><code>:set numberwidth = 10</code></p><p><code>:set numberwidth = 8</code></p><p>上面的例子,都是使用</p><p>键值来进行选项的设定</p><p><code>:set &lt;name&gt;=&lt;value&gt;</code></p><p>可以进行布尔选项内容的切换</p><ul><li><strong>一次性进行多个选项的设定</strong></li></ul><p>VimScript是支持一次性设置多个选项的</p><p>举个例子:</p><p>同时设置行号选项与行号宽度</p><p><code>:set number numberwidth=4</code></p><p>交换顺序也是可以的</p><h2 id="4-键盘映射"><a href="#4-键盘映射" class="headerlink" title="4.键盘映射"></a>4.键盘映射</h2><p>如果说VimScript可以进行自己个性化的Vim设置,那就非<strong>键盘映射</strong>莫属了,这真TM是个神奇的功能</p><p>键盘映射:<strong>按下这个键的时候,放弃默认操作,执行我指定的操作</strong></p><ul><li><strong>基本映射(normal模式)</strong></li></ul><p>简单的语法:</p><p><code>map 键 想要映射的功能</code></p><p>举个例子:</p><p><code>map - dd</code> - 可以进行整行内容的删除</p><ul><li><strong>特殊字符的映射</strong></li></ul><p>不仅可以映射简单地字符,还可以进行特殊按键的映射,即组合键,十分方便</p><p>语法:</p><p><code>map &lt;keyname&gt;  映射的功能</code></p><p>举个例子:</p><p><code>map &lt;space&gt; viw</code></p><p>同时可以使用Ctrl以及Alt作为映射键</p><p><strong>但是注意,只能写&lt;c-?&gt; 或者 &lt;a-?&gt;进行映射,完整的ctrl/alt名称是不能进行映射的</strong></p><p>建议映射的键:</p><p><strong>&lt; F2 &gt; - &lt; F 12 &gt;</strong></p><p><strong>shift + ?   &lt;s-?&gt;</strong></p><p>之后进行的映射会刷新之前的映射</p><p>同时,映射可以连接起来使用</p><p><code>map - ddp</code>可以实现将本行粘贴在下一行的功能<code>map</code>在任何模式都通用</p><p><code>nmap imap vmap</code><br>分别对应在normal,insert,visusal三种模式下指定的映射</p><p>在normal以及visusal模式下的映射正如上面所讲</p><p><strong>insert模式的映射就比较特殊了,需要特殊对待</strong></p><p>因为insert比较特殊,例如要进行删除当前行,输入<c-d>却只能输入两个d字符</c-d></p><p>所以要借助,<esc>的功能</esc></p><p><code>imap &lt;c-d&gt; &lt;esc&gt;dd</code></p><p>对于此映射还可以加强,即最后需要回到本模式</p><p><code>imap &lt;c-d&gt; &lt;esc&gt;ddi</code></p><p>最后的i字符说明回到insert模式</p><ul><li><strong>精确映射</strong></li></ul><p>在VimScript的映射中,会出现递归的问题</p><p>很可怕,可能你的映射会被解释为其他的映射</p><p>这个时候,精确的映射就很重要了</p><p>那么如何解决递归映射的问题呢?</p><p>使用<code>*noremap*</code>系列映射</p><p><code>noremap nnoremap</code>,<code>inoremap</code>,<code>vnoremap</code>,</p><p>这四种便是映射的非递归版本,</p><p>什么时候使用呢?</p><p><strong>任何时候,没错,任何时候</strong></p><ul><li><strong>前缀映射</strong></li></ul><p>映射一般都选用不常用的键,但是你不常用的键并不多,难道Vim的可定制化传说是骗人的?</p><p>并不是,可以使用前缀映射</p><p><code>nmap -d dd</code></p><p>可以实现按两个键完成dd的映射</p><p>但是,这么多前缀改着不累吗?</p><p>所以,我们采用设置leaders的方式进行定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mapleader = &quot;leader&quot;</span><br><span class="line">*map &lt;leader&gt;***   映射的功能</span><br></pre></td></tr></table></figure><p>使用 &lt; leader &gt; 的作用,不用我多说,你也明白,不是吗?</p><p>同理还可以使用localleader,会在之后进行详解</p><p><strong>下次会有更为有趣的内容</strong></p>]]></content>
      
      <categories>
          
          <category> VimScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim名词解释</title>
      <link href="/2017/10/17/VimScript/Vim_help/"/>
      <url>/2017/10/17/VimScript/Vim_help/</url>
      <content type="html"><![CDATA[<h3 id="Vim中的一些常用名词解释-一"><a href="#Vim中的一些常用名词解释-一" class="headerlink" title="Vim中的一些常用名词解释(一)"></a>Vim中的一些常用名词解释(一)</h3><h5 id="Vim中经常要使用help命令-注意’messages’与messages的区别-会进入不同的帮助文档"><a href="#Vim中经常要使用help命令-注意’messages’与messages的区别-会进入不同的帮助文档" class="headerlink" title="Vim中经常要使用help命令,注意’messages’与messages的区别,会进入不同的帮助文档"></a>Vim中经常要使用help命令,注意’messages’与messages的区别,会进入不同的帮助文档</h5><ul><li><p><strong>: ec[ho]</strong> : 进行回显输出</p></li><li><p><strong>: echom[sg]</strong> : 同理于echo,但是echom会将信息保存,可以使用message查看,消息存储在message-history当中</p></li><li><p><strong>: messages</strong> : 显示之前给出的消息</p></li><li><p><strong>: nu[mber]</strong> : 布尔型,常用的显示行号的布尔选项</p></li><li><p><strong>: numberwidth/:numw</strong> : 数值型,设置行号宽度的数值型选项</p></li><li><p><strong>: relativenumber</strong> : 布尔型,用于设置相对于光标所在行的行号,方便计算垂直的计数值 count</p></li></ul><p>来举个简单地例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2 int main(void)&#123;</span><br><span class="line">  1 printf(&quot;VimScript!\n&quot;);</span><br><span class="line">3   return 0;</span><br><span class="line">  1 &#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>: wrap</strong> : 布尔型,Vim中新添加的布尔选项,可以使没一行输入的内容进行回绕,但是缓冲区不会,不设置的话,会一直一行写下去,推荐打开</p></li><li><p><strong>: shiftroud/sr</strong> : 布尔型,缩进取到shiftwidth的整数倍</p></li><li><p><strong>: shiftwidth/sw</strong> : (自动)缩进每一步得空白数</p></li><li><p><strong>: matchtime</strong> : 数值型,显示配对括号的1/10秒数</p></li><li><p><strong>: showmatch</strong> : 布尔型,插入括号时,可以短暂的跳转到匹配的括号,显示匹配的时间使用”matchtime”进行设定</p></li><li><p><strong>*map</strong> : 进行各种模式下的键盘的映射,noremap使用非递归映射</p></li><li><p><strong> unmap</strong> : 解除键盘的指定映射</p></li><li><p><strong>: *map</strong> : 查看当前的映射</p></li><li><p><strong>: leader</strong> : 进行全局映射的东西</p></li><li><p><strong>: localleader</strong> : 更多的时候进行文件内的映射东西</p></li></ul>]]></content>
      
      <categories>
          
          <category> VimScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于RedHat本地源的配置</title>
      <link href="/2017/10/11/Linux/ReadHat-yum/"/>
      <url>/2017/10/11/Linux/ReadHat-yum/</url>
      <content type="html"><![CDATA[<p><em>而摆在RedHat用户面前的第一个问题,就是关于本地源配置的问题</em></p><p><em>因为,RedHat是主打服务的.所以,RedHat软件源列表的更新是付费的.</em></p><h2 id="配置原理"><a href="#配置原理" class="headerlink" title="配置原理"></a>配置原理</h2><p>如何修改RedHat的包管理器呢?</p><p>我们的思路是:更换掉RedHat本身的包管理器,而使用与其更加相近的CentOs的包管理器进行配置</p><h2 id="配置组件"><a href="#配置组件" class="headerlink" title="配置组件"></a>配置组件</h2><p>因为一些版本的兼容的问题,我在这里将一套可以完整使用的rpm名称贴在这里</p><ul><li><p>python-urlgrabber-3.10-8.el7.noarch.rpm</p></li><li><p>yum-3.4.3-132.el7.centos.0.1.noarch.rpm</p></li><li><p>yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</p></li><li><p>yum-plugin-fastestmirror-1.1.31-34.el7.noarch.rpm</p></li><li><p>yum-updateonboot-1.1.31-34.el7.noarch.rpm</p></li><li><p>yum-utils-1.1.31-34.el7.noarch.rpm</p></li></ul><p>而这些包去哪里找呢?</p><p>到 <a href="http://rpm.pbone.net" target="_blank" rel="noopener">RPMsearch</a> 去寻找</p><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>第一步 : 查询所安装的RPM包(yum)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep yum</span><br></pre></td></tr></table></figure><p><img src="http://oww4cv296.bkt.clouddn.com/rpm-qa.png" alt=""></p><p>第二步 : 解除依赖,并卸载所有的自带yum包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -aq | grep yum | xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure><p>第三步 : 进行rpm包的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh python-urlgrabber-3.10-8.el7.noarch.rpm</span><br><span class="line">rpm -ivh yum*               (注意这几个包因为相互依赖,所以同时安装可以取消问题)</span><br></pre></td></tr></table></figure><p>第四步 : 配置新的CentOs源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.163.com/centos/6/os/.......(自行查找)</span><br></pre></td></tr></table></figure><p>之后,将下载到的repo文件移动到/etc/yum.repos.d目录下</p><p>使用Vim打开进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/<span class="variable">$releasever</span>/7/gc</span><br></pre></td></tr></table></figure><p>第五步 : 进行本地元数据的更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><strong>到此为止,新配置的yum及源基本可以使用了,之后进行软件的管理,只要继续添加,修改源就可以了</strong></p><p><img src="http://oww4cv296.bkt.clouddn.com/mysql.png" alt=""></p><h2 id="相关声明"><a href="#相关声明" class="headerlink" title="相关声明"></a>相关声明</h2><p><strong>首先,RedHat的确是一个为了社区及发行版的发展而不懈努力的公司</strong></p><p><strong>配置RedHat本地源,并没有进行商业利益损害的想法,只是进行基础的技术交流而已</strong></p><p><strong>而且,这样配置好的包管理器,在依赖上的打磨没有RedHat处理的好,</strong></p><p><strong>如果喜欢RedHat,建议进行用户的注册.同时CentOS以及Fedora也是不错的发行版</strong></p><p>October 11, 2017 8:09 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>my_shell项目文档</title>
      <link href="/2017/09/22/documents/my_shell%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/2017/09/22/documents/my_shell%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p>在<strong>进程</strong>的相关知识学习完了之后,按小组要求实现了my_shell</p><p><strong>一个类似与bash shell的命令分析器</strong></p><p>本篇即是我自己实现的my_shell的项目文档</p><p>my_shell的源码,已上传至Github,可以<a href="https://github.com/Evil-crow/Linux_C/tree/master/Chapter_VII/Shell" target="_blank" rel="noopener">点击这里</a></p><hr><p>本篇项目文档分为五个部分,可通过点击以下标签进行访问</p><ul><li><p><a href="#1">一,项目需求</a></p></li><li><p><a href="#2">二,设计思路</a></p></li><li><p><a href="#3">三,实现要点</a></p></li><li><p><a href="#4">四,项目演示</a></p></li><li><p><a href="#5">五,存在问题</a></p></li><li><p><a href="#6">六,设计感想</a></p></li></ul><hr><h4 id="一-项目需求"><a href="#一-项目需求" class="headerlink" title="一.项目需求"></a>一.项目需求</h4><p><strong>1.支持输入输出重定向(&lt; &gt; &gt;&gt;)</strong></p><p><strong>2.支持管道(|)</strong></p><p><strong>3.支持shell内置命令(实现cd即可)</strong></p><p><strong>*4.支持后台运行程序(&amp;)</strong></p><p><strong>*5.支持tab补全目录文件以及历史记录上下翻(提示:使用readline库)</strong></p><p><strong>*6.ctrl+c不能中断程序(提示:使用信号)</strong></p><p><strong>*7.设置环境变量，使程序可以像bash，zsh这种shell一样运行</strong></p><hr><h4 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二,设计思路"></a>二,设计思路</h4><p>本项目的主题思路是<strong>系统编程+进程操作</strong></p><p>通过大量的系统编程来实现系统功能,</p><p>在加上进程操作来实现其他的功能</p><p>1.<a href="https://github.com/Evil-crow/Linux_C/blob/master/Chapter_VII/Shell/main.c" target="_blank" rel="noopener">main.c</a></p><p><img src="http://img.blog.csdn.net/20170731040746556?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>2.<a href="https://github.com/Evil-crow/Linux_C/blob/master/Chapter_VII/Shell/print_shell.c" target="_blank" rel="noopener">print_shell.c</a></p><p><img src="http://img.blog.csdn.net/20170731040800867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>3.<a href="https://github.com/Evil-crow/Linux_C/blob/master/Chapter_VII/Shell/get_command.c" target="_blank" rel="noopener">get_command.c</a></p><p><img src="http://img.blog.csdn.net/20170731040850458?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>4.<a href="https://github.com/Evil-crow/Linux_C/blob/master/Chapter_VII/Shell/explain_command.c" target="_blank" rel="noopener">explain_command.c</a></p><p><img src="http://img.blog.csdn.net/20170731040911331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>5.<a href="https://github.com/Evil-crow/Linux_C/blob/master/Chapter_VII/Shell/go_command.c" target="_blank" rel="noopener">go_command.c</a></p><p><img src="http://img.blog.csdn.net/20170731040924292?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>6.<a href="https://github.com/Evil-crow/Linux_C/blob/master/Chapter_VII/Shell/find_command.c" target="_blank" rel="noopener">find_command</a></p><p><img src="http://img.blog.csdn.net/20170731041554550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><em>以上的思维导图可以较好的反映功能的实现思路</em></p><hr><h4 id="三-实现细节"><a href="#三-实现细节" class="headerlink" title="三,实现细节"></a>三,实现细节</h4><ol><li><p>main.c的实现其实就是按照思路进行设计,将下面的函数有效的组织在了一起</p></li><li><p>在print_shell的部分里,主要的环节就是打印shell提示符</p><p>为了追求尽可能的真实,我就做了这样的设计</p><p><strong>“[用户名@主机名 目录名] “</strong></p><p>其中主要的设计在目录名的打印上,先使用getcwd系统调用获取绝对路径,再进行字符串操作,获取当前目录</p><p><strong>注意其中最重要的是,根目录/的目录名打印需要特殊处理</strong></p><p>代码实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if(getcwd(dir,100) == NULL)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Error!\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int i,j;</span><br><span class="line">for(i = 0;dir[i] != &apos;\0&apos;;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(dir[i] == &apos;/&apos;)</span><br><span class="line">    j = i+1;</span><br><span class="line">&#125;</span><br><span class="line">if(dir[j+1] == &apos;\0&apos;)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;[Crow@Shell /]Σ &quot;);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">char Dir[30];</span><br><span class="line">for(i = 0;i &lt; 100;i++,j++)</span><br><span class="line">&#123;</span><br><span class="line">    Dir[i] = dir[j];</span><br><span class="line">&#125;</span><br><span class="line">Dir[i+1] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">printf(&quot;[Crow@Shell %s]Σ &quot;,Dir);</span><br></pre></td></tr></table></figure></li><li><p>get_command的功能是进行命令的获取,并且保证其以’\n’结尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">i = 0;</span><br><span class="line">ch = getchar( );</span><br><span class="line">while(ch != &apos;\n&apos;)</span><br><span class="line">&#123;</span><br><span class="line">    str[i++] = ch;</span><br><span class="line">    ch = getchar( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(i &gt; len)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Command isn&apos;t allowed!\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">if(strcmp(str,&quot;^C&quot;) == 0)</span><br><span class="line">&#123;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str[i++] = &apos;\n&apos;;</span><br><span class="line">str[i++] = &apos;\0&apos;;</span><br></pre></td></tr></table></figure></li><li><p>expian_command是为执行命令进行准备,对命令参数进行划分获取</p><p>下面这段代码很好的演示了使用交叉指针进行移动并获取参数,存入字符串的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">q = p;</span><br><span class="line">n = 0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">  if(*q != &apos;\n&apos; &amp;&amp; *q != &apos; &apos;)</span><br><span class="line">  &#123;</span><br><span class="line">     q++;</span><br><span class="line">     n++;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">strncpy(parameter[count],p,n+1);</span><br><span class="line">parameter[count][n] = &apos;\0&apos;;</span><br><span class="line">count++;</span><br><span class="line">p = q;</span><br></pre></td></tr></table></figure></li><li><p>go_command是整个程序的核心,其中进行了参数的判断,并使用switch函数进行功能选取</p><p>尤其好用的操作就是在处理父子进程的问题上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(background == 1)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;processid is %d\n&quot;,pid);</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br><span class="line">if(waitpid(pid,&amp;status,0) == -1)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;wait chile process failed!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>find_command是在go_command中嵌套的操作,是进行是否为有效命令的判断</li></ol><h4 id="四-项目演示"><a href="#四-项目演示" class="headerlink" title="四,项目演示"></a>四,项目演示</h4><p>1.实现重定向</p><p><img src="http://img.blog.csdn.net/20170731041659599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><img src="http://img.blog.csdn.net/20170731041731232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>2.实现管道</p><p><img src="http://img.blog.csdn.net/20170731041908583?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>3.实现shell内置命令(cd为例)</p><p><img src="http://img.blog.csdn.net/20170731041827969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>4.阻断Ctrl-C的信号</p><p><img src="http://img.blog.csdn.net/20170731041938738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>5.实现后台应用程序</p><p><img src="http://img.blog.csdn.net/20170731042003705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>6.设置了环境变量</p><p><img src="http://img.blog.csdn.net/20170731042049248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h4 id="五-存在问题"><a href="#五-存在问题" class="headerlink" title="五,存在问题"></a>五,存在问题</h4><p>在此次的项目设计中,也存在许多的问题</p><p>如:</p><p>1.cd,不能实现直接回家目录的功能,如果使用readline库可能实现会方便一点</p><p>2.不支持多管道,多重定向,需要继续进行设计</p><p>3.实现的内置命令不够</p><p>4.没有成功使用readline库,Tab补全不行,不能上下翻</p><p>以上只是其中比较明显的问题,自己设计的shell离bash还有很长的一段距离</p><p>在之后得更新中,会逐步解决这些问题</p><h4 id="六-设计感想"><a href="#六-设计感想" class="headerlink" title="六,设计感想"></a>六,设计感想</h4><p>这次的进程相关设计,使我认识到自己学习的不足</p><p>进行编程的学习,书本的知识远远是不够的,</p><p>很多时候,自己上手实践的结果要更可靠得多</p><p>比如wait函数的调用,在进行了程序设计之后,才对其有明了的认识</p><p>在管道功能的实现处,真正了解到进程在程序设计中的重要性</p><p>以后的路还很长,还需要继续进行努力</p><p>my_shell暂时告一段落,以后有时间会继续进行更新的</p>]]></content>
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于C语言课程设计的经验总结</title>
      <link href="/2017/09/22/documents/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/2017/09/22/documents/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近总算把期末考试给处理完了,在暑期再也没有课业压力的烦恼了</p><p>总算又可以开心的撸码了!</p><p>既然之前的一段时间都在忙课程设计,那今天就说说课程设计的事吧!</p><hr><h5 id="C语言课程设计的内容"><a href="#C语言课程设计的内容" class="headerlink" title="C语言课程设计的内容"></a>C语言课程设计的内容</h5><p>C语言课程设计是我们计科专业在学期底需要进行的,</p><p>其主要内容是设计一个信息的处理系统,</p><p>主要实现的功能是:<strong>文件读取信息-&gt;程序处理信息-&gt;文件保存信息</strong></p><p>下面我就功能部分进行说明:</p><hr><p>1.文件的读取和保存</p><p>此部分主要的内容是文件部分的操作,</p><p><em>其中包括文件的打开与关闭,文件的读写操作,文件的关闭,以及一些文件指针的移动操作</em></p><p>只要熟练掌握了文件部分的知识,这一部分的功能实现,还是比较容易的了</p><p>2.程序处理信息</p><p>在这个课程设计中,对于信息的处理方式,要求是使用链表的方法</p><p>但是还是有同学使用,结构数组,这个就不太恰当了</p><p>相对于结构数组,链表还是有很大的优点的:</p><blockquote><p>一,使用链表其中所存储的数据不是连续的,当程序不能一次性的处理所有的信息时,使用链表方便</p></blockquote><blockquote><p>二,从第一点继续往后谈,链表存储数据属于按需存取,分配内存空间,不会浪费内存空间</p></blockquote><blockquote><p>三,使用链表,之后对于信息的增,删,改,查,十分方便</p></blockquote><p><em>以上两部分即为此项课程设计实现必要功能时的知识储备</em></p><hr><p><em>接下来,我来分享我自己在课程设计中的经验</em></p><p>1.关于模块化函数设计的编程思想</p><p><strong>模块化的编程思想是我在此次课程设计中感受最深的东西!</strong></p><p><strong>进行编程时,建议尽可能多的使用函数,并且将函数模块化.说实在的这样看上去,</strong></p><p><strong>程序的代码,美观,条理清晰</strong></p><p>因为进行课程设计时,是多个班的同学一起在机房里进行的,有的同学程序有问题,在帮忙进行改Bug时</p><p>我发现了这样的问题,在改代码时,没有模块化的程序设计思想,整个程序杂乱无章,没有条理</p><p>不说函数原型,函数声明也没有…程序的可读性较低,</p><p><strong>而且,更恶心的事是,不使用函数原型,你的函数顺序需要十分注意,否则,进行函数的相互调用时,就会报错!</strong></p><p>下面我贴一张我的函数原型的图,这样的话条理清晰,而且可移植性高<br><img src="http://img.blog.csdn.net/20170710121045211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><hr><p>2.关于使用google新闻组的便利之处</p><p>在进行文件读写时可以使用以下代码判断是否文件结束:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen(&quot;/home/Evilcrow/C/information&quot;,&quot;r+&quot;);</span><br><span class="line">if(fp != NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Error!&quot;);</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">while(!feof(fp))</span><br><span class="line">&#123;</span><br><span class="line">...........(省略)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码即可使程序在遇到文件尾以前,循环读出/写入信息</p><p><strong>那么,问题来了,要是文件为空文件,程序还能正常运行吗?</strong></p><p>答案,<strong>是否定的!</strong></p><p><code>while(!feof(fp))</code>对于文件开头要是为空时无法处理的,会进入死循环</p><p>遇到这个问题,我思考了很久,没有找到合适的方法,最后还是去了小组的google新闻组上才找到了解答</p><p><img src="http://img.blog.csdn.net/20170710121126984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><img src="http://img.blog.csdn.net/20170710121141737?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>最后,我自己也进行了尝试</p><p>但是,我也发现了一个问题,就是在fgtc进行首字符是否为空的判断之后,会私自吞掉一个字符</p><p>这样,每次进行操作完成之后,都会少一个字符,最后,我找到了fseek函数,对代码进行了以下修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(fgetc(fp) == EOF)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;\t\t\t\tThe file is empty!\n&quot;);</span><br><span class="line">    return pHead;</span><br><span class="line">&#125;</span><br><span class="line">fseek(fp,0L,0);</span><br><span class="line"></span><br><span class="line">while(!feof(fp))</span><br><span class="line">&#123;</span><br><span class="line">...........(省略)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行这样的修改之后,便可以很顺畅的进行文件开头是否为空的判断了.</p><p>在这一过程中,收获到的不仅仅是这样的一个小技巧,灵活使用,善于使用google新闻组,真的很方便</p><p>不仅可以解决自己的问题,以前的前辈所留下的宝贵经验,也可以进行学习!</p><hr><p>3.关于链表的操作</p><p>之前提到在整个课程设计中,链表的操作至关重要!</p><p><strong>我之前一直以来创建的都是无头节点链表,之后在进行链表的操作时,十分困难</strong></p><p><strong>于是,听从恒毅哥的指导  @Hg_yi 使用了有头节点链表,之后的增,删,改,查,排序操作十分方便</strong></p><p><strong>使用有头节点的链表,头节点始终是不参与存储数据的,尤其是排序,很方便</strong></p><p><strong>此篇Blog重点是课设经验的总结,下次有机会总结一篇链表操作</strong></p><hr><p>4.Win与Linux下的一些区别</p><ul><li><p>关于system函数的问题</p></li><li><p>关于密码回显的问题</p></li><li><p>getchar( )与system(“pause”)</p></li></ul><p><strong>system函数在Win下与Linux下有很大的区别</strong></p><p>但是,在Linux下可以通过其他的方式来实现Win下各式各样的system函数</p><p>比如:getchar( )可以实现system(“pause”)的进程中止功能</p><p>密码的回显在Win下是依靠&lt; conio.h &gt;中的getch()函数实现不回显的功能的</p><p>在Linux下,则没有此函数头文件,需要依靠system(“stty (-)echo”)来实现输入的回显功能.<br><img src="http://img.blog.csdn.net/20170710121223906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><hr><p>以上即为，目前我自己所总结的经验，要是大家认为哪里不对，可随时留言联系我．</p>]]></content>
      
      <categories>
          
          <category> 一些经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chatting_X_Chatting项目文档</title>
      <link href="/2017/09/22/documents/Chatting_X_Chatting%E6%96%87%E6%A1%A3/"/>
      <url>/2017/09/22/documents/Chatting_X_Chatting%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h1 id="Chatting-X-Chatting项目文档"><a href="#Chatting-X-Chatting项目文档" class="headerlink" title="Chatting_X_Chatting项目文档"></a>Chatting_X_Chatting项目文档</h1><p><em>暑期的项目文档,也真的是拖了好久才来完成,真的很差劲</em></p><p><em>本项目的内容一切都是可以随意进行学习,使用的,但是切勿用于一切具有商业目的的用途上</em></p><p><em>请于下载内的24小时内迅速删除</em></p><h2 id="0-目录"><a href="#0-目录" class="headerlink" title="0.目录"></a>0.目录</h2><ul><li><a href="#1.引言">1.引言</a><ul><li><a href="#1.1项目综述">1.1项目综述</a></li><li><a href="#1.2术语表">1.2术语表</a></li><li><a href="#1.3参考资料">1.3参考资料</a></li><li><a href="#1.4开发环境及使用工具">1.4开发环境及使用工具</a></li><li><a href="#1.5使用说明">1.5使用说明</a></li></ul></li><li><a href="#2.数据结构">2.数据结构说明</a></li><li><a href="#2.模块设计">3.模块设计</a><ul><li><a href="#3.1程序函数调用图及模块分化">3.1程序函数调用图及模块分化</a></li><li><a href="#3.2功能设计说明">3.2功能设计说明</a></li></ul></li><li><a href="#4.文件说明">4.文件说明</a></li><li><a href="#5.异常,错误处理">5.异常,错误处理</a></li><li><a href="#6.已经存在的问题及改善方案">6.已经存在的问题及改善方案</a></li><li><a href="#7.运行截图">7.运行截图</a></li></ul><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><h3 id="1-1项目综述"><a href="#1-1项目综述" class="headerlink" title="1.1项目综述"></a>1.1项目综述</h3><hr><p>随着网络的发展越来越快,地球越来越小,人与人之间的距离越来越小,<strong>实时通讯</strong>成为必须要实现的一个问题</p><p>而在计算机发展史上,也不乏有各种各样的通讯工具的出现<strong>ICQ,MSN,Skype,QQ,Wechat,Yahoo!_Messager.</strong></p><p>此项目是基于一些通讯软件的功能,再结合所学习到的<strong>进程,线程,网络通信</strong>的知识实现的一个通讯软件.</p><p>仍然有许多的缺陷,但是已经初步具有实现通讯功能的能力.</p><h3 id="1-2术语表"><a href="#1-2术语表" class="headerlink" title="1.2术语表"></a>1.2术语表</h3><hr><table><thead><tr><th>序号</th><th>术语</th><th>说明性定义</th></tr></thead><tbody><tr><td>1</td><td>C/S</td><td>Client/Server模型</td></tr><tr><td>2</td><td>epoll</td><td>Linux下处理并发的API</td></tr><tr><td>3</td><td>makefile</td><td>Linux下进行工程构建的文件</td></tr></tbody></table><h3 id="1-3参考资料"><a href="#1-3参考资料" class="headerlink" title="1.3参考资料"></a>1.3参考资料</h3><hr><p>在进行该项目的实现时,也查阅了很多的资料</p><blockquote><p>a.相关类型的书籍</p></blockquote><blockquote><table><thead><tr><th>书籍</th><th>作者</th></tr></thead><tbody><tr><td>&lt; Linux_C编程实战 &gt;</td><td>董永清</td></tr><tr><td>&lt; 高性能Linux服务器构建实战 &gt;</td><td>高俊峰</td></tr><tr><td>&lt; 鸟哥的Linux私房菜(第三版)</td><td>VBird</td></tr></tbody></table></blockquote><blockquote><p>b.查阅的相关的博客,网上资料</p></blockquote><blockquote><table><thead><tr><th>资料名</th><th>作者</th></tr></thead><tbody><tr><td><a href="http://blog.csdn.net/bgylde/article/details/53096739" target="_blank" rel="noopener">Linux-C下C/S架构实例,实现文件传输功能</a></td><td>bgylde</td></tr><tr><td><a href="http://2627lounuo.blog.51cto.com/10696599/1784975" target="_blank" rel="noopener">IO复用之——epoll</a></td><td>敲完代码好睡觉zzz</td></tr></tbody></table></blockquote><p><del>事实上,网路上,很多书上的内容都是千篇一律,很废的</del></p><p><strong>但是,我很推荐上面”IO多路复用之—epoll”,剖析得很好</strong></p><h3 id="1-4开发环境及使用工具"><a href="#1-4开发环境及使用工具" class="headerlink" title="1.4开发环境及使用工具"></a>1.4开发环境及使用工具</h3><p>开发环境: Fedora 4.11.12 X86_64</p><p>开发工具: Vim及VSCode,gcc编译器</p><p>绘图工具: ProcessOn</p><h3 id="1-5使用说明"><a href="#1-5使用说明" class="headerlink" title="1.5使用说明"></a>1.5使用说明</h3><p>如果你曾经有过进行编程的经验,翻一翻目录就会知道该怎么使用了,</p><p>但是你如果是初级小白,请按照我接下来的方法进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">安装说明:</span><br><span class="line">cd ~/Public</span><br><span class="line">git clone https://github.com/Evil-crow/Chatting_X_Chatting.git</span><br><span class="line">cd Chatting_X_Chatting/v1.5/Client</span><br><span class="line">make</span><br><span class="line">make clean</span><br><span class="line">cd ../Server</span><br><span class="line">make</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用说明:</span><br><span class="line"></span><br><span class="line">Terminal_I</span><br><span class="line"></span><br><span class="line">cd Chatting_X_Chatting/v1.5/Server/</span><br><span class="line">./Server</span><br><span class="line"></span><br><span class="line">Terminal_II</span><br><span class="line"></span><br><span class="line">cd Chatting_X_Chatting/v1.5/Client</span><br><span class="line">./Client</span><br><span class="line"></span><br><span class="line">之后,就可以按照提示进行使用</span><br></pre></td></tr></table></figure><p>此为本机测试方法,若要进行跨机器的通信,请发邮件至我的邮箱</p><blockquote><p>Evilcrow</p></blockquote><blockquote><p><a href="mailto:evilcrow486@gmail.com" target="_blank" rel="noopener">evilcrow486@gmail.com</a></p></blockquote><hr><h2 id="2-数据结构说明"><a href="#2-数据结构说明" class="headerlink" title="2.数据结构说明"></a>2.数据结构说明</h2><p>本项目中主要是进行线程,进程,网络编程知识的综合运用</p><p>所涉及到的数据结构并不是很多,主要是以下两种:</p><table><thead><tr><th>数据结构</th><th>使用之处</th></tr></thead><tbody><tr><td>数组</td><td>使用数组,主要是在TCP发送包以及各种功能函数实现时所使用的.<br>存储字符串,标识符,各种各样的元素,这样可以使得功能的实现更加便利.<br>但是,在一定情况下,使用数组,并不能很好的提高程序的性能</td></tr><tr><td>链表</td><td>链表主要是在Server端使用,使用链表用来存储在线用户.<br>使用C语言不像其他OOP一样,有封装好的类,手动实现,虽然麻烦,但是后面很好使用.<br>,链表基本上,查找上相对慢一点,的那是其他操作很方便.</td></tr></tbody></table><h2 id="3-模块设计"><a href="#3-模块设计" class="headerlink" title="3.模块设计"></a>3.模块设计</h2><h3 id="3-1程序函数调用图及模块分化"><a href="#3-1程序函数调用图及模块分化" class="headerlink" title="3.1程序函数调用图及模块分化"></a>3.1程序函数调用图及模块分化</h3><hr><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p><img src="https://i.imgur.com/i29cDLM.png" alt=""></p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><img src="https://i.imgur.com/5xhYBPf.png" alt=""></p><h3 id="3-2功能设计说明"><a href="#3-2功能设计说明" class="headerlink" title="3.2功能设计说明"></a>3.2功能设计说明</h3><hr><h4 id="3-2-1-Client–main模块"><a href="#3-2-1-Client–main模块" class="headerlink" title="3.2.1 Client–main模块"></a>3.2.1 Client–main模块</h4><hr><h5 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h5><p>此模块是进行Client总体控制的main模块</p><h5 id="算法和流程图"><a href="#算法和流程图" class="headerlink" title="算法和流程图"></a>算法和流程图</h5><p><img src="https://i.imgur.com/K3BuFYz.png" alt=""></p><h4 id="3-2-2-Client–recv模块"><a href="#3-2-2-Client–recv模块" class="headerlink" title="3.2.2 Client–recv模块"></a>3.2.2 Client–recv模块</h4><hr><h5 id="功能描述-1"><a href="#功能描述-1" class="headerlink" title="功能描述"></a>功能描述</h5><p>此模块是Client进行接收包的recv模块</p><h5 id="算法和流程图-1"><a href="#算法和流程图-1" class="headerlink" title="算法和流程图"></a>算法和流程图</h5><p><img src="https://i.imgur.com/d78hUjq.png" alt=""></p><h4 id="3-2-3-Client–chat-data模块"><a href="#3-2-3-Client–chat-data模块" class="headerlink" title="3.2.3 Client–chat_data模块"></a>3.2.3 Client–chat_data模块</h4><hr><h5 id="功能描述-2"><a href="#功能描述-2" class="headerlink" title="功能描述"></a>功能描述</h5><p>此模块是进行Client聊天室的主体控制程序模块</p><h5 id="算法与流程图"><a href="#算法与流程图" class="headerlink" title="算法与流程图"></a>算法与流程图</h5><p><img src="https://i.imgur.com/cyY3fbh.png" alt=""></p><h4 id="3-2-4-Server–main模块"><a href="#3-2-4-Server–main模块" class="headerlink" title="3.2.4 Server–main模块"></a>3.2.4 Server–main模块</h4><hr><h5 id="功能描述-3"><a href="#功能描述-3" class="headerlink" title="功能描述"></a>功能描述</h5><p>此模块是Server总体控制的main模块</p><h5 id="算法与流程图-1"><a href="#算法与流程图-1" class="headerlink" title="算法与流程图"></a>算法与流程图</h5><p><img src="https://i.imgur.com/nUsHYKB.png" alt=""></p><h4 id="3-2-5-Server–epoll-server模块"><a href="#3-2-5-Server–epoll-server模块" class="headerlink" title="3.2.5 Server–epoll_server模块"></a>3.2.5 Server–epoll_server模块</h4><hr><h5 id="功能描述-4"><a href="#功能描述-4" class="headerlink" title="功能描述"></a>功能描述</h5><p>此模块是Server进行事件管理的重要的epoll模块</p><h5 id="算法与流程图-2"><a href="#算法与流程图-2" class="headerlink" title="算法与流程图"></a>算法与流程图</h5><p><img src="https://i.imgur.com/pCzXwPa.png" alt=""></p><h3 id="3-2-6-Server–epoll-menu模块"><a href="#3-2-6-Server–epoll-menu模块" class="headerlink" title="3.2.6 Server–epoll_menu模块"></a>3.2.6 Server–epoll_menu模块</h3><hr><h5 id="功能描述-5"><a href="#功能描述-5" class="headerlink" title="功能描述"></a>功能描述</h5><p>此模块是Server进行事件处理的模块</p><h5 id="算法与流程图-3"><a href="#算法与流程图-3" class="headerlink" title="算法与流程图"></a>算法与流程图</h5><p><img src="https://i.imgur.com/hWXdRD5.png" alt=""></p><h2 id="4-文件说明"><a href="#4-文件说明" class="headerlink" title="4.文件说明"></a>4.文件说明</h2><table><thead><tr><th>文件名</th><th>位置</th><th>文件描述</th></tr></thead><tbody><tr><td>buffer1</td><td>~/Public/buffer1</td><td>存储离线内容</td></tr><tr><td>buffer2</td><td>~/Public/buffer2</td><td>存储离线信息位置</td></tr><tr><td>File目录</td><td>~/Public/File</td><td>接受发送的文件</td></tr><tr><td>[用户名]目录</td><td>/Public/Information/[用户名]</td><td>每一个用户建立一个目录,<br>其中包含了用户的好友目录,群组目录</td></tr><tr><td>[好友名]目录</td><td>~/Public/Information/[用户名]目录/[好友名]目录</td><td>其中包含了buffer,history两个文件</td></tr><tr><td>Groups目录</td><td>~/Public/information/Groups目录</td><td>其中包含了groups以及members两个文件</td></tr></tbody></table><h2 id="5-异常-错误处理"><a href="#5-异常-错误处理" class="headerlink" title="5.异常,错误处理"></a>5.异常,错误处理</h2><p>1.关于乱输入引发的错误</p><p>解决方案:<strong>使用控制终端的方法进行选项的获取</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int getch(void)</span><br><span class="line">&#123;</span><br><span class="line">     struct termios tm, tm_old;</span><br><span class="line">     int fd = 0, ch;</span><br><span class="line"></span><br><span class="line">     if (tcgetattr(fd, &amp;tm) &lt; 0) &#123;//保存现在的终端设置</span><br><span class="line">          return -1;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     tm_old = tm;</span><br><span class="line">     cfmakeraw(&amp;tm);//更改终端设置为原始模式，该模式下所有的输入数据以字节为单位被处理</span><br><span class="line">     if (tcsetattr(fd, TCSANOW, &amp;tm) &lt; 0) &#123;//设置上更改之后的设置</span><br><span class="line">          return -1;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ch = getchar();</span><br><span class="line">     if (tcsetattr(fd, TCSANOW, &amp;tm_old) &lt; 0) &#123;//更改设置为最初的样子</span><br><span class="line">          return -1;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在其他方面因为操作文件的错误</p><p>解决方法:<strong>进行文件打开结果的判断,不合格打印错误提示消息,并且退出</strong></p><h2 id="6-已经存在的问题及改善方案"><a href="#6-已经存在的问题及改善方案" class="headerlink" title="6.已经存在的问题及改善方案"></a>6.已经存在的问题及改善方案</h2><p><strong>问题1:不合理的文件结构</strong></p><p><strong>解决方案:分析实际程序的运行情况,一台主机仅绑定一个客户端,进行合理的文件结构分配</strong></p><p><strong>问题2:对于不合理的输入</strong></p><p><strong>解决方案:仍然需要继续进行非法输入的处理</strong></p><h2 id="7-运行截图"><a href="#7-运行截图" class="headerlink" title="7.运行截图"></a>7.运行截图</h2><p>1.file<br><img src="https://i.imgur.com/soOzFv6.gif" alt=""></p><p>2.friends<br><img src="https://i.imgur.com/SrQgs4b.gif" alt=""></p><p>3.groups<br><img src="https://i.imgur.com/vO4ws3m.gif" alt=""></p><p>4.history<br><img src="https://i.imgur.com/sriJJls.gif" alt=""></p><p>5.file<br><img src="https://i.imgur.com/m7erd3M.gif" alt=""></p>]]></content>
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>暑期生活总结</title>
      <link href="/2017/09/22/documents/2016%E6%9A%91%E6%9C%9F%E6%80%BB%E7%BB%93_%E9%99%88%E6%A3%AE/"/>
      <url>/2017/09/22/documents/2016%E6%9A%91%E6%9C%9F%E6%80%BB%E7%BB%93_%E9%99%88%E6%A3%AE/</url>
      <content type="html"><![CDATA[<h3 id="暑期学习生活总结"><a href="#暑期学习生活总结" class="headerlink" title="暑期学习生活总结"></a>暑期学习生活总结</h3><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><em>说起来很惭愧,暑期已经都已经结束几天了,结果我才来总结暑期的学习生活</em></p><p><strong>但是,将真,这个暑假是我度过最有意义的暑假.因为,我爱学习&lt;滑稽&gt;&lt;滑稽&gt;</strong></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>对于整个暑期的总结分为三部分来谈吧:</p><ul><li><a href="#学习">学习</a><ul><li><a href="#Linux_C">Linux_C</a></li><li><a href="#&lt;鸟哥的Linux私房菜">&lt;鸟哥的Linux私房菜&gt;</a></li><li><a href="#算法与数据结构">算法与数据结构</a></li></ul></li><li><a href="#生活">生活</a><ul><li><a href="#食">食</a></li><li><a href="#住">住</a></li><li><a href="#漫">漫</a></li></ul></li><li><a href="#感悟">感悟</a><ul><li><a href="#项目">项目</a></li><li><a href="#人际">人际</a></li></ul></li></ul><p>##学习</p><h3 id="Linux-C"><a href="#Linux-C" class="headerlink" title="Linux_C"></a>Linux_C</h3><p><em>毫无疑问,整个暑假的主要学习目标便是Linux_C的内容.</em></p><p><em>那么,就先来总结一下只要的学习任务吧!</em></p><p>Linux_C整本书,貌似是详细的介绍了在Linux下进行C开发的诸多事项,这本书初衷是好的</p><p><strong>但同样正是因为这一点,使得本书再没一方面都不是很深入.</strong></p><p><strong>同时,其中也出现了很多的错误.大家都是一边写,一边改,还挺有意思的(不过这都是后话了~)</strong></p><ul><li><p>文件操作</p></li><li><p>进程控制</p></li><li><p>线程控制</p></li><li><p>网络编程</p></li></ul><blockquote><p>这就是暑期主要学习的内容,不仅了解了Linux下进行开发的事宜,</p></blockquote><blockquote><p>同时接触到了,进程,线程,socket网络套接字这些以后都十分有用的东西,当然现在的了解还差得远.</p></blockquote><p>最后,总结一下,在Linux_C编程的路上,还有很长的路要走(在我以后选这个方向的前提下)</p><p>(<strong>或者说,还是自己的编码能力有待提高</strong>)</p><h3 id="lt-鸟哥的Linux私房菜-gt"><a href="#lt-鸟哥的Linux私房菜-gt" class="headerlink" title="&lt;鸟哥的Linux私房菜&gt;"></a>&lt;鸟哥的Linux私房菜&gt;</h3><p>这本书,是暑假学习的另一个任务</p><p>这本书,再看到bash之后,进度一下就慢了,</p><p><strong>在bash这里的内容实在是太杂太乱了</strong></p><p>还是尽力读下去吧,毕竟是一本好书,从不懂Linux到能玩玩Linux,全靠这本书了!</p><p><strong>bash之后的正则表达式,shell script的编写,都是很重要的</strong></p><p><strong>毕竟大家都是脚本语言,写起来还是比较方便的</strong></p><p><strong>开学后,这本书是一定要好好读完的</strong></p><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p><em>说起这部分,我真的很惭愧,我本来就是大家之中算法和数据结构最垃圾的</em></p><p><em>结果还是,鱼塘摸鱼摸得最高兴的</em></p><p><strong>最后,真的是坚持不了,有时给自己找借口,就不作了</strong></p><p><strong>现在想了想,真的是欠妥,算法与数据结构是十分重要的核心基础课,以后其他大多数课程都是建立在其上的</strong></p><p>开学之后,对于这门课要上心,下学期的课,就想好好上个(数据结构与算法,概率论与数理统计,数字电路设计)</p><blockquote><p>最后,任重而道远,需要一直坚持不懈的走下去</p></blockquote><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>可能每年除了学习以外,留下印象最深的就是,吃饭这件事吧…</p><p>每年吃饭,可能小组的大家都没少受折腾</p><ul><li><p>统一订饭</p><p><strong>每天订饭,民族餐厅,出去改善伙食,</strong></p><p>本来,大家同一订饭还是可以的,结果后来</p><p><strong>哪个gou老板,越来越来皮,越来越来皮,不仅质量,时间上也在搞事,真的是欠锤了</strong></p></li><li><p>民族餐厅</p><blockquote><p>也是来了西邮的民族餐厅,我才知道什么是回民饭               —一位不愿透漏姓名的回民</p></blockquote><p><strong>民族餐厅的饭不能吃!</strong></p><p><strong>民族餐厅的饭不能吃!</strong></p><p><strong>民族餐厅的饭不能吃!</strong></p><p>重要的事要说三遍</p><p>民族餐厅,这个地方,一辈子去过一次就够了…</p></li></ul><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>说完了食,那么还要说一说的就是住了</p><p><strong>西邮现已成为全西安惟一没有装有空调的高校</strong></p><p><strong>那你说,暑假,是让我死,还是活…</strong></p><p>整个暑假的经历还是比较可歌可泣的,,,</p><p><strong>比如我们宿舍留了五个人,最热的时候,睡在地上,地方小</strong></p><p><strong>我睡觉的时候,会莫名其妙的挨上几脚…</strong></p><p><strong>所幸,最后的时候,天气还是比较凉爽的,好多了…</strong></p><h3 id="漫"><a href="#漫" class="headerlink" title="漫"></a>漫</h3><p>整个暑假,每一天的任务都是挺重的,所以我一开始还给自己准备了几个放松每个的项目:</p><p><em>读&lt;诗经&gt;,看漫画,玩手机,</em></p><p>结果到最后,就只有玩手机和看漫画的<em>“好习惯”</em>保持了下来</p><p>一个暑假,将看漫画保持了下来</p><p><strong>&lt;浪客行&gt; 宫本武藏的”天下无双”</strong></p><p><strong>&lt; JOJO的奇妙冒险 &gt; 伟大的人类的赞歌</strong></p><p><strong>&lt;爆漫王&gt; 立志成为畅销漫画家的最哥和秋犯</strong></p><p><strong>&lt;北斗神拳&gt; 肩负着世纪末救世主的拳四郎</strong></p><p>怎么说呢,其实这一部分想要说的是:</p><p><strong>即是大家以后都是与代码狼狈为奸.但是,始终都要保持着自己的一个爱好.</strong></p><p><strong>也可以算是自己的放松吧 ~ ~ </strong></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p><em>这一部分算是好好的感悟了,一个是项目的方面,另一个是关于以后的感悟</em></p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>对于自己的项目,真的是不近人意,本来还想去写个2.0</p><p><strong>但是,最后只写了个1.5,其中还有许多的问题,哎~ ~ ~ ~ ~</strong></p><p>关于项目我的感悟是:</p><p><strong>多思考,多交流,我不是很喜欢多问,因为这样,我觉得就没有自己的思想了,就完了</strong></p><p><strong>从一开始根本不知道怎么写,到磕磕绊绊的网络通信跑通,一直到后来粗糙的目录结构</strong></p><p><strong>还有最后想要好好处理的分层结构</strong></p><p><strong>最后对于项目:每个客户端只是绑定一台主机,咱们平时的设计模式,其实是不合理的</strong></p><p>有更多的问题,大家可以多交流</p><p>反正就是一句话:<strong>多交流,才能使自己进步得更快</strong></p><h3 id="人际"><a href="#人际" class="headerlink" title="人际"></a>人际</h3><p>刚开始到小组,真的是很尴尬</p><p>处处都是大佬,也跟别人说不上话,感觉真的是很冷漠</p><p><strong>后来.经过一个暑假的相处,大家之间真的是越来越融洽,这种感觉,真的很棒!</strong></p><p>整个暑假的总结就是这些了,完成,上传的晚了,抱歉!</p><p>September 5, 2017 12:00 AM</p>]]></content>
      
      <categories>
          
          <category> 一些经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第八章 线程控制(一)</title>
      <link href="/2017/09/22/Linux_C/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
      <url>/2017/09/22/Linux_C/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p><em>上一次的内容是进程控制,到了这一章则是比进程用处更广泛的线程了</em></p><p><em>学好线程,可是有很大的作用呢!</em></p><p>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\</p><p><strong>一,线程的概念</strong></p><p>在进行线程的学习时,首先来了解一下概念:</p><p><strong>线程是进程中的一个实体,自己不拥有资源,(除了运行中的必不可少的资源,如堆栈段,寄存器)</strong><br><strong>一个线程可以创建/撤销其他的线程,同一个进程中的多个线程可以并发执行</strong>,由于线程之间的相互制约<br>有间断性{就绪,阻塞,运行}<br><strong>每一个进程至少存在一个线程,如果只有一个线程,那么这个线程 = 进程 = 程序自身</strong></p><p>再用用户看来,多个线程同时进行,实质上线程还也是类似于进程一样在进行调度运行,叫做<strong>并发</strong></p><p>但是,要注意的一点是:<strong>在多核CPU的现世代,多个线程可以在不同的CPU上工作,即真正意义上的并行</strong></p><hr><p>为什么要有多线程,因为它比多进程有这些优点:</p><ol><li><p>多进程是独立的地址空间(vfork除外)</p><p>反观多线程是独立的地址空间,<strong>同一进程内的线程,共享此进程的内存空间</strong></p><p><strong>所以,多线程更具有时间优势</strong></p></li><li><p>系统调度方面</p><p>在系统调度方面,<strong>因为线程共享内存空间,所以在线程调度切换上更具有优势,内部直接进行通信</strong></p><p>而进程之间的系统调度,<strong>则需要信号机制调度,必经过操作系统,时间上更麻烦</strong></p></li><li><p>另外的一些优势</p><p>使用线程,可以提高响应速度,可以提高多处理器效率,改善程序结构</p></li></ol><p>在我自己的理解看来,</p><p><strong>线程也没有多神秘,其实就是在进程中继续划分的更小的计算机工作单位,可以更好地提高效率,节省时间</strong></p><p>上面提到了,同一进程内的线程线程共享进程的地址空间,但是,线程也有其私有数据(区别于之后的<strong>“私有数据”</strong>)</p><blockquote><p>线程号,ThreadID</p></blockquote><blockquote><p>寄存器 [程序计数器,堆栈指针]</p></blockquote><blockquote><p>堆栈</p></blockquote><blockquote><p>信号掩码</p></blockquote><blockquote><p>优先级</p></blockquote><blockquote><p>线程的私有存储空间</p></blockquote><p>Linux系统下,不同于进程,线程的实现方式基于POSIX多线程标准</p><p>所有线程的操作,都是基于POSIX基准的接口函数</p><p>所以,<strong>在进行编译时,要链接动态库 -lpthread</strong></p><p>下面说一些线程其他事情吧:</p><hr><ol><li><p>为什么会有线程出现?</p><p>上世纪60年代,出现了进程的概念,方便工程师进行程序的设计,</p><p>但是,随着科学日益进步,工程量的增加,进程已经明显不能满足需求了</p><p>主要问题体现在两点上:</p><ul><li><p>进程较大的时 + 空开销(时间,空间的开销都大)</p></li><li><p>SMP,对称多处理机的出现,是同时运行几个程序成为了可能,但是使用进程的开销会很大</p></li></ul><p>就这样,在需求不段增长的时候,80年代,线程就出生了.</p></li><li><p>线程有几种调度方式?</p><p>线程进行调度分为三种:</p><p><strong><1>. 操作系统内核线程 e.g.Win32线程</1></strong></p><p><strong><2>. 用户线程 e.g.POSIX Thread</2></strong></p><p><strong><3>. 内核与用户线程混合调度 e.g.Win7 线程</3></strong></p></li><li><p>线程的属性</p><p>最早在Linux环境下,并没有真正的实现线程,所使用的名为”轻量进程”,实则用进程来实现线程功能</p><p>直至后来,才再真正意义上实现了线程</p><p><strong>线程 = 程序(代码) + 数据 +　TCB(类似于PCB)</strong></p><p>而其动态特性,则由TCB进行描述:</p><p><strong>线程状态 + 线程不运行时资源问题 + 执行堆栈 + 线程局部变量主存区 + 访问同一进程主存与其他资源</strong></p><p><strong>最后,用一句话来描述线程与进程的关系 : 进程是线程的容器,线程是进程执行程序真正实体</strong></p></li></ol><p>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\</p><p><strong>二,线程操作</strong></p><p><strong>1.创建线程</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_creat</span><span class="params">(<span class="keyword">pthred_t</span> *thread,<span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line">                  void *(*start_routine)(void *), void arg)</span><br></pre></td></tr></table></figure><p>pthread_creat,线程创建函数</p><p>其作用是:<strong>创建线程号为thread,线程属性为attr,执行参数为arg的start_routine函数的线程</strong></p><p><strong>创建一个新的线程后,线程也去执行新的程序,类似于进程的exec系函数,但是在内存空间上分配有不同之处</strong></p><p><strong>新创建的线程去运行指针指向的函数,而原线程继续执行接下来的操作</strong></p><p>再来看几个函数:</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>pthread_t pthread_self(void)</td><td>类似于getpid(),获取线程自身线程ID</td></tr><tr><td>int pthread_equal(pthread_t thread1,pthread_t thread2)</td><td>判断两个进程是否为同一进程</td></tr><tr><td>int pthread_once(pthread_once_t <em>once_control,void(</em>int_routine)(void))</td><td>保证该函数仅执行一次</td></tr></tbody></table><p>下面来看看如何创建进程:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_thid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;                     <span class="comment">//声明进程ID变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent pthread is me,my thid is %lu\n"</span>,pthread_self( ));</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;thid,<span class="literal">NULL</span>,(<span class="keyword">void</span> *)get_thid,<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error!\n"</span>);                 <span class="comment">//调用函数进行进程的创建</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_thid</span><span class="params">(<span class="keyword">void</span>)</span>                      <span class="comment">//创建进程时,被调用的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;</span><br><span class="line"></span><br><span class="line">    thid = pthread_self( );</span><br><span class="line">    <span class="keyword">if</span>(thid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I'm child pthread,my thid is %lu\n"</span>,thid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图所示,即为结果<br><img src="http://img.blog.csdn.net/20170807192925226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><hr><p><strong>2.线程属性</strong></p><p>在线程的创建函数中一个参数是attr,其类型为pthread_attr_t,此结构体定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>                      detachstate;</span><br><span class="line"><span class="keyword">int</span>                      schedpolicy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>       <span class="title">schedparam</span>;</span></span><br><span class="line"><span class="keyword">int</span>                      inheritsched;</span><br><span class="line"><span class="keyword">int</span>                      scope;</span><br><span class="line"><span class="keyword">size_t</span>                   guardsize;</span><br><span class="line"><span class="keyword">int</span>                      stackaddr_set;</span><br><span class="line"><span class="keyword">void</span> *                   stackattr;</span><br><span class="line"><span class="keyword">size_t</span>                   stacksize;</span><br><span class="line">&#125; <span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>以上即为attr,线程属性的定义,类似于文件描述符FILE的定义,</p><p>线程的属性设置又有重要的作用,因为此处目前没有太多作用,不予深究,有兴趣的可自行查阅man手册</p><hr><p><strong>3.线程的终止</strong></p><p>在Linux环境下,有两种方式实现线程的终止</p><ul><li><p>调用return函数,实现线程终止</p></li><li><p>使用POSIX标准的接口API,pthread_exit函数</p></li></ul><p><strong>这两个函数主要的区别之处在于在主线程中调用的区别:</strong></p><p><strong>在主线程中调用return/exit,会使主线程结束,进而整个线程结束,全部线程消亡</strong></p><p><strong>如果是调用pthread_exit( )函数,则主线程消亡后,其他线程并不会受到影响,知道所有线程结束,进程才会结束</strong></p><hr><p>在线程的终止时,另外一个重要的问题就是关于资源的释放问题:</p><p><strong>特别是一些临界资源,临界资源在同一时间只能被其中一个线程所使用,如若被多个线程使用,则会导致资源混乱</strong></p><p>而如果,临界资源给一个线程所使用,的那是线程退出时没有释放临界资源,</p><p><strong>则其他线程会一直认为该临界资源还在被其他线程所占用,就会导致死锁问题的出现</strong></p><p><strong>死锁问题的出现,在程序设计的过程中,往往是灾难性的</strong></p><p>所以为了妥善处理线程结束时,临界资源的释放问题,Linux系统提供了一对函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pthread_cleanup_push(routine ,arg) \</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span> \</span><br><span class="line">      _pthread_cleanup_push(&amp;buffer,(routine),(arg));</span><br><span class="line"><span class="meta">#dedine pthread_cleanup_pop  \</span></span><br><span class="line">         _pthread_clean_pop(&amp;buffer,(exeute));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个函数,pthread_cleanup_pop( )与pthread_cleanup_push( )是要配合起来使用的</p><p>*cleanup_push( )用来在线程提前结束时清理函数,</p><p>而,*cleanup_pop( )则是在线程正常结束时,用来清理*cleanup_push( )函数的</p><hr><p>在释放资源以外,另一个需要谨慎处理的就是资源的同步问题了,</p><p>一般情况下,进程中各个线程的运行是相互独立的,线程的终止并不会相互通知,终止的线程资源仍归线程独有</p><p><strong>所以资源的同步十分重要,同进程中的wait函数,在线程中所使用的是pthread_join( )函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthred.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thid,<span class="keyword">void</span> *thread_return)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thid)</span></span>;</span><br></pre></td></tr></table></figure><p>函数pthread_join用来使调用者挂起等待thid线程的结束</p><p>要注意的点有:</p><p><strong>1.一个线程只能被另一个线程所等待,并且被等待的线程必须处于可join的状态,即它不能被设定为DETACHED</strong></p><p><strong> 处于DETACHED状态的线程是指内核不关心线程返回值,线程结束后,内核自动回收的分离模式</strong></p><p><strong> 所以,为了防止内存泄漏,并且完成线程同步,所有的线程结束时,都要设定为DETACHED或者被join( )等待</strong></p><p><strong>2.一个线程只能被一个线程等待,若被多个线程等待,其中一个线程恢复恢复就绪状态后,其他线程便进入了死锁</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thid,<span class="literal">NULL</span>,(<span class="keyword">void</span> *)test,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thid,(<span class="keyword">void</span> *)&amp;status);                                     <span class="comment">//使主线程进行阻塞,等待子线程结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I  (%lu)  have waited for a long time  %d"</span>,pthread_self( ) ,status);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am for test !\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);                                                  <span class="comment">//用sleep来延时函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I have achieved!\n"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上结果即可看出,调用函数对目标函数完成了挂起等待.<br><img src="http://img.blog.csdn.net/20170807192942808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><hr><p><strong>4.私有数据</strong></p><p><strong>区别于之前提到的私有数据,此处私有数据指的是多个线程中操作不同的数据,并非是..</strong></p><p><strong>在这里举一个特殊的的例子:errno全局变量</strong></p><p><strong>理论上errno应该是任何线程都够访问的全局变量.但是如若errno中保存的值还没有被使用</strong></p><p><strong>便被其他线程更改了其中的值,同样也会影响使用</strong></p><p><strong>像这种全局变量,即是我们此处要讨论的私有数据,即都能访问的全局变量,但是在各个线程中又是不一样的值</strong></p><p>私有数据的实现方式借用了:<strong>一键多值</strong></p><p>此处对这个键可以理解为:<strong>一个数据管理器,在各个线程中,调用时,键会告诉在此线程中应该使用什么值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">int pthread_key_creat (pthread_key_t *key,void (*destr funcation) (void *));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span> <span class="params">(<span class="keyword">pthred_key_t</span> *key,<span class="keyword">const</span> <span class="keyword">void</span> *pointer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure><p>上面的函数,</p><p><strong>Creat函数是用来创建键的,</strong></p><p><strong>setspecific函数用来将线程的私有数据与键绑定,在线程自身中调用</strong></p><p><strong>getspecific函数用来获取键值中绑定的私有数据</strong></p><p><strong>delete函数用来销毁键</strong></p><p>有以下要注意的点:</p><p>1.在使用pthread_key_creat函数时,</p><p>切记只能初始化一次如果一个键值被创建了两次,会覆盖</p><p>建议:<strong>在创建键时,可以在main函数中创建一次,或者使用prhread_once函数只进行一次创建</strong></p><p>创建新键时,每个私有数据的地址为NULL.</p><p>2.在pthread_key_creat函数中,</p><p>使用了析构函数.所谓析构函数指的是用来在键值使用完成之后</p><p>清除并释放与键值绑定的私有数据所占的内存空间,</p><p><strong>键值对与私有数据所占用的并不是相同的数据空间,所以要分开进行释放</strong></p><p><strong>一旦在键值对释放时,未释放私有数据所占据的空间,则会导致内存泄漏,灾难性的后果</strong></p><p><strong>所以调用析构函数有其一定的必要性,当为NULL,会调用内核自身的清理函数</strong></p><p>一般情况下,<strong>线程调用malloc为私有数据分配内存空间</strong></p><p>3.在pthread_delete函数中</p><p><strong>pthread_delete函数是用来取消键与私有数据间关联的函数</strong></p><p>调用pthread_delete函数并不会影响正在使用的私有数据与键值,但是容易造成内存泄漏</p><p><strong>最后总结,不同的线程对私有数据的访问对彼此之间是不可见的,操作互不影响,</strong></p><p><strong>即键同名且全局但访问内存空间不同</strong></p><p><strong>可以将key理解为一个数据管理员</strong></p><p>来看一个示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> key;                <span class="comment">//定义全局变量库--键</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;          <span class="comment">//线程1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;          <span class="comment">//线程2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;                 <span class="comment">//线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread begins running!\n"</span>);</span><br><span class="line">    pthread_key_create(&amp;key,<span class="literal">NULL</span>);                        <span class="comment">//参数为,键地址,以及析构函数(用于私有数据的内存清理),如果为NULL,则调用系统的清理函数</span></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);               <span class="comment">//四个参数依次是线程ID,线程属性,调用函数,函数参数</span></span><br><span class="line">    sleep(<span class="number">10</span>);                                            <span class="comment">//睡眠以使主线程等待</span></span><br><span class="line">    pthread_key_delete(key);                              <span class="comment">//销毁键,私有数据的销毁必须在其之前,不然会内存泄漏</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mian pthread ends \n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tsd = <span class="number">5</span>;                                          <span class="comment">//pthread中的私有数据</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thid_1;                                     <span class="comment">//分配新的线程号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread 11  %lu is running!\n"</span>,pthread_self(  ));</span><br><span class="line">    pthread_setspecific(key,(<span class="keyword">void</span> *)tsd);                        <span class="comment">//使键与私有数据绑定</span></span><br><span class="line">    pthread_create(&amp;thid_1,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);            <span class="comment">//创建新线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 %lu ends,pthread's tsd is %d\n"</span>,pthread_self(  ),pthread_getspecific(key));</span><br><span class="line">    sleep(<span class="number">5</span>);                                            <span class="comment">//睡眠以等待新线程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tsd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread 22 %u is running\n"</span>,pthread_self(  ));</span><br><span class="line">    pthread_setspecific(key,(<span class="keyword">void</span> *)tsd);                       <span class="comment">//绑定键值与私有数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %lu ends,thread's tsd is %d\n"</span>,pthread_self(  ),pthread_getspecific(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对此段代码,其中需要注意的地方是,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一,关于Thid的问题,使用%d,整型根本保存不下线程ID,必须使用%u,不然会出现溢出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二,即是任意类型指针的问题,(void *)可以指向任何类型的数据,但是会出现警告</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 而在网路上的解法都是直接进行取地址去获取地址,并传参</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 至于细节,还需要再琢磨</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20170807192959580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\</p><p>本次线程控制总结至此,下次将会是线程同步的内容,十分重要!!!</p><p>另外还有小实验的总结,十分有用!</p><p>August 7, 2017 7:24 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux_C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第七章 进程控制(二)</title>
      <link href="/2017/09/22/Linux_C/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C(%E4%BA%8C)/"/>
      <url>/2017/09/22/Linux_C/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<p><em>接上一章,在进行了进程最后部分的学习后,现将进程最后部分的知识进行总结学习</em></p><p><em>同时会附上进行my_shell项目文档实现的经验</em></p><hr><p><strong>一,进程的其他操作</strong></p><p>本部分是一些进程的其他操作,虽然不如<strong>进程操作</strong>的部分重要,但是还是有很重要的意义</p><p><strong>1.获取进程ID</strong></p><p>进程ID,是进程的标识之一,进程ID(即PID)的重要性不言而喻</p><p>而且,<strong>通过进程ID,方便对进程进行其他的操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>)      <span class="comment">//获取当前进程ID</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>)     <span class="comment">//获取当前进程父进程ID</span></span><br></pre></td></tr></table></figure><p>另外还有获取进程实际用户,有效用户的函数,在之前已经提到过,此处不再赘述</p><p><strong>2.setuid与setgid</strong></p><p>看过&lt;鸟哥的Linux私房菜&gt;的同学,可能对这两个概念了解的比较好一点</p><p>简而言之,这两个函数,使用来处理程序中对用户权限的处理问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span></span><br><span class="line"><span class="function">itn <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span></span><br></pre></td></tr></table></figure><p>其中需要谨慎处理的是,root权限的问题</p><p>因为,一旦用root权限去处理,则最后会将uid与gid进行修改,最后会导致失去root权限的问题出现</p><p>下面来看一个简单的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Process Start!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Process uid is %d,euid is %d\n"</span>,getuid(  ),geteuid(  ));</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"test.c"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open Suessfully!\n"</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子的结果<br><img src="http://img.blog.csdn.net/20170731225312247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>此即为文件权限的问题</p><p><strong>3.改变进程的优先级</strong></p><p>改变进程的优先级,是用来将常用,频繁的进程的优先级提高,换句话来说,就是提高计算机的效率</p><p>需要掌握的有三个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> increment)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which,<span class="keyword">int</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which,<span class="keyword">int</span> who,<span class="keyword">int</span> prio)</span></span>;</span><br></pre></td></tr></table></figure><p>具体示例,还请自行进行测试</p><hr><p><strong>二,my_shell经验分享</strong></p><p><strong>进程的知识,暂时告一段落,在此处,我想要和大家分享的是my_shell项目实践经验</strong></p><p>我先放出,我的源码,以及项目文档</p><p><a href="https://github.com/Evil-crow/Linux_C/tree/master/Chapter_VII/Shell" target="_blank" rel="noopener">传送门</a></p><p>想要分享的经验如下:</p><ol><li><p>进行编码前,多思考,多考虑,尽量考虑周到一点</p></li><li><p>多和别人交流,会有意想不到的收获</p></li></ol><hr><p>现在是技术上的分享</p><ol start="3"><li><p>关于守护进程,创建出一个脱离当前shell环境的进程,使用守护进程,算是后台进程的一种</p></li><li><p>信号的实现,使用signal系列函数 <code>signal(SIGCHLD,SIG_IGN)</code></p></li><li><p>经过我亲身经历,makefile真的很有用,用了都说好,而且还能装逼(滑稽-&gt; &lt;-)</p></li><li><p>PATH环境变量的设置,注意/etc/profile 与~/.bash_profile,的区别,并且学会如何修改环境变量</p></li></ol><p><img src="http://img.blog.csdn.net/20170731225325868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>以上即为我的分享,有不足的地方还请大家指出,</p><p>下次会进行线程控制的分享(有机会一定补上文件操作的坑)</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux_C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第七篇 进程控制(一)</title>
      <link href="/2017/09/22/Linux_C/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C(%E4%B8%80)/"/>
      <url>/2017/09/22/Linux_C/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p><em>经历了上一周悲剧的学习,这一周,我决定让自己充实起来,</em></p><p><em>而进程控制(Peocess_Control)的学习尤为关键</em></p><p><em>所以,下面即为我的收获,本章的学习分为两部分</em></p><p><em>第一部分是进程的了解,以及相关操作</em></p><p><em>第二部分就是进程的一些其他操作,以及项目的一些实现要点</em></p><hr><h5 id="一-进程"><a href="#一-进程" class="headerlink" title="一,进程"></a>一,进程</h5><ul><li>进程的概念</li></ul><p>了解什么是进程,进程的概念以及特点.</p><p>进程的概念总结后有以下几点:(进程与程序,线程的区别)</p><ol><li><p>进程是一个动态的实体,是操作系统分配资源的基本单位</p></li><li><p>进程与程序的区别在于:</p><p>程序只是代码块,而进程是将代码移至内存中,之后为其分配资源以及空间运行中的程序,</p><p>可以这样理解进程,即特点之一是动态的</p></li><li><p>进程与线程:</p><p>为了使计算机能够在同一时间执行更多的任务,又在进程中划分了多个线程,</p><p>线程是操作系统所能操作控制的最 小单位,</p><p>进程分配有资源和内存,对于这些内容,线程不单独享用,多个线程共享这些资源以及内存,</p><p>同一个进程可以创建和撤销多个线程,</p><p>多个线程可以在进程中并行进行.</p></li></ol><p>以上即为进程的基本概念.</p><p>其实我们可以从计算机的发展过程来看:</p><p>1.进程最早是分时操作系统(一个计算机史上的分支方向)的基本单位</p><p>2.后来是面向进程编程的操作系统 <strong>(例如 UNIX, Linux Kernel &lt; 2.6)</strong></p><p>3.直到现在,是以面向线程编程的操作系统.进程只是线程的容器,  <strong>(现代大多数操作系统,Linux Kernel&gt;2.6)</strong></p><p>进程(Peocess)一直是十分重要的概念,可以说进程是计算机对计算机资源的调度方式</p><p>这样才能使计算机能够执行任务.</p><hr><ul><li>关于进程的特点:</li></ul><p>动态性:进程是动态产生的,也是动态消亡的</p><p>并发性:多个进程可以并行进行</p><p>独立性:单个进程可独立进行,系统为其分配资源,是计算机调度的基本单位</p><p>异步性:进程以不可预知的方向前进,速度,耗时,都是不可预知的</p><hr><ul><li>进程标识符(process ID)_PID</li></ul><p>进程是计算机操作系统资源分配的基本单位,那么,</p><p>计算机中同时进行的可能会有成百上千的进程,</p><p>所以对进程最直观的区分就是进行编号,即进程ID Process_ID</p><p><strong>关于进程标识符:</strong></p><blockquote><p>所有进程标识符都是惟一的</p></blockquote><blockquote><p>所有进程标识符非负</p></blockquote><blockquote><p>所有的PID,在进程开始时,为其分配PID,之后对其进行操作,进程结束后,PID回收</p></blockquote><p>Linux操作系统中提供了用于获取PID的相关函数,如下:</p><p>头文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th>函数声明</th><th>功能</th></tr></thead><tbody><tr><td>pid_t getpid( )</td><td>获取到当前进程ID</td></tr><tr><td>pid_t getppid( )</td><td>获取当前进程父进程ID</td></tr><tr><td>Pid_t getuid( )</td><td>获取当前进程实际用户ID</td></tr><tr><td>pid_t geteuid( )</td><td>获取当前进程有效用户ID</td></tr><tr><td>pid_t getgid( )</td><td>获取当前进程实际用户组ID</td></tr><tr><td>pid_t getegid( )</td><td>获取当前进程有效用户组ID</td></tr></tbody></table><p>既然提到进程ID,就不得不进行细分:</p><p>1.RUID 实际用户ID:进程的执行者ID,仅只有root可以进行修改</p><p>2.EUID 有效用户ID:进程需要执行的用户ID,可以理解为权限ID,即该进程的拥有者</p><p>3.SUID 保留设置用户ID:进程切换其有效用户(EUID)时使用</p><p>对于这三种用户ID,有这些需要注意的点:</p><blockquote><p>1.一般用户可以将EUID设置为RUID,SUID其一,root可以将EUID设置为任意合法的UID</p></blockquote><blockquote><p>2.当未设置SUID时,SUID = RUID,当设置SUID后,SUID = EUID</p></blockquote><blockquote><p>root将S,E,RUID进行修改,修改他们的值.一般用户,仅当UID = R/SUID时,可将EUID置为UID,且不会修改值</p></blockquote><ul><li>进程的结构</li></ul><p>之前上面也提到过,进程时动态的实体,既然是实体,那么他必然有其既定的数据结构</p><p>如图:<br><img src="http://img.blog.csdn.net/20170727110851990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>代码段:即是这个进程的代码</p><p>数据段:保存的是,进程中的全局变量,常量,静态变量</p><p>堆栈段:栈用于函数调用,其中保存着函数的参数,函数的内部定义的局部变量</p><p><strong>注意:这三部分实体构成了进程的结构,之后在进程操作中,要特别注意三个段数据的变化</strong></p><ul><li>进程的状态</li></ul><p>运行状态:R,<strong>实际上,运行状态与就绪状态,统称可运行状态,R表示</strong></p><p>可中断的等待状态:S,<strong>现在可中断的等待状态,称为可终端的睡眠状态,可以被其他程序唤醒</strong></p><p>不可中断的等待(睡眠)状态:D,不可被唤醒,直至等待事件完成</p><p>僵死状态:Z,已终止,描述符仍在,直至父进程调用wait后才能释放</p><p>停止状态:T,表示进程暂停,或者正在被信号跟踪(gdb调试)</p><p>同时使用后缀字符进行状态的补全:</p><p><strong>&lt; :高优先级程序</strong></p><p><strong>N :低优先级进程</strong></p><p><strong>L :内存锁页,此页不可以被换出内存</strong></p><p><strong>s :该进程为会话首进程</strong></p><p><strong>l :多线程进程</strong></p><p><strong>+ :进程位于前台进程组</strong></p><p>既然上面提到了这么多的进程状态,我们就来看看怎么查看进程状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps  查看进程的基础命令</span><br><span class="line"></span><br><span class="line">常用选项:</span><br><span class="line"></span><br><span class="line">-A,显示所有进程,</span><br><span class="line"></span><br><span class="line">-u显示指定用户进程</span><br><span class="line"></span><br><span class="line">-ef 显示进程信息,搭配命令行(可配合管道使用)</span><br><span class="line"></span><br><span class="line">常用:</span><br><span class="line"></span><br><span class="line">ps -aux 即可成功查看,当前计算机上所有进程</span><br></pre></td></tr></table></figure><p>如图:</p><ul><li>进程的内存映像</li></ul><p>说了这么多,都是基于软件上的进程概念,那么,实质上进程是如何反映在内存中的呢?</p><p>一,将程序拷贝至内存中,使程序变成进程,之后,就是进程在内存中的映像</p><p>二,进程在内存中的映像</p><p>何为映像?</p><p><strong>我的理解就是,映像,即为进程在内存中的实际反映,即是,进程在内存中是如何编排的</strong></p><p>首先,来看两张图(图片引自网络)<br><img src="http://img.blog.csdn.net/20170727110724278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><img src="http://img.blog.csdn.net/20170727110743139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>从内存的低地址开始,依次填入进程结构块中的内容</p><p>通过了解内存映像,可以加深对于进程概念的理解:</p><p>可执行程序没有堆栈,存储在硬盘中;进程存储在内存中,有堆栈段</p><p>可执行程序存储在硬盘,是静态的,不变的.而进程储存在内存中,是变化的,动态的.</p><hr><h5 id="二-进程控制"><a href="#二-进程控制" class="headerlink" title="二,进程控制"></a>二,进程控制</h5><p>了解了进程之后,进程控制则是重点内容</p><p>进程控制,主要有以下方面:</p><ul><li><p>创建进程</p></li><li><p>创建守护进程(后台)</p></li><li><p>退出进程</p></li><li><p>执行新程序</p></li><li><p>等待进程结束</p></li></ul><p><strong>1.创建进程</strong></p><p>进程很重要,那么重中之重就是进程的创建了,因为只有创建了进程,才能有后续的进程操作.</p><p>在UNIX/Linux中进程的创建只有两种类型:</p><blockquote><p>由父进程创建出新的子进程</p></blockquote><blockquote><p>由操作系统内核创建出的一些特殊进程,比如,init进程,0,1号进程</p></blockquote><p>而我们平时进行进程创建的多是第一种类型,即从父进程重新创建出新的子进程</p><p>来理解进程的生命过程:</p><p><strong>开始 -&gt; 调用函数创建进程 -&gt; 进程执行 -&gt; 进程终止 -&gt; 传递信息给父进程 -&gt; 父进程进行资源的回收 -&gt; 结束</strong></p><p>而进程在创建时,则是:</p><p><strong>开始-&gt;为进程分配惟一的PID-&gt;分配数据段,堆栈段</strong></p><p>首先介绍一个函数,fork( )函数,这是UNIX/Linux中特有的函数,不同于Win下的CreatProcess( )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>fork在英语中的语义是”分叉,分支”,在程序设计里则是创建新进程的不二法宝.</p><p>fork( )一个新进程,主要有两点作用:</p><p>1.使用多进程执行一个程序(通常用处不大)</p><p>2.fork( )之后,立即调用exec函数族,执行另一个程序(常用法)</p><p>现在来理解一下fork( )的实际过程:</p><blockquote><p>调用fork( )之后,操作系统立马新建一个进程在内存中,称为子进程.</p></blockquote><blockquote><p>子进程与父进程共享代码段,其数据段以及堆栈段为父进程的拷贝,即,调用fork( )之后,</p></blockquote><blockquote><p>创建了两个几乎完全相同的进程,而两个进程的关系,更像是兄弟关系.</p></blockquote><p>fork进行进程的创建,当进程fork( )创建完后,</p><p><strong>fork( )这个特殊的函数会返回两个返回值</strong></p><p>来画一张图理解:</p><p><img src="http://img.blog.csdn.net/20170727110815381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>如上图,进程fork后,新建了一个子进程,</p><p>两个进程并行运行,互相各走各的,</p><p><strong>所以希望大家注意一个误区,现在是两个进程在执行fork之后的相同代码</strong></p><p><strong>所以才会有不同输出结果! ! !</strong></p><p>看下面这段程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="comment">/* printf("Fork start!");*/</span>            <span class="comment">/*子进程对缓冲区的数据实行了拷贝,虽然fork( )在printf之后*/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Fork start!\n"</span>);</span><br><span class="line">   pid = fork( );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I'm child process! my pid is %d,my father pid is%d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I'm parent process!my pid is %d,my parent pid is%d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20170727110942485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>由其进程ID,可以看出其父子进程关系,</p><p>比較有意思的是:</p><p>Fork start!,打印了一次</p><p>但是如果,是使用了上面的那條語句,則會打印两次Fork start!</p><p>这是为什么?</p><p><strong>这就要提到printf的机制了,他先将内容输出到缓冲区中,然后等待缓冲区刷新进行内容的输出</strong></p><p><strong>但是,如果缓冲区没有刷新,也就是说,子进程会将缓冲区拷贝,然后进行输出,在最后程序结束时</strong></p><p>可以总结一下,缓冲区刷新的条件:</p><p>1.缓冲区满溢出</p><p>2.\n ,\t,\v等强制刷新化冲区</p><p>3.程序结束时,不管是使用return还是exit,都会清理I/O输出,将缓冲区的内容输出,(默认return,接下来一个例子证明)</p><p>再来分析一下上面的程序:</p><blockquote><p>pid获取fork( )的返回值,fork( )之后是两个进程分别进行fork( )后面的代码</p></blockquote><blockquote><p>swich语句中,</p></blockquote><blockquote><p>父进程获取到的pid是fork第一个返回值–子进程的PID,都是非0的</p></blockquote><blockquote><p>子进程获取到的pid是fork第二个返回值–0,因为子进程无子进程</p></blockquote><blockquote><p>如果fork( )失败,则会返回-1</p></blockquote><p>fork的返回值很特殊,在进行程序设计时,需要明辨各自的返回值</p><p>那么,fork( )的实质清楚了,那么父子进程的运行情况又是什么样的呢?</p><p>看代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">char</span> *s;</span><br><span class="line">  <span class="comment">/* printf("Fork start!");*/</span>   <span class="comment">//同上例的缓冲区问题</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Fork start!\n"</span>);</span><br><span class="line">   pid = fork( );</span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         s = <span class="string">"I'm child process! my pid is ,my father pid is\n"</span>;</span><br><span class="line">         k = <span class="number">3</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">/*sleep(1);*/</span></span><br><span class="line">         k = <span class="number">5</span>;</span><br><span class="line">         s = <span class="string">"I'm parent process!my pid is ,my parent pid is\n"</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(k--)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n%d\n"</span>,s,k);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="http://img.blog.csdn.net/20170727111020554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其实但从上面结果来看,结果是不甚明显的,可以看到子父进程勉强是交替进行的,</p><p>如果把上面的sleep函数去掉,你会发现,其实是一个进程结束后,另一个进程才进行.</p><p>这一定就是对的吗?</p><p>事实上,在了解了操作系统的相关内容后,会发现,</p><p><strong>父子进程其实是杂乱无章的,而且是随机的,你所看到的规律是因为试验结果比较小导致的</strong></p><p><strong>真正决定子父进程顺序的其实是操作系统的调度算法,以及时间片的分配</strong></p><p><strong>进程具有异步性,反映出来就是父子进程是随机进行的</strong></p><p><strong>而且,需要给大家补充的一个概念,就是计算机同一时间只能处理单进程,多线程</strong></p><p><strong>之所以我们平时可以看到计算机同时进行多个任务,这是因为计算机切换进程的速度太快,约1/60s</strong></p><hr><p>既然上面提到了,父子进程是随机的,主要依靠计算机CPU的调度算法,现在来了解两个特殊的进程:</p><p><strong>1.孤儿进程</strong></p><p>既然父子进程有异步性,不同时开始,不同时结束.那么,一旦父进程先于子进程结束,</p><p>则子进程称为<strong>“孤儿进程”</strong></p><p><strong>因为此时该子进程失去了其父进程,而在UNIX类操作系统中,这样的事是不被允许的,一个子进程必须有父进程</strong></p><p>这个时候,特殊进程,PID == 1的进程,init进程就派上用场了,</p><p><strong>init进程会收养该子进程,成为该子进程的父进程,处理之后的一系列动作</strong></p><p>来看一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;                       <span class="comment">/*获取PID的参数*/</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Fork start!\n"</span>);</span><br><span class="line">   pid = fork( );                   <span class="comment">/*创建新进程并获取其PID*/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         sleep(<span class="number">1</span>);          <span class="comment">/* 此语句用来睡眠,使得子进程后于父进程结束,研究子进程pid的变化*/</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am child process my pid is %d my parent process pid is %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am parent process,my pid is %d, my parent process pid ios %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="http://img.blog.csdn.net/20170727111042059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>注意子进程的ppid(父进程ID),并非上面父进程ID,而是一个奇怪的数字1560,有时是1578,</p><p><strong>在/proc中可以看到,里面的编号其实都是PID,15xx,在进入目录,cat status后,会发现</strong></p><p><strong>都是名为systemd,1号也是systemd,可以说有多个init进程来接管孤儿进程</strong></p><p>你可能会疑惑,为什么对于孤儿进程必须要找一个人来收养,</p><p>那么,来看下面一个特殊的进程</p><p><strong>2,僵尸进程</strong></p><p>上面提到父进程先结束成为孤儿进程,那么子进程先结束便称作<strong>僵尸进程</strong></p><p>僵尸进程,不要听上去就感觉耸人听闻,其实他更重要的是因为,进程处于”Z+”,僵死状态</p><p><strong>现在来解释上面提出的一个问题:为什么一定要找出一个进程来收养孤儿进程</strong></p><p><strong>因为,在UNIX类操作系统中,一个进程消亡,并非是真正的死亡,而是会留下一个称为”僵尸进程”的数据结构</strong></p><p><strong>因为,UNIX类操作系统使用此机制,可以避免因为异步的特性,子进程先结束,而是父进程失去子进程信息的情况</strong></p><p>那么,这也就带来了一个问题,<strong>有大量地僵尸进程,则会占用进程标识符PID,最终导致资源泄漏</strong></p><p>来看一段代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   pid = fork( );</span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am child process my pid is %d,i = %d\n"</span>,getpid( ),i++);</span><br><span class="line">         _exit(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Fork Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         sleep(<span class="number">5</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"I am parent process my pid is %d,i = %d\n"</span>,getpid( ),i++);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="http://img.blog.csdn.net/20170727111104442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中Z+即为子进程,僵尸进程</p><p>至于为什么需要进程来收养孤儿进程 <strong>就是防止不可回收的僵尸进程</strong></p><p>僵尸进程大量存在,会严重危害计算机的工作效率</p><p>来看看集中解决僵尸进程的办法:</p><p>1&gt; 父进程调用wait或者waitpid函数等待子进程的结束</p><p>2&gt; 使用信号SIGCHLD,用忽略信号,使得父进程忽略信号,子进程直接移交内核处理</p><p>3&gt; 小技巧:kill “僵尸爸爸”,因为一般情况下.僵尸进程很难被杀死</p><p>4&gt; 小技巧:连续fork( )两次,并杀死第一次的子进程,之后使用被收养的孤儿进程exec族函数调用新程序</p><p><strong>这里,需要给大家明确一个概念:僵尸进程,是很正常的一种情况</strong></p><p><strong>是进程结束的必经过程,不过有的进程在进行合理处理后,僵尸进程的时间很短暂,但还是经历了Z+状态</strong></p><p><strong>而且,不要将僵尸进程理解成有害而无利的,僵尸进程是因为父进程可能需要获取子进程信息而存在的</strong></p><p><strong>在最后,切记一点,在进行僵尸进程的测试时,ps -aux命令需要在另一个终端中使用(个中原因大家自行体会)</strong></p><hr><p><strong>vfork( )创建新进程</strong></p><p>上面的内容都是以fork( )创建新进程为主,那么vfork( )有什么作用呢?</p><p><strong>vfork( )也是创建新进程的函数,同样也是调用一次,有两个返回值</strong></p><p><strong>vfork( )和fork( )的区别在于:</strong></p><p><strong>1.vfork( )共享代码段,和数据空间,两个进程是共享的,而fork( )只有代码段共享,其他部分都是分离的</strong></p><p><strong>2.vfork( )调用后,父进程会等待子进程结束才继续进行,相当于使用了wait/waitpid的fork( )函数</strong></p><p><strong>由上面的1.即可知,子进程对于一些全局变量的操作在父进程中也是可见的,因为他们共享,而非拷贝</strong></p><p><strong>如果在子进程中依赖父进程的行为,则会造成死锁,(互相等待对方进程的完成)</strong></p><p><strong>最后,十分重要的一点,只有调用了exec族函数/exit,才能由子进程回到父进程</strong></p><p>来通过代码看结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">3</span>,i;</span><br><span class="line">   pid = vfork( );                                  <span class="comment">/*创建子进程*/</span></span><br><span class="line">   <span class="comment">/*pid = fork( );*/</span></span><br><span class="line">   <span class="keyword">switch</span>(pid)                                          <span class="comment">/*进行pid判断*/</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         i = <span class="number">3</span>;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">         &#123;</span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//_exit(0);                                        /*注意此处应该如何对子进程进行操作*/</span></span><br><span class="line">         <span class="comment">//return;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         i = <span class="number">5</span>;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">         &#123;</span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"a = %d,b = %d\n"</span>,a,b);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在注释掉case 0结束时的两句话时,结果是这样<br><img src="http://img.blog.csdn.net/20170727111134782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>在使用return,结果也这样(顺便可以了解,函数结束时若不作处理,默认是return,返回)<br><img src="http://img.blog.csdn.net/20170727111218674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><strong>这就要讲到,return与exit机制的区别了</strong></p><p><strong>return是关键字,而exit是函数</strong></p><p><strong>return是函数结尾,用于返回值使用.exit是函数中,用于结束进程使用</strong></p><p><strong>尤其是在vfork( )函数中,因为父子进程共享空间</strong></p><p><strong>那么,如果使用return,在子进程结束时,会弹栈,破坏公共的堆栈段,等父进程结束时,就会出现错误</strong></p><p><strong>可能会返回诡异的栈值,才会出现奇怪的结果,如图一</strong></p><p><strong>而使用exit就不会出现这样的结果,exit函数进行进程的结束,并不会破坏公共堆栈段</strong></p><p><strong>这就是为什么要使用exit/exec函数族的原因了.</strong></p><p>另外,我们再来谈谈exit这个函数</p><p><strong>这是个神奇的函数,exit为libc函数,_exit为系统调用Systemcall,exit函数,是封装_exit系统调用而来的</strong></p><p><strong>而这两个最大的区别就是,exit会清理I/O输出,即会将所有缓冲区的内容输出,或者写入文件</strong></p><p><strong>在main函数中exit(0) ~~ return 0</strong></p><hr><p>上面的内容即为创建进程的主要内容了,</p><p><strong>在这里我想要分享的是,fork( )函数,vfork( )函数其重要作用都是为了新建子进程后调用exec族函数</strong></p><p><strong>执行其他程序的,我们这里是为了了解函数特性才这么做的</strong></p><p><strong>虽然vfork( )也是比较好用的,但是现行标准是不建议使用vfork( )的</strong></p><p><strong>因为vfork( )共享数据段,堆栈段.操作十分干危险,而且在子进程中影响父进程,在实际开发中是十分危险的</strong></p><p><strong>如果,vfork( )之后不是立刻进行exec调用,就要十分小心,谨慎判断</strong></p><p><strong>但是现在,fork(　）实现了优化，实现了写时拷贝，则使得fork( )之后exec的代价十分小了</strong></p><p><strong>所以,现在的建议还是,使用fork( )为好</strong></p><hr><p><strong>2.创建守护进程</strong></p><p>何为守护进程?简单点讲,就是后台进程,不会因为终端键入的信息而响应,也不会将错误信息发送到屏幕上,</p><p>此处,我们对守护进程并不深入展开,仅进行守护进程的创建步骤解析:</p><p>1.fork( )创建新进程,并结束父进程,交由init接管</p><p>2.setsid( )创建新会话,并使该子进程成为会话组长</p><p>3.再次fork( ),创建新的子进程,并且结束父进程</p><p>4.关闭不必要的文件描述符,</p><p>5.设置掩码为0</p><p>6.处理信号</p><p>通过以上的步骤即可建立一个后台守护进程.</p><p>结果如图:<br><img src="http://img.blog.csdn.net/20170727111155217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>可以看到,没有反应,表面上,然后可以发现后台有一个进程在执行</p><hr><p><strong>3.进程的退出</strong></p><p>进程的退出,Linux系统中表示进程的结束,退出的方法分为正常退出和异常退出,主要有以下的方法:</p><p>(1)正常退出:</p><p>return 进行返回(main中结束进程)</p><p>调用exit,_exit,_Exit函数</p><p>最后一个线程从启动例程返回</p><p>最后一个线程调用pthrad_exit</p><p>(2)异常退出:</p><p>调用abort函数</p><p>接受到信号并终止</p><p>最后一个线程对取消请求响应</p><p>其中重点注意return,exit的区别,exit,_exit的特色,以上已经讲过,在此不表</p><hr><p><strong>4.执行新程序</strong></p><p>上面提到过fork( ),vfork(　)，实际的重要作用,是创建一个新进程后,立刻进行新程序的调用</p><p><strong>而提到新程序的执行,不得不提到的便是exec族函数</strong></p><p><strong>通过exec族函数的调用,可以用新的程序来替代当前的进程映像</strong></p><p><strong>注意:调用exec族函数并没有新生成进程,调用的同时,原进程”死亡”,其代码段被替换</strong></p><p><strong>为其分配新的数据段和堆栈段,惟一相同的就只有PID了,可以说还是同一个进程,但进行的已经是其他程序了</strong></p><p>因为exec族函数要调用环境变量,先来了解一下环境变量</p><p><strong>通俗点讲,环境变量path,就是在使用程序时,没有告诉其完整路径,系统除了在本目录下寻找以外</strong></p><p><strong>还应该去到指定的path路径下去寻找</strong></p><p>使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**显示环境变量有两种方式,看代码**</span><br><span class="line"></span><br><span class="line">**第一种,使用在别处定义的全局变量environ**</span><br><span class="line"></span><br><span class="line">``` cpp</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;                  /*在别处定义的系统变量(预定义)*/</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line"></span><br><span class="line">   for(i = 0;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;argv[%d] is %s\n&quot;,i,argv[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for(i = 0;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;%s\n&quot;,environ[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第二种,使用main函数的完整形式,并打印其值envp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv,<span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"argv[%d] is %s\n"</span>,i,argv[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,envp[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面的两种方法都可以获取到环境变量的值.<br><img src="http://img.blog.csdn.net/20170727111656922?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>exec族函数中,execve为惟一的系统调用,其他的函数都会调用此系统调用</p><p><img src="http://img.blog.csdn.net/20170727111433999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><img src="http://img.blog.csdn.net/20170727111445309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><strong>exec族函数的详细用法,查看man手册</strong></p><p>来看一段exec演示代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用的新程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"HaHa I'm the program to replace the process!\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"My pid is %d,my parent pid is %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv,<span class="keyword">char</span> **envi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> pid;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Exec start!\n"</span>);</span><br><span class="line">   pid = fork( );</span><br><span class="line">   <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"I am child process !\n"</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"my pid is %d,my parent pid is %d\n"</span>,getpid( ),getppid( ));</span><br><span class="line">      execve(<span class="string">"program"</span>,argv,envi);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This sentence won't be print!\n"</span>);</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"This is parent process!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会发现,调用exec族函数后,进程的PID是不会改变的,<br><img src="http://img.blog.csdn.net/20170727111555352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>其中还有许多项目是保留的:</p><p>1.当前工作目录</p><p>2.根目录</p><p>3.使用的屏蔽字</p><p>4.控制终端</p><p>5.文件锁</p><hr><p><strong>5.等待进程结束</strong></p><p>前面提到过,父进程需要等待子进程的结束,可以避免僵尸进程</p><p>那么,如何等待进程的结束,调用wait,waitpid函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc)</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure><p><strong>wait函数会返回等待进程的PID,如果statloc指向不为空,会将退出码储存在statloc指向的变量中</strong></p><p><strong>在这里需要注意的是,退出码是一个字段,并非是单个数字,可以用宏去取出退出码中的信息</strong></p><p>举个例子:</p><p><strong>WIFEXITED(&amp;statloc)</strong>即可取出其中的信息</p><p>关于wait函数的宏,详情请查找man手册,</p><p>现在介绍waitpid函数,其中pid表示目标子进程的PID,statloc意义相同,options是可以添加的选项</p><p><strong>可以看出,waitpid函数yuwait的一个重要区别就是,wait只等待第一个结束的子进程</strong></p><p><strong>而waitpid函数,可以等待指定的子进程结束,而且waitpid提供了wait的非阻塞版本</strong></p><p><strong>即,在调用了waitpid后,使父进程不被挂起,而立刻返回,提供了WNOHANG这样的一个选项</strong></p><p>下面是一个演示的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> status;                              <span class="comment">/*用来记录wait返回值*/</span></span><br><span class="line">   <span class="keyword">int</span> pid;                                 <span class="comment">/*记录fork的返回值*/</span></span><br><span class="line">   <span class="keyword">int</span> exit_code,k;                           <span class="comment">/*设置退出码,用于获取结束信息*/</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"fork start!\n"</span>);</span><br><span class="line">   pid = fork( );                      <span class="comment">/*新进程已经建立,父子进程并行,或者说是操作系统对进程的快速切换*/</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">switch</span>(pid)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         k = <span class="number">4</span>;                             <span class="comment">/*之后子进程循环操作,使父进程阻塞的依据*/</span></span><br><span class="line">         exit_code = <span class="number">45</span>;                    <span class="comment">/*子进程设置退出码,之后可以在父进程中获取*/</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         exit_code = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pid [^]!= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">int</span> status;                          <span class="comment">/*此即为wait函数中的statloc变量,用于获取退出码*/</span></span><br><span class="line">      <span class="keyword">pid_t</span>  child_pid;                   <span class="comment">/*wait函数的返回值,用于取得结束的子进程的pid*/</span></span><br><span class="line"></span><br><span class="line">      child_pid = wait(&amp;status);           <span class="comment">/*获取到退出码(退出码中储存着退出时的信息,是一个字段,可用宏取出其中信息)以及结束的子进程的pid*/</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Child process has exited!It's pid is %d\n"</span>,child_pid);</span><br><span class="line">      <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Child process has exited,It's exit_code is %d\n"</span>,WEXITSTATUS(status));   <span class="comment">//WEXITSTTUS宏用来获取exit函数低8位</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Child process exit abnormally\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(k--)</span><br><span class="line">   &#123;</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Child process is running!\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">exit</span>(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br><img src="http://img.blog.csdn.net/20170727111339029?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>可以看到父进程处于阻塞状态,即在等待子进程的结束</p><hr><p>以上即为基本的进程操作,如果代码有问题,可以到我的Github上来进行查看</p><p>++<a href="https://github.com/Evil-crow/Linux_C/tree/master/Chapter_VII" target="_blank" rel="noopener">传送门</a>++</p><p>下次会谈谈进程控制中的其他操作,诸如改变进程的优先级,用户的权限操作之类的,</p><p>如果本篇Blog有问题,可以在评论区中提出</p><p>July 27, 2017 11:00 AM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux_C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第四篇 安装系统与多重引导</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E5%9B%9B%E7%AF%87%20%20%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%A4%9A%E9%87%8D%E5%BC%95%E5%AF%BC/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E5%9B%9B%E7%AF%87%20%20%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%A4%9A%E9%87%8D%E5%BC%95%E5%AF%BC/</url>
      <content type="html"><![CDATA[<p><em>本章内容区别与之前的装机，之前的一篇之我自己没有任何学习经验的情况下，</em></p><p><em>误打误撞进行装机的经验，此篇是比较系统正式的学习了之后的知识总结。</em></p><ul><li><p>第一步：由BIOS调整开机选项</p><p>  通过上一章的学习，认识到BIOS在开机时的重要性，即对电脑开机时的一些配置选项</p><p>  那么我们调整开机选项就与BIOS密切相关了。</p><p>  通过网上查询，找到自己型号电脑开机时进入BIOS的快捷键</p><p>  开机时，迅速进入BIOS设置界面，</p><p>  之后，做到以下几点</p><p>  1.关闭快速启动 Source Boot</p><p>  2.改为Legacy only</p><p>  重新开机，使用光盘，或可启动U盘进入安装。</p></li><li><p>第二步： 在安装时选择合适的选项</p><p>  <strong>安装时的选项，语系，时区，Root账户，用户账户</strong></p><p>  切记：<strong>以上内容需进行谨慎设置</strong></p></li><li><p>第三步：进行磁盘分区</p><p>  如何进行分区，已经在上一章详述。</p><p>  接下来介绍几种常用的文件系统类型：</p><p>  在Win中基本都是FAT32，NTFS跑不掉</p><p>  在Linux中则是ext2/ext3/ext4 日志文件系统</p><p>  swap 内存交换空间，<strong>swap空间并不会使用到目录的挂载</strong></p><p>  biosbrug 针对BIOS的挂载</p><p>  vfat 兼容的文件系统</p><p>  LVM 弹性调整文件系统的机制，</p><p>  以上内容，我目前能懂得也不多，只能算是了解而已。</p><blockquote><p>针对swap分区：</p></blockquote><blockquote><p>swap分区是用来存储物理内存中不常访问的数据的，可以理解为扩展内存</p></blockquote><blockquote><p>Linux说明中，有建议swap是物理内存的1-1.5倍</p></blockquote><blockquote><p>但是，这也只能算是以前的标准了，按现在来讲，其实都用不了，只要4G以上内存</p></blockquote></li></ul><p>最后的一些建议：</p><p>强烈建议设置两个用户，普通用户作平时用，Root用户权限过大，可能会出错的。</p><p>如果小白的水平不够，不建议自行进行grub2引导程序的安装，我当时就是这样把舍友电脑玩坏的，捂脸</p><p>安装顺序：Win-&gt;Linux</p><p>如果安装顺序反了不行吗？也可以使用grub2引导程序进行修正。</p><p>还有具体的安装问题可以继续戳我。</p><p>June 3, 2017 4:03 AM</p><p><strong>———————————————–</strong></p><p>Update: November 30, 2017 10:48 PM</p><h3 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h3><h5 id="系统引导概述"><a href="#系统引导概述" class="headerlink" title="系统引导概述"></a>系统引导概述</h5><ol><li><p>计算机加载BIOS,最接近硬件的软件,同时对计算机进行自检,”加电自检” (Power On Self Test)</p></li><li><p>BIOS读取MBR的内容,或者GPT中的内容进行系统启动引导,一段引导程序及分区信息,对于Grub,详述</p></li><li><p>运行Grub,同时开始计算机的第一个进程 /sbin/init 进行初始化</p></li><li><p>系统根据/etc/inittab中的设置,进行初始化配置,</p><p>进行一系列的设置,比如系统变量,网络配置,并启动swap,设置/proc,加载用户自定义模块,加载内核设置</p></li><li><p>根据/etc/inittab中的runlevel启动对应的服务,运行指定rc?.d/下的脚本来启动服务</p></li><li><p>运行,/etc/rc.local</p></li><li><p>生成终端以及X Window来等待用户登录</p></li></ol><h5 id="Grub-Runlevel-比较容易理解-在此不详述了"><a href="#Grub-Runlevel-比较容易理解-在此不详述了" class="headerlink" title="Grub,Runlevel 比较容易理解,在此不详述了"></a>Grub,Runlevel 比较容易理解,在此不详述了</h5>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 装机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第十篇 磁盘与文件系统管理</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E5%8D%81%E7%AF%87%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E5%8D%81%E7%AF%87%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p><em>距离上一篇blog也有几天的时间了,一是偷懒了,二是这一篇的内容确实挺麻烦的..</em></p><p><strong>那么,这一章的主要内容是什么呢?正如标题所言,磁盘与文件管理系统的内容,下面就听我一一道来吧</strong></p><h5 id="一-相关的硬件知识"><a href="#一-相关的硬件知识" class="headerlink" title="一.相关的硬件知识"></a>一.相关的硬件知识</h5><table><thead><tr><th>磁盘的组成</th><th>作用</th></tr></thead><tbody><tr><td>磁盘盘面</td><td>记录数据的地方</td></tr><tr><td>机械手臂与磁盘头</td><td>用来读写磁盘内容的工具</td></tr><tr><td>主轴马达</td><td>使机械手臂转动</td></tr></tbody></table><p>既然盘面是其中最主要的部分,那就来谈谈盘面吧!</p><p><strong>盘面 = 扇区 + 磁柱(由扇区组成一个圆)</strong></p><p><strong>其中,第一个扇区最后重要:boot file (446 Bytes) + 分区表 (64 Bytes)</strong></p><p><strong>关于SATA与IDE接口的磁盘:SATA为/dev/sd*   IDE为/dev/hd*</strong></p><p>注:分区表为64bytes 所以,只能写入4组分区信息(主分区 + 扩展分区[逻辑分区] &lt;= 4)</p><p>磁盘 = 硬盘 + 软盘</p><hr><h5 id="二-文件系统-filesystem-的知识"><a href="#二-文件系统-filesystem-的知识" class="headerlink" title="二,文件系统(filesystem)的知识"></a>二,文件系统(filesystem)的知识</h5><p>为什么会有文件系统这一说,不是所有的都是在硬盘上的吗?</p><p><strong>最早,因为硬件及技术的原因,并不能使多个文件系统在一块硬盘上共存</strong></p><p><strong>但是,随着技术的发展,LVM以及磁盘矩阵等一些新技术的发展,使得同一块磁盘系统,可以有多种文件系统</strong></p><p><strong>,意即,可以对同一块磁盘进行分区,使其上不同的分区有着不同的文件系统</strong></p><p>谈及文件系统,自然就要说说文件系统上到底保存了哪些数据?</p><table><thead><tr><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td>SuperBlock</td><td>用来记录文件系统的整体信息,block/inode的管理信息</td></tr><tr><td>inode</td><td>记录文件的属性和权限,其中存储着对应的Block号码</td></tr><tr><td>Block</td><td>记录文件的实际数据,文件数据过大时,会占用多个Block</td></tr></tbody></table><p><strong>文件系统中,使用以上的数据进行构建的便是”索引式文件系统”</strong></p><p><strong>整体思路是,inode存储文件权限和属性意即对应的Block号码</strong></p><p><strong>而实际的文件数据存储在Block中,通过inode进行Block的索引查找</strong></p><p><strong>不同于,索引式文件系统,闪存盘里所使用的FAT文件格式(包括Win平台)则没有inode的设定</strong></p><p><strong>仅使用Block进行文件数据的存储,同时Block记录着下一个Block的号码</strong></p><p>相比之下,<strong>索引式文件系统的工作效率和可维护性更高</strong></p><p>原因在于:</p><blockquote><p>索引式文件系统,block的号码都存在inode,可以一次性的把文件的Block号码全部获取,进而访问,快,高效</p></blockquote><blockquote><p>相对的,FAT文件格式的文件系统,效率低,一次只能读取一个Block,</p></blockquote><p>注:<strong>关于磁盘整理的问题,FAT中,因为不断进行数据的读写,擦除,会使得同一个文件的Block零散化,</strong></p><p><strong>最终的访问效率,不忍直视,所以有磁盘碎片整理的文件功能,但是,对于索引式文件系统,这个问题就不是很明显</strong></p><p><strong>一般情况下,不需要对inode进行整理,除了特别的例外情况以外,Block号码过于复杂,也是需要进行整理的</strong></p><p><strong>一般情况下,索引式文件系统是不需要进行磁盘碎片整理的</strong></p><p>既然我们学习,使用Linux,那就重点看一看linux下的文件系统把!</p><p>Linux下最早使用的便是Ext2文件系统(<strong>现在最新的已经是Ext4了!</strong>)</p><p>而Ext2文件系统就是基于,索引式文件系统所建立的.</p><p>接下来,详解Ext2文件系统:</p><p><strong>注:因为特别大的文件磁盘里,inode与block是要进行分区的,不然会混乱的</strong></p><p>所以,在Ext2文件系统里,划分出了多个blockgroup供用户使用</p><p>每个blockgroup中所包含的内容有:</p><p><strong>SuperBlock + Inode table + Datablock + Block bitmap + Inode bitmap + filesystem description</strong></p><hr><h5 id="Data-Block-数据块-实际存储数据的地方"><a href="#Data-Block-数据块-实际存储数据的地方" class="headerlink" title="Data Block:数据块,实际存储数据的地方"></a>Data Block:数据块,实际存储数据的地方</h5><p><strong>每个Block都存在编号,而且,每个Block的大小在文件系统建立时就已经确定 1K,2K,4K</strong></p><table><thead><tr><th>条目</th><th>Block的限制</th></tr></thead><tbody><tr><td>1.</td><td>原则上,Block的大小和数目在文件系统建立后便不能再发生变动</td></tr><tr><td>2.</td><td>一个Block中只能存储一个文件</td></tr><tr><td>3.</td><td>接第二条,当存储不下时,会多分配Block</td></tr><tr><td>4.</td><td>接第三条,当存储空间有剩余时,保留空间,不能存储其他文件</td></tr></tbody></table><p>因为以上限制,所以,在进行block得分配时,需谨慎选择</p><p>大:造成存储空间的浪费</p><p>小:会造成过多的inode号码,降低读写效率</p><hr><h5 id="Inode-Table-inode-记录区域"><a href="#Inode-Table-inode-记录区域" class="headerlink" title="Inode Table:inode 记录区域"></a>Inode Table:inode 记录区域</h5><p>inode中存储的是文件的权限和属性,</p><p>Inode Table中存储的内容:</p><p><strong>权限 + 属性 + 容量 + ctime + atime + mtime + SetUID + 真正的Block指向</strong></p><table><thead><tr><th>条目</th><th>inode的限制</th></tr></thead><tbody><tr><td>1.</td><td>每个inode站固定大小128bytes</td></tr><tr><td>2.</td><td>每个文件会占用一个inode</td></tr><tr><td>3.</td><td>filsystem能建立的文件数与inode有关</td></tr><tr><td>4.</td><td>读取时,先找到,inode,权限符合后,才能进行Block号码的读取</td></tr></tbody></table><p>因为 inode仅仅128bytes,并不能存储过多的Block号码,但有的时候又需要特别多的Block号码进行存储</p><p>怎么办呢?大佬们,已经解决这个问题了</p><p><strong>12 + 1 + 1 + 1,12直接,1间接,1二重间接,1三重间接进行inode号码的存储,即进行多次间接指向</strong></p><hr><h5 id="SuperBlock-用于存储文件系统的相关信息"><a href="#SuperBlock-用于存储文件系统的相关信息" class="headerlink" title="SuperBlock:用于存储文件系统的相关信息"></a>SuperBlock:用于存储文件系统的相关信息</h5><p>上面提到的inode,以及Block的内容,的相关信息,都是存储在SuperBlock当中的</p><p>SuperBlock中存储的相关信息:</p><p><strong>Block,inode的相关用量 + filesystem的挂载,最近一次写入文件的时间,valid bit的数值</strong></p><p>SuperBlock中一般为1KB的信息</p><p><strong>在一个文件系统中,一般第一个blockgruop中为整个filesystem中的superblock信息,而其他的blockgroup中的superblock信息都是其备份</strong></p><hr><h5 id="Filesystem-Description-文件系统的描述说明"><a href="#Filesystem-Description-文件系统的描述说明" class="headerlink" title="Filesystem Description :文件系统的描述说明"></a>Filesystem Description :文件系统的描述说明</h5><p>用于查看每个blockgroup,从开始到结束的号码,以及blockgroup中每个区段分别介于的号码</p><h5 id="Block-Inode-bitmap-区块-索引节点-Block-Inode-对照表"><a href="#Block-Inode-bitmap-区块-索引节点-Block-Inode-对照表" class="headerlink" title="Block/Inode bitmap:区块/索引节点(Block/Inode]对照表"></a>Block/Inode bitmap:区块/索引节点(Block/Inode]对照表</h5><p>用来保存哪些Block(inode)非空,哪些为空的标记信息,在进行文件的读写时十分有用!</p><hr><h4 id="三-文件系统与目录树的关联"><a href="#三-文件系统与目录树的关联" class="headerlink" title="三,文件系统与目录树的关联"></a>三,文件系统与目录树的关联</h4><p>上面的便是文件系统(filesystem)的基本内容,那么这个东西如何与目录树有关联的呢?</p><p><strong>一个目录,实际上也是一个文件,其中filesystem会给目录分配一个inode及一个(多个)block</strong></p><p><strong>目录中所记录的是,文件名及其对应的inode号码</strong></p><p>藉此进行文件的访问,也正式因为Ext系列文件系统的索引式结构,所以,才能有接下来软,硬连接两种方式</p><hr><p>此处,进行ls,知识的拓宽:(毕竟要自己实现一个ls)</p><ol><li><p>ls -i 用于显示inode号码的命令</p></li><li><p>ll后面的一行信息中数字4096,之类的表示目录的容量,连接数的含义:有多少个文件连接到这个inode号码上</p></li></ol><p><strong>我来解释一下,为什么时4096这些数字,这与block的大小有关,都是默认大小4K的整倍数!</strong></p><p><strong>问题又来了,为什么有的就不是4K的整倍数,因为,有的问就不是同一文件系统!使用<code>dumpe2fs</code>查看</strong></p><p>例如/proc,swap,更甚,这些只是虚拟内存中东西,并不占实际的内存空间</p><p><strong>之前说过Ext2/3/4 的filesystem基本不需要进行磁盘碎片整理,但如果非要整理该怎么办呢?</strong></p><p><strong>正解:将所有文件拷贝出来,之后重新格式化磁盘,最后将文件重新写入!</strong></p><hr><p>继续上面的内容,</p><p>在文件系统中,进行文件的存取时的步骤:</p><ul><li><p>用户对该目录是否具有w,x权限,目录的inode</p></li><li><p>inode bitmap,找到为使用的inode,写入为文件的权限和属性</p></li><li><p>block bitmap 找到未使用的block,写入数据,并更新inode中的,block指向</p></li><li><p>block bitmap,inode bitmap.superblock的数据更新</p></li></ul><hr><h4 id="四-日志式文件系统的出现"><a href="#四-日志式文件系统的出现" class="headerlink" title="四,日志式文件系统的出现"></a>四,日志式文件系统的出现</h4><p>众所周知,在使用电脑时,难免会出现一些意外情况,断电,死机,那么数据怎么办?</p><p>肯定是开机后进行修复排查,但是,太过耗时,耗力,很费时间.</p><p>所以,前辈们便开发出了,<strong>Ext3日志式文件系统</strong></p><p><strong>其实现原理是,在filesystem在重新划出一个区块来,用来记录写入/修改的信息</strong></p><p><strong>万一出现意外情况,那么,只检查journal中的记录日志,便可以迅速找出目标区块,大大提高了效率</strong></p><p><strong>另外,可以通过异步处理sync,来解决这个问题.</strong></p><p><strong>实际上,异步处理就是系统不定时的把编辑过的文件写入磁盘中,可以用sync强制写入</strong></p><hr><h4 id="五-关于Linux文件系统中的连接问题-软-硬连接"><a href="#五-关于Linux文件系统中的连接问题-软-硬连接" class="headerlink" title="五,关于Linux文件系统中的连接问题(软/硬连接)"></a>五,关于Linux文件系统中的连接问题(软/硬连接)</h4><h5 id="1-硬连接-Hard-Link"><a href="#1-硬连接-Hard-Link" class="headerlink" title="1.硬连接(Hard-Link)"></a>1.硬连接(Hard-Link)</h5><p>硬连接,需要与之前见到过的快捷方式(软连接有所区别)</p><p>硬连接(Hard Linuk):</p><p>在Ext4 filesystem中,这一类的索引式文件系统中,inode与block的关系正如上文所讲</p><p>即,查找,访问一个文件,关键的是,先找到文件inode,便可以访问到文件</p><p>所以,就有了这样的一种连接:硬连接</p><p><strong>在目录信息中(block)所写入一条数据/关联数据,用来连接到目标文件的inode上</strong></p><p><strong>这样下来,创建的硬连接,实际上便是源文件的别名,而文件的inode上便连接到了两个文件名与其关联</strong></p><p><strong>所以,ll之后,文件的连接数都会加’1’,这两个文件名,是除了文件名(路径)之后,属性完全相同的数据</strong></p><p>而且,因为硬连接,只是在其中block中,多写入了数据,并未分配inode,所以不能算是新建文件</p><p>如下图</p><p><img src="http://img.blog.csdn.net/20170719153607870?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>硬连接的优劣:</p><p><strong>优: 硬连接因为不创建新的文件,所以相比较于软连接,不会占用大量的内存空间,</strong></p><p><strong>同时,硬连接可以理解为给文件起别名,完全一致,所以,误删其中一个文件,不会影响文件的打开情况</strong></p><p><strong>劣</strong></p><p><strong>1.硬连接不能跨文件系统,因为不同的文件系统中inode可能会有重复,胡乱连接,会出错的</strong></p><p><strong>2.硬连接不能连接目录,因为连接目录意味着,还要与目录下的每个文件建立连接,不仅任务量大,而且目录内容的更新,也会影响着硬连接内容的更新</strong></p><h5 id="2-软连接-Symbolic-Link"><a href="#2-软连接-Symbolic-Link" class="headerlink" title="2.软连接(Symbolic-Link)"></a>2.软连接(Symbolic-Link)</h5><p>理解了上面的硬连接,下面软连接就比较好理解了</p><p>访问文件是要去寻找文件的inode号码,而文件保存在目录中,目录的block保存着文件的inode信息</p><p><strong>硬连接是连接文件在目录block中储存的inode号码</strong></p><p><strong>而软连接,则是去连接文件名的inode,并非是与文件名对应的,储存实际数据的inode号码</strong></p><p><strong>可以理解为,直接连接与间接连接</strong></p><p>如下图:</p><p><img src="http://img.blog.csdn.net/20170719153624176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>软连接的优劣:</p><p><strong>优:跨目录,跨文件系统,能力十分强大</strong></p><p><strong>劣:在删除源文件后,便不能访问文件,基本上可以近似理解软连接为Win下的”快捷方式”</strong></p><p><img src="http://img.blog.csdn.net/20170719153638233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>而且,注意:软连接,实际上是分配了inode与block,十一个新建的文件</p><hr><h4 id="六-关于磁盘的操作知识"><a href="#六-关于磁盘的操作知识" class="headerlink" title="六,关于磁盘的操作知识"></a>六,关于磁盘的操作知识</h4><p><em>先说说我自己学习这部分的感受,这部分知识,学得快,忘得快,这部分的知识,其实更主要的是命令的操作,</em></p><p><em>是要你能够熟练得运用名命令,便可以很好的处理这些磁盘问题</em></p><p><em>但是,我自己是不喜欢这部分知识的,虽然很重要,但是,枯燥,乏味,而且好多东西用不到</em></p><p><em>比如我自己挂载U盘时,从来都不给我机会,要不自动挂载,要不就,不挂载</em></p><p><em>而且,也听了Hg_Yi的建议,上面中重要的知识,需要进行详细的记录,但是这些命令的操作,仅提供思路,功能</em></p><p><em>实际上去man或者info命令,比我自己记录要来的更好</em></p><p><strong>磁盘分区:fdisk,root权限,fdisk更像是一个程序,根据其中的help要求操作即可</strong></p><p><strong>磁盘格式化:mkfs 即可设置文件系统,然后格式化对应的磁盘 , mke2fs提供更详细的设置</strong></p><p><strong>磁盘检验:fsck 当文件系统遭遇一些可怕的情况时(停电,死机)时,用此命令进行检验修复</strong></p><p><strong>磁盘的挂载与卸载:完全靠mount这个强大的命令,其详细使用方法,man mount</strong></p><p><strong>磁盘参数的修改:mknod,修改磁盘的对应参数,使其成为指定的设备文件</strong></p><p><strong>开机挂载:便是将挂载信息,写入指定文件中 /etc/fstab 与 /etc/mtab</strong></p><p><strong>特殊的loop挂载:..</strong></p><p><strong>Swap分区的构建:其中包括了DD建立大文件 + loop挂载两部分内容</strong></p><hr><h4 id="七-文件系统中得一些小问题"><a href="#七-文件系统中得一些小问题" class="headerlink" title="七,文件系统中得一些小问题"></a>七,文件系统中得一些小问题</h4><h5 id="1-boot-sector-与-super-block的关系"><a href="#1-boot-sector-与-super-block的关系" class="headerlink" title="1.boot sector 与 super block的关系"></a>1.boot sector 与 super block的关系</h5><p>这个要涉及block的大小</p><p><strong>若为1K则,boot扇区在前,superblock在后,各占1K空间</strong></p><p><strong>若为2K或者4K,则boot扇区内容占了0-1024号内容,superblock占了第二部分的内容</strong></p><p><strong>之后,这个block的内容保留,不再存储其他文件数据</strong></p><h5 id="2-磁盘空间的查看"><a href="#2-磁盘空间的查看" class="headerlink" title="2.磁盘空间的查看"></a>2.磁盘空间的查看</h5><p>du -s 与 du -S不同</p><p>-s会记录子文件夹,所以,最后空间并不会十分准确</p><h5 id="3-parted进行分区"><a href="#3-parted进行分区" class="headerlink" title="3.parted进行分区"></a>3.parted进行分区</h5><p>当单磁盘的空间达到2TB时,不适合继续用fdisk进行后续的处理,应该使用parted进行处理</p><hr><p>本篇的内容,到此告一段落,最近理完了系统操作中最复杂的磁盘与文件系统,就需要进行Linux_C的学习了</p><p>下次会进行Linux中,十分有用的打包与压缩命令的学习</p><p><strong>另外 @Hg_Yi,写Blog抓住重点很有用,但是在进行系统的学习时,我还是继续详尽的进行记录</strong></p><p><strong>等到之后的编程学习时,便可以有效的进行总结</strong></p><p>July 19, 2017 3:32 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> File system </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第十一篇 文件的打包压缩与备份</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<p><em>最近的重心都放在了Linux_C编程上,也没时间仔细研读&lt;鸟哥的Linux私房菜&gt;</em></p><p><em>今天先来总结一下关于文件打包与压缩吧</em></p><hr><p>提起文件的打包与压缩,想必大家都会提起的一个软件就是<strong>WinRAR</strong></p><p>从接触电脑开始,很经典的一个打包压缩软件,之后还出现了诸如<strong>7Z,2345好压</strong>等一系列的压缩软件</p><p>那么,在Linux/UNIX平台上,又是如何处理压缩文件的问题呢?</p><hr><h5 id="一-关于压缩"><a href="#一-关于压缩" class="headerlink" title="一,关于压缩"></a>一,关于压缩</h5><p>既然要说打包压缩,那么,首先应该知道为什么需要进行<strong>文件压缩</strong>?</p><p>现在的计算机硬件发展日新月异,TB已经成为计算机硬盘容量的标配了,</p><p>你可能会说:怎么会需要压缩呢?<strong>直接放原始文件不就行了?</strong></p><p><strong>表面上看来,的确是这样.但是,打包压缩在现在的计算机技术应用中还有很重要的作用,一一道来</strong></p><p>之所以会使用压缩,是因为历史原因,在当年计算机硬件技术落后,</p><p><strong>磁盘不能很好的起到便携大文件的作用,所以衍生出压缩技术</strong></p><p>来看看压缩技术的实质:</p><blockquote><p>实际上,在我们的计算机中,一个文件所占的空间并不是它是实际的大小,即使在看上去装满了的文件</p></blockquote><blockquote><p>它其中还是有很大一部分得空闲空间的,而压缩技术,就是要把这部分空间挖出来而应运而生的</p></blockquote><p>压缩技术,主要分这么两类:</p><ol><li><p>将一个字节中未使用的内容,压缩出来,比如,一个字节记录了数字1,那么,它其他7位都是补0,而压缩技术就是</p><p>要把这些0,给收集起来的,至于收集的算法,在这里不予讨论</p></li><li><p>另一种情况就是将文件中的重复元素记录下来,并进行记录,以使的空间紧凑</p></li></ol><p>至于为什么压缩技术会成功,其中很大一部分原因还是因为有大量的文本文件,而这些文件都是ASCII格式的</p><p><strong>其中就会有更多得空余空间! ! !</strong></p><p>举一个最直观的例子:2.6.x版本的内核原始文件300MB左右,压缩后只有60MB,压缩的效率可见一斑</p><p>说了这么多,那么压缩技术的应用呢?</p><p>++1. 可以使你的硬盘中存储更多的数据 (虽然现在硬盘已经很大了…)++</p><p>++2. <strong>在网络数据传输时,文件越小,传输效率越高,宽带利用率越高</strong> ++</p><hr><h5 id="二-Linux下常见的压缩命令"><a href="#二-Linux下常见的压缩命令" class="headerlink" title="二,Linux下常见的压缩命令"></a>二,Linux下常见的压缩命令</h5><p><em>既然压缩技术这么好用,那么我们就来看看如何使用压缩命令吧</em></p><p>首先来看看,压缩文件常见的扩展名吧!</p><blockquote><p>*.z (表示compress压缩的文件)</p></blockquote><blockquote><p>*.gz (gzip程序压缩出来的文件)</p></blockquote><blockquote><p>*.bz2 (bzip2压缩的文件)</p></blockquote><blockquote><p>*.tar tar打包的文件(并非压缩文件)</p></blockquote><blockquote><p>*tar.gz (tar打包后,使用gzip压缩的文件)</p></blockquote><blockquote><p>*tar.bz2 (tar打包后,使用bzip2压缩的文件)</p></blockquote><p>还是和之前介绍的一样,</p><p><strong>在Linux系统中,文件的扩展名可有可无,但是为了使用方便,加上扩展名以便于区分文件</strong></p><p><del>Compress,此命令已经十分久远,而且其压缩效率也很不堪,此处不予详解</del></p><p>下面来详解,gzip与bzip2两个常用的压缩命令</p><p><strong>1.gzip</strong></p><p>上面提到了,Compress已经不常用了,而gzip便是Compress的替代品</p><p>先来看几个常用的参数</p><blockquote><p>-c 将结束输出到屏幕上,可以之后使用重定向</p></blockquote><blockquote><p>-d 解压缩的参数</p></blockquote><blockquote><p>-t 用来检验文件的一致性</p></blockquote><blockquote><p>-v 显示一些进行压缩时的信息,如压缩比之类的</p></blockquote><blockquote><p>-#,压缩等级有1-9 九级,用速度换压缩效果,数字越大,速度越慢</p></blockquote><p>结合上面命令便是</p><figure class="highlight plain"><figcaption><span>gzip -ctv file```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```解压命令 gzip -d file</span><br></pre></td></tr></table></figure><p>而且,对于gzip压缩产生的文件,*.gz,可以直接使用命令 zcat进行不解压查看文件</p><p><strong>2.bzip2</strong></p><p>如果说上面gzip时为了取代Compress而产生的,那么bzip2就是为了取代gzip而产生的</p><p><strong>重要的一点,bzip2的压缩效率比gzip提高了许多</strong></p><p>bzip2的参数基本上与gzip是相同的,来看一些不同的参数</p><blockquote><p>-k,保留源文件,而不会删除原始的文件</p></blockquote><blockquote><p>-z,压缩的参数</p></blockquote><p>同时,同gzip类似的是<strong>通过bzcat命令,也可以读出bzip2压缩的文件</strong></p><p><strong>重要的第二点,兼容关系 bzip2 &gt; gzip &gt; Compress</strong></p><p><strong>3.tar 打包命令</strong></p><p>可能你会奇怪,为什么我没有用截图来演示压缩命令的用法</p><p>等你看完tar打包命令就知道为什么了,</p><p>++细心一点你可能会发现,上面的三个命令都是对于单文件进行压缩的++</p><p>++实际上他们也可以对多文件压缩,但是,压缩出来的结果,5个源文件压缩成为5个压缩文件++</p><p>++实际上没有实际意义,基本是废掉了++</p><p>++所以,就要使用我们现在最常用的tar打包命令++</p><p>++<strong>何为打包,即为将多个文件进行打包成为一个大文件</strong>++</p><p><strong>而这样也就满足了我们将多个文件进行压缩成为一个大的压缩文件的需求</strong></p><p>来看一看tar的常用参数:</p><blockquote><p>-c 新建打包文件,搭配-V显示过程中被打包的文件名</p></blockquote><blockquote><p>-t 查看打包文件中含有哪些文件</p></blockquote><blockquote><p>-x 解压缩火或者解打包的参数</p></blockquote><blockquote><p>-j 通过bzip2的压缩方式进行处理打包文件</p></blockquote><blockquote><p>-z 通过gzip的压缩方式处理打包文件</p></blockquote><blockquote><p>-v 在压缩的过程中将处理的文件名显示出来</p></blockquote><blockquote><p>-f 表示要处理的文件名</p></blockquote><blockquote><p>-C 表示解压操作要处理的目录</p></blockquote><p>乍看之下,的确是十分复杂,所以我们抽丝剥茧,跳出其中最常用的关键内容:</p><p><strong>以下默认使用bzip2处理,也可以使用gzip</strong></p><p><strong>1.处理压缩命令 tar -jcv -f 目标文件  源文件</strong></p><p><strong>2.处理解压命令 tar -jxv -f 目标文件 -C 想要解压的目录</strong></p><p><strong>3.查看压缩文件 tar -jtv -f 目标文件</strong></p><p>以上即为常用的tar操作,其他的用法自行搜索</p><p><strong>这里要强调一点,即使是在以后使用命令的时候也是十分有用的</strong></p><p><strong>即,在进行-f -C这些选项的使用时,需要十分注意,选项的顺序问题,理论上,选项的顺序与命令的执行是无关的</strong></p><p><strong>但是,选项后跟的参数就很关键了,-jcv -f 与 -jcfv都是可以的,但是,-f后,v也称为了文件名的一部分</strong></p><p><strong>这就会造成很大的问题了,所以,需要谨慎的处理这些问题</strong></p><p>下面简单说说几个tar的有趣操作</p><p>1.打包,但并不包含,</p><p>有的时候,你想要打包整个目录的文件,但是又不想包括其中的一些文件,怎么办呢?</p><p>–exclude=FILE就是一个十分好的办法</p><p>e.g. <figure class="highlight plain"><figcaption><span>-jcv -f filename.tar.bz2</span><a href="/root">--exclude</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.以时间为参数进行文件的区别并打包</span><br><span class="line"></span><br><span class="line">```tar -jcv -f failname.tar.bz2 --newer-mtime=&quot;2008/02/12&quot; 源文件</span><br></pre></td></tr></table></figure></p><p>使用 –newer-mtime 参数对于处理这样的问题十分方便</p><hr><h5 id="三-文件的备份工具"><a href="#三-文件的备份工具" class="headerlink" title="三,文件的备份工具"></a>三,文件的备份工具</h5><p>因为,我对此处没有深入区分析,所以不好对此进行详解,仅提供命令,有兴趣的读者可以去尝试</p><p>1.文件备份工具:dump</p><p>2.恢复备份:restore</p><p>3.新建镜像文件:mkisofs</p><p>4.光盘刻录工具:cdrecord</p><p>5.制作大文件:dd</p><p>6.万能的备份工具:cpio</p><hr><h5 id="Vim的操作与使用"><a href="#Vim的操作与使用" class="headerlink" title="Vim的操作与使用"></a>Vim的操作与使用</h5><p><strong>这一章本来是独立的,但是我不准备进行细讲,因为,Vim讲的话无非就是命令的使用</strong></p><p><strong>在此处推荐三个三个东西</strong></p><p><strong>1.我自己在用的Vim配置文件</strong></p><p><a href="https://github.com/spf13/spf13-vim" target="_blank" rel="noopener">spf13</a>(我觉得是与spaceemacs同级别的怪兽)</p><p><strong>2.小组很多人也在用的配置文件(从网上的足迹来看应该是某位小组的学长写的)</strong></p><p><a href="https://github.com/ma6174/vim" target="_blank" rel="noopener">ma6174/vim</a></p><p><strong>3.推荐一本书吧</strong></p><p><a href="http://www.oreilly.com.cn/index.php?func=book&amp;isbn=978-7-5641-2604-9" target="_blank" rel="noopener">学习vi和vim编辑器</a> O’reilly出品,必属精品</p><p><strong>Vim的学习是一个长久的过程,用的越多,会的越快也越熟练</strong></p><p><strong>所以,平时多多使用Vim吧,Vim会让你沉迷Conding的</strong></p><p>August 3, 2017 10:18 AM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第六篇 Linux的文件权限与目录配置(上)</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E5%85%AD%E7%AF%87%20Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E5%85%AD%E7%AF%87%20Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><em>本篇的内容开始进入Linux系统的本体学习，既然要学习Linux系统，那么了解Linux系统中的文件与目录</em></p><p><em>肯定是首要的任务喽！</em></p><p>说点题外话，之前的五篇笔记都是干巴巴的笔记，我也觉得不好看</p><p>在我更新了系统后，提供了screenshot(即截图)功能，方便了我的笔记记录，从本篇开始</p><p>我在笔记中会加入插图，更方便我的复习与交流。</p><p>注：<strong>Evilcrow</strong>为我的用户名，以后不再注释。</p><hr><ul><li>文件权限</li></ul><p>本章的内容，分为两大模块，<strong>文件权限</strong>和<strong>目录配置</strong></p><p>从之前的章节开始，就一直在强调一个Linux中的重要概念：<strong>一切皆文件！</strong></p><p>而且，听闻过Linux的同学都听说过Linux的安全性，那么，Linux中文件到底有多大的权限?</p><hr><p>首先，来了解一组概念：</p><p><strong>user,group,others</strong></p><p>这是在Linux系统操作时很重要的三个概念，接下来我会一一介绍：</p><p>首先，user,文件总会有文件的所有者，对吗？</p><p>而这个<strong>user就是指文件的所有者。</strong></p><p>在进行开发时，Linux作为多用户，多任务的主机，肯定会拥有多个用户，但是进行开发时，</p><p>用户肯定会进行分组。而且，会有相互竞争的小组。那么，对于不同的小组怎么办呢？</p><p>这个时候，<strong>group所指的是就是用户组</strong></p><p>用户，只是一个独立的个体，进行开发时，多个用户为一组，相互之间，文件是可以进行交流并修改的。</p><p>所以，他们应该作为一个用户组进行管理。</p><p>既然有一个组，那么其他的组，相对于这个组即是其他人</p><p><strong>others所表示的就是其他人的意思</strong></p><p>总结一下：</p><p>在Linux中，使用者分为，<strong>user，group，others</strong>三种。</p><p>三者的关系是：用户属于用户组，其他的使用者，使用组都属于其他人(others)。</p><p><strong>注：在三种使用者身份之外，还存在着一个Boss，即，管理员。</strong></p><p><strong>全称：系统管理员，一般叫root，这个东西是Linux中最无敌的存在，一切的文件都可以被其操作</strong></p><hr><p>在介绍了以后上几个概念后，我们可以开始<strong>文件权限</strong>的学习了</p><p>在Linux中，文件权限决定着文件的归属以及其他人对于此文件所能进行操作的权利属性。</p><p>当你初次接触Linux系统，可能经常会看见这样的情况<br><img src="http://img.blog.csdn.net/20170610141654454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>会出现Permission denied 就是因为权限不够所致，当你在处理自己当前用户权限以外</p><p>的文件时，就会提醒你，权限不够。</p><p>那么，我们如何了解到文件的权限属性呢？</p><p>现在没有正式开始命令的操作和学习，但是此处需要用到一个Linux系统操作的常用命令</p><hr><p><strong>ls 命令</strong></p><p>此命令是一个极其重要的命令，全称为list，即列表，列出目录中的文件</p><p>ls命令也具有许多的选项和参数，以下介绍其中较为常用的</p><blockquote><p>ls命令单独使用只会列出其中的文件，不包括隐藏文件</p></blockquote><blockquote><p>ls -a 使用此选项可以列出所有文件，<strong>其中以.开头的是隐藏文件</strong></p></blockquote><blockquote><p>ls -l 将所有的文件以列表的形式列出，<strong>并且将所有的文件属性也列出来。</strong></p></blockquote><p>注，-l，-a只是其中最常用的两个命令，而且这两个选项可以组合使用</p><p>以下为演示：<br><img src="http://img.blog.csdn.net/20170610141712893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>上图展示了ls,ls -a,ls -l三个命令<br><img src="http://img.blog.csdn.net/20170610141727252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>上图为ls -al命令</p><p>好，目前ls命令了解这么多已经足够了，<strong>详情，请戳man或者info。</strong></p><hr><p>通过ls 命令的 -l选项可以列出文件所有的属性，十分方便我们进行文件权限属性的学习</p><p>那么，接下来一起来看看一个文件究竟有多少的属性：</p><p>我新建一个文件夹test，其中包含了文件file </p><p>其中会使用到的cd,touch,mkdir rm rmdir 命令在下一章，我会进行详解。</p><p>上图：<br><img src="http://img.blog.csdn.net/20170610141740518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>因为使用了ls -al命令，所以连隐藏文件也显示出来，这其中，.表示当前目录，..表示上级目录</p><p>现在你可能不是很理解，但是以后你会了解到这两个隐藏文件的方便之处的。</p><p>接下来，来仔细看看文件(目录)的属性吧！</p><blockquote><ol><li>文件(目录)的权限属性，共有10个字符，其中<br>第1个字符表示文件类型，后面每三个字符一组，表示user,group,others各自的r,w,x属性。</li><li>结点数，表示与此文件(目录)有所联系的节点数目。此概念之后会详解。</li><li>user，表示文件所属用户，一般情况下，文件所属用户同文件建立者</li><li>group，表示文件所属用户组</li><li>大小，<strong>注意：此处表示的是，文件为内容大小，目录为其容量大小，以B给出。</strong></li><li>时间，文件创建的时间或最近的修改时间，可以通过ls –full-time完全显示其详细时间。</li><li>文件名，或者目录名</li></ol></blockquote><p>以上，即为一个文件或者目录，所能具有的属性，尤其注意其前十个权限属性十分重要！</p><hr><p>文件权限</p><p>举个栗子：-rwxr-xr-x  root root  ……………(信息省略)</p><p>对于此文件，属于root用户，root用户组。</p><p>Evilcrow作为others，对于此文件，仅仅具有r,x权限，并不能进行修改的权限</p><p>每次分析文件的权限时，仔细分清，用户，用户组，其他人的概念，并且对r,w,x进行分析即可了解</p><blockquote><p>浅谈，文件权限的重要性</p><ol><li>最重要的，文件权限可以保护文件的安全性，设置得当，你想让谁操作文件，谁才可以操作文件，不想让谁操作文件，甚至文件名都不会被看见</li><li>Linux经常作为主机进行开发，同一个团队的成员，之间进行资料共享，就要完全靠group</li><li>从反面来说，如果你对权限的问题没有足够的重视，那么，你的PC机对于有恶意的人而言<br>就是毫无防线，等着被破坏的，虽然最近“比特币勒索”事件是OS X和Linux升华的一天，但是也不能保证，说不定那一天就会有针对于Linux系统的破坏事件的发生</li></ol></blockquote><p><strong>以上，所以我们掌握好文件权限的内容，十分有必要！</strong></p><hr><p>那么，说了这么多，到底怎么样，才能进行文件的权限操作呢？？？</p><p>首先，要用到之前说到的一个Boss，<strong>管理员账户 root</strong></p><p><strong>强烈建议：从此处开始，往下的内容，以root进行学习！</strong></p><p>root账户，权力很大，承担的责任也很多，希望大家能妥善使用root账户</p><p>建议：<strong>su 进入root账户，使用exit 可退出root，回到一般用户</strong></p><p>之前说过，在Linux系统中，有三种使用者，user，group，others，又各自有r,w,x三种权限</p><p>那么，权限操作就是针对这9中权限的操作</p><p>介绍三种命令，用于权限修改：</p><p><strong>注：必须在root用户下进行这些命令。否则，权限无效</strong></p><blockquote><p>1.chgrp 改变用户组 即（change group)<br>2.chown 改变用户   即（change owner）<br>3.chmod 改变权限   即（change model）</p></blockquote><p>1.chgrp 改变用户组</p><p>重要参数：-R 递归改变权限，即把该目录下的文件，目录的权限全部同步修改，很好用，也很危险！</p><p>语法： chgrp [-R] group dirname/filename  (目录/文件名）</p><p>如上例所示，我先进入root用户，从’$’变为’#’，之后进行chagrp操作，</p><p>改变file的用户组：Evilcrow-&gt;root<br><img src="http://img.blog.csdn.net/20170610141758237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><strong>注意：不管进行用户组，还是用户的权限更改操作时，都必须是目前系统中已经注册的用户和用户组，不然，操作时不能成功的，系统不会自己去进行新用户，新用户组的添加。</strong></p><hr><p>2.chown 改变用户</p><p>重要参数：同上 [-R]，递归更改用户</p><p>语法： chown [-R] owner dirname/filename          改变所属用户</p><p>或者这样 chown [-R] owner:group dirname/filename  改变所属用户，用户组</p><p>或者这样 chown [-R] .group dirname/filename       改变所属用户组<br><img src="http://img.blog.csdn.net/20170610141811097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>如上，我分别进行了，用户，用户和用户组，用户组的权限更改，都是chown命令实现</p><p>文件的原始信息，在第一行。可以对照比较，以认识chown命令的详细用法。</p><p><strong>那么，我们来说说，为什么会有chown，chgrp两个命令的出现</strong></p><p><strong>大家肯定会经常进行文件的复制，移动之类的操作，在Linux中，复制文件后，文件的不变</strong></p><p><strong>即意味着，user，group的信息也不会更新，即你有可能打不开你从从其它地方所拷贝过来的文件!!!</strong></p><p><strong>即使是，从网路上，下载来的文件也不一定能保证其文件权限的属性！</strong></p><hr><p>3.chmod 改变权限</p><p>说完了改变用户，用户组的命令后，来看看怎么进行文件权限的更改，</p><p>重要参数：-R  递归改变权限 同理</p><p>用法 ：<strong>注：chmod 改变文件/目录权限，有数字更改，字符更改两种方式</strong></p><p>1.数字更改方式</p><p>我们都知道，user，group，others都具有r,w,x三种权限属性，便有以下：</p><table><thead><tr><th>属性</th><th>权数</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><p>有了上表，我们就可以据此来写出user，group，others各自的权限权数</p><p>chmod  [-R]  xyz  dirname/filename</p><p>其中xyz，即为所要修改文件的权数，，<br><img src="http://img.blog.csdn.net/20170610141828612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>由上图，并对照权限表，基本可以掌握此类修改文件权限的方法</p><p>2.使用符号进行文件权限的修改</p><p>这里使用符号，用法类似与使用数字进行修改，先看下表：</p><table><thead><tr><th>命令</th><th>用户</th><th>权限处理</th><th>权限</th><th></th></tr></thead><tbody><tr><td></td><td>g</td><td>+(加入)</td><td>r</td><td></td></tr><tr><td>chmod</td><td>o</td><td>-(除去)</td><td>w</td><td>dirname/filename</td></tr><tr><td></td><td>a</td><td>=(设置)</td><td>x</td><td></td></tr><tr><td></td><td>u</td><td></td><td></td><td>`</td></tr></tbody></table><p>使用上表进行chmod的权限更改也是十分方便的。</p><p><img src="http://img.blog.csdn.net/20170610141845362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>使用如上的权限更改方式，说实话，我也不习惯</p><p>但是，不可否认的是，当你不知道原文件所具有的属性时，使用，a，=无疑是最方便的操作</p><p>两种方式，各有其方便之处，希望大家能熟练运用</p><hr><p>那么，接下来，学会了，更改文件/目录的权限后，</p><p>我们来谈谈对于目录，对于文件，权限到底有什么意义？</p><p>首先，记住目录与文件的权限属性，有不少差别！</p><p>文件权限</p><blockquote><p>文件指的实际上是，含有数据的东西，包括文本数据，数据库内容文件，二进制可执行文件</p></blockquote><p>对文件而言，权限实际意义上：</p><blockquote><p>r：可读，意思是指可以读取文件的内容，即能读取文件的数据，eg：vim list<br>w：可写，意思就是可以修改文件的内容，比如你修改文件的内容，：wq保存退出<br>x：可执行，这个是身份重要的概念！！！！！，我在下面专门谈谈</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">大家平时可能使用win的机会更多，我就讲win下与Linux下的区别吧！</span><br><span class="line"></span><br><span class="line">Win：windows中的可执行文件，都有其后缀名，</span><br><span class="line"></span><br><span class="line">比如：可以执行的，.c ，.cpp，.asm，.obj，.exe有的可以直接打开，有的需要对应的程序</span><br><span class="line"></span><br><span class="line">但是，后缀名/扩展名能反映出该文件的属性及类型</span><br><span class="line"></span><br><span class="line">但是，在Linux下：</span><br><span class="line"></span><br><span class="line">切记：</span><br><span class="line"></span><br><span class="line">**文件的属性，可执行与否，与后缀名无关！！！**</span><br><span class="line"></span><br><span class="line">**文件的属性，可执行与否，与后缀名无关！！！**</span><br><span class="line"></span><br><span class="line">**文件的属性，可执行与否，与后缀名无关！！！**</span><br><span class="line"></span><br><span class="line">重要的事要说三遍，换句话说，Linux下，文件没有后缀名/扩展名</span><br><span class="line"></span><br><span class="line">所以，文件的可执行与否，与-x权限属性有着莫大的关系，</span><br><span class="line"></span><br><span class="line">但是，你有会说，为什么有的文件还有有扩展名？？？</span><br><span class="line"></span><br><span class="line">**是这样：虽然没有扩展名这一说，但是，我们建议，加上扩展名方便文件的管理与分类！**</span><br></pre></td></tr></table></figure><p>目录权限</p><p>目录也是Linux文件系统中一个十分重要的概念，我会在下一篇中详解。</p><p>对于目录而言：</p><blockquote><p>r：可读，意思是指可以读出目录中的文件信息<br>w：可写，意思是指可以对目录进行操作<br>指的是可以进行：<br>进入目录<br>新建文件<br>删除文件<br>移动，重命名文件<br>等一系列对于文件的操作<br>x：可执行，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你一定会疑惑，此处的可执行到底是什么意思？？？</span><br><span class="line"></span><br><span class="line">此处的可执行，指的是可以将此目录切换为你的工作目录，cd命令（之后会详解）</span><br><span class="line"></span><br><span class="line">举个例子，只拥有r,可读并不能进入该目录，最多只能浏览目录的信息</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20170610141901473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>此例子，test 目录只有可读权限，对于一般用户，路已经被堵死了，无法进入test目录</p><p>之后，我用root示范，可以进入目录，即证明目录是存在的。</p><p><strong>在此强调一点：如果要给others访问目录数据的权限，至少要给予r,x权限，</strong></p><p><strong>但是，w的权限不能随便交出，切记！！！</strong></p><p>再举一个例子:</p><p>目录test下，用户bin对目录有[-rwx]权限，其中有文件</p><p>-rwx——— 2 root root ………file </p><p>对于此文件，bin用户不可读，不可写</p><p>但是，可以删除该文件，是不是觉得很神奇！</p><p>对，没错</p><p><strong>在Linux下，目录与文件权限并没有必然联系，文件本体的变动与否与目录关系极大！</strong></p><p><strong>相反的，文件本身的属性则更倾向于处理数据内容！</strong></p><p>简单，总结，目录的权限里</p><p>W，与文件的删除，新建有极大关系</p><p>X，则与能否切换进入该目录直接挂钩！</p><hr><p>至此，Linux的文件权限内容告一段落，下一篇介绍Linux下的目录配置</p><p>June 8, 2017 10:09 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> File system </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第八篇 Linux文件与目录管理(上)</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E5%85%AB%E7%AF%87%20%20Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86(%E4%B8%8A)/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E5%85%AB%E7%AF%87%20%20Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86(%E4%B8%8A)/</url>
      <content type="html"><![CDATA[<p><em>最近有几天在忙自己的事,所以没写博客,今天调整好状态,继续开始写吧!</em></p><p><em>经过了上一篇章中对Linux目录与文件配置的洗礼后,这一篇的内容便是对文件与目录的基本操作</em></p><hr><h3 id="1-目录与路径"><a href="#1-目录与路径" class="headerlink" title="1 目录与路径"></a>1 目录与路径</h3><hr><h4 id="1-1-相对路径与绝对路径"><a href="#1-1-相对路径与绝对路径" class="headerlink" title="1.1 相对路径与绝对路径"></a>1.1 相对路径与绝对路径</h4><p>谈到目录与文件的操作,不得不提的就是路径问题,</p><p>因为在Linux系统中,文件系统是用一层一层的目录串起来的,那么,要进行文件与目录的操作</p><p><strong>路径就显得十分重要了!</strong></p><p>如上一篇所讲,路径分为<strong>绝对路径</strong>与<strong>相对路径</strong>,两者的概念,请去上一篇学习.</p><p>两者最大的区别在于:<strong>相对路径是相对于当前目录来讲,而绝对路径则是完整的路径名</strong>gyigegongzuo</p><p>用处:</p><p>相对路径:<strong>再进行日常操作时,使用相对路径就较为方便,比如</strong></p><blockquote><p>有/home/Evilcrow/Document/Kitch,,/home/Evilcrow/Document/Option,</p></blockquote><blockquote><p>要从Kitch目录切换至option目录怎么办? 用<figure class="highlight plain"><figcaption><span>../option```就显得很方便</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">绝对路径:**进行系统管理,程序编写时,准确无误**</span><br><span class="line"></span><br><span class="line">就像之前说的一样,使用绝对路径是十分准确的,尤其是进行程序的编写时,使用绝对路径尤为重要!</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 1.2 目录的基本操作</span><br><span class="line"></span><br><span class="line">接下来谈谈目录的基本操作</span><br><span class="line"></span><br><span class="line">首先来记忆一些比较特殊,但是又十分好用的目录名</span><br><span class="line"></span><br><span class="line">&gt; .        表示当前目录</span><br><span class="line"></span><br><span class="line">&gt; ..       表示上级目录</span><br><span class="line"></span><br><span class="line">&gt; ～       表示当前用户的主文件夹</span><br><span class="line"></span><br><span class="line">&gt; ～user   表示user用户的主文件夹</span><br><span class="line"></span><br><span class="line">&gt; —        表示上一个目录</span><br><span class="line"></span><br><span class="line">其中，“—&quot;表示&quot;上一级目录&quot;,这个用法,在进行两个目录间的切换时十分方便,需要常用进行熟悉</span><br><span class="line"></span><br><span class="line">**注:根目录是没有上层目录的,即```[Evilcrow@Evilcrow /] $ cd ..```仍为根目录 **</span><br><span class="line"></span><br><span class="line">介绍几个常用的目录命令</span><br><span class="line"></span><br><span class="line">&gt; cd:切换目录                  (change dictionary)</span><br><span class="line"></span><br><span class="line">&gt; pwd:显示当前目录的路径</span><br><span class="line"></span><br><span class="line">&gt; mkdir: 在当前目录下创建一个新目录 (make dictionary)</span><br><span class="line"></span><br><span class="line">&gt; rmdir: 删除一个&quot;空&quot;目录        (rm dictionary)</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####cd 命令,</span><br><span class="line"></span><br><span class="line">进行目录的切换  用法:</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow ~]$ cd [相对路径/绝对路径]</span><br></pre></td></tr></table></figure></p></blockquote><p>其中注意,～，—，两个特殊目录,同时,</p><figure class="highlight plain"><figcaption><span>cd```命令,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**注：进行cd命令，切换目录时，cd 与目录路径之间有一个空格，同时我们建议使用[Tab]补齐功能**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####pwd 命令</span><br><span class="line"></span><br><span class="line">显示当前目录路径,用法</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ pwd [-P]</span><br></pre></td></tr></table></figure><p>其中,直接使用pwd即可显示当前目录路径,为<strong>绝对路径</strong></p><p>[-P]选项的作用是显示出文件的真实路径,</p><p>举个例子,比如,/var/mail  与  /var/spool/mail</p><p>/var/mail连接文件,加上-P参数后,便会完整显示文件路径,不会显示连接文件(可以勉强理解为快捷方式)</p><p><strong>pwd -P可以使我们获取到文件的完整路径名</strong></p><hr><p>#####mkdir 命令</p><p>创建一个新目录</p><figure class="highlight plain"><figcaption><span>目录名```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重要参数</span><br><span class="line"></span><br><span class="line">&gt; -m 可以直接进行文件权限的配置 ,不用按照umask的默认权限进行设置</span><br><span class="line"></span><br><span class="line">&gt; -p 有时我们需要进行多级目录的创建,使用此参数,可以进行目录的递归创建</span><br><span class="line"></span><br><span class="line">举个例子:</span><br><span class="line"></span><br><span class="line">```mkdir -m 744 test```   可以自己进行</span><br><span class="line"></span><br><span class="line">```mkdir -p /home/Evilcrow/test/test1/test2```即可进行多级目录的创建</span><br><span class="line"></span><br><span class="line">**注意:-p参数虽然十分好用,但是一旦你的参数名混乱,就王炸!,后续的处理十分麻烦**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####rmdir 命令</span><br><span class="line"></span><br><span class="line">**删除一个空目录**</span><br><span class="line"></span><br><span class="line">谈到此命令时,必须强调一点就是,删除一个空目录!</span><br><span class="line"></span><br><span class="line">即rmdir命令,只是用来删除空目录的!,若目录不为空,不能进行删除!</span><br><span class="line"></span><br><span class="line">重要参数:**-p参数是用来进行多级目录删除的,若删除此目录后,..目录也为空则一同删除**</span><br><span class="line"></span><br><span class="line">**那么,问题来了,要是目录不为空,怎么一次性删除目录 ?**</span><br><span class="line"></span><br><span class="line">**这时,就要使用到rm -r的命令了**</span><br><span class="line"></span><br><span class="line">**[Evilcrow@Evilcrow]$ rm -r test,可以直接递归删除掉test及其test以下所有目录!**</span><br><span class="line"></span><br><span class="line">**但是,-r,这个递归参数的使用需要十分注意!**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 1.3 关于路径的变量:PATH</span><br><span class="line"></span><br><span class="line">谈到路径的切换,那么为什么在任何地方都可以执行/bin/ls的命令呢?</span><br><span class="line"></span><br><span class="line">这就要提到路径PATH的配置,</span><br><span class="line"></span><br><span class="line">&gt; 我们再使用某一个命令时,系统会根据我们自己PATH的配置,去到相应的目录下</span><br><span class="line"></span><br><span class="line">&gt; 需找该文件,之后就进行命令的使用,那么,PATH很重要,没错吧?</span><br><span class="line"></span><br><span class="line">那么,我们如何查看目前的PATH配置呢?</span><br><span class="line"></span><br><span class="line">使用```echo $PATH```命令</span><br><span class="line"></span><br><span class="line">**echo,有&quot;显示,打印出&quot;的作用,而$则是,之后跟的是变量的标识符**</span><br><span class="line"></span><br><span class="line">如何上图所示</span><br><span class="line"></span><br><span class="line">PATH中,包含了好多的路径配置,用**&quot;:&quot;**进行路径的区分,对于一个命令,先查找到哪里</span><br><span class="line"></span><br><span class="line">他的PATH就是哪里</span><br><span class="line"></span><br><span class="line">有时候,某些命令的PATH是没有划给user的,但是你仍然可以通过</span><br><span class="line"></span><br><span class="line">**使用绝对路径直接访问文件进行命令调用!**</span><br><span class="line"></span><br><span class="line">**亦即是说,如果,目标命令没有添加至PATH中,那么即使是root用户,也不能直接使用此命令!**</span><br><span class="line"></span><br><span class="line">关于PATH,我们有以下的建议:</span><br><span class="line"></span><br><span class="line">&gt; 不同用户的默认PATH是不同的,所以默认能执行的命令也是不同的</span><br><span class="line"></span><br><span class="line">&gt; 承上一条,PATH是可以修改的,我们可以根据自己的需求进行PATH的修改</span><br><span class="line"></span><br><span class="line">&gt; 可以直接使用**绝对路径的方式进行命令的访问,这样来的更快!**</span><br><span class="line"></span><br><span class="line">&gt; 由以上几点,命令必须在PATH中配置正确的命令,才能进行正常方便的使用</span><br><span class="line"></span><br><span class="line">&gt; 最后一点,不建议将&quot;.&quot;与&quot;..&quot;这两级目录添加至PATH路径中!</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">###2 文件与目录管理</span><br><span class="line"></span><br><span class="line">谈到文件与目录的管理,就是指&quot;移动,复制,重命名,显示属性&quot;等几方面的内容</span><br><span class="line"></span><br><span class="line">#### 2.1 文件/目录的查看操作</span><br><span class="line"></span><br><span class="line">针对文件/目录的查看操作,用到的命令,想必已经很熟悉了</span><br><span class="line"></span><br><span class="line">**ls  (list)**</span><br><span class="line"></span><br><span class="line">而ls命令的参数就有很多了,下面一一详细说明,**其中加粗的是常用参数**</span><br></pre></td></tr></table></figure><p><strong>1. -a 全部文件,连同隐藏文件也一一显示出来(.开头的即为隐藏文件)</strong></p><p>2.-A 作用同-a参数,但是并不会列出(.与..)两个目录</p><p><strong>3. 仅列出目录本身,而不会列出目录的文件数据</strong></p><p>4.-f直接列出文件的名,并不会进行排序,(使用默认排序)</p><p><strong>5. -F根据文件类型,自动附加文件结构</strong></p><p>  *可执行文件,  /目录,  =代表socket文件,  | 表示管道FIFO文件</p><p>6.-h,将文件容量以人们常用的方式读出,GB,KB等</p><p>7.-i 列出i-node的号码</p><p><strong>8.-l列出长数据串,其中包含了目录/文件的各种信息</strong></p><p>9.-n 列出UID与GID,而非用户名与用户组</p><p>10.-r,将排序结果反向输出</p><p>11.-R,连同子目录的内容一起显示出来</p><p>12.-S,将文件按照文件容量的大小进行排序,而非文件名</p><p>13.-t,依照时间名进行排序,而非文件名</p><p>14.–color=never/auto/always,总是,从不,自动显示颜色</p><p>15.–full-time,完整的时间进行显示</p><p>16.–time=atime/ctime(mtime为默认显示),显示权限改变时间/引用时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从上面就可以看出:ls的命令十分之多,但是,这么多的命令,与你日常经常用到的,</span><br><span class="line"></span><br><span class="line">基本上只有4,5和左右,所以熟练掌握常用参数,了解其他参数</span><br><span class="line"></span><br><span class="line">**正如之前所谈到的,所有的命令,对于他们的参数都是可以进行合并的,比如-alF**</span><br><span class="line"></span><br><span class="line">**但是,请注意,像--color,--time这种完整名的参数,就不能和其他的合并,而要自己单独写**</span><br><span class="line"></span><br><span class="line">**注:由于ls -l异常频繁的使用,在.bashrc文件中,已经用alias加入ll表示ls-l了!**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 2.2 复制,删除与移动</span><br><span class="line"></span><br><span class="line">前一小节谈到的是,文件/目录的查看,那么,这一节就是对文件/目录的操作了!</span><br><span class="line"></span><br><span class="line">#####cp 命令</span><br><span class="line"></span><br><span class="line">复制文件,对文件进行更新,创建连接文件,复制整个目录</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ cp 源文件  目标文件</span><br></pre></td></tr></table></figure></p><p>对于cp命令,其参数也是十分之多,</p><blockquote><p><strong>-a == -pdr,集合参数</strong></p></blockquote><blockquote><p>-d 对连接文件进行复制时,复制连接文件,而并非文件本身</p></blockquote><blockquote><p>-f fource强制的意思，即如果目标文件存在且无法打开，则删除后再尝试一次</p></blockquote><blockquote><p><strong>-i,若目标文件已经存在,那么在操作开始前会进行操作是否进行的访问</strong></p></blockquote><blockquote><p>-l,进行硬连接文件的创建,而非复制文件本体,硬连接</p></blockquote><blockquote><p>-p,连同文件的属性一起复制过去,而非使用默认的属性,即umask</p></blockquote><blockquote><p><strong>-r,持续性的递归复制,常用于目录的复制行为</strong></p></blockquote><blockquote><p>-s,复制成为”符号链接文件”,即”快捷方式”,软连接</p></blockquote><blockquote><p>-u,目标文件比源文件版本低的时候,会进行文件的更新</p></blockquote><blockquote><p><strong>重要的内容,如果源文件由两个以上,则最后一个参数,一定是目录!表示多个文件复制进入同一目录</strong></p></blockquote><p>其中,请十分注意-a,-p参数,不同的用户,进行的操作,最后导致的结果会有较大差异</p><p><strong>注意:这里要提到cp命令的两个默认属性:</strong></p><p><strong>1.cp命令进行文件的复制时,会改变用户名,用户名等属性,所以,不仅有-p,-r命令,更要有-a</strong></p><p><strong>2.cp命令再进行复制时,以源文件为主,意思是默认并不会复制符号连接文件,会去复制源文件</strong></p><p><strong>所以,要进行”快捷方式”的复制时,需要加上-d参数</strong></p><p><strong>另外很重要的一点,再使用-a保留文件属性时,使用root用户,一般用户没有修改用户,用户组的权限</strong></p><hr><p>#####rm 命令</p><p>移除文件/目录的命令</p><figure class="highlight plain"><figcaption><span>文件/目录名```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rm命令的参数不是很多,但是很关键</span><br><span class="line"></span><br><span class="line">&gt; -f 同之前cp命令的参数,强制进行,忽略警告消息</span><br><span class="line"></span><br><span class="line">&gt; -i 互动模式,即在删除文件前进行询问**(root下的默认模式)**</span><br><span class="line"></span><br><span class="line">&gt; -r 递归删除,当目录不为空的时候,可以使用递归参数进行删除</span><br><span class="line"></span><br><span class="line">**建议:一般进行删除操作时,可以加上-i,仔细检查文件名,以防误删操作**</span><br><span class="line"></span><br><span class="line">**通配符 *,此符号如其名,通配,可以表示任何字符&#123;..&#125;无穷个**</span><br><span class="line"></span><br><span class="line">**意即,File*表示,以File开头的文件,*File表示,以File结尾的文件**</span><br><span class="line"></span><br><span class="line">**再介绍两个技巧:**</span><br><span class="line"></span><br><span class="line">**1.删除以-开头的文件,-之后接的是参数,那么误判该怎么处理?**</span><br><span class="line"></span><br><span class="line">**很简单,使用.本目录即可化解,eg: ./-aaa-,即可表示本目录下的-aaa-文件**</span><br><span class="line"></span><br><span class="line">**在man中,还提供了一种方法,rm -- -aaa-**</span><br><span class="line">**2.如何忽略-i参数,默认真的有时候有点烦**</span><br><span class="line"></span><br><span class="line">**在命令前加上反斜杠\即可,eg:\rm test.即可不进行互动直接删除**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####mv 命令</span><br><span class="line"></span><br><span class="line">进行文件/目录的移动，重命名的操作</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ mv 源文件  目标文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>mv 源文件 源文件 源文件.... 目标目录```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参数与rm基本相同,略有差异</span><br><span class="line"></span><br><span class="line">&gt; -f fource强制,若目标文件已经存在,不会进行询问,而是直接进行覆盖</span><br><span class="line"></span><br><span class="line">&gt; -i  互动默认,会进行询问</span><br><span class="line"></span><br><span class="line">&gt; -u 不同于-r的递归,(mv怎么能递归...),若源文件更新,则进行目标文件的更新</span><br><span class="line"></span><br><span class="line">**当两个文件/目录在同一个目录下时.,在进行mv命令的调用,即为重命名操作**</span><br><span class="line"></span><br><span class="line">rename可以进行多个文件的重命名,以后再进行详述</span><br><span class="line"></span><br><span class="line">mv主要功能即在于进行文件的移动和重命名!</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 2.3 取得文件的路径名和文件名</span><br><span class="line"></span><br><span class="line">看到这个标题,你会想到,之前不是有pwd命令进行路径的显示吗?</span><br><span class="line"></span><br><span class="line">但是,此命令是对于长串的文件名(最长可达4096字符)进行文件名和路径名(目录名)的区别的命令</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$basename  绝对路径``` 获得文件名</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$dirname   绝对路径```  获得路径名</span><br><span class="line"></span><br><span class="line">这两个命令可能你看上去比较鸡肋,说出来你可能不信,我也觉得鸡肋</span><br><span class="line"></span><br><span class="line">但是,则会两条命令既然存在就有他存在的意义,主要是用于程序中进行判断的命令.</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">### 3.文件内容查阅</span><br><span class="line"></span><br><span class="line">*上一节提到的是文件/目录的操作,实现完毕后,我们就来进行文件的查阅*</span><br><span class="line"></span><br><span class="line">首先预告一下,文件查阅的命令:cat,tac,more,less,head,tail,od,nl</span><br><span class="line"></span><br><span class="line">####  3.1 直接查阅文件内容</span><br><span class="line"></span><br><span class="line">直接查看文件内容可以使用cat,tac,nl几个命令进行查看</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####cat 命令</span><br><span class="line"></span><br><span class="line">查阅文件内容的功能</span><br><span class="line"></span><br><span class="line">cat命令具有几个很实用的参数</span><br><span class="line"></span><br><span class="line">&gt; **-A 相当于-vET,同样地,是个聚合参数**</span><br><span class="line"></span><br><span class="line">&gt; -b,可以列出行号,但是指针对于非空白行,空白行不列出行号</span><br><span class="line"></span><br><span class="line">&gt; **-E,将结尾的断行字符(\n)以&quot;$&quot;的形式输出**</span><br><span class="line"></span><br><span class="line">&gt; **-n,完整的打引出行号,即使空白行也打引出行号**</span><br><span class="line"></span><br><span class="line">&gt; -T,将[Tab]制表符按照^T,进行打印</span><br><span class="line"></span><br><span class="line">&gt; -v,列出一些看不出来的特殊字符</span><br><span class="line"></span><br><span class="line">cat命令实际上是&quot;Concatenate&quot;即在屏幕上连续的显示文件内容</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####tac 命令</span><br><span class="line"></span><br><span class="line">可能眼尖的你也发现了,**tac命令正是cat命令的逆置!**</span><br><span class="line"></span><br><span class="line">tac命令的作用也正是与cat命令相反,将内容反向输出至屏幕上</span><br><span class="line"></span><br><span class="line">两者的参数也都是相同的</span><br><span class="line"></span><br><span class="line">**但是,即便如此,还是不推荐平时使用cat和tac命令,因为一旦文件内容过长,那么**</span><br><span class="line"></span><br><span class="line">**屏幕上并不能完整的显示出文件的内容,很不方便**</span><br><span class="line"></span><br><span class="line">**而使用more,less,nl等命令,则十分方便**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#####nl 命令</span><br><span class="line"></span><br><span class="line">添加行号打印的功能</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ nl  文件```,即可在屏幕上显示文件内容</span><br><span class="line"></span><br><span class="line">&gt; -b 指定行号指定的方式,有两种:</span><br><span class="line"></span><br><span class="line">&gt;  -b a,不论有无空行,都显示行号 cat -n</span><br><span class="line"></span><br><span class="line">&gt;  -b t,空行不显示行号,(默认值)</span><br><span class="line"></span><br><span class="line">&gt; -n 列出行号表示的方法</span><br><span class="line"></span><br><span class="line">&gt;   -n ln  行号在屏幕左边显示</span><br><span class="line"></span><br><span class="line">&gt;   -n rn  行号在右边显示,不加0</span><br><span class="line"></span><br><span class="line">&gt;   -n rz  行号在右边显示,加0</span><br><span class="line"></span><br><span class="line">&gt;   -w :行号字符段占用的位数(即行号0的个数)</span><br><span class="line"></span><br><span class="line">**使用nl命令时,多个参数组合使用,比如```[Evilcrow@Evilcrow]$nl -b a -n rz -w 3**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 3.2 翻页查看文件内容</span><br><span class="line"></span><br><span class="line">刚才所介绍的,cat,tac,nl三个命令都是将文件内容输出到屏幕上的命令</span><br><span class="line"></span><br><span class="line">当文件内容很多的时候,毕竟不方便,所以,就有以下的翻页查看命令</span><br><span class="line"></span><br><span class="line">#####more 命令</span><br><span class="line"></span><br><span class="line">一页一页的翻动</span><br><span class="line"></span><br><span class="line">**more使用的时候,可以作为一个程序对待,类似与man,可以进行操作**</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ more 文件</span><br></pre></td></tr></table></figure><blockquote><p>Space  向下翻一页</p></blockquote><blockquote><p>Enter  向下一行</p></blockquote><blockquote><p>/字符串 向下查找字符串</p></blockquote><blockquote><p>:f     立刻显示出文件名及当前行数</p></blockquote><blockquote><p>q      退出more程序</p></blockquote><blockquote><p>b或者Ctrl-b  进行退格</p></blockquote><p>more命令只要按照以上要求操作就好</p><h5 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h5><p>less与more大同小异,只不过less功能更具有弹性,所以<strong>推荐使用less</strong></p><blockquote><p>Space     向下翻页</p></blockquote><blockquote><p>[Pagedown]     向下一页</p></blockquote><blockquote><p>[Pageup]       向上一页</p></blockquote><blockquote><p>/string        向下搜索字符串</p></blockquote><blockquote><p>?string        向上搜索字符串</p></blockquote><blockquote><p>n            向下一个查询</p></blockquote><blockquote><p>N            向上一个查询</p></blockquote><blockquote><p>q            离开less程序</p></blockquote><p>以上即为less命令的操作,</p><p>是不是和man的用法很像啊?</p><p><strong>对,没错,man文档实际上就是用less显示在屏幕上的</strong></p><h4 id="3-3-数据选取"><a href="#3-3-数据选取" class="headerlink" title="3.3 数据选取"></a>3.3 数据选取</h4><p><em>以上的几个命令都是对文件内容的显示,那么如果我取出文件中的部分内容使用,怎么办呢?</em></p><p>#####head 与 tail命令</p><p>从文件开头/末尾取出一定行的内容(默认值为10行)</p><figure class="highlight plain"><figcaption><span>head/tail  [-number]  文件```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中number即为你指定后想要取出的行数</span><br><span class="line"></span><br><span class="line">**注意,number -,+的使用,对于head,-number表示减去后面若干行输出**</span><br><span class="line"></span><br><span class="line">**而对于,tail +number表示减去前面若干行进行输出**</span><br><span class="line"></span><br><span class="line">**这很方便在不知道文件总行数的情况下进行操作,而且,可以通过管道这两个命令联合使用**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 3.4 非纯文本文件</span><br><span class="line"></span><br><span class="line">#####od 命令</span><br><span class="line"></span><br><span class="line">将文件按照二进制进行读取</span><br><span class="line"></span><br><span class="line">由C语言文件的知识可知,计算机中文件分为文本与二进制,之前的命令都是对文本文件适用</span><br><span class="line"></span><br><span class="line">对于二进制文件,就得使用od命令了</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ od [-参数]  文件</span><br></pre></td></tr></table></figure><blockquote><p>a          :利用默认字符进行输出</p></blockquote><blockquote><p>c          :利用ASCII码进行输出</p></blockquote><blockquote><p>d[SIZE]    :利用十进制输出,每个整数SIZE个字节</p></blockquote><blockquote><p>o[SIZE]    :利用八进制输出,每个整数SIZE个字节</p></blockquote><blockquote><p>x[SIZE]    :利用十六进制进行输出,每个整数SIZE个字节</p></blockquote><p>活用以上的参数,可以有效的处理二进制文件!</p><p>举个例子:<figure class="highlight plain"><figcaption><span>od -oCc  test```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">意思即是,使用八进制输出,每个整数12个字节,按照ASCII码输出</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 3.5 创建文件与修改时间</span><br><span class="line"></span><br><span class="line">之前讲了这么多的目录创建,现在该轮到文件的创建了</span><br><span class="line"></span><br><span class="line">首先来了解几个概念:时间的几个概念</span><br><span class="line"></span><br><span class="line">modification time(mtime):当文件的&quot;数据内容&quot;改变时,此时间刷新</span><br><span class="line"></span><br><span class="line">status time(stime):当文件的权限发生改变的时候,此时间刷新</span><br><span class="line"></span><br><span class="line">access time(atime):当此文件被引用,被访问时,此时间刷新</span><br><span class="line"></span><br><span class="line">**要查看这三个时间属性的方法,之前已经在ls的参数中提到过了--time=a/stime(mtime默认)**</span><br><span class="line"></span><br><span class="line">在系统的操作中,时间属性是很关键的!</span><br><span class="line"></span><br><span class="line">那么,万一时间出错我们怎么修改呢?</span><br><span class="line"></span><br><span class="line">#####touch 命令</span><br><span class="line"></span><br><span class="line">用于新建文件,修改文件时间</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ touch [-acdmt]  文件</span><br></pre></td></tr></table></figure></p><blockquote><p>-a 仅修改访问时间(atime)</p></blockquote><blockquote><p><strong>-c 仅修该文件时间,若文件不存在,则不新建文件</strong></p></blockquote><blockquote><p>-d 可以指定修改的日期,并非是当前的日期(默认),格式–date=”…..”</p></blockquote><blockquote><p>-m,仅修改mtime</p></blockquote><blockquote><p>-t 同-d,但是日期的格式为[YYMMDDhhmm]</p></blockquote><p><strong>注:平时最关心的时mtime,因为它记录了文件什么时候被修改。</strong></p><p><strong>注:可以在同一行中使用 ；来表示命令的顺序执行</strong></p><p><strong>touch最常用的情况:1.新建文件 2.修改文件日期为当前日期(mtime与atime)</strong></p><hr><p><em>PS:至此,Linux文件/目录的基本操作就告一段落了,但是你还记得吗?之前在文件属性中有10个字符</em></p><p><em>是不是匪夷所思呢?这就是文件的隐藏属性,属于下一篇探讨的内容了.</em></p><p><em>从这篇开始,换了新的输入法,同时合理使用了标题,我还会尽快使自己的博客风格成型的</em></p><p>06/16/2017</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第五篇 在线求助与基本操作</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E4%BA%94%E7%AF%87%20%20%E5%9C%A8%E7%BA%BF%E6%B1%82%E5%8A%A9%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E4%BA%94%E7%AF%87%20%20%E5%9C%A8%E7%BA%BF%E6%B1%82%E5%8A%A9%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><em>本章是入门与安装的最后一章节，也可以是开启Linux系统学习的开始，会逐步接触Linux深处的东西</em></p><p>首先，明确一个概念，我安装Linux作为练习机，非学习服务器的内容，</p><p>则一些关于服务器的内容现在并不会深入。</p><hr><p>##命令行 与 图形界面</p><p>Linux操作系统与Win一个很重要的区别就是：用户</p><p>Linux属于多用户多任务类型的操作系统</p><p>Win属于单用户多任务的操作系统</p><p>所以，Linux的系统进行开关机就尤为重要，因为进行关机操作时其他的用户任务不一定完成。</p><p>所以，了解对桌面环境的登陆与注销是十分有必要的，而这就牵扯到了命令行界面。</p><p><strong>Linux系统本身是没有桌面环境的，即注销退出桌面环境后，还是Linux。桌面环境只是一个程序。</strong></p><p><strong>对于Win而言，现在图形界面已经在内核(Kernel)中实现，若没有桌面环境，就不是Win了。</strong></p><p><strong>注意:图形界面与命令行模式的切换</strong></p><blockquote><p>Linux会默认提供6各种终端供用户操作，为[ctrl]+[alt]+F1-F6 文字登陆界面的切换</p></blockquote><blockquote><p>若要切换回图形界面桌面：[ctrl]+[alt]+F7即可</p></blockquote><p>如果图形界面没有启动，如何启动呢？</p><p>有这样的代码<code>[Evilcrow@Evilcrow ~] $ startx</code>，即可启动图形界面。</p><p>既然已经学习了如何在命令行模式与图形界面间的切换，那么开始终端操作吧！</p><hr><p>##在命令行模式下进行操作</p><p>众所周知，只有在终端下操作Linux系统才是最有意思的，终端中进行操作都是使用命令行模式。</p><p>那么，如何开始上手命令行模式呢？</p><p>命令行，命令行，如字面意思而言，使用多行命令进行操作的模式。</p><p>1.使用命令行模式登陆用户，</p><p>在命令行模式下，输入密码即可登陆，注意：<strong>此时输入密码是不回显的，并非键盘失灵！</strong></p><p>2.使用命令行模式退出/注销主机</p><p>使用命令<code>[Evilcrow@Evilcrow ~ ] $ exit</code>即可注销主机，<strong>切记：注销并非关机</strong></p><blockquote><p>分析<code>[Evilcrow@Evilvrow] $/#</code></p></blockquote><blockquote><p>Evilcrow 既为普通用户用户名，也为用户全名</p></blockquote><blockquote><p>其中 $表示普通用户权限下操作</p></blockquote><blockquote><p>而 #表示Root权限下操作。</p></blockquote><blockquote><p>强烈建议，设置系统用户时，一个普通用户，和一个管理员用户。</p></blockquote><blockquote><p>Why? 因为Root账户权力太大了！</p></blockquote><hr><p>##开始在命令行中执行命令</p><ul><li>执行命令：</li></ul><p><code>[Evilcrow@Evilcrow] $ command [-options] parameter1 parameter2</code></p><p>即为，执行命令时的标准格式</p><p>则有以下要点要注意：</p><blockquote><p>1.执行命令时的格式：命令/可执行文件名 + 选项 + 参数</p></blockquote><blockquote><p>2.command 为命令名称或者文件名称 cd ls ./a.out</p></blockquote><blockquote><p>3.模板中[]仅仅起到区分的作用，实际操作时，并非输入选项</p></blockquote><blockquote><p>4.选项一般用 -l -a之类按需秋，但是，在某些选项时需要完整选项名  –help，详情查看说明文件</p></blockquote><blockquote><p>5.在命令中，命令，选项，参数，用空格来分开，无论空几个空格，shell(即bash)均视为一格</p></blockquote><blockquote><p>6.[Enter]键按下表示命令的执行，<strong>在命令中，是区分大小写的，cd：变换路径  CD：未知</strong></p></blockquote><p>举个例子：</p><p>将当前目录下所有的文件都显示出来</p><p>ls -al ~</p><p>ls -a   -l  ~</p><p>效果同理，选项可以合并写，也可以分开写，不影响实际操作结果。</p><ul><li>语言的选择：</li></ul><p>尽管我也很不情愿，但是我还是要说一句，<strong>在shell中，大家能使用英语还是使用英语！</strong></p><p>首先是，使用中文可能会乱码，毕竟许多文件都是外国友人写的，一些文件也没有针对性的汉化</p><p>贸然在shell中完全使用zh_CN.UTF-8可能会发生一些难处理的错误！</p><p>建议：<strong>在使用shell时，使用英语语系</strong></p><p>1.检查当前语系</p><p><code>[Evilcrow@Evilcrow] $ echo $LANG</code></p><p>即可查看当前语系，美式英语为en_US</p><p>2.修改语系</p><p><code>[Evilcrow@Evilcrow] $ LANG=en_US</code></p><p>即可修改语系，<strong>注意LANG后“=”没有空格</strong></p><p>修改为英语语系后，就可以在shell中畅游了，遇到英语不要怕，即使拿着字典查。</p><p>###几个基础的简单命令</p><ul><li><p>日期与时间：date(<strong>注意：此命令一定为小写！</strong>)</p><p><code>[Evilcrow@Evilcrow] $ date +%Y/%m/%d</code></p></li></ul><p>即可，按照xxxx/xx/xx格式输出日期，其中+%Y/%y/%d都是参数，进行合理使用即可</p><p><strong>命令行之后的参数不一定都是“-”，也存在“+”的情况</strong></p><ul><li>日历：cal(<strong>注意：此命令依然为小写！</strong>)</li></ul><p>直接使用<code>[Evilcrow@Evilcrow] $ cal</code>即可得本月(同计算机时间)日历</p><p>cal的语法为：<code>cal[month][year]</code></p><p>month的参数必须为1-12之间的数！</p><p><strong>某些参数有特殊的取值范围，我们可以通过错误信息来了解他</strong></p><ul><li>简单的计算器：bc</li></ul><p><code>[Evilcrow@Evilcrow] $ bc</code> 即可打开计算器</p><p>此计算器，在第一行输入算式，第二行即可得到结果</p><p><strong>注意：bc计算器，实际上默认的数据都为整型，所以输出1/10的结果为0</strong></p><p><strong>解决办法：<code>scale = number</code>，其中number为需要保留的小数位数</strong></p><p>最后，退出计算器，quit进行退出即可。</p><p>以上内容的总结：</p><p>1.在命令行模式中执行命令，有两种情况：</p><p>  命令直接显示结果并回到命令行模式界面</p><p>  或者 进入该命令环境中，直到结束命令才能回到命令行模式界面</p><p>判断：每次只要是<code>[Evilcrow@Evilcrow] $</code>光标等待击键，即为命令提示符界面，等待命令输入</p><p>2.一直在说shell，shell到底是什么？shell(壳)区别于kernel(核)，</p><p>即指人与机器互的程序，例如在Linux下的bash，Win下的cmd都是shell</p><p>##几个重要的热键</p><ul><li>Tab补全</li></ul><p>大家是不是经常也会出现命令记不全的时候，对吗？</p><p>那该怎么办，难道去背吗？</p><p>Linux中提供了一个很方便的热键 Tab</p><p>Tab键可以进行命令/文件补全功能</p><blockquote><p>用法：</p></blockquote><blockquote><p>在command的位置，输入相关部分的命令，在敲击两次[Tab]即可显示出之后所有可能的命令</p></blockquote><blockquote><p>而选项，参数，这些并不会补全，这些需要你自行查阅说明解决</p></blockquote><blockquote><p>在命令确定后，即可进行文件名的补全，同理敲击两次[Tab]即可，显示出所有可操作文件名</p></blockquote><p>Tab作为一个很重要的补全功能热键，希望大家能合理使用！</p><ul><li>[Ctrl]-c  进程终止热键</li></ul><p>有时候避免不了的，会进行了错误的进程，那么怎么办？</p><p>热键[Ctrl]-c解决了这个而问题，会强制终止进程！</p><p>虽然好用，但是有的时候，也需要谨慎使用，不能肆意使用，否则会引起重大错误的出现</p><ul><li>[Ctrl]-d  结束输入热键</li></ul><p>使用[Ctrl]-d可迅速结束从键盘的输入，相当于输入exit（ ）一样</p><p><strong>注意：请刻关注错误消息，可以从错误报告中进行挖掘</strong></p><h2 id="man-page-与-info-page"><a href="#man-page-与-info-page" class="headerlink" title="man page 与 info page"></a>man page 与 info page</h2><p>在上面的小节中，介绍了几个简单的命令</p><p>ls，cal，date，bc，</p><p>但是，你能完全掌握它的功能吗？</p><p>你了解它的每一个选项，没一个参数吗？</p><p>这个时候就需要用到强大的在在线求助 <strong>man page</strong></p><p>man 也是命令 为manual(操作说明）</p><p><code>man command</code>即可显示此命令的操作说明！</p><p>举个例子：</p><p>man ls     即可显示关于 ls 命令的所有内容，包括其用法，等级，相关环境参数等一系列信息</p><p>而使用 man命令时会进入一个界面，此即所谓的 man page，在其中也可以使用许多快捷键进行操作</p><p>可以说，过man命令即可了解到所有的命令相关的操作说明。</p><p>即，虽然Linux中有许多许多的命令，你背不完所有的命令，你也不需要背过所有的命令</p><p><strong>记住平时常用的命令，然后灵活使用man 与 Tab补全即可完成许多复杂操作</strong></p><p>info page的用法与 man page基本类似，</p><p>但是，在info中将文件数据折叠成一个个段落，更方便使用者的查询与查看。</p><p>##nano轻量级编辑器</p><p>虽然在Linux下，提及编译器莫不是</p><p><strong>“编辑器之神”Vim 和“神之编辑器”Emacs</strong></p><p>但是，一些轻量级，精简的编辑器也是十分的好用，比如nano</p><p>nano中同样使用了大量的快捷键，根据他的快捷键，也可以了解到许多有趣的操作。</p><p>最后，回到最开始的问题上：正确的关机方法</p><p>由于涉及此部分不多，所以简要说明</p><p>要对Linux进行关机，首先进行资源的查看，确保不会中断其他用户的关键操作</p><p>然后关机时给个用户发消息，预留备份数据的时间</p><p>最后按需求关机</p><p>June 3, 2017 12:32 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第二篇 Linux基础知识</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E4%BA%8C%E7%AF%87%20%20Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E4%BA%8C%E7%AF%87%20%20Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p><em>本章的知识是对Linux的初步了解，内容比较散。</em></p><p><em>以自己的体悟为主，不会进行书本内容复制</em></p><p>谈及Linux，则必须从计算机的发展史说起，Linux只是其发展过程中所激起的一个小波澜而已。</p><ul><li>First</li></ul><p>从计算机产生伊始，并没有操作系统这种东西，要对计算机进行操作所使用的都是，卡片机。</p><p>在之后，由麻省理工所开发出的分时操作系统开创了一个新时代。</p><p>但是，所谓分时操作系统也只能供30多余台终端机在主机中进行操作</p><p><strong>注：此时的终端机并不具有计算功能，终端机仅仅具有进行输入/输出指令的功能。</strong></p><ul><li>Second</li></ul><p>人们不满足一直使用这样的主机进行操作，认为30台终端机太少，</p><p>便意图开发出可以进行300多台终端机同时进行操作的系统出来。</p><p>此项目汇聚了许多业界有名的人物，但后来因为进度的原因，便被搁置，虽然后来也做出了个东西，</p><p>但也没有引起多大的关注。</p><p>而参与此项目的一个人：肯 汤普逊则不满意此成果，想自己做出一个小系统出来供自己使用，</p><p>此系统用汇编语言编写，即之后UNIX的原型</p><p>之后，又有一个人参与进行来，丹尼斯 里奇，即C语言之父。</p><p>此两人便完成了UNIX系统。</p><p>而贝尔实验室所隶属的AT&amp;T公司，便进行发售UNIX的发行版，直至第七版开始，进行专利授权。</p><ul><li>Third</li></ul><p>因为在UNIX第七版里指出：不能向学生开放源码，使得谭教授的课程无法开放，</p><p>所以谭教授便自己编写了一个Minix操作系统，即之后Linux的前身。</p><p>此时又有了一个人理查德 史托曼先生，即GNU项目的创始人</p><p>提倡，自由软件的倡导者，先后开发出：</p><p>“神之编辑器”Emacs，GCC（GNU C Complier），等一些自由软件，从此开始了自由软件</p><p>但是他们始终缺少一个自由的操作系统</p><p>而林纳斯 托瓦兹 的出现便解决了这个问题</p><ul><li>Fourth</li></ul><p>Linus为了好玩，使用汇编语言的他，由于对硬件的深刻了解，最后使用C语言开发出了Linux 内核0.02版本</p><p>而他在其中使用了bash，GCC等自由软件，所以他自己也将自己的软件作为自由软件释放出来</p><p>之后更是衍生出了虚拟团队</p><p>介绍一下Linux的版本：奇数为试用版本，不稳定。偶数版本为稳定版本。</p><p>另外：关于Linux Distribution：</p><p>Linux Distribution = Linux 内核 + 自由软件 + Tools + 可进行完整安装的安装包 即为Linux Distribution</p><p>基本分为两大系：RedHat系 与 Debian 系，，也可以说区别在于安装包的区别，rpm包与tar.gz包</p><ul><li>Last</li></ul><p>谈谈Linux的优点与缺点：</p><p>优点：极其稳定，免费或少许费用，软件更新修复快，多用户多任务的主机操作区别于Windows的单用户单任务。</p><p>缺点：说到底，尽管Linux现在也是有很不错的桌面环境，比如：KDE，Gnome，xafe等</p><p>但是图像界面终究是个短处，而且使用Linux操作系统时，终究避免不了使用终端操作，只有使用终端操作</p><p>才能真正的体会到：Linux的乐趣。</p><p>Date：2017/05/25/18:22</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第九篇 Linux文件与目录管理(下)</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E4%B9%9D%E7%AF%87%E3%80%80Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86(%E4%B8%8B)/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E4%B9%9D%E7%AF%87%E3%80%80Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86(%E4%B8%8B)/</url>
      <content type="html"><![CDATA[<p><em>上一篇提到了LInux系统下文件/目录的基本操作,诸如:切换目录,</em></p><p><em>对于目录/文件的新建,移动,拷贝,删除.</em></p><p><em>以及对于文件的各种形式的查看</em></p><p><em>那么这一篇所要谈到的就是,文件/目录的隐藏属性以及文件/目录的查询操作</em></p><hr><h3 id="1-文件-目录的默认权限和和隐藏权限"><a href="#1-文件-目录的默认权限和和隐藏权限" class="headerlink" title="1.文件/目录的默认权限和和隐藏权限"></a>1.文件/目录的默认权限和和隐藏权限</h3><p>进行了之前的了解,你应该已经自己动手创建过文件或者目录了吧?</p><p>但是你有没有好奇过,每次新建文件/目录,他们的出生权限都是一致的.<br><img src="http://img.blog.csdn.net/20170617190716652?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>如上图所示,新建test1,test2,他们的权限都是664</p><p>这就要牵扯到文件/目录的<strong>默认权限</strong>与<strong>隐藏权限</strong>了</p><hr><h4 id="1-1-文件默认权限-umask"><a href="#1-1-文件默认权限-umask" class="headerlink" title="1.1 文件默认权限:umask"></a>1.1 文件默认权限:umask</h4><p><strong>默认权限:当前用户在新建文件/目录时,文件/目录的默认权限</strong></p><p>使用umask命令即可查看当前默认权限</p><figure class="highlight plain"><figcaption><span>umask```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ umask -S</span><br></pre></td></tr></table></figure><p>上图中的0002即为当前的默认权限</p><p>看见这个0002你是不是也是一脸懵比?,没错,一开始我和你也差不多.</p><p>对于0002默认权限的理解:</p><p>首先需要明确的是,在新建文件/目录时,对于文件/目录的权限分配:</p><blockquote><p>对于文件,默认是没有X,可执行权限的,因为不确定文件是否可以执行</p></blockquote><blockquote><p>即文件 -rw-rw-rw-,所以文件权限默认最大666</p></blockquote><blockquote><p>对于目录,默认是权限全开,即目录 drwxrwxrwx,所以目录的默认权限最大为777</p></blockquote><p>接下来,再来理解umask,默认权限的数字0002,其中后三位,分别为user,group.others的rwx权限</p><p><strong>所谓”默认权限”的意思是:在最大权限上减去默认的权限,即为目前的默认权限</strong></p><p>举个例子:umask 0002</p><p>对于文件:<strong>-rw-rw-rw-减去 ——–w-,则文件的默认权限为-rw-rw-r–,即664</strong></p><p>对于目录:<strong>-rwxrwxrwx减去 ——–w-,则目录的默认权限为-rwxrwxr-x,即775</strong></p><p>到这里,你就了解了umask以及它与默认权限的关系了吧!</p><p>既然默认权限影响着我们进行工作配置时的快捷与否,那么该如何进行默认权限的修改呢?</p><figure class="highlight plain"><figcaption><span>umask number```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在**umask+数字**即可修改默认权限.</span><br><span class="line"></span><br><span class="line">**注:在未进行修改的时候,root用户的默认权限是022,一般用户的默认权限是002**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 1.2 文件的隐藏属性 lsattr,chattr命令</span><br><span class="line"></span><br><span class="line">在之前的内容中,你可能也曾注意到,文件的权限中有10个字符,9个为rwx权限,</span><br><span class="line"></span><br><span class="line">那么剩下的一个是什么呢?</span><br><span class="line"></span><br><span class="line">**剩下的一个,即为&quot;隐藏属性&quot;**</span><br><span class="line"></span><br><span class="line">隐藏属性,可以称之为文件的高级属性,隐藏属性有很多,其中有几个最常用的</span><br><span class="line"></span><br><span class="line">##### chattr 命令</span><br><span class="line"></span><br><span class="line">**chattr 用来进行隐藏属性的更改(change attr)**</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ chattr [-+=] [ASacdisu]  文件/目录</span><br></pre></td></tr></table></figure><p>chattr命令,也类似于chmod,使用-+=来赋予文件/目录以隐藏属性</p><blockquote><p>-A 访问文件时,atime不会发生改变(access time),可以避免过度访问磁盘,保护磁盘</p></blockquote><blockquote><p>-S 一般文件是”异步”写入磁盘的,关机前才会有sync命令,使数据写入磁盘,-S可以”同步”写入磁盘</p></blockquote><blockquote><p>-a (重要)设置此权限后,文件只能增加数据,不能修改数据,也不能删除数据,只有root才有此权限</p></blockquote><blockquote><p>-c 此参数使得文件存储时自动压缩,读取时自动解压,方便存储大文件</p></blockquote><blockquote><p>-d dump程序运行时,不会使文件被dump程序备份</p></blockquote><blockquote><p>-i (重要),-i可以使文件”不能被改名,删除,设置连接也无法写入或者添加数据”只有root有此权限</p></blockquote><blockquote><p>-s 设置s属性,当文件被删除时,完全被删除,并不会进行备份,(相当于shift+del)</p></blockquote><blockquote><p>-u 与-s相反,删除文件后并没有被完全删除,可以通过一定方法找回数据</p></blockquote><p>以上即为chattr可以修改的隐藏属性,也是文件的所有隐藏属性</p><p><strong>注:其中的-a,-i参数十分重要,对系统的安全也有极大的保护,但只有root才有此权限</strong></p><p>chattr用来修改文件属性,那么修改后的文件属性如何查看?</p><p><strong>使用lsattr命令</strong></p><figure class="highlight plain"><figcaption><span>lsattr [-adR]  文件/目录```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; -a 将隐藏的文件属性也全部显示出来</span><br><span class="line"></span><br><span class="line">&gt; -d 如果接的是目录,则不显示其中的文件,而只是目录本身的隐藏属性</span><br><span class="line"></span><br><span class="line">&gt; -R 连同目录下的子文件隐藏属性也全部显示出来</span><br><span class="line"></span><br><span class="line">使用chattr命令修改隐藏属性,lsattr命令查看隐藏属性,系统管理效率事半功倍</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### 1.3 文件的特殊权限: SUID,SGID,SBIT</span><br><span class="line"></span><br><span class="line">当时现在umask查看默认权限的时候,你可能看到有四个数字,既然后面的是u,g,o的rwx权限</span><br><span class="line"></span><br><span class="line">那么,第一个是什么呢? 就是文件的特殊权限</span><br><span class="line"></span><br><span class="line">之前在目录树中也有几个特殊的目录,仔细观察</span><br><span class="line">![](http://img.blog.csdn.net/20170617191118232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br><span class="line">![](http://img.blog.csdn.net/20170617190835263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br><span class="line">上图中passwd的权限为-rwsr-xr-x,这个S即为&quot;特殊权限&quot;</span><br><span class="line"></span><br><span class="line">我们来考虑一个问题,如果对于某一类文件,他的权限属于root用户</span><br><span class="line"></span><br><span class="line">权限为&quot;-r--------&quot;</span><br><span class="line"></span><br><span class="line">但是一般用户又必须具有W的权限才能进行文件操作,</span><br><span class="line"></span><br><span class="line">这个时候特殊的文件权限就派上用场了</span><br><span class="line"></span><br><span class="line">有这种例子吗?</span><br><span class="line"></span><br><span class="line">**最常用的: 密码**</span><br><span class="line"></span><br><span class="line">一般用户明明不具有密码文件的W&quot;写&quot;权限,但是它却可以修改自己的密码,这就是特殊权限</span><br><span class="line"></span><br><span class="line">**实质上,特殊权限,相当于对于非权限内用户,特殊的执行权**</span><br><span class="line"></span><br><span class="line">特殊权限有三种:SUID,SGID,SBIT</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### SUID 特殊权限</span><br><span class="line"></span><br><span class="line">**当s出现在user上时,称为Set UID,即SUID**</span><br><span class="line"></span><br><span class="line">&gt; SUID权限仅对二进制程序有效,(即对shell script无效)</span><br><span class="line"></span><br><span class="line">&gt; 执行者对于此程序有X权限</span><br><span class="line"></span><br><span class="line">&gt; 这个特殊的执行权限仅仅在执行过程中生效</span><br><span class="line"></span><br><span class="line">&gt; 执行者将具有程序拥有者的权限</span><br><span class="line"></span><br><span class="line">上面的话很生硬对吗?</span><br><span class="line"></span><br><span class="line">我用自己的话帮大家总结:</span><br><span class="line"></span><br><span class="line">**权限外用户,(对此文件有x权限),在执行程序期间,获得程序所有者权限,仅对二进制程序生效**</span><br><span class="line"></span><br><span class="line">举个实际的例子:</span><br><span class="line"></span><br><span class="line">**密码文件属于root,但是一般用户在使用期间,却可以获得密码文件的使用权,以及修改权(仅限自己的)**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### SGID 特殊权限</span><br><span class="line"></span><br><span class="line">**当s出现在group中时,称为 Set GID,即SGID**</span><br><span class="line"></span><br><span class="line">如上图</span><br><span class="line"></span><br><span class="line">**SGID不同于SUID权限,SGID可以使用在目录和文件上,但是SUID只能使用在二进制程序上**</span><br><span class="line"></span><br><span class="line">对于文件而言:</span><br><span class="line"></span><br><span class="line">&gt; SGID对二进制程序有效</span><br><span class="line"></span><br><span class="line">&gt; 程序执行者对文件需要具有x权限</span><br><span class="line"></span><br><span class="line">&gt; 执行者在执行过程中将获得用户组的支持</span><br><span class="line"></span><br><span class="line">对于目录而言:</span><br><span class="line"></span><br><span class="line">&gt; 用户需要对于该目录具有r与x权限,才能进入该目录</span><br><span class="line"></span><br><span class="line">&gt; 用户在此目录下的有效用户组,将会变成该目录的用户组</span><br><span class="line"></span><br><span class="line">&gt; 若用户对于改目录具有w&quot;写&quot;权限,那么新建的文件用户组与目录的用户组相同,而非用户的用户组</span><br><span class="line"></span><br><span class="line">对于SGID在目录上的应用,我总结一下:</span><br><span class="line"></span><br><span class="line">**当权限外用户,具有r,x权限(对目录)后,可获得目录用户组的支持,而且,W权限的操作,为目录用户组所为**</span><br><span class="line"></span><br><span class="line">**SGID这个特殊权限对于文件的作用不谈,但是对于目录的特殊权限太重要了**</span><br><span class="line"></span><br><span class="line">**尤其是在,进行项目目录的构建时,设置SGID权限,则项目成员所完成的项目文件同属一个用户组,方便管理**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### SBIT 特殊权限</span><br><span class="line"></span><br><span class="line">**这个权限目前只对目录有效,当&quot;t&quot;出现在others中时,即为SBIT**</span><br><span class="line"></span><br><span class="line">&gt; 当用户对此目录具有w,x权限时,该用户便具有了写入的权限</span><br><span class="line"></span><br><span class="line">&gt; 当用户在该目录下创建文件或者目录时,只有自己和root用户才有权限进行删除操作</span><br><span class="line"></span><br><span class="line">那么，SBIT特殊权限意义何在呢？</span><br><span class="line"></span><br><span class="line">**同上理，在进行项目组的开发时，同一用户组的成员进行协作，在同一目录下进行工作**</span><br><span class="line"></span><br><span class="line">**任何用户都可以再次目录里进行新建和修改文件，但是只有文件创建者和root才有权限进行删除**</span><br><span class="line"></span><br><span class="line">**这样，是不是很方便呢？**</span><br><span class="line"></span><br><span class="line">##### 特殊权限的修改</span><br><span class="line"></span><br><span class="line">看过上面的内容,你应该了解特殊权限的巨大作用了吧?</span><br><span class="line"></span><br><span class="line">那么,特殊权限如何修改</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ chmod abcd 文件```  abcd为文件权限的权值</span><br><span class="line"></span><br><span class="line">之前的权限修改是 chmod+xyz,那么现在再加上一个数字用于特殊权限的修改不就好了</span><br><span class="line"></span><br><span class="line">权值: SUID--4 , SGID--2 , SBIT--1</span><br><span class="line">![](http://img.blog.csdn.net/20170617190947715?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br><span class="line">如上图所示,给目录添加了SBIT权限,SUID,SGID权限的修改同理</span><br><span class="line"></span><br><span class="line">**有没有发现,第一次修改后,test目录的SBIT权限为&quot;T&quot;?**</span><br><span class="line"></span><br><span class="line">&gt; 这是因为,test的权限为1644,它没有可执行权限x,当修改特殊权限SBIT时,</span><br><span class="line"></span><br><span class="line">&gt; 没有可执行权限,t也就不复存在了,所以&quot;T&quot;含义是&quot;空&quot;</span><br><span class="line"></span><br><span class="line">&gt; SUID,SGID中的&quot;S&quot;同理,表示空</span><br><span class="line"></span><br><span class="line">当然进行特殊权限的修改时,也可以使用符号</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ chmod u+s/g+s/o+t  文件</span><br></pre></td></tr></table></figure><hr><h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><p>对于一个文件,我们可以使用<figure class="highlight ls"><figcaption><span>-l 文件```来显示他的所有属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是,如果只是要知道文件类型,使用file命令更方便呢!</span><br><span class="line"></span><br><span class="line">```[EVilcrow@Evilcrow]$ file  文件/目录</span><br></pre></td></tr></table></figure></p><p><img src="http://img.blog.csdn.net/20170617191046282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>如上图所示,file命令可以清楚的知道每一个文件/目录的类型</p><h3 id="2-命令与目录的查询"><a href="#2-命令与目录的查询" class="headerlink" title="2. 命令与目录的查询"></a>2. 命令与目录的查询</h3><p><em>前面提到的都是文件/目录的操作,查阅,修改权限.你首先要能做到的是查阅文件</em></p><h4 id="2-1-脚本文件明的查询"><a href="#2-1-脚本文件明的查询" class="headerlink" title="2.1 脚本文件明的查询"></a>2.1 脚本文件明的查询</h4><h4 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h4><p>用于查找脚本文件(简单来讲,查找名令)</p><figure class="highlight plain"><figcaption><span>which [-a] command```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">which用于查找命令所在目录位置,当然这就扯到之前的PATH,which是在PATH中查找命令</span><br><span class="line"></span><br><span class="line">所以有时候需要进行更新内容才能显示出来,</span><br><span class="line"></span><br><span class="line">&gt; -a ,次参数,可以将command在PATH中的所有路径显示出来,并非只是最先找到路径</span><br><span class="line"></span><br><span class="line">**注:既然说了是在PATH中寻找路径,那么,不再路径中的目录肯定就是找不到的了!**</span><br><span class="line"></span><br><span class="line">**别惊讶,这样的command可是不少的呢!**</span><br><span class="line"></span><br><span class="line">_ _ _</span><br><span class="line"></span><br><span class="line">#### whereis与locate 命令</span><br><span class="line"></span><br><span class="line">上面的which是脚本命令的查找,那么接下来就是文件的查找了</span><br><span class="line"></span><br><span class="line">进行文件的查找,所需要的命令是whereis与locate命令</span><br><span class="line"></span><br><span class="line">```[Evilcrow@Evilcrow]$ whereis [-bmsu] 文件/目录名</span><br></pre></td></tr></table></figure><blockquote><p>-b 表示仅查找二进制的文件</p></blockquote><blockquote><p>-m 仅查找再说明文件manual下的文件</p></blockquote><blockquote><p>-s 仅查找source源文件</p></blockquote><blockquote><p>-u 查找其他类型的文件</p></blockquote><p><code>[Eilcrow@Evilcrow]$ locate [-ir] keyword</code></p><blockquote><p>-i 忽略大小写的差异</p></blockquote><blockquote><p>-r后面可接正则表达式的形式</p></blockquote><p>以上即为whereis与locate的用法</p><p><strong>但是,请注意,whereis与locate查找的依据是各自的数据库!!!</strong></p><p><strong>意即,有时你会查找到删除了的文件,有时也会查找不到新建的文件,这就</strong></p><p><strong>需要更新数据库了 updatedb</strong></p><p><code>updatedb</code>:根据/etc/updatedb.conf的设置进行数据库内容的更新</p><p><code>locate</code>:依据/var/lib/mlocate内的数据记载,找出用户输入的关键字文件名</p><p><strong>让我来理解,即wheris与locate的搜索很快,但是需要更新数据库</strong></p><p>接下来,介绍find命令,</p><hr><h4 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h4><p>上面说的whereis与locate命令并非是在硬盘中查找数据,而是在各自得数据库中查找</p><p><strong>然而,find命令,就是在硬盘中进行文件查找的命令</strong></p><p><code>[Evilcrow@Evilcrow]$ find [PATH] [option] 文件/目录名</code> find命令</p><p>这里为什么不再格式里写上find命令的参数呢?</p><p><strong>因为find,功能强大,它的参数太多了 !</strong></p><blockquote><p>1.与时间有关的参数(atime,stime,mtime),下面以mtime进行说明</p></blockquote><blockquote><p>-mtime n:n为数字,表示在n天之前的那个”一天之内”所修改过时间的文件名</p></blockquote><blockquote><p>-mtime -n:列出n天之内(包括n天在内),修改过文件时间的文件名</p></blockquote><blockquote><p>-mtime +n:列出n天以上(不含n天在内),修改过文件时间按的文件名</p></blockquote><p><strong>注:n = 0表示目前的时间</strong></p><p><strong>其中,请切身体会,n,+n,-n三种不同时间限定所带来的文件搜索不同,</strong></p><p><strong>并且,时间搜索,还有atime与stime,同mtime理</strong></p><blockquote><p>2.与用户和用户组有关的参数</p></blockquote><blockquote><p>-uid n: 第四章详解</p></blockquote><blockquote><p>-gid n: 同上</p></blockquote><blockquote><p>-user name:  搜索特定目录下,name用户的文件</p></blockquote><blockquote><p>-group name:  搜索特定目录下,name用户的文件</p></blockquote><blockquote><p>-nouser   :寻找文件的所有者不在,系统文件中记录的内容</p></blockquote><blockquote><p>-nogroup  :同上(用户组)</p></blockquote><p><strong>最后的两个参数很适合去查找一些不太正常的文件或者目录出来</strong></p><blockquote><p>3.与权限有关的参数</p></blockquote><blockquote><p>-name filename :按照文件名查找文件</p></blockquote><blockquote><p>-size [+-] SIZE:查找比SIZE大(+)小(-)的文件,SIZE的单位有,B,K</p></blockquote><blockquote><p>-type TYPE :查找文件类型为TYPE的文件,-,d,l,s,p等</p></blockquote><blockquote><p>-perm mode:查找文件权限恰好为mode的文件</p></blockquote><blockquote><p>-perm -mode:”查找文件权限比需要全部包含mode的文件”</p></blockquote><blockquote><p>例如:-perm -755,则777符合条件</p></blockquote><blockquote><p>-perm +mode:”查找文件权限包含任一mode权限的文件”</p></blockquote><blockquote><p>例如:perm +755,则701也符合要求</p></blockquote><p><strong>事前谈到过的,特殊权限SUID,SGID,SBIT,同样也是可以用在这里的,比如:4755</strong></p><blockquote><p>4.一些特别的参数:</p></blockquote><blockquote><p>-exec command: command为其他的命令,-exec,接其他的命令用来处理查找的结果</p></blockquote><blockquote><p>-print   ：将处理的结果打印到屏幕上</p></blockquote><p>举个例子：</p><p><code>[Evilcrow@Evilcrow]$ find / -perm +7000 -exec ls -l { } \;</code>则</p><p>这条命令表示在根目录下查找权限含任一7000的文件，并将它的文件信息ls -l显示出来</p><p><strong>上例中，{}表示查找到的内容，－exec一直到＼都是关键字，在其中间的就是额外命令</strong></p><p><strong>而且，重要的是，可以使用通配符进行查找操作，十分方便，同时，多重参数互相组合，更方便</strong></p><p><strong>最后一点，不到最后时刻，find命令真的很费时，因为它是直接在硬盘中进行搜索</strong></p><hr><h3 id="3-权限与命令间的关系"><a href="#3-权限与命令间的关系" class="headerlink" title="3.权限与命令间的关系"></a>3.权限与命令间的关系</h3><p><em>此处的内容十分关键，请认真对待</em></p><blockquote><p>使用户拥有进入目录的权限，使用CD命令</p></blockquote><p><strong>至少需要对该目录有ｘ权限，如果需要读取目录中的文件，则必须要有ｒ的权限</strong></p><blockquote><p>使用户具有在目录内读取文件的权限，可使用cat,more,less命令</p></blockquote><p><strong>如果是读取目录，至少需要ｘ权限，对于文件，需要ｒ权限</strong></p><blockquote><p>使用户具有修改一个文件的权限vi,vim,nano,emacs</p></blockquote><p><strong>如果是目录，需要ｘ权限，如果是文件，至少需要ｒ，ｗ权限</strong></p><blockquote><p>使用户具有创建文件的权限，如mkdir,touch</p></blockquote><p><strong>对于目录需要有ｗ，ｘ权限，重要的是ｗ权限，因为没有ｘ权限，无法进入目录</strong></p><blockquote><p>使用户具有进入一个目录并执行目录下文件的权限</p></blockquote><p><strong>对目录，至少要有ｘ权限，对于文件至少要有ｘ权限，已知文件名的情况下，可以没有ｒ（目录）权限</strong></p><p><strong>以后内容十分重要，需认真进行分析理解</strong></p><hr><p><em>这一篇的内容也到此为止了，到现在Linux系统中的文件/目录从配置到操作，到分析查阅就结束了</em></p><p><em>从下一篇开始，就是磁盘与文件系统的管理了，下次再见　！</em></p><p>06/17/2017</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第三篇 磁盘分区问题</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E4%B8%89%E7%AF%87%20%20%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E4%B8%89%E7%AF%87%20%20%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><em>本章的主要内容是关于磁盘分区的硬件知识，其中涉及了许多我在自己进行装机时所遇到的问题</em></p><p><em>有兴趣的朋友，可以去看看我之前那篇装系统的博客，<a href="http://blog.csdn.net/e_vilcrow/article/details/72620481" target="_blank" rel="noopener">传送门</a></em></p><p><strong>强调一个很重要的观念：在Linux系统中，一切皆文件，包括硬件设备也是文件</strong></p><p>举个栗子：</p><p>IDE硬盘      /dev/ha[a-d]</p><p>SATA硬盘   /dev/sa[a-p]</p><p>U盘       /sdv/sa[a-p]</p><p><strong>一切的设备，文件，只要是计算机的内容都被系统视为文件！</strong></p><p>磁盘分区的问题：</p><p>磁盘的连接方式与设备文件名关系：</p><p>比如有两个IDE接口，则应名为 hda,hdb,又因为存在主设备与从设备，即(Master)(Slave)，如下表：</p><table><thead><tr><th>IDE</th><th>Master</th><th>Slave</th></tr></thead><tbody><tr><td>IDE1</td><td>/dev/hda</td><td>/dev/hdb</td></tr><tr><td>IDE2</td><td>/dev/hdc</td><td>/dev/hdd</td></tr></tbody></table><p>从上表即可看出规律：首先对于设备优先命名，主设备在前，从设备在后，之后命名新设备</p><p>对于SATA接口的硬盘来说，先接先识别的设备先进行命名，例如USB设备，基本都是最后才能进行命名。</p><ul><li>磁盘的知识</li></ul><p>关于磁盘结构的知识，参考 <em>&lt;计算机科学导论&gt;</em> 进行理解。</p><p>每块磁盘，最重要的第一个扇区，记录了两个重要信息：<strong>主引导分区,分区表</strong></p><p>  比如：我的磁盘有两块，一块118GB的SSD，还有一块460GB的机械盘。至于C：D：E：这些都是后来的磁盘分区。</p><p>主引导分区：MBR 安装引导加载程序的地方，即开机引导程序，我在安装系统时遗漏掉的东西。</p><p>分区表：存储磁盘分区信息的状态的东西，类似于malloc二维数组时的第一步工作。</p><p>关于磁盘分区的重要信息：</p><ol><li><p>每次进行所谓“分区”操作时都是对64Byte的分区信息表进行操作。</p></li><li><p>磁盘默认的分区表只能有四组磁盘信息。（硬件问题）</p></li><li><p>四组磁盘分区，只能是主分区 + 扩展分区，且扩展分区最多只能有一个（操作系统的原因）</p></li></ol><p>即，可以是P+P+P+P（这样做，要是不把空间用完，则会造成空间浪费）,P+P+P+E的形式。</p><ol start="4"><li>分区的最小单位是柱面。</li></ol><p>使用磁盘分区表的必要性：</p><ol><li><p>处于安全性能的考虑</p></li><li><p>对系统性能的考虑。</p></li></ol><hr><p><strong>新概念：逻辑分区</strong></p><p>那么，要是四个分区不够用，别人还有10几个分区是怎么做到的呢？</p><p>牵扯到逻辑分区的概念。</p><p>对扩展分区，进行再分区，即为扩展分区</p><p>对于IDE 硬盘可分到59号，SATA只能分到11号</p><p><strong>而且，关键是,逻辑分区是基于扩展分区所分出来的，所以/dev/sd[?]的编号从5号开始</strong></p><p>而且，主分区与逻辑分区可以格式化，扩展分区无法格式化。对于同为主分区，或同为逻辑分区可以合并</p><p><strong>相对的，对于不同的分区是不能进行合并分区的！</strong></p><hr><ul><li>介绍开机的流程</li></ul><p>所谓开机，那么在还没有操作系统的时候，操作系统这个软件是怎么被识别的呢？</p><p>牵扯到BIOS与CMOS </p><p>CMOS中写入的是硬件的参数和嵌入主板上的存储器。</p><p>而BIOS则是，开机时所执行的第一个程序，会根据用户的设置</p><p>去寻找所能进行开机的硬盘，并且读取这个硬盘里的MBR程序，即开机引导程序，从而开机</p><p>而在这个MBR中存储的就是Boot Loader，可以加载内核文件的东西，从而实现开机。</p><hr><p><strong>Linux安装时，对磁盘的分区</strong></p><p>介绍概念：<br><strong>1.目录树概念</strong></p><p>在linux的系统中，有着<strong>“一切皆是文件”</strong>的思想。</p><p>而在系统中有着目录树的结构，以此来管理着整个系统，</p><p>其中，举以下例子来描述目录树：</p><blockquote><p>/   根目录，一般存储目录用</p></blockquote><blockquote><p>/home  家目录，一般存储用户数据</p></blockquote><blockquote><p>/usr  一般存储软件</p></blockquote><blockquote><p>/etc  一般存储配置文件</p></blockquote><p>就像以上所举的例子一样，目录树结构即可理解为，像树一样的目录，</p><p>一级一级延续下来。</p><p>比如文件的路径为：/home/etc/.vimrc即可</p><p><strong>2.挂载</strong></p><p>既然上面提到了Linux系统中是抽象为文件，目录树的概念，</p><p>然而，众所周知，数据是存在磁盘中的，那么这两者是如何联系起来的呢？</p><p>这就要牵扯到<strong>”挂载“</strong>的概念了。</p><p>所谓，挂载，意即，进入目录树系统的一个入口，即将某一个目录作为进入口。</p><p><strong>挂，即是将磁盘挂在某一个目录下。</strong></p><blockquote><p>不同于Win系统下，</p></blockquote><blockquote><p>在Linux系统下，磁盘挂载在哪里，其路径即在哪里，而在Win中，无论在哪里，都会有固定的盘符。会有固定的代号，而在Linux下是自由的。</p></blockquote><p><strong>寻找挂载点方法：反向追踪，寻找最早出现的目录，即为此磁盘的挂载点。</strong></p><p>了解了以上两个概念后，就来谈谈怎么进行磁盘分区了。</p><p>对于，初次安装的同学建议是，<strong>只分出/，/home即可。</strong></p><p>其他的分区，暂不建议接触，出现差错，则会导致安装失败。</p><blockquote><p>/usr 应用程序存放的地方，万一分配不足，就GG</p></blockquote><blockquote><p>/boot 引导加载程序的地方</p></blockquote><blockquote><p>swap 交换空间（物理内存中不常用的数据，会分配到硬盘内存中）</p></blockquote><p>之后的内容为：鸟哥进行服务器主机构建的内容，暂且不表。</p><p>June 3, 2017 3:32 AM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第七篇 Linux文件权限与目录配置(下)</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E4%B8%83%E7%AF%87%20Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE(%E4%B8%8B)/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E4%B8%83%E7%AF%87%20Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE(%E4%B8%8B)/</url>
      <content type="html"><![CDATA[<p>看了上一篇的文件权限后是不是觉得Linux系统十分神奇呢？</p><p>是不是感受到了被root账户支配的恐惧？！</p><p>上一篇说了那么多关于文件/目录的权限知识，那么，文件/目录下到底存储了怎样的文件？</p><p>你有没有兴趣了解呢？</p><p>那么，本篇，第七篇就是介绍在Linux中的目录配置问题。</p><p>其中有许多专业方面的文件，目前只做了解，以后会详细深入每一部分。</p><hr><p>首先来说说Linux下的文件种类和扩展名的问题</p><p>像上一篇中所讲,可以用 ls -l命令列出文件所有属性,在10字符中,第一个极为即为文件类型</p><p>文件类型分为, <strong>-,d,l,b,c,s,p,等</strong></p><p>其中最多的,肯定就是一般文件了</p><p><strong>普通文件</strong></p><p>[-],又可以分为<em>纯文本文件</em> 与 <em>二进制文件</em></p><p>纯文本文件中基本都是可以直接读出来的数字,字母等信息,可以使用cat命令</p><p>如<code>cat .vimrc</code></p><p>二进制文件,系统只认识二进制文件,比如你所使用的程序都是二进制文件,像上面的cat也是二进制文件</p><p><strong>目录</strong></p><p>[d],即为目录.接下来我们详述目录,可以近似的理解为”文件夹”</p><p><strong>连接文件</strong></p><p>[l],类似于Win中的”快捷方式”,有两种链接方式</p><p><strong>设备及设备文件</strong></p><p>因为在Linux中,一切皆为文件,所以设备也被抽象化为文件</p><p>分为块设备文件与字符设备文件</p><p>[b],表示系统随机访问的设备文件,sd<em>与hd</em></p><p>[c],表示字符设备文件,为串行端口接口设备,例如鼠标,键盘都是.</p><p><strong>套接字(sockets)</strong></p><p>通常用于网络数据连接,目前不详述</p><p><strong>管道(FIFO,pipe)</strong></p><p>为一种特殊的文件类型,解决多个程序同时访问一个文件造成的错误上</p><ul><li>扩展名</li></ul><p>如上一篇所讲,<strong>扩展名在Linux系统中只是为了标明文件的属性,与文件能否执行无关!!!</strong></p><p><strong>而-x也只是决定有无执行的可能,能否执行成功与能否执行无关</strong></p><p>最后:Linux文件名的限制,</p><p>一般情况下,建议不要使用* ? &gt; &lt; ; &amp; ! \ ‘ “ ` (  )  {  }等符号作文件名</p><p><strong>因为这些符号,在命令行行中是有其他特殊意义的!</strong></p><hr><p>Linux下的目录配置</p><p>之前说过，Linux只是Linus Torvalds先生所编写的系统内核，</p><p>所谓的“Linux系统”实质上是<code>Linux内核 + 软件包 + 各种工具</code>的Linux Distribution。</p><p>那么，问题来了，各种的Linux发行版系统差别有多大？</p><p>每个人的Linux系统差这么多，怎么进行交流？</p><p>就目前而言，Redhat与Debian系占比很高，另外还有Arch Linux独领风骚</p><p>那么，这么多个系统的差别到底在哪里？</p><hr><p>当时进行开发的虚拟团队，肯定是考虑到这一点的，那么，他们是怎么处理的？</p><p>这就要提到，<strong>Linux系统的目录配置标准：FHS</strong></p><p>所谓“FHS”即是 <strong>Filesystem Hierarchy Standard</strong>(文件系统配置标准)</p><p>因为进行Linux Distribution即开发的个人，团体太多了</p><p>如果你更换一个版本的Linux系统，就需要重新学习Linux系统的目录配置，</p><p>岂不是很麻烦？？？</p><p>所以制定了FHS，这个Linux下，目录配置文件标准，以此来进行目录配置规范</p><p>据FHS官方文件指出：</p><blockquote><p>其主要目的是，希望用户可以了解到已安装的软件通常放置在那个目录下，所以希望独立软件的开发商，操作系统的制作者，以及想要维护系统的用户，都能够遵循FHS的标准</p></blockquote><p>也即是，<strong>FHS实质上重点在于规范系统在什么样的目录下应该放置什么样的文件数据</strong></p><p>这样做，真的十分便于进行Linux系统的其他工作</p><p>FHS根据文件使用的频繁度和更新度，划分了下面四个标准</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">可分享的</th><th style="text-align:center">不可分享的</th></tr></thead><tbody><tr><td style="text-align:center">不变的</td><td style="text-align:center">/usr(软件放置)</td><td style="text-align:center">/etc(配置文件)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">/opt(第三方软件)</td><td style="text-align:center">/boot(开机与内核文件)</td></tr><tr><td style="text-align:center">可变动的</td><td style="text-align:center">/var/mail(邮件)</td><td style="text-align:center">/var/run(程序相关)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">/var/spool/news</td><td style="text-align:center">/var/lock(程序相关)</td></tr></tbody></table><p>通过以上一览表，可以了解到Linux中文件的四种交互作用形态。</p><p>其中所举例的，是其中比较特色，典型的目录文件，之后会详解。</p><p>现在来分析那四个交互作用形态：</p><p><strong>1.可分享的</strong></p><p>所谓可分享的，之可以分享给其他系统挂载的目录，了解过“挂载”的概念，相信你能理解</p><p>可分享的意思了吧，就是指这部分文件，是可以分享给他人看的。</p><p>比如可以分享给网络上主机挂载的目录等。</p><p><strong>2.不可分享的</strong></p><p>所谓不可分享的，指的是与自己程序相关，这些都是只与你自己的电脑有关的东西</p><p>当然也就不适合，也不方便拿出来分享了。</p><p><strong>3.不变的</strong></p><p>所谓不变的，指的是不会随着发行版的不同而发生改变的文件，比如函数库，/lib中的文件</p><p>这些都是不随Linux发行版的改变而改变的文件，如内核文件。所以算作是不变的</p><p><strong>４.可变动的</strong></p><p>所谓可变动的指的是经常改变的文件，比如登录信息，新闻组等。</p><hr><p><strong>事实上，FHS标准对于Ｌinux系统的目录配置文件，只定义了三层目录配置：</strong></p><blockquote><p>/ (root)目录：与开机系统有关</p></blockquote><blockquote><p>/usr目录：与软件安装/执行有关</p></blockquote><blockquote><p>/var目录：与系统运作过程有关</p></blockquote><p>下面一个一个目录来详解：</p><p>/ ：根目录，也可以叫做root目录　与开机系统有关的文件</p><p>/,根目录，是Linux系统中最重要的一个目录了！</p><p>所有的目录都是由根目录所衍生出来的，而且根目录还与机器的开机，还原，系统修复有关</p><p>所以，</p><blockquote><p>FHS建议：<br>根目录/，所在的分区越小越好，而且应用程序安装的软件最好不要与根目录放在同一个分区下<br>，保证根目录越小越好。如此不但性能较好，根目录所在的文件系统也不容易发生问题。</p></blockquote><p>鉴于以上的建议：根目录下应该存在这样的目录：</p><table><thead><tr><th style="text-align:center">目录　　</th><th style="text-align:center">　　　　　应放置的文件内容　　　　　</th></tr></thead><tbody><tr><td style="text-align:center">/bin</td><td style="text-align:center">/bin放置的是在单用户模式下还可以操作的命令</td></tr><tr><td style="text-align:center">/boot</td><td style="text-align:center">/boot中存放内核文件以及开机配置文件　　　</td></tr><tr><td style="text-align:center">/dev</td><td style="text-align:center">之前讲一切皆文件，/dev目录下都是设备文件</td></tr><tr><td style="text-align:center">/etc</td><td style="text-align:center">系统的主要配置文件都存放在此处　　　　　</td></tr><tr><td style="text-align:center">/home</td><td style="text-align:center">home目录即为用户目录　　　　　　　　　　</td></tr><tr><td style="text-align:center">/lib</td><td style="text-align:center">系统开机时所用到的函数库　　　　　　　　</td></tr><tr><td style="text-align:center">/media</td><td style="text-align:center">“媒体”，指软盘，光盘等设备　　　　　　　</td></tr><tr><td style="text-align:center">/mnt</td><td style="text-align:center">用于暂时挂载的目录　　　　　　　　　　　</td></tr><tr><td style="text-align:center">/opt</td><td style="text-align:center">用于给第三方软件放置的目录　　　　　　　</td></tr><tr><td style="text-align:center">/root</td><td style="text-align:center">系统管理员目录　　　　　　　　　　　　　</td></tr><tr><td style="text-align:center">/sbin</td><td style="text-align:center">可以视为“service”，网络服务数据目录　</td></tr><tr><td style="text-align:center">/tmp</td><td style="text-align:center">　一般用户或者暂时放置数据的地方　　　　</td></tr></tbody></table><p><img src="http://img.blog.csdn.net/20170610190836877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>上面只是大体上的目录介绍，现在进行详细的　/根目录　内容介绍，</p><p><strong>/bin</strong>　  (binary)</p><p>如上面所说，放置的是单用户模式下还可以被操作的命令，即指在一些特殊情况下，比如系统</p><p>崩坏，出现故障时，还可以使用的命令,如，cat,chmod,chown,date,mv,mkdir,cp,bash等。</p><p><strong>/boot</strong></p><p>其中主要包括开机时会使用到的文件，包括内核文件</p><p><strong>注意：内核文件夹名为vmlinuz，请谨慎对待！</strong></p><p><strong>/etc</strong>     (etceteras)</p><p>其中放置的是几乎所有主要的系统配置文件，例如个用户的账号信息，服务的起始文件，</p><p>一般用户可以查阅，只有root可以修改这些文件！</p><p><strong>FHS建议不要放置可执行文件在此目录！！！</strong></p><p><strong>/dev</strong>  (device)</p><p>其中一切的设备和接口都是以文件的形式存在的，通过访问文件来访问设备</p><p>比较重要的有：/dev/null, /dev/tty, /dev/hd<em>, /dev/sd</em>.</p><p><strong>/home</strong></p><p>其中　～：表示本用户的主文件夹</p><p>～XXXX:表示XXXX用户的主文件夹(非本用户进行访问)</p><p><strong>/lib</strong></p><p>放置开机和/bin, /sbin目录中的命令成功使用所需要的函数库，</p><blockquote><p>将函数库理解为”外挂“，只有调用他们，才能正常运行－－鸟哥</p></blockquote><p><strong>/opt</strong></p><p>即放置第三方软件的地方</p><p><strong>/root</strong></p><p>根据之前的笔记,你应该对root这个名字不陌生了吧?</p><p>那么,root文件夹为什么要放在根目录下呢? ? ?</p><p>这是因为,一旦系统出现问题,保证还可以进入root管理员用户,来进行系统的修复.</p><p><strong>/sbin</strong></p><p>其中包括了<strong>开机,修复,还原系统所需要的命令</strong>,十分重要!</p><p><strong>/tmp</strong></p><p>此目录下放置的是任何人都可以查看的暂存数据,所以,重要数据不能放在此目录下</p><p>而且FHS建议:在开机时,应该将/tmp目录下的数据全部删除!</p><p><strong>FHS标准中,对于/root目录只定义了以上的几个目录,但是Linux系统中一般还会有下面的几个重要目录</strong></p><p>这也是需要我们了解的:</p><p><strong>/lost+found</strong></p><p>此目录下是使用标准的ext2/ext3/ext4日志文件系统格式在会产生的一个目录</p><p>目的在与文件系统发生错误时,将一些丢失的片段放在该目录下</p><p><strong>/proc</strong></p><p>该目录是一个虚拟的文件系统,他放置的数据都是在内存当中的,例如系统的内核,进程,</p><p>外部设备的状态,网络状态等,</p><p><strong>注:因为该目录是在内存中,所以不占据任何硬盘空间!</strong></p><p><strong>/sys</strong></p><p>这个目录类似于/proc,同样不占据硬盘空间! ,其中存放着已加载的内核模块和</p><p>内核监测到的硬件设备信息等</p><p>上图即为 / 根目录下的目录信息</p><p><strong>注意:开机过程中,仅仅只有根目录会被挂载,其他的分区是在开机完成之后才挂载上去的</strong></p><p><strong>所以,注定有一些目录是必须在/目录下的,不能分开!</strong></p><p>这些目录是:</p><ul><li><p>/etc:配置文件</p></li><li><p>/bin:重要执行文件</p></li><li><p>/dev:所需要的设备文件</p></li><li><p>/lib:执行文件所需要的函数块与内核所需要的模块</p></li><li><p>/sbin:重要的系统执行文件</p></li></ul><hr><p>接下来介绍/usr目录,<strong>/usr目录是与软件的安装/执行有关的目录</strong></p><p>/usr目录下所存放的是<strong>可分享的</strong>与<strong>不可变动的</strong>数据文件</p><p>usr的缩写并非是”user”而是<strong>“UNIX Software Resource”</strong></p><p>而且,建议,所有的软件应该合理的配置在/usr下的子目录里,而并非自行新建子目录</p><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">应放置的文件内容</th></tr></thead><tbody><tr><td style="text-align:center">/usr/X11R6/</td><td style="text-align:center">为X Windows系统重要数据放置目录</td></tr><tr><td style="text-align:center">/usr/bin/</td><td style="text-align:center">绝大部分的用户可使用命令都在此处</td></tr><tr><td style="text-align:center">/usr/include/</td><td style="text-align:center">C/C++的头文件,包含文件都在此处</td></tr><tr><td style="text-align:center">/usr/lib/</td><td style="text-align:center">各类应用软件的函数库,目标文件以及一些非惯用的执行文件或脚本</td></tr><tr><td style="text-align:center">/usr/local/</td><td style="text-align:center">用户自行安装的软件都在此处,区别于发行版自带的软件</td></tr><tr><td style="text-align:center">/usr/sbin/</td><td style="text-align:center">非系统正常运行所需要的系统命令</td></tr><tr><td style="text-align:center">/usr/share/</td><td style="text-align:center">放置共享文件</td></tr><tr><td style="text-align:center">/usr/src/</td><td style="text-align:center">一般源码存放在这里,而内核源码存放在/usr/src/linux下</td></tr></tbody></table><p><img src="http://img.blog.csdn.net/20170610190900586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>以上即为/usr下的配置目录</p><p><strong>显然./usr与/下有不少相同的目录,接下来就看看他们的区别:</strong></p><blockquote><p>/bin 与 /usr/bin</p></blockquote><p>/bin是根目录下的目录,其与开机过程有关,所以要放在开机时就挂载的/目录下</p><p>/usr/bin 中存放的也是一般用户所能用到的大多数命令,但是与开机过程不挂钩</p><blockquote><p>/lib 与 /usr/lib</p></blockquote><p>/lib中放置的是在开机时首先会用到的函数库</p><p>/usr/lib中放置的则是各种应用软件的函数库,不一定开机时会用到!</p><blockquote><p>/sbin 与 /usr/sbin</p></blockquote><p>/sbin中存放的是超级用户 root一般使用的命令放置着系统管理所必须的程式</p><p>/usr/sbin中放置的则不一定是系统正常运行所必须的系统指令</p><blockquote><p>/opt与 /usr/local</p></blockquote><p>/opt在根目录下,存放第三方软件,即并非发行版Linux安装时就装的软件</p><p>/usr/local,系统管理员在本机的软件,<strong>是不是会想起每次安装软件,都要sudo yum/apt-get?</strong></p><p>一般经由root安装的软件都放置于此,所以,实质上</p><p><strong>你的软件大部分都是在/usr/local这个目录下的! ! !</strong></p><hr><p>接下来,谈谈最后一个FHS标准规定的配置目录/var (variable)</p><p><strong>/usr是安装时会占据大空间的目录,/var是安装完系统后才会渐渐增大空间的目录</strong></p><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">放置的文件内容</th></tr></thead><tbody><tr><td style="text-align:center">/var/cache/</td><td style="text-align:center">应用程序本身产生的缓存文件</td></tr><tr><td style="text-align:center">/var/lib</td><td style="text-align:center">程序运行时需要的数据放置的目录</td></tr><tr><td style="text-align:center">/var/lock</td><td style="text-align:center">程序锁,对于只能同时一个用户使用的程序上锁,防止两人同时使用</td></tr><tr><td style="text-align:center">/var/log</td><td style="text-align:center">登录文件放置的目录</td></tr><tr><td style="text-align:center">/var/mail</td><td style="text-align:center">个人信箱的目录</td></tr><tr><td style="text-align:center">/var/run</td><td style="text-align:center">程序的PID放置目录</td></tr><tr><td style="text-align:center">/var/spool</td><td style="text-align:center">通常放置一些队列数据</td></tr></tbody></table><blockquote><p>　小建议，在读完基础篇之后，可以挑战FHS官方文档</p></blockquote><p><img src="http://img.blog.csdn.net/20170610190918758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>FHS只规定了/，/usr，/var三个目录的标准，所以各个版本的Linux Distribution</p><p>在一些小细节上有些差异，用户在使用前阅读说明文档即可。</p><hr><p>以上所介绍的即为FHS规定所制定的Linux系统目录配置标准,</p><p>那么,有了这样一个目录,整个Linux中的文件系统是怎么样的呢?</p><p><strong>目录树</strong></p><p>目录树具有以下特性:</p><ul><li><p>目录树的起点是根目录(/,root)</p></li><li><p>没一个目录不只能使用本地的文件系统,还可以挂载网络上的主机</p></li><li><p>每一个文件在目录树在中的文件名(包括完整路径,4096个字符)<strong>是独一无二的!</strong></p></li></ul><p>接下来,Linux文件系统的目录树结构如图:<br><img src="http://img.blog.csdn.net/20170610191204276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>看了上图,就可以理解Linux中的文件系统了吧?</p><p>接下来,我从Win与Linux的文件系统的差别来谈<strong>目录树结构</strong></p><blockquote><p>Win大家都使用过,磁盘有着明确的分区,分区有着明确的盘符,进入分区好的硬盘进行文件查找</p></blockquote><blockquote><p> 十分方便,Win的文件系统更便于我们进行理解,</p></blockquote><blockquote><p>硬盘 -&gt; 分区磁盘 -&gt; 文件数据</p></blockquote><blockquote><p>但同时,Win这样处理不方便进行文件的管理,以后系统中的垃圾越来越多,杂乱</p></blockquote><p>相对的,再来看Linux文件系统的配置</p><blockquote><p>Linux中是,先存在一个<strong>虚拟文件系统</strong>,对没错,这个虚拟文件系统就是<strong>目录树</strong></p></blockquote><blockquote><p>在Linux中进行文件查看是这样的</p></blockquote><blockquote><p>虚拟文件系统 -&gt; 挂载硬盘 -&gt; 分区 -&gt;文件数据</p></blockquote><blockquote><p>所有进行的操作都是基于虚拟的文件系统,</p></blockquote><p>看过上面的分析,你现在应该能理解目录树这个晦涩一点文件系统了吧!</p><p>但是,问题又来了,<strong>目录树,硬盘哪个先,哪个后呢?</strong></p><p>这个问题就像鸡,蛋到底先有哪个? !这如果继续分析下去,就……</p><p>但是,Linux系统很巧妙地解决了这个问题,</p><p><strong>就是,使用内存!,当你使用内存时,开机时,首先在内存中有这个虚拟的文件系统,之后的工作就好做了</strong></p><p>现在,对于<strong>挂载</strong>,相信你也有更多的了解了吧,因为如果没有挂载,虚拟的文件系统是无法读出你的数据的! ! !</p><hr><p><strong>下面讨论一个问题,可以帮助你更透彻的了解Win与Linux系统文件系统区别</strong></p><p>就是”FHS中明确建议,/目录尽可能的小,但是在目录树中,./是开始的目录,按理说,/不应该是最大的么”</p><p>这个问题,可以这样理解</p><blockquote><p>之前提过,Linux系统使用虚拟的文件系统,就是说,无论怎样变,每个Linux系统都会</p></blockquote><blockquote><p>有这样一个虚拟的文件系统,就像上面的图一样,而实际进行系统使用时,</p></blockquote><blockquote><p>需要对,磁盘和目录进行匹配,挂钩,即<strong>挂载</strong>,</p></blockquote><blockquote><p>FHS标准的意思是,对/根目录挂在载一个小的分区里面,尽可能小的容量</p></blockquote><blockquote><p><strong>即可以这样理解,在Linux系统中,目录上有母子关系的东西,在实际硬盘上可能相差甚远</strong></p></blockquote><blockquote><p><strong>而这与Win下就是不同的,Win下,比如C:\Windows下存在system32文件夹</strong></p></blockquote><blockquote><p><strong>那么,Windows文件夹一定比System32所占内存大,即在Win中上下级目录</strong></p></blockquote><blockquote><p><strong>不仅仅只有目录层面上的包含,在物理内存方面也是包含的关系!</strong></p></blockquote><hr><p>最后,在讲完了目录配置的内容后,你一定迫不及待的想试试了吧!</p><p>让我来给你说说<strong>路径</strong>的内容</p><p>路径分为<strong>绝对路径 ,相对路径</strong></p><p>绝对路径:必须以/根目录开始,比如访问home中的test目录</p><p>/home/Evilcrow/test</p><p>相对路径:不以/根目录开始,而是相对于当前目录进行目录访问,比如进行test目录访问</p><p>cd Evilcrow/test   (当前是在home目录下)</p><p><strong>简单而言,开头不是/即为相对路径</strong></p><p>绝对路径,不管你当前在哪一级目录下都可以进行访问</p><p>另外,在每个目录下都存在:</p><p><strong>. 表示当前目录</strong></p><p><strong>.. 表示上一级目录</strong></p><p>关于Linux系统下目录配置的内容至此结束,有不对的地方,请指正.</p><p>PS:另外我有一个问题,</p><p>在鸟哥的书中讲到/bin与/usr/bin中文件的区别,意即这是两个文件夹,</p><p>但是我在ls -l根目录后,发现/bin为连接文件,即/bin与/usr/bin是为同一个目录<br><img src="http://img.blog.csdn.net/20170610191431853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRV92aWxjcm93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>这又怎么解释呢? ? ?</p><p>June 10, 2017 7:04 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一篇 计算机概论</title>
      <link href="/2017/09/22/Linux/%E7%AC%AC%E4%B8%80%E7%AF%87%20%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/"/>
      <url>/2017/09/22/Linux/%E7%AC%AC%E4%B8%80%E7%AF%87%20%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p><em>本章主要内容是对计算机基础知识的了解，涉及一部分的计算机硬件知识，及一些装机知识</em></p><ul><li>计算机</li></ul><p>计算机的定义：接受用户输入的数据，进行数据与逻辑单元运算处理并输出信息的工具。</p><p>计算机主要分为三部分：</p><p>输入单元：鼠标，键盘，触控板，扫描仪之类。</p><p>中央处理器：指CPU，含有，算术逻辑处理，控制，记忆单元。</p><p>输出单元：屏幕，打印机为主。</p><p>计算机处理数据的流程：输入 ——&gt;内存———&gt;输出,其中，CPU从内存中读取数据，硬盘也从内存中读取数据并保存</p><p>很关键的一点：<strong>CPU只要是需要处理数据，必须从从内存中进行数据的读取。硬盘存储数据也必须经过内存。</strong></p><p><strong>可以将内存理解为中转交换位置。</strong></p><hr><p>接下来，进行个部分的详细注解：</p><ul><li><strong>CPU</strong></li></ul><p>首先，CPU分为两类，RISC (精简处理指令集）与 CISC(复杂处理指令集)</p><p>详解：</p><p>RISC </p><p>每条指令简单高效，执行时间短，效率高，但进行复杂操作时，操作指令异常多。</p><p>Sun公司SPARC系列 ，IBM的PA及PowerPC，ARM系列。</p><p>用于：大型工作站中，高效，快捷。PS3中的Cell处理器以及各种手机米，交换机等都是ARM处理器。</p><p>CISC </p><p>每条指令相较较为复杂，但每条指令可以处理的工作比较丰富，若进行简单操作时，所耗时间较长。</p><p>AMD ，Intel开发的处理器</p><p>主要用于个人计算机，</p><hr><p>x86架构的由来：</p><p>Intel最早开发出来的此类处理器命名为8086，此后便一直沿用这种叫法。此种架构的计算机，统称x86架构。</p><p>x86_64架构的由来：</p><p>Intel开发了此类处理器后，位数从8，16到32位，由AMD开发出了64位处理器，从此，统称x86_64架构。</p><p>i368与x86_64的用法：</p><p>主要用于软体32与64位的区别，软件版本可向下兼容。i386与x86_64名称上的区别。</p><hr><ul><li>接口设备</li></ul><p>因为两种CPU的架构不同，所以也衍生出了两种不同的主板架构</p><p>1.</p><p>Intel主板架构：存在北桥，南桥。</p><p>北桥用于连接：显卡，内存与CPU</p><p>南桥用于连接：各种接口，插槽之类的，速度较北桥缓慢</p><p>2.</p><p>AMD主板架构与Intel主板架构的区别：</p><p>AMD主板架构直接将内存与CPU连接，不通过北桥，理论上加快了两种设备之间数据传输的速度，</p><p>将内存控制组件集成至CPU。</p><p>注：CPU的外频与倍频：  </p><p>外频，指CPU与外部组件进行交换和数据运算的速度，倍频指CPU内部用来进行加速的频率</p><p>CPU的频率 = 外频 x 倍频。而“超频”指的是：玩家自己使CPU的外频/倍频通过主板设定提高的一种方式</p><p>从而达到提高频率的目的，一般而言，倍频是固定的，进行超频的，一般是外频。</p><hr><p>浅谈：CPU的32位与64位，</p><p>CPU的位数指的就是，CPU进行数据运算时每次所能传输数据的位数，即总线宽度</p><p>同时，北桥的总线称为系统总线，南桥为I/O总线，北桥的速度称为，前端总线速度，FSB</p><p>即，总线频宽 = FSB x 总线频宽（32/64）；</p><p>CPU每次能处理的数据大小，称为字组大小，字组大小有32位/64位。</p><p>注，字组大小可以和总线宽度不相同，架构的名称以CPU的字组大小为准。</p><hr><ul><li><strong>内存</strong></li></ul><p>在主板上，内存插槽中间的突起物上有防误插操作，</p><p>介绍内存的类型：</p><p>1.</p><p>DRAM（动态随机访问内存）Dynamic</p><p>也即挥发性内存，在通电时可以使用，断电后，所有的数据会消失。</p><p>现在产生了 DDR SDRAM内存，相比于SDRAM，DDR的好处在于，双倍内存传输速度</p><p>理论上：内存速度越大，系统的运行速度会越快。</p><p>如果内存小，则必须等待此段数据释放后才能进行下次的存储与释放，会影响系统速度。</p><p>双通道设计：加快速度，类似于双卡交火之类，尽量容量，型号都相同最佳。</p><p>2.</p><p>SRAM（静态随机访问内存） Static</p><p>使用大量晶体管，价格高，速度快，一般用于CPU访问一些核心数据时，将此集成在CPU上用于访问数据。</p><p>3.</p><p>以上都是可以进行数据读写的内存，接下来是只读存储器ROM</p><p>举个例子：BIOS，就是存储在只读存储器中的，</p><p>ROM是不会再断电后被擦除的，所以每次开机都能访问到并运行BIOS ，但是ROM为只读属性，无法进行修改。</p><p>也因此，之后出现了，EEPROM之类的，可擦除，修改的东西。详情，见计算机科学导论。</p><hr><ul><li>显卡,硬盘等内容</li></ul><p>此处介绍不够详细，仅为基础了解，建议去研读计算机科学导论。</p><hr><ul><li>关于软件与操作系统</li></ul><p>操作系统中最关键的就是内核，而内核是控制计算机硬件之间的相互调用的工具，内核用来控制硬件，</p><p>所以用户如果要编写调用硬件的软件，就需要参考内核，因此衍生出了系统调用，即System Call </p><p>而内核 + 系统调用 = 操作系统</p><p>再介绍一个概念：驱动程序</p><p>操作系统可是使用很长时间，几年甚至十多年，那么，新产生的硬件，操作系统如何进行辨认并调用？</p><p>这就牵扯到驱动程序了，驱动程序可以用来使操作系统调用并管理新产生的硬件。</p><p>操作系统与应用程序的关系：只有操作系统时，计算机并不能完成什么任务，可以说，有了操作系统</p><p>计算机便做好了进行工作，并执行任务的准备，要执行用户的任务，则必须牵扯到应用程序的调用。</p><hr><p>最后说一点有意思的事情：</p><p>市面上，无论是买U盘，买硬盘都会有买回来的东西，实际容量小于目标容量的情况</p><p>原因在于：计算容量时，所采用的是进位运算是1024，而实际操作时时1000的换算。</p><p>所以有16GB的U盘，使用时是14.4GB的情况。</p><p>并非厂家骗人，而是因为硬盘的区间的原因，扇区512Byte的原因。</p><hr><p>注：此章所有的问题都可以在计算机硬件知识里得到解决，推荐书籍：计算机科学导论！</p><p>Date:2017/05/24 21:40</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux系统装机</title>
      <link href="/2017/09/22/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%20(%E9%92%88%E5%AF%B9Fedora%E4%B8%8EUbuntu%EF%BC%89/"/>
      <url>/2017/09/22/Linux/Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%20(%E9%92%88%E5%AF%B9Fedora%E4%B8%8EUbuntu%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><strong>写在前面</strong></p><p>我想向大家来分享一下我在安装Linux系统是的一下经验</p><p>首先，我注明，我所安装过的是<strong>Ubuntu 16.04</strong>与<strong>Fedora 25</strong></p><ul><li>对于安装前的一些基础知识的准备</li></ul><p>BIOS + MBR 以及 UEFI+GPT</p><p>这两个东西怎么怎么的，理论知识我也没有搞清楚，具体也讲不清。</p><p>但是就是因为这东西，<strong>使得在2010年之后的本子上装Linux的系统成为了一个大问题</strong></p><p>接下来我来说一下如何进行Linux系统的安装:</p><hr><h4 id="一-，前期的准备工作"><a href="#一-，前期的准备工作" class="headerlink" title="一 ，前期的准备工作"></a>一 ，前期的准备工作</h4><ol><li><p>一块至少8G的U盘，理论上4G也是可以用的，但是建议至少8G</p></li><li><p>从fedora官网或者Ubuntu官网下载的iso镜像文件</p><p> fedora（<a href="http://https://getfedora.org/" target="_blank" rel="noopener">http://https://getfedora.org/</a>）</p><p> Ubuntu（<a href="http://www.ubuntu.org.cn" target="_blank" rel="noopener">http://www.ubuntu.org.cn</a>）</p></li><li><p>合理的可启动U盘制作工具（手动滑稽）</p><p> 强烈推荐<strong>rufus</strong>！</p></li><li><p>具有一定的动手能力</p></li></ol><hr><h4 id="二，实际安装的过程"><a href="#二，实际安装的过程" class="headerlink" title="二，实际安装的过程"></a>二，实际安装的过程</h4><hr><p>以下分为两个版本，分别对应早期的本子无UEFI版，和现在的UEFI启动版</p><p><strong>无UEFI启动版</strong></p><ol><li><p>先去戳度娘，查询自己的本子，BIOS的进入快捷键，一般也就是F2，F8，Esc，Enter之类的</p><p> 然后，右击”计算机“，点击”管理“，</p><p> 在”磁盘管理“中，”压缩卷“分出一定的空间来进行系统安装，一般建议60G左右即可</p><p> <strong>注意，只需要”压缩卷“，不需要”新建卷“，系统安装时需要的是未分配的空间。</strong></p></li><li><p>使用上面推荐的rufus U盘制作工具进行Linux系统可启动U盘的制作</p><p> <strong>详细步骤，戳度娘，此处不赘述如何进行可启动U盘的制作</strong></p></li><li><p>顺利进入BIOS设置，（在某些BIOS固件版本中，可以设置中文）</p><p> 然后首先将secure boot 改为<strong>disabled</strong></p><p> 之后更改启动引导选项为<strong>legacy only</strong></p><p> 按F10 保存并退出</p><p> 然后插上你的U盘，并重启，按下F12，进入启动选项</p><p> 选择自己的U盘作为启动选项，<strong>可以通过名字找到自己的U盘</strong></p></li><li><p>此时，你应该已经进入可移动U盘中的内容了吧，</p><p> 别得意，下来的设置也是需要仔细处理的</p><p> 有两个选项，<strong>try Ubuntu /try Fedora</strong></p><p> 和<strong>install Ubuntu/Fedora to hard drive</strong></p><p> 可以先进行系统的体验再进行安装，也可以直接进行安装到硬盘的操作</p></li><li><p>选择之后，进入了语言，键盘，地区时间，主机名的设定，这些大家自己一一设置即可了</p><p> 最关键的地方来了  <strong>分区选择</strong></p><p> 讲道理，如果是小白，建议选择<strong>自动分区</strong></p><p> 否则，有你好受的</p><p> 如果是老油条了，其实可以进行进行分区自己的调整，</p><p> 比如<strong>/boot  /bios burg  /home  swap  /</strong>等分区可以进行自己的计划和调整</p><p> 关键的是，<strong>启动引导器的安装位置</strong>需要进行十分小心的甄选，</p><p> 不然系统安装完成后，要不然Windows无法启动，要不然没有linux系统的启动引导选项</p><p> 我知道来看这篇文章的都是想装双系统的同学-&gt; &lt;-（手动滑稽）</p><p> 此处注意：<strong>选择启动器的安装位置时，建议挂载到/boot或者windows的/efi目录下</strong></p><p> <strong>如果这样继续提醒grub2引导无法安装，要不然重装选择自动分区，否则可以在windows目录下</strong></p><p><strong>使用EasyUEFI 或者EasyBCD两个工具进行启动项的修复，</strong></p><p><strong>可以进行正常的引导因为刚接触Linux操作系统所以不是很清楚如何在Linux中使用终端进行启动项修复，请见谅</strong></p></li><li><p>在分区进行了合理的划分之后，就可以进行安装了呦！ <strong>~o~</strong></p><p> 另外，再注意的一点是，对于 Root密码与用户密码的设置需要谨慎处理</p></li><li><p>最后，在系统安装完成后进行重启就可以使用系统了呦</p></li></ol><p><strong>UEFI启动版</strong></p><p>如果是支持UEFI启动版的，直接按F12，进行启动项的选择即可</p><p>其余步骤同理</p><p>比如，fedora 25的安装</p><p><strong>我自己偏好使用Fedora，滑稽  -&gt; &lt;-</strong></p><hr><h4 id="三，我自己安装过程中所遇到的问题"><a href="#三，我自己安装过程中所遇到的问题" class="headerlink" title="三，我自己安装过程中所遇到的问题"></a>三，我自己安装过程中所遇到的问题</h4><hr><ol><li><p><strong>合理的可启动U盘制作工具</strong></p><p> 我安装的经历是，自己安装个了两次Fedora，帮舍友安装了Ubuntu（很不幸，舍友的电脑是先被我搞崩，才装好的）</p><p> 然后我第一次安装时，运气好装好了，但因为镜像有点下问题准备重装，然后就拉闸了，无法安装</p><p> 就差没把度娘戳死了，也没找到有效的解决办法。</p><p> 所以，<strong>Ultraiso 基本不要尝试，坑了不少新人</strong>，（并非抹黑此软件，</p><p> 只是在Linux系统安装时不方便，对于Windows系统的镜像安装还是很不错的</p><p> 然后，<strong>poweriso，还可以，但也只是对于Ubuntu支持比较好</strong>，如果要装Fedora，还是算了，看运气</p><p> Fedora，在网上给出的方法已经是让，先装Ubuntu，再使用dd命令，在Linux环境下制作Fedora的启动盘</p><p> 然后，雪上加霜的是，Fedora社区官方给出的可启动U盘制作工具，<strong>在win10下就是个笑话</strong>，</p><p> 有的人支持，有的人不支持，就像我。</p><p> 而之后重装时所遇到的问题更是让我这种刚开始的小白无言以对，</p><p> <img src="http://i.imgur.com/oIs8s4b.jpg" alt="错误"></p><p> 很久以前的方法，也能解决问题，但是我觉得不是很轻松，直到发现了<strong>rufus</strong></p><p> 那么如果想要进行Fedora在Win平台下的启动盘制作就没有办法了吗？？？</p><p> <strong>方法还是有的：rufus 真的是神器！</strong></p><p> 让我安利一口，700k大小，支持各种格式的启动盘制作，而且是开源软件，因为下载源是国外，所以速度较慢，需要耐心等待</p></li><li><p><strong>对于小白，我真的很建议采用自动分区，毕竟玩的没意思了，以后还可以换其他的使用，</strong></p><p>  <strong>Linux不装个10次，不能说自己装过机</strong></p></li><li><p><strong>卸载问题</strong></p><p> 我在上面说，我卸载过，那么怎么才能卸载的干干净净呢？</p><p> 方法还是有的，对于用来装Linux的盘，直接删除卷即可，不需要多操作，</p><p> <strong>问题就在于，如何处理无效的启动引导项，每次开机看见无用的引导项，很不爽的QAQ</strong></p><p> 那么，就再让我安利一个软件，<strong>easyUEFI</strong>，类似与easyBCD,但是我觉得要比easyBCD更好用</p><p> 对无效的开机启动引导项的删除即可</p></li></ol><hr><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><hr><p>首先很抱歉，本教程，没有多少的截图</p><p>本篇安装Linux系统的经验分享到这里就结束了，我自己也了解的不是很多，如果有错也希望大家能过来指正</p><p>另外，本篇的经验，基本上只适用于Ubuntu 与Fedora，其他的Linux发行版我还没有尝试过</p><p>诸如：<strong>deepin  debian  arch  redhat  Linuxmint</strong></p><p>最近在进行Linux系统初装后的配置，大家也可以来一起交流</p><p>我也只是刚开始接触Linux，也希望大家多来和我交流</p><p>编辑时间： 2017/5/19 2:54:35<br>发表时间： 2017/5/22 2:05:23</p><hr><p><strong>更新:</strong></p><p>今天帮二蛋学姐的同学装机,才彻底使我真真切切的理解了装机时的设定</p><p>之前其实也只是听说了,Bios,UEFI,MBR,GPT这些东西.</p><p>但是,在装了这一台机子后,我是真的快被搞死了,这机子TM的,真的是在搞我</p><p>几年前的Bios,MBR分区,</p><p>首先教给大家鉴别MBR分区,GPT分区</p><p><img src="http://oww4cv296.bkt.clouddn.com/2.jpg" alt=""></p><p><strong>如果现在显示的是”转换为MBR分区”,那么现在就一定是GPT分区喽</strong></p><p>第二,教给大家鉴别UEFI启动和传统的Bios</p><p><img src="http://oww4cv296.bkt.clouddn.com/%E6%8D%95%E8%8E%B7.JPG" alt=""></p><p><img src="http://oww4cv296.bkt.clouddn.com/1.JPG" alt=""></p><p>首先通过以上两步,便可以确定到,一会使用Rufus进行写盘的方式了!</p><p>这里,安装系统,我是份推荐使用写盘工具—rufus,十分方便又好用</p><p>之后,按照rufus操作便可以正式进行写盘了,</p><p><strong>使用合理的写盘方式进行写盘,是成功安装系统的关键之一</strong></p><hr><p>在安装系统时,可能最常见的一个问题就是,<strong>启动项消失,丢失的情况</strong></p><p>在这里,我先谈谈我的经历吧!</p><p>在装完系统后,我打开机子,结果只有CentOS的启动项,咦? !</p><p>之后,我便使用<strong>bootice</strong>将启动项改回Win的传统启动,而不使用grub2进行引导</p><p>这TM才开始坑了……</p><p>使用bootice修改后,可以使用EasyBCD,或者EasyUEFI进行启动项修改</p><p><strong>但是,太年轻了,Easy*系列进行启动项的修改后,基本用不了,,,</strong></p><p>这时,还得使用grub2进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>你会发现结果启动项<strong>并没有什么改变</strong>,</p><p>2333333333!</p><p><strong>因为Linux不支持NTFS文件系统,而Win是基于NTFS的,所以上面的命令</strong></p><p><strong>基本上没有什么卵用,那么,没有办法了吗?</strong></p><p><strong>办法还是有的,毕竟前人已经为我们造好了轮子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install netf-3g</span><br></pre></td></tr></table></figure><p>安装这个包后,再使用grub2的命令,就会有奇迹发生!</p><p>(<strong>注:以上方法对CentOS Linux7适用,已测试,其他发行版,差别不大</strong>)</p><p>September 26, 2017 10:49 PM</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
