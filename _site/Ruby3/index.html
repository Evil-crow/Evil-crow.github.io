<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css"> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title>Ruby学习笔记(三) &#8211; Road to Coding</title> <meta name="description" content="只要那一抹笑容尚存, 我便心无旁骛"> <meta name="keywords" content="Ruby"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="Ruby学习笔记(三)"> <meta name="twitter:description" content="OOP程式设计语言,肯定是少不了关于类的介绍,我也是第一次接触OOP,就来聊聊类"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="Ruby学习笔记(三)"> <meta property="og:description" content="OOP程式设计语言,肯定是少不了关于类的介绍,我也是第一次接触OOP,就来聊聊类"> <meta property="og:url" content="http://localhost:4000/Ruby3/"> <meta property="og:site_name" content="Road to Coding"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <link rel="canonical" href="http://localhost:4000/Ruby3/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Road to Coding Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="Road to Coding photo" class="author-photo"> <h4>Road to Coding</h4> <p>只要那一抹笑容尚存, 我便心无旁骛</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:evilcrow486@gmail.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/Evil-crow" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://localhost:4000/posts/">All Posts</a></li> <li><a href="http://localhost:4000/tags/">All Tags</a></li> </ul> </li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn" style="background-color:rgba(255,255,255,0.97);"> <div class="content"> <div class="post-title "> <h1>Ruby学习笔记(三)</h1> <h4>06 Feb 2018</h4> <a class="btn zoombtn" href="http://localhost:4000/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <p><em>类是Ruby作为面向对象语言的特征之一,模块又是Ruby的特色花样之一,就来聊聊这两方面内容吧</em></p> <h2 id="一-类-class">一 类 (class)</h2> <p>类是面向对象中,定义对象的数据与行为的结构</p> <p>类就像是对象的雏形或设计图,决定了对象的行为</p> <h3 id="1-常见类方法">&lt;1&gt; 常见类方法</h3> <p>下面介绍几个常用的方法:</p> <ol> <li> <p>类方法: new方法</p> <p>既然对象是类的实例,那么,类便提供了,创建对象的方法,即为new方法</p> <p>同时,数值类,字符串类,数组可以使用字面量来进行初始化</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span>
 <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s2">"asa"</span><span class="p">]</span>
 <span class="n">c</span> <span class="o">=</span> <span class="mi">123</span>
 <span class="n">d</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">new</span>
 <span class="nb">p</span> <span class="n">d</span> <span class="c1">#=&gt; {}</span>
 <span class="nb">p</span> <span class="n">a</span> <span class="c1">#=&gt; []</span>
</code></pre></div> </div> </li> <li> <p>实例方法: class方法</p> <p>既然每个对象都是类的实例,那么如何判断改对象的类,使用class方法,可以判断出对象的类</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
 <span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
 <span class="nb">p</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">class</span> <span class="c1">#=&gt; "Hash"</span>
 <span class="nb">p</span> <span class="n">array</span><span class="p">.</span><span class="nf">class</span> <span class="c1">#=&gt; "Array"</span>
</code></pre></div> </div> </li> <li> <p>实例方法: instance_of?</p> <p>用于判断某个对象是否属于某方法,和以前的约定一样返回值为真假的以”?”结尾</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
 <span class="nb">p</span> <span class="n">array</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>   <span class="c1">#=&gt; true</span>
 <span class="nb">p</span> <span class="n">array</span><span class="p">.</span><span class="nf">instance_of?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>  <span class="c1">#=&gt; false</span>
</code></pre></div> </div> </li> </ol> <h3 id="2-继承">&lt;2&gt; 继承</h3> <p>继承是类中很重要一个概念</p> <p><strong>继承 : 通过扩展已定义的类来创建新的类</strong></p> <p>那么,继承有什么作用呢?</p> <ol> <li> <p>再不影响原有类功能的前提下,追加新的功能</p> </li> <li> <p>可以重定义父类中的功能,使名称相同的方法产生不同的结果</p> </li> <li> <p>在已有的功能上,追加新的处理,扩展已有功能</p> </li> </ol> <p><strong>新创建的类叫子类(subclass),被继承的类叫父类(superclass)</strong></p> <p><strong>注意: Ruby不支持父类的多重继承,即一个类只能继承一次,只能有一个父类,Ruby保证了单一继承关系</strong></p> <p><strong>那么,有时候就是需要多个类的功能该怎么办,后面自有办法,使用模块(module)</strong></p> <p><strong>Basicobject类shiRuby中最最基础的类,仅仅包含了作为一个类最低限度的方法</strong></p> <p><strong>所以,Ruby中一般默认的继承类是Object类,我们可以看看这两个类中方法的比较</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="no">BasicObject</span><span class="p">.</span><span class="nf">instance_methods</span>
<span class="c1">#=&gt; [:!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]</span>

<span class="nb">p</span> <span class="no">Object</span><span class="p">.</span><span class="nf">instance_methods</span>
<span class="c1">#=&gt; [:remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :public_send, :instance_variable_defined?, :singleton_method, :instance_variable_set, :method, :public_method, :extend, :define_singleton_method, :to_enum, :enum_for, :&lt;=&gt;, :===, :=~, :!~, :eql?, :respond_to?, :freeze, :inspect, :object_id, :send, :display, :to_s, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variable_get, :instance_variables, :!, :==, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]</span>
</code></pre></div></div> <p><strong>而我们一般创建类时,默认的继承类是Object类,所以,这个类就不能再继承其他类了,</strong></p> <p><strong>违背单一继承的规则,会抛出异常</strong></p> <p>下面是一张Ruby中常见类的继承关系图</p> <p><img src="http://owzoakbc5.bkt.clouddn.com/Screenshot_20180207_182032.png" alt="" /></p> <p>现在,再介绍一种方法,用来辨别继承关系</p> <p>4.is_a?方法</p> <p>is_a? 方法用来辨别接收者是否是参数的子类</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="no">Array</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Object</span><span class="p">)</span>  <span class="c1">#=&gt; true</span>
<span class="nb">p</span> <span class="no">Array</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>  <span class="c1">#=&gt; false</span>
<span class="nb">p</span> <span class="no">Array</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>   <span class="c1">#=&gt; false</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nb">p</span> <span class="n">a</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>       <span class="c1">#=&gt; true</span>
</code></pre></div></div> <h3 id="3-类的创建">&lt;3&gt; 类的创建</h3> <p>上面说了那么多,类的创建是怎么做的呢?</p> <p>类定义的语法</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="n">class_name</span>
  <span class="n">class_definition</span>
<span class="k">end</span>
</code></pre></div></div> <p>其中需要介绍的一个是,<strong>initialize方法</strong></p> <p>类创建一个对象的new方法,就是以initialize方法进行定义的</p> <p><strong>虽然调用的是new方法,但是再类的定义中就是用的initialize方法</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HelloWorld</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span> <span class="o">=</span> <span class="s2">"Ruby"</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>   
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"Hello I'm </span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">m</span> <span class="o">=</span> <span class="no">HelloWorld</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"SinCrow"</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="no">HelloWorld</span><span class="p">.</span><span class="nf">new</span>
<span class="n">m</span><span class="p">.</span><span class="nf">hello</span>   <span class="c1">#=&gt; Hello I'm SinCrow</span>
<span class="n">n</span><span class="p">.</span><span class="nf">hello</span>   <span class="c1">#=&gt; Hello I'm Ruby</span>
</code></pre></div></div> <p>上面的例子中,new方法便是由initialize方法定义的,传参也是同一道理</p> <h4 id="31-实例变量与实例方法">3.1 实例变量与实例方法</h4> <p>之前总是说实例变量,实例方法.到底是怎么使用的呢?</p> <p><strong>1.实例变量,就是在类的定义中,@var形式的变量,可以在类的实例方法中通用</strong></p> <p><strong>算是类中实例方法间的全局变量,只要在同一个实例中,就可以超越方法的局限,任意引用,修改实例变量</strong></p> <p><strong>2.实例方法,顾名思义,实例才能调用的方法,即对象的方法</strong></p> <p><strong>备注: 不同的实例的实例变量值是可以不同的,而且这些实例变量都是存在的,只要实例存在,就不会消失</strong></p> <p><strong>反观,局部变量的作用域,生命周期都是在方法中,只能在方法内部使用,方法调用结束,局部变量释放</strong></p> <h4 id="32-存取器">3.2 存取器</h4> <p>那么,现在就有一个问题,关于在实例方法中的实例变量,既然是在类中定义的,随着实例存在</p> <p>如果,需要使用实例变量怎么办呢?</p> <p>很容易就可以构建下面的两个实例方法</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HelloWorld</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">myname</span> <span class="o">=</span> <span class="s2">"Ruby"</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="n">myname</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="vi">@name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">name</span><span class="o">=</span><span class="p">(</span><span class="n">modify_name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="n">modify_name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>其中需要注意的是,<strong>name=方法,一定是紧紧相连的,不然就不能定义为方法名</strong></p> <p>但是,很没意思啊,整天都要些存取器的内容,每个实例变量都要写,所以Ruby提供了定义方法</p> <table> <thead> <tr> <th>存取器</th> <th>作用</th> </tr> </thead> <tbody> <tr> <td>attr_reader</td> <td>读方法(name方法)</td> </tr> <tr> <td>attr_writer</td> <td>写方法(name=方法)</td> </tr> <tr> <td>attr_accessor</td> <td>皆有</td> </tr> </tbody> </table> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">attr_reader</span> <span class="ss">:a</span>
<span class="nb">attr_writer</span> <span class="ss">:b</span>
<span class="nb">attr_accessor</span> <span class="ss">:c</span><span class="p">,</span> <span class="ss">:d</span>
</code></pre></div></div> <p>这样定义就可以了,用法相当于直接调用name方法与name=方法</p> <h4 id="33-self变量">3.3 self变量</h4> <p>介绍一个十分特殊的变量,<strong>self变量</strong></p> <p>以前就提到过,Ruby是完全的面向对象,</p> <p>实际上,在顶部,是main对象,平时调用的函数式方法也是有接收者的</p> <p>只不过是不在意接收者的信息,实际上函数式方法的接收者,就是self</p> <p><strong>我不清楚Java的this指针与self有何区别</strong></p> <p><strong>但是,Ruby是解释性语言,所以,他的self严格的与上下文息息相关</strong></p> <p><strong>self变量,其实就是指当前的层次</strong></p> <p>来看看,下面的例子</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="nb">self</span>    <span class="c1">#=&gt; main</span>

<span class="k">class</span> <span class="nc">SelfTest</span>
  <span class="nb">p</span> <span class="nb">self</span>    <span class="c1">#=&gt; SelfTest</span>
  
  <span class="k">def</span> <span class="nf">method_test</span>
    <span class="nb">p</span> <span class="nb">self</span>   <span class="c1">#=&gt; #&lt;SelfTest:0x0000000001c48500&gt;</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">m</span> <span class="o">=</span> <span class="no">SelfTest</span><span class="p">.</span><span class="nf">new</span>
<span class="n">m</span><span class="p">.</span><span class="nf">method_test</span>
</code></pre></div></div> <p><strong>对于最外层顶部来讲,就是main,</strong></p> <p><strong>对于类来讲,就是类名</strong></p> <p><strong>对于实例方法来讲,就是本实例,而本实例是存在于内存上的,所以就是地址了</strong></p> <p>那么,self变量有什么用呢?</p> <p><strong>可以进行变量自身的调用,而且,可以隐式调用,Ruby缺省条件下,接收者就是self</strong></p> <p>看下面这个例子:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hello</span>
  <span class="nb">attr_accessor</span> <span class="ss">:name</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">myname</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="n">myname</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"Hello ,My name is </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>实例方法中的hello,获取到,name变量的值,但是,name并不是传进来的参数</p> <p><strong>而且,这个方法是没有Bug的!</strong></p> <p><strong>其实这个name是 #{self.name},换成{@name}也是可以的</strong></p> <p>那么,平时调用函数式方法,是不是也可以加上self呢?</p> <p><strong>答案是,不行!,函数式方法,多为private(私有)方法,必须是隐式调用</strong></p> <p><strong>注意: 调用写方法的时候,不能隐式调用,必须显式调用,不然会有很诡异的事情发生呦,来看下面的例子</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">name</span> <span class="o">=</span> <span class="s2">"hello"</span>   <span class="c1">#=&gt; name视为变量</span>
<span class="nb">self</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="s2">"hello"</span>  <span class="c1">#=&gt; name= 视为写方法</span>
</code></pre></div></div> <p>这样懂了吧? (滑稽)</p> <h4 id="34-类方法">3.4 类方法</h4> <p>我们在这里就不多纠缠了,类方法就是给类对象使用的方法</p> <p><strong>对,实际上我们区分方法按照接收者去区分</strong></p> <p><strong>但是,实际上,Ruby所有的方法都应该叫做实例方法,每一个对象都有类</strong></p> <p><strong>类方法调用者(接收者)是类,各个类,都是Class类的实例对象</strong></p> <p>下面介绍4种Ruby类方法的定义形式</p> <ol> <li> <p>单例方法形式</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="err">在</span><span class="k">class</span> <span class="nc">HelloWorld</span><span class="err">已存在条件下</span>

 <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="no">Hello</span>
   <span class="k">def</span> <span class="nf">hello</span>
     <span class="nb">puts</span> <span class="s2">"I'm Class method"</span>
   <span class="k">end</span>
 <span class="k">end</span>
</code></pre></div> </div> </li> <li> <p>class上下文中,引用self形式</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Hello</span>
   <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
     <span class="k">def</span> <span class="nf">hello</span>
       <span class="nb">puts</span> <span class="s2">"Class method"</span>
     <span class="k">end</span>
   <span class="k">end</span>
 <span class="k">end</span>
</code></pre></div> </div> </li> <li> <p>显式标明类名,进行实例方法形式的定义</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Hello</span>
   <span class="k">def</span> <span class="nc">Hello</span><span class="o">.</span><span class="nf">name</span><span class="p">(</span><span class="n">myname</span><span class="p">)</span>
     <span class="nb">puts</span> <span class="s2">"my name is </span><span class="si">#{</span><span class="n">myname</span><span class="si">}</span><span class="s2">"</span>
   <span class="k">end</span>
 <span class="k">end</span>
</code></pre></div> </div> </li> <li> <p>等效于3,类名可以用self变量取代,但是,self切记不能省略,<strong>不然会视为实例方法</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Hello</span>
   <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">name</span>
     <span class="nb">puts</span> <span class="s2">"My name is Ruby"</span>
   <span class="k">end</span>
 <span class="k">end</span>
</code></pre></div> </div> </li> </ol> <p>虽然提到了四种定义的形式,准确的来讲应该是三种,其中<strong>第四种用的最多,单例方法的形式,重复量太大</strong></p> <p><strong>而将,类方法以实例方法的形式定义,很方便</strong></p> <p><strong>后面还会有通过模块的方法进行类方法定义,也是很方便的方法</strong></p> <p><strong>备注: class « 类名 ~ end 的写法为单例类定义,其中的方法是单例方法,后面会详解</strong></p> <h4 id="35-常量">3.5 常量</h4> <p>类中肯定也是可以定义常量的,一般常量为大写,通过”::”进行访问,类似于类方法的访问</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hello</span>
<span class="no">VERSION</span> <span class="o">=</span> <span class="s2">"v1.0"</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">Hello</span><span class="o">::</span><span class="no">VERSION</span> <span class="c1">#=&gt; "v1.0"</span>
</code></pre></div></div> <h4 id="36-类变量">3.6 类变量</h4> <p>类变量,类似于实例变量,是在整个类的实例方法间都可以任意引用,修改的变量</p> <p><strong>但是,区别于实例变量,类变量是子类继承后仍然能够存在的变量,存储期更长</strong></p> <p><strong>实例变量,是随着实例对象存在而存在.那么,类变量就是随着类对象存在而存在</strong></p> <p><strong>@@class_var是存在于类中的,所以几个实例对象,是共享这个类变量的</strong></p> <p><strong>,但是,类变量定义存取器,不能使用attr系列方法,attr系列只能给实例变量使用</strong></p> <p>可以看看下面的例子:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hello</span>
  <span class="vc">@@hello_count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nb">attr_accessor</span> <span class="ss">:name</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">myname</span> <span class="o">=</span> <span class="s2">"Ruby"</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="n">myname</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"my name is </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
    <span class="vc">@@hello_count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">count</span>
    <span class="vc">@@hello_count</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="no">Hello</span><span class="p">.</span><span class="nf">new</span>
<span class="n">b</span> <span class="o">=</span> <span class="no">Hello</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"NIOH"</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="no">Hello</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Uncharted"</span><span class="p">)</span>
<span class="nb">p</span> <span class="no">Hello</span><span class="o">::</span><span class="n">count</span>   <span class="c1">#=&gt; 0</span>
<span class="n">a</span><span class="p">.</span><span class="nf">hello</span>
<span class="nb">p</span> <span class="no">Hello</span><span class="o">::</span><span class="n">count</span>   <span class="c1">#=&gt; 1</span>
<span class="n">b</span><span class="p">.</span><span class="nf">hello</span>
<span class="nb">p</span> <span class="no">Hello</span><span class="o">::</span><span class="n">count</span>   <span class="c1">#=&gt; 2</span>
<span class="n">c</span><span class="p">.</span><span class="nf">hello</span>
<span class="nb">p</span> <span class="no">Hello</span><span class="o">::</span><span class="n">count</span>   <span class="c1">#=&gt; 3</span>
</code></pre></div></div> <h4 id="37-修饰方法的关键字">3.7 修饰方法的关键字</h4> <p>曾经看过C,C种存在着,static关键字,可以用来修饰函数,使函数只能在本文件中调用,常说的:</p> <p><strong>具有内部链接的静态类型函数,链接,存储期,作用域是C中进行控制的几个关键点</strong></p> <p><strong>随着代码组织的不同,相应的关键字发生变化(hepangda说的,不是我说的)</strong></p> <p>在,Ruby中有这样三个修饰方法的关键字:<strong>public, private, protected</strong></p> <p>之前被国内的概念误导了很长时间,</p> <p><strong>他们死要纠缠访问与调用这两个概念, , ,</strong></p> <p>其实,这三个关键字分得很清楚,可以用下面几句话概括:</p> <p><strong>1. public以外的两类方法,都不能被显式的实例对象调用</strong></p> <p><strong>2. public方法为默认属性,可以任意访问调用,无论是类还是实例对象,或是同父类的实例对象</strong></p> <p><strong>3. protected方法相当于类之内的public方法,可以被随意调用,即所谓的被同父类的实例对象访问</strong></p> <p><strong>接上一条,也就是指可以在其他的方法中,调用protected方法,其他方法的实例对象是self</strong></p> <p><strong>4. private方法就更好说了,只能进行隐式的调用,即自身调用(self)</strong></p> <p><strong>即private是这个类进行私有实现所使用的,只能隐式的被self调用,不能显示地指定接收者</strong></p> <p><strong>要写,只能 private_method_test,不能obj.private_method_test</strong></p> <p><strong>有一句话,挺恰当的,private私有方法是内部实现所使用的,对其他的类(非同父类),实例都是不可见的</strong></p> <p>在Ruby社区提问,得到了这样比较好的答案</p> <p><del>访问和调用扯半天,真的是拖裤子放P</del></p> <h3 id="4-扩展类">&lt;4&gt; 扩展类</h3> <h4 id="41-给原有类添加方法">4.1 给原有类添加方法</h4> <p>很简单,就是定义和类名相同的类,如果是已存在的类,则会追加方法</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="nf">count_word</span>
    <span class="n">array</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/\s+/</span><span class="p">)</span>    <span class="c1">#=&gt; array = self.spilt(/\s+/)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">str</span> <span class="o">=</span> <span class="s2">"hello world"</span>
<span class="nb">p</span> <span class="n">str</span><span class="p">.</span><span class="nf">count_word</span> <span class="c1">#=&gt; 2</span>
</code></pre></div></div> <h4 id="42-继承">4.2 继承</h4> <p>前面说了很多次继承了,下面是继承的语法</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubClass</span> <span class="o">&lt;</span> <span class="no">SuperClass</span>
  <span class="n">class_definition</span>
<span class="k">end</span>
</code></pre></div></div> <p><strong>还是要提醒一点,Ruby缺省继承为Object类</strong></p> <h4 id="43-alias与undef">4.3 alias与undef</h4> <p>这两个关键字在其他语言中可能也用过</p> <p><strong>alias就是Linux中命令别名的命令,这里同义</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">alias</span>  <span class="n">new_name</span>    <span class="n">old_name</span>
<span class="k">alias</span> <span class="ss">:new_symbol</span> <span class="ss">:old_symbol</span>
</code></pre></div></div> <p><strong>undef在C中应该也是使用过的,用来取消命令别名</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">undef</span> <span class="err">方法名</span>
<span class="k">undef</span> <span class="p">:</span><span class="err">方法名</span>
</code></pre></div></div> <p>用来删除方法定义的,例如:我们可以在子类中删除不需要的父类方法定义,并且重新定义</p> <h3 id="聊一聊单例类">聊一聊”单例类”</h3> <p>之前,进行类方法的定义时说过,使用单例类的形式进行类方法的定义</p> <p>什么叫单例类?</p> <p><strong>单例类,指的就是,并非对类定义进行修改,只是针对这一个实例进行方法等的修改,只对这一个实例有效</strong></p> <p><strong>所以叫单例类,单例类中的方法叫单例方法</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str1</span> <span class="o">=</span> <span class="s2">"hello"</span>
<span class="n">str2</span> <span class="o">=</span> <span class="s2">"world"</span>
<span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">str1</span>
  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"I'm hello"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">str1</span><span class="p">.</span><span class="nf">hello</span> <span class="c1">#=&gt; "I'm hello"</span>
<span class="n">str2</span><span class="p">.</span><span class="nf">hello</span> <span class="c1">#=&gt; undefined method `hello' for "world":String (NoMethodError)</span>
</code></pre></div></div> <p>上面的例子即可说明hello方法对于同类实例str1与str2而言,只对str1有效,所以叫做单例方法</p> <p>那么,我们定义类方法,与单例(实例)又有什么关系呢?</p> <p><strong>这里就可以清晰地说明: Ruby中一切皆对象,类都是Class类的实例,所以使用单例方法,就是添加类方法</strong></p> <p>前面说过,Ruby部支持父类多重继承(没有Java diao,对吧?(滑稽))</p> <p>但是,Ruby却很好的处理了一定情况下的需求,靠得就是模块(module)</p> <p>下面,我们来仔细看看模块(module)</p> <h2 id="二-模块-module">二 模块 (module)</h2> <h3 id="1-模块的作用与意义">&lt;1&gt; 模块的作用与意义</h3> <p>模块为什么存在,从下面两点来说明:</p> <h4 id="11-提供命名空间">1.1 提供命名空间</h4> <p>之前其实一直没有注意过,但是,一旦工程量比较大的时候,命名空间就十分重要了.</p> <p>系统的讲,命名空间就是指<strong>对方法,常量,类的名称进行区分和管理的单位</strong></p> <p><strong>使用模块(module),天生进行命名空间的区分,互相不污染</strong></p> <p>举个简单的例子:</p> <p>很火爆的网络Web服务器Nginx</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">ngx_module_t</span> <span class="n">ngx_kqueue_module</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ngx_module_t</span> <span class="n">ngx_eventport_module</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ngx_module_t</span> <span class="n">ngx_devpoll_module</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ngx_module_t</span> <span class="n">ngx_epoll_module</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ngx_module_t</span> <span class="n">ngx_select_module</span><span class="p">;</span>


<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ngx_event_init_conf</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
<span class="k">static</span> <span class="n">ngx_int_t</span> <span class="n">ngx_event_module_init</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">);</span>
<span class="k">static</span> <span class="n">ngx_int_t</span> <span class="n">ngx_event_process_init</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ngx_events_block</span><span class="p">(</span><span class="n">ngx_conf_t</span> <span class="o">*</span><span class="n">cf</span><span class="p">,</span> <span class="n">ngx_command_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ngx_event_connections</span><span class="p">(</span><span class="n">ngx_conf_t</span> <span class="o">*</span><span class="n">cf</span><span class="p">,</span> <span class="n">ngx_command_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ngx_event_use</span><span class="p">(</span><span class="n">ngx_conf_t</span> <span class="o">*</span><span class="n">cf</span><span class="p">,</span> <span class="n">ngx_command_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ngx_event_debug_connection</span><span class="p">(</span><span class="n">ngx_conf_t</span> <span class="o">*</span><span class="n">cf</span><span class="p">,</span> <span class="n">ngx_command_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ngx_event_core_create_conf</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ngx_event_core_init_conf</span><span class="p">(</span><span class="n">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
</code></pre></div></div> <p>使用ngx作为统一的命名空间,当然这里只是举例子,实际上Ruby中使用模块可以避免命名空间冲突的问题</p> <p><strong>A模块中的foo方法,与B模块中的foo方法完全是两个方法</strong></p> <p>我们使用类似于<strong>调用类中的方法的放法来调用模块方法,模块名.方法名,也叫模块函数</strong></p><pre><code class="language-Ruby">FileTest.exist?("/usr?bin/ruby")
FileTest.size("/usr?bin/ruby")
</code></pre><p>如果,在当前命名空间中不与模块函数冲突,那么,可以使用include来省略模块名</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">include</span> <span class="no">Math</span>
<span class="n">sin</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="n">sqrt</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div></div> <p><strong>注意,一定是不发生命名空间冲突的时候,可以使用include进行命名空间的合并,反之,抛出异常</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sin</span>
  <span class="mi">5</span>
<span class="k">end</span>

<span class="kp">include</span> <span class="no">Math</span>
<span class="nb">p</span> <span class="n">sin</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>   
<span class="c1">#&gt; in `sin': wrong number of arguments (given 1, expected 0) (ArgumentError)from test.rb:6:in `&lt;main&gt;'</span>
</code></pre></div></div> <p><strong>这个错误,会在继承机制中进行解答,见下</strong></p> <h4 id="12-利用mix-in进行扩展">1.2 利用Mix-in进行扩展</h4> <p><strong>前面提到过,Ruby只支持单一父类继承,那么问题来了,如果碰到需要继承多个类的功能时怎么办?</strong></p> <p>答案是,<strong>使用模块来进行类功能的扩展</strong></p> <p>可以将模块作为通用功能的实现,来完成多个功能类似的类的扩展</p> <p><strong>Mix-in指的就是,将通用功能设计在模块中实现,之后include,则module的变量,方法都可以在类中使用</strong></p> <p>那么,套用前人总结的经验,一般Mix-in解决这两种问题:</p> <p><strong>1. 虽然两个类拥有相似的功能,但是不惜望将他们作为相同的类来考虑时</strong></p> <p><strong>2. Ruby不支持父类的多重继承,因此无法对已继承的类添加共通的功能的时候</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Mix</span><span class="o">-</span><span class="k">in</span> <span class="no">Example</span>
<span class="k">module</span> <span class="nn">MyModule</span>
  <span class="n">module_difinition</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MyClass1</span>
  <span class="kp">include</span> <span class="no">MyModule</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MyClass2</span>
  <span class="kp">include</span> <span class="no">MyModule</span>
<span class="k">end</span>
</code></pre></div></div> <h3 id="2-创建模块">&lt;2&gt; 创建模块</h3> <p>上面说了这么多,下面说说模块的用法吧</p> <p>首先,使用<strong>module</strong>关键字</p> <p>至于语法,与class是一致的</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">module_name</span>
  <span class="n">module_difination</span>
<span class="k">end</span>
</code></pre></div></div> <p>下面是一个模块的使用示范</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Hello</span>
  <span class="no">Version</span> <span class="o">=</span> <span class="s2">"v1.0"</span>
  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"Hello"</span>
  <span class="k">end</span>

  <span class="kp">module_function</span> <span class="ss">:hello</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">Hello</span><span class="o">::</span><span class="no">Version</span>    <span class="c1">#=&gt; "v1.0</span>
<span class="no">Hello</span><span class="p">.</span><span class="nf">hello</span>         <span class="c1">#=&gt; "Hello"</span>

<span class="kp">include</span> <span class="no">Hello</span>
<span class="nb">p</span> <span class="no">Version</span>           <span class="c1">#=&gt; "v1.0"</span>
<span class="n">hello</span>               <span class="c1">#=&gt; "Hello"</span>
</code></pre></div></div> <p>现在来说说上面中的一些之前没有见到过的东西</p> <h4 id="21-常量">2.1 常量</h4> <p>常量的用法同类中的常量(并非类变量)</p> <p><strong>模块中,不能出现类变量,实例变量(如有不懂,看前面)</strong></p> <h4 id="22-方法">2.2 方法</h4> <p>模块中的方法,定义是同类方法的</p> <p>但是,需要注意的是:</p> <p><strong>如果要想使模块函数对外可见,使其可以使用”模块名.方法名”的形式调用</strong></p> <p><strong>这里指的是,使用模块进行模块函数的调用,任何包含此模块的上下文都可以直接调用模块函数</strong></p> <p><strong>那么,一定要使用module_function方法,进行模块函数的声明,使其对外可见,参数是模块函数的符号名</strong></p> <p>另外,</p> <p><strong>模块方法中的self,是当前模块对象</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">HelloName</span>
  <span class="nb">p</span> <span class="nb">self</span>              <span class="c1">#=&gt; "HelloName"</span>
  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">p</span> <span class="nb">self</span>
  <span class="k">end</span>

  <span class="kp">module_function</span> <span class="ss">:hello</span>
<span class="k">end</span>

<span class="no">HelloName</span><span class="p">.</span><span class="nf">hello</span>       <span class="c1">#=&gt; "HelloName"</span>
</code></pre></div></div> <p><strong>区别于类的不同之处：类中的实例方法，self只当前的对象(实例,有实体)</strong></p> <p><strong>而模块函数中的self指模块对象,因为模块不具有实例</strong></p> <p><strong>但是,模块中的self一旦Mix-in之后,便表示类对象,所以,Mix-in一般不建议模块使用self</strong></p> <h3 id="3-mix-in">&lt;3&gt; Mix-in</h3> <p>聊聊Mix-in及其相关</p> <p>首当其冲的是,判断一个类是否Mix-in了某模块,使用include? 方法</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ClassName</span>
<span class="k">end</span>
<span class="no">ClassName</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>   <span class="c1">#=&gt; "true"</span>
</code></pre></div></div> <p>现在,就来说说一个很关键的,类的继承机制</p> <p><img src="http://owzoakbc5.bkt.clouddn.com/Screenshot_20180215_033346.png" alt="" /></p> <p><strong>在类中include的模块会做为虚拟的父类进行方法的继承,以及方法的查找</strong></p> <p>来看一个例子:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">TestModule</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">TestClass</span>
  <span class="kp">include</span> <span class="no">TestModule</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">TestClass</span><span class="p">.</span><span class="nf">ancestors</span>   <span class="c1">#=&gt; "[TestClass, TestModule, Object, Kernel, BasicObject]"</span>
<span class="nb">p</span> <span class="no">TestClass</span><span class="p">.</span><span class="nf">superclass</span>  <span class="c1">#=&gt; "Object"</span>
</code></pre></div></div> <p>如上所示,TestModule模块作为虚拟的”父类”进入了TestClass的继承顺序列表中</p> <p>但是,TestClass的直接父类还是Object类</p> <p><strong>就像这样,我们可以使用模块功能来实现构建多个功能类似的扩展类的需求</strong></p> <h3 id="4-来聊聊模块方法查找规则">&lt;4&gt; 来聊聊模块方法查找规则</h3> <ol> <li> <p>原类中定义了同名方法时,优先使用类中的方法</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">module</span> <span class="nn">M</span>
   <span class="k">def</span> <span class="nf">hello</span>
     <span class="nb">puts</span> <span class="s2">"M#hello"</span>      
   <span class="k">end</span>
 <span class="k">end</span>

 <span class="k">class</span> <span class="nc">C</span>
   <span class="kp">include</span> <span class="no">M</span>
   <span class="k">def</span> <span class="nf">hello</span>
     <span class="nb">puts</span> <span class="s2">"C#hello"</span>
   <span class="k">end</span>
 <span class="k">end</span>

 <span class="no">C</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">hello</span> <span class="c1">#=&gt; "C#合理咯"</span>
</code></pre></div> </div> <p>原因就是: <strong>p C.ancestors #=&gt; [C, M, Object, Kernel, BasicObject]</strong></p> <p><strong>类的继承顺序上,C类在M模块之前</strong></p> </li> <li> <p>在同一个类中,优先使用最后一个包含的模块</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">module</span> <span class="nn">M1</span>
   <span class="k">def</span> <span class="nf">hello</span>
     <span class="nb">puts</span> <span class="s2">"M1#hello"</span>      
   <span class="k">end</span>
 <span class="k">end</span>

 <span class="k">module</span> <span class="nn">M2</span>
   <span class="k">def</span> <span class="nf">hello</span>
     <span class="nb">puts</span> <span class="s2">"M2#hello"</span>      
   <span class="k">end</span>
 <span class="k">end</span>

 <span class="k">class</span> <span class="nc">C</span>
   <span class="kp">include</span> <span class="no">M1</span>
   <span class="kp">include</span> <span class="no">M2</span>
 <span class="k">end</span>

 <span class="no">C</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">hello</span>  <span class="c1">#=&gt; "M2#hello"</span>
</code></pre></div> </div> <p><strong>同理,看继承顺序: [C, M2, M1, Object, Kernel, BasicObject]</strong></p> </li> <li> <p>嵌套模块和类时,继承也是线性的</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">module</span> <span class="nn">M1</span>
 <span class="k">end</span>

 <span class="k">module</span> <span class="nn">M2</span>
 <span class="k">end</span>

 <span class="k">module</span> <span class="nn">M3</span>
   <span class="kp">include</span> <span class="no">M2</span>
 <span class="k">end</span>

 <span class="k">class</span> <span class="nc">C</span>
   <span class="kp">include</span> <span class="no">M1</span>
   <span class="kp">include</span> <span class="no">M3</span>
 <span class="k">end</span>

 <span class="nb">p</span> <span class="no">C</span><span class="p">.</span><span class="nf">ancestors</span> <span class="c1">#=&gt; "[C, M3, M2, M1, Object, Kernel, BasicObject]"</span>
</code></pre></div> </div> </li> <li> <p>多次使用include嵌套同一模块,忽略已经包含的模块</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">module</span> <span class="nn">M1</span>
 <span class="k">end</span>

 <span class="k">module</span> <span class="nn">M2</span>
 <span class="k">end</span>

 <span class="k">class</span> <span class="nc">C</span>
   <span class="kp">include</span> <span class="no">M1</span>
   <span class="kp">include</span> <span class="no">M2</span>
   <span class="kp">include</span> <span class="no">M1</span>
 <span class="k">end</span>

 <span class="nb">p</span> <span class="no">C</span><span class="p">.</span><span class="nf">ancestors</span>  <span class="c1">#=&gt; "[C, M2, M1, Object, Kernel, BasicObject]"</span>
</code></pre></div> </div> </li> </ol> <p>之前提到单例方法时,都是使用 “ class « 实例 ~ end “ 的形式定义单例方法</p> <p>对于类(Class类的实例)来讲,就是进行类方法的定义</p> <p>出了使用这种形式以外,我们还可以灵活使用模块,来实现单例方法</p> <p><strong>同之前的例子,看一下这个例子</strong></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Hello</span>
  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"hello"</span>
  <span class="k">end</span>
 <span class="c1">#module_function :hello</span>
<span class="k">end</span>

<span class="n">str1</span> <span class="o">=</span> <span class="s2">"hello"</span>
<span class="n">str2</span> <span class="o">=</span> <span class="s2">"world"</span>
<span class="n">str1</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="no">Hello</span><span class="p">)</span>
<span class="nb">p</span> <span class="n">str1</span><span class="p">.</span><span class="nf">hello</span>    <span class="c1">#=&gt; "hello"</span>
<span class="nb">p</span> <span class="n">str2</span><span class="p">.</span><span class="nf">hello</span>    <span class="c1">#=&gt; "nil"in `&lt;main&gt;': undefined method `hello' for 										  "world":String (NoMethodError)</span>
</code></pre></div></div> <p><strong>将单例方法,定义成为模块函数,之后对单例使用Object#extend方法,进行单例方法的扩展即可</strong></p> <p><strong>注意: 其中的module_funcation是不能有的,他会将模块函数定义为某唉进行调用的外部函数</strong></p> <p><strong>如果将类作为实例,那自然就是类方法了,</strong></p> <p>现在,我们可以系统的来说:</p> <p><strong>使用模块,一方面可以利用Mix-in特性来,扩展类.另一方面,可以使用Object#extend方法来扩展单例</strong></p> <p><strong>即,使用include可以帮助我们突破继承的限制.extend可以跨过类,使用模块来扩展对象</strong></p> <h3 id="5-类与mix-in">&lt;5&gt; 类与Mix-in</h3> <p>之前说过很多次类方法</p> <p>我们可以这样理解类方法:</p> <p><strong>1. Class类的实例方法 (任何类都是Class类的实例)</strong></p> <p><strong>2. 类对象的单例方法(只对此类适用,对其他类不适用,这些类都作为对象来考虑)</strong></p> <p>所以,在扩展类的方面,我们这样综合类与模块</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Hello</span>
  <span class="k">def</span> <span class="nf">hello</span>
    <span class="nb">puts</span> <span class="s2">"hello,method"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">Bye</span>
  <span class="k">def</span> <span class="nf">bye</span>
    <span class="nb">puts</span> <span class="s2">"Bye,method"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Test</span>
  <span class="kp">include</span> <span class="no">Hello</span>         <span class="c1">#=&gt; include将Hello模块扩展为类的实例方法</span>
  <span class="kp">extend</span> <span class="no">Bye</span>            <span class="c1">#=&gt; extend将Bye扩展为类的类方法</span>
<span class="k">end</span>

<span class="n">m</span> <span class="o">=</span> <span class="no">Test</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">p</span> <span class="n">m</span><span class="p">.</span><span class="nf">hello</span>
<span class="nb">p</span> <span class="no">Test</span><span class="p">.</span><span class="nf">bye</span>
</code></pre></div></div> <p>又扯到之前提到过的: <strong>其实Ruby中一切皆对象,所谓的类方法其实也是实例方法</strong></p> <h2 id="面向对象程序设计">面向对象程序设计</h2> <p>这部分,我也不时啃的十分清楚,说说下面几个问题:</p> <ol> <li> <p>什么是对象</p> </li> <li> <p>封装与多态</p> </li> <li> <p>鸭子类型</p> </li> </ol> <hr /> <p><em>来说点其他的吧,寒假学习,确实容易放松,这篇博客拖了很长时间</em></p> <p><em>一方面是理解起面向对象,走了一点弯路,另一方面还是太皮了</em></p> <p><em>不过现在搞得差不多了,Ruby整个语法框架差不多了</em></p> <p><em>后面也就是运算符,异常处理,块的内容,理解消化挺快的</em></p> <p><em>接下来,就是一系列Ruby默认类的内容了,很方便,有各种黑魔法(可能就拖起来看了,唉~)</em></p> <p><em>之前逛得太多了,下来改回归Kernel的任务了</em></p> <p><em>驱动,CS:APP还是要好好对待,估计到开学勉强差不多</em></p> <p><em>对了,还有算法题,那就好好写写BFS与DFS吧,写的深入一点</em></p> <p>February 15, 2018 3:41 AM</p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://localhost:4000/tags/#Ruby" title="Pages tagged Ruby" class="tag"><span class="term">Ruby</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/Ruby3/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/Ruby3/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/Ruby3/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'Evilcrow'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
