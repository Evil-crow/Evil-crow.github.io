<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css"> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title><STL> Containers &#8211; Road to Coding</title> <meta name="description" content="只要那一抹笑容尚存, 我便心无旁骛"> <meta name="keywords" content="EffectiveSTL"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="<STL> Containers"> <meta name="twitter:description" content="第一次听说容器的概念还是在C中, 形容存放对象的对象就叫做容器.当然在C中, 对象与此处的对象不同,广义上的对象,指的是具名分配的内存. 但是容器的概念沿用下来, 在C中数组也被视为一种容器.那么C++中容器究竟是什么样子, 我们又应该注意些什么要点呢?"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="<STL> Containers"> <meta property="og:description" content="第一次听说容器的概念还是在C中, 形容存放对象的对象就叫做容器.当然在C中, 对象与此处的对象不同,广义上的对象,指的是具名分配的内存. 但是容器的概念沿用下来, 在C中数组也被视为一种容器.那么C++中容器究竟是什么样子, 我们又应该注意些什么要点呢?"> <meta property="og:url" content="http://localhost:4000/containers/"> <meta property="og:site_name" content="Road to Coding"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <link rel="canonical" href="http://localhost:4000/containers/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Road to Coding Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="Road to Coding photo" class="author-photo"> <h4>Road to Coding</h4> <p>只要那一抹笑容尚存, 我便心无旁骛</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:evilcrow486@gmail.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/Evil-crow" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://localhost:4000/posts/">All Posts</a></li> <li><a href="http://localhost:4000/tags/">All Tags</a></li> </ul> </li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn" style="background-color:rgba(255,255,255,0.97);"> <div class="content"> <div class="post-title "> <h1><STL> Containers</h1> <h4>08 Nov 2018</h4> <a class="btn zoombtn" href="http://localhost:4000/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <p><em>第一次听说容器的概念还是在C中, 形容存放对象的对象就叫做容器.</em> <em>当然在C中, 对象与此处的对象不同,广义上的对象,指的是具名分配的内存.</em> <em>但是容器的概念沿用下来, 在C中数组也被视为一种容器.</em> <em>那么C++中容器究竟是什么样子, 我们又应该注意些什么要点呢?</em></p> <p>首先, 我们来说说容器. <strong>用来存放对象的对象就叫做容器</strong> 在C++中,主要是两(三)种类型的容器: 顺序容器(序列容器) + 关联容器 + 无序关联容器(C++11) [即哈希容器] 另外还存在容器适配器(Container Adapter) 以及 span(C++20)</p> <p>因为我们使用容器, 要容纳各种类型. 所以容器都是模板实现, 故容器是STL的重要组成部分之一</p> <p>我们就来看看, 容器的使用究竟都需要注意些什么方面吧!</p> <h2 id="item-01-choose-you-containers-with-care">Item 01: Choose you containers with care</h2> <p>是的, 可供我们选择的容器中类相当多. 如何选择适合我们的容器便成了一个问题. 我们先从各种容器的特点来进行分析吧, 这样采访便我们确定适合自己使用的类型.</p> <p>发展至今, 完整的容器列表如下:</p> <table> <thead> <tr> <th>顺序容器</th> <th>注解</th> </tr> </thead> <tbody> <tr> <td>vector</td> <td>向量,说的简单点就是变长数组(非VLA), 支持尾部的插入, 弹出.适合构造栈</td> </tr> <tr> <td>deque</td> <td>双端队列, 支持从首尾进行元素的插入和删除</td> </tr> <tr> <td>list</td> <td>双向链表, 支持首尾的元素插入和删除</td> </tr> <tr> <td>array (C++11)</td> <td>将内置数组STL化, 支持STL的通用操作, 实用性一般.[不过为了STL规范化]</td> </tr> <tr> <td>forward_list (C++11)</td> <td>单向链表, 手写的性能最好的单向链表</td> </tr> </tbody> </table> <table> <thead> <tr> <th>关联容器</th> <th>无序关联容器</th> <th>注解</th> </tr> </thead> <tbody> <tr> <td>map</td> <td>unordered_map (C++11)</td> <td>K-V对集合,底层使用自平衡二叉查找树</td> </tr> <tr> <td>set</td> <td>unordered_set (C++11)</td> <td>唯一键集合</td> </tr> <tr> <td>multimap</td> <td>unordered_multimap (C++11)</td> <td>(允许重复)K-V对集合</td> </tr> <tr> <td>multiset</td> <td>unordered_multiset (C++11)</td> <td>(允许重复)唯一键集合</td> </tr> </tbody> </table> <table> <thead> <tr> <th>适配器</th> <th>注解</th> </tr> </thead> <tbody> <tr> <td>stack</td> <td>堆栈适配器, 一般使用vector, deque构造</td> </tr> <tr> <td>queue</td> <td>队列适配器, 一般使用deque构造</td> </tr> <tr> <td>priority_queue</td> <td>优先队列</td> </tr> </tbody> </table> <table> <thead> <tr> <th>相接容器</th> <th>注解</th> </tr> </thead> <tbody> <tr> <td>span (C++20)</td> <td>…,看Reference吧,C++20为此还添加了相接迭代器</td> </tr> </tbody> </table> <p>关于迭代器非法化:</p> <p>**只读方法决不非法化迭代器或引用。修改容器内容的方法可能非法化迭代器和/或引用， **</p> <p>按照常理我们进行容器的选择时, 按照这样的思路: <em>容器的特点来进行考虑</em></p> <p>例如:</p> <ul> <li>vector擅长在尾后添加/删除元素</li> <li>deque擅长在首尾添加/删除元素</li> <li>…</li> </ul> <p>然而我们现在要考虑的不仅仅是这些, 我们可以从下面这些方面入手:</p> <ol> <li>是否需要在任意位置插入元素</li> <li>是否关心元素在容器中的排序情况 (此处强推哈希容器, 即无序关联容器)</li> <li>需要何种类型的迭代器 (vector中是任意访问迭代器, List中是双向迭代器)</li> <li>查找速度是否是关键因素 (无序关联容器 &gt; 排序vector &gt; 序列容器)</li> <li>…</li> </ol> <p>以上只是我们提出的一些选择容器的建议, 本质上还是要依靠: <strong>我们对于不同容器的熟悉程度决定</strong></p> <h2 id="item-02-beware-the-illusion-of-container-independent-code">Item 02: Beware the illusion of container-independent code</h2> <p>STL的设计概念是泛化的思想.没错,它在想办法将元素存放在容器中实现为类型无关的 (使用Template)</p> <p>也许就会引发出一个问题: <em>你想尝试编写与容器类型无关的代码, 以此来实现更高程度的泛化</em></p> <p>可行吗 ? <strong>一定不可行</strong></p> <p>可以稍微考虑一下: 序列容器提供了<code class="highlighter-rouge">Container::push_back</code>,<code class="highlighter-rouge">Container::push_front</code>等方法, 关联容器则提供了<code class="highlighter-rouge">Container::lower_bound</code>, <code class="highlighter-rouge">Container::upper_bound</code>, <code class="highlighter-rouge">Container::equal_range</code>等方法</p> <p>这种你如何编写容器无关的代码 ? ? ?</p> <p>那么,范围缩小一点. 对于同时序列容器, 我们比较<code class="highlighter-rouge">list</code>和<code class="highlighter-rouge">vector</code></p> <p><code class="highlighter-rouge">list::splice</code>完成列表的链接工作, 保证常数时间. <code class="highlighter-rouge">vector::reserve</code>用于消除重分配,</p> <p>这两个小的能力,在<code class="highlighter-rouge">list</code>与<code class="highlighter-rouge">vector</code>之间可以实现互操作吗？</p> <p><strong>答案否定的！</strong></p> <p><strong>最后, 如果我们能够实现真正”泛化”的容器代码, 其所能提供的功能一定是极为有限的</strong> **这种东西, 还能够叫做STL吗 ? **</p> <p>究其原因, 实质是因为：　<strong>不同的容器是为了不同的功能而设计, 而且他们也提供了不同性能的迭代器</strong> 因此我们尝试编写容器无关的代码, <strong>从出发点就是错误的, 不同容器有不同用途, 怎么能轻易泛化呢?</strong></p> <p>但是, 如果真的有一天, 我们需要进行容器的修改, 我们该怎么办呢?</p> <p>一行一行代码去修改吗? 那肯定是不现实的.</p> <p>我们可以提供封装技术. 最基础的封装就是类型定义<code class="highlighter-rouge">typedef/using</code></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Weight</span><span class="p">{};</span>
<span class="k">using</span> <span class="n">WidgetContainer</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">WCIterator</span> <span class="o">=</span> <span class="n">WidgetContainer</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>

<span class="n">WidgetContainer</span> <span class="n">cw</span><span class="p">;</span>
<span class="n">widget</span> <span class="n">temp</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">cw</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">cw</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">temp</span><span class="p">);</span>
</code></pre></div></div> <p>在我们有需要的时候进行替换即可.</p> <p>再高级一点的封装便是使用面向对象的class机制了</p> <h2 id="item-03--make-copying-cheap-and-correct-for-objects-in-containers">Item 03: Make copying cheap and correct for objects in containers.</h2> <p>曾经在EffectiveC++的系列博客中, 我们提到过: 我们推荐pass-by-reference 的形式进行值传递 我们也说过, C++是一个语言联邦, 我需要根据目前所处的不同领域来决定我们应该使用的方式.</p> <p><strong>在STL中, 使用的是pass-by-value的形式</strong></p> <p>没错, 我们将值拷贝进入容器中, 进行操作, 最后又将值拷贝出来.</p> <p>整个STL的工作方式就是进行拷贝, 为什么呢? <em>Container是提供容器功能的, 我们可以同时将一组数据装在不同的容器中进行不同需求的操作</em> <em>这样, 你明白了, 我们为什么处理拷贝了吗 ?</em></p> <p>那么,它如何实现呢? 是的依靠你的<code class="highlighter-rouge">copy constructor</code> / <code class="highlighter-rouge">copy assign operator</code></p> <p>那么, 比如我们提供下面这样的类型,</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Temp</span><span class="p">();</span>
    <span class="n">Temp</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Temp</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Temp</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Temp</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="o">~</span><span class="n">Temp</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div> <p>它是无法使用容器的.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="o">::</span><span class="k">new</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">__p</span><span class="p">))</span> <span class="n">_T1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__args</span><span class="p">)...);</span> <span class="p">}</span>
       <span class="o">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">// 其中 _T1是构造函数, __args是模板变参. 这里的构造, 委托给对象的拷贝构造函数</span>
</code></pre></div></div> <p>即使使用C++11,新增加的<code class="highlighter-rouge">Container::emplace_back</code>,直接构造,也需要使用<code class="highlighter-rouge">Temp::copy_constructor</code></p> <p>那么, 我们实际进行容器使用的时候, 相当需要注意的一个问题便是: <strong>splice down(剥离)</strong></p> <p>指的是: <strong>对于基类实例化的容器, 我们存放派生类的对象, 就会导致派生类对象中的派生部分剥离</strong></p> <p>=&gt; <strong>会导致, 我们使用多态机制失败, 至于为什么, 不言自喻</strong></p> <p>那么, 我们有什么办法呢? <strong>指针</strong>, Emmm, 是个不错的想法, 但是指针太危险了</p> <p>有什么办法呢? 我们之前在EffectiveC++的内容中提到过, 智能指针. 是的,这是个不错的想法.</p> <h2 id="item-04--call-empty-instead-of-checking-size-against-zero">Item 04: Call empty instead of checking size() against zero.</h2> <p>使用<code class="highlighter-rouge">Container::empty()</code> 替换 <code class="highlighter-rouge">Container::size()</code></p> <p>这是问题吗? 是的, 在追求效率的STL面前, 适当的编码是真的可以提高效率</p> <p>为什么呢? 这个问题 <strong>原因就是: STL规定了实现要求的时间复杂度, 却不限制实现方式</strong></p> <p>而<code class="highlighter-rouge">.empty()</code>是常数时间, <code class="highlighter-rouge">.size()</code>对于某些容器并非常数时间.</p> <p>我们来看这样的例子:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">empty</span><span class="p">();</span>     <span class="c1">// 空</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">();</span>      <span class="c1">// 大小</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">splice</span><span class="p">();</span>    <span class="c1">// 链接操作</span>
</code></pre></div></div> <p>对于标准容器<code class="highlighter-rouge">list</code>, 我们将它作为链表来使用, 也即是说: 我们要求它擅长进行节点的创建与链接操作</p> <p>因此, <code class="highlighter-rouge">list::splice</code>的实现被要求是常数时间, 即链接节点的时间复杂度与链表长度无关. 所以, 这也就意味着, 我们在<code class="highlighter-rouge">list::size</code>实现时, 就达到了线性时间, 因为它必须遍历链表才能求出长度 所以, 你懂了吧,为什么我们使用<code class="highlighter-rouge">empty()</code>而非<code class="highlighter-rouge">size() == 0</code>进行空容器的判断</p> <p><em>当然, 只是针对于splice是常数时间, size是线性时间实现的STL, 如果有其他实现, 我们便要阅读文档判断</em></p> <p>STL是追求高性能的标准库设施, 高效的使用STL, 也是我们所努力的目标.</p> <h2 id="item-05-prefer-range-member-functions-to-their-single-element-counterparts">Item 05: Prefer range member functions to their single-element counterparts.</h2> <p>如果说之前的手法都是小打小闹, 那么这一点, 则是明显提高效率的手法 !</p> <p>Scott Meyers先生首先提出了一个<strong>将某容器c后半部分如何拷贝进vector</strong>的问题. 正确答案是 <code class="highlighter-rouge">vec.assign(c.cbegin() + c.size() / 2, c.cend());</code></p> <p>很简洁明了, 不是吗? 另外我要强调的是: <strong>这同时还是相当高效的操作</strong></p> <p>首先是: 我们经常会写成循环的方式, (<del>如果你写成多重循环, 拖出去斩了</del>)</p> <p>那么, 这里便是我们所要进行阐述的地方: <strong>使用区间形式的调用 替换(replcae) 单元素形式的调用</strong> 是的没错, 正是这样: <strong>区间形式的操作, 比你想像中效率要好一大截</strong></p> <p>主要基于以下三大原因: [这部分主要针对顺序容器]</p> <ol> <li> <p>区间形式的调用, 减少多次函数调用, (当然<code class="highlighter-rouge">inline</code>就不会有额外开销,但这个很难是<code class="highlighter-rouge">inline</code>实现)</p> </li> <li> <p>Emmm ,你仔细想想.顺序容器我们之前说过, 它也是连续内存的容器, 所以: <strong>进行元素的修改, 会导致元素的挪移,没错吧 ? ** 那么, 我们如果使用区间形式的调用 =&gt; **是的, 一次到位, 减少了相当大次数的挪移(具体数据自算)</strong></p> </li> <li> <p>第三个, 是针对STL的动态扩展特性来说的, 因为其动态的特性, 所以我们才舍弃内置数组/C-String 当然, <code class="highlighter-rouge">std::array(C++11)</code>可以了解一下(统一规范, 没有什么大用…) 来了, 关键的: <strong>插入, 修改此类操作, 经常超出容器的容量(区分容量/大小), 会导致重分配</strong> 重分配一般涉及 <strong>重分配 -&gt; 拷贝构造 -&gt; 析构 -&gt; 释放内存</strong> 按照, 大多数<code class="highlighter-rouge">vector</code>的实现规范, 插入1000个元素, 基本上近似于10次重分配 而如果我们使用<strong>区间形式调用, 还是同第二点, 一步到~~胃~~, 不对, 一步到位, 效率增长可想而知</strong></p> </li> </ol> <p>听了上面的三点分析, 是不是恍然大悟呢? 我们还没说完:</p> <blockquote> <p>Tips:</p> <ol> <li>我们最开始展示了<code class="highlighter-rouge">Container::assign</code>的用法, 旨在说明, 还存在方便的成员函数可用 但是, 我们更范用性的操作是<code class="highlighter-rouge">Container::insert</code>, 赋值也是一种插入嘛. 不过, 我个人(当然是Scott先生提到过), <code class="highlighter-rouge">std::copy</code>其实有相当大的误导性 STL, 就是拷贝, 使用<code class="highlighter-rouge">copy</code>一方面是会误导我们针对明确语义的<code class="highlighter-rouge">assign</code>, <code class="highlighter-rouge">insert</code>操作 更重要的是, 一般实现, copy展开之后, 基本就是显式循环, <strong>是的, 上面三个分析,不复存在</strong> 即使你的确使用了区间形式的调用…</li> </ol> </blockquote> <blockquote> <ol> <li>我们针对第二点, 需要注意的是, 我们能够一步到位的运算挪移, 是要建立在迭代器支持的基础上的, 这种迭代器, <strong>前向迭代器往上</strong> 但是, 一般容器提供的都达到了这一步, 除非是<strong>输入迭代器(等同于单元素调用, 步步移动)</strong>, 不然不需要考虑这一点.</li> </ol> </blockquote> <p>*虽然有上面两个tips, 但是, 好像并无大碍, 不是吗 ? *</p> <p>那么,我们需要注意的是什么? <strong>该关联容器了</strong></p> <p><strong>众所周知, 关联容器, 一般是基于节点的容器, 实现上经常是链表/树等</strong></p> <p>*那么, 我们的分析还实用吗 ? *</p> <p>我们对于关联容器要从这一方面来切入: 就拿list来说. <img src="http://phxjezimr.bkt.clouddn.com/STL_list.png" alt="std::list::insert" /></p> <p>其中要干什么? <strong>修改指针指向, 没错吧?</strong></p> <p><strong>那么,单次循环插入, 和区间一次链接, 做进行的操作开销, 懂了吧?</strong></p> <p>*是的, 指针赋值开销很低, 但是, 不付出开销岂不是更好 ? *</p> <p>那么, 我们总结一下:</p> <ol> <li>插入(insert) 建议使用<code class="highlighter-rouge">std::COntainer::insert(pos, c.cbegin(), c.cend())</code></li> <li>赋值(assign) 建议使用<code class="highlighter-rouge">std::Container::assign(c.cbegin(), c.cend())</code></li> <li>删除(erase) 建议使用<code class="highlighter-rouge">std::Container::erase(c.begin(). c.end());</code></li> </ol> <p>是的, 除非你有足够的理由能够推翻三驾马车, 否则,使用区间形式的调用是更好的选择</p> <h2 id="item-06--be-alert-for-cs-most-vexing-parse">Item 06: Be alert for C++’s most vexing parse</h2> <p>摆脱C++烦人的分析(parse)机制, 是的,这个问题主要是进行函数原型的诊断所导致的问题</p> <p>函数原型会有什么问题 ?</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Weight</span><span class="p">{};</span>

<span class="n">Weight</span> <span class="n">w</span><span class="p">();</span>            <span class="c1">// Error !</span>
<span class="n">Weight</span> <span class="n">w</span><span class="p">;</span>              <span class="c1">// 使用default constructor</span>
</code></pre></div></div> <p>是的, 我们在C++中调用默认构造函数, <strong>一定不能加上括号, 否则会被parse =&gt; function prototype</strong></p> <p>这种创建对象还比较明显, 下面这种例子就相当隐晦了</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">istream_iterator</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="n">istream_iterator</span><span class="p">());</span>
</code></pre></div></div> <p>看上去并没有什么问题, 但这也只是看上去没有什么问题.. 这其实是一个函数原型的声明</p> <p>我们来分析一下: 1: 类型为<code class="highlighter-rouge">istream_iterator</code>名为<code class="highlighter-rouge">file</code>的变量. 2: 返回值为<code class="highlighter-rouge">istream_iterator</code>类型, 无参数的函数指针 [此处省略函数名, 所以可以没有(*fp)]</p> <p>看看我们下面的正常用法:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>             <span class="c1">// 我们在函数原型中是可以省略参数名的</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>                       <span class="c1">// UNP中看到的邪教, 其实声明也不一定放外面</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{...}</span>

<span class="c1">// 同时, 此处说明函数与函数指针, 用法相同, 不过语义是不同的. (指针 | 函数)</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">void</span> <span class="n">fp</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{...}</span>       <span class="c1">// 定义中, 因为我们要使用参数, 所以函数名不可省略</span>
</code></pre></div></div> <p><strong>我们在此处着重强调的是: 不要因为分析机制而产生误用!</strong></p> <h2 id="item-07-when-using-containers-of-newed-pointers-remember-to-delete-the-pointers-before-the-container-is-destroyed">Item 07: When using containers of newed pointers, remember to delete the pointers before the container is destroyed.</h2> <p>这一条款, 我觉得可以是 EffectiveC++中 Chapter III 资源管理的扩展 (具象化)</p> <p><strong>当容器中使用new的到的指针时, 在容器销毁时, 一定要delete掉</strong></p> <p>这是怎么说? <strong>因为C++中析构和释放内存是两码事</strong></p> <p>我们从容器中退出时, 它仅仅是, 对象销毁(是的, 指针销毁掉了), <strong>但是, 相关的内存并没有释放掉</strong> <strong>因此造成了内存泄漏 !(Memory Leak)</strong></p> <p>来看个例子吧:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Weight</span> <span class="o">*&gt;</span> <span class="n">vec</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(...)</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Weight</span><span class="p">);</span> <span class="c1">// vec.emplace_back(new Weight)</span>
    <span class="p">...</span>
    <span class="p">...</span>
<span class="p">}</span>                 <span class="c1">// Memory Leak</span>
</code></pre></div></div> <p>那么, 单纯的构造却不delete势必会造成问题.</p> <p>如果这样呢?</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Weight</span> <span class="o">*&gt;</span> <span class="n">vec</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(...)</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Weight</span><span class="p">);</span> <span class="c1">// vec.emplace_back(new Weight)</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">var</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span>          <span class="c1">// Iterator 遍历当然也行</span>
        <span class="k">delete</span> <span class="n">var</span><span class="p">;</span>
<span class="p">}</span>                 <span class="c1">// Memory Leak</span>
</code></pre></div></div> <p>这种做法情况比上面好一点, 也只是好一点…. <strong>因为, 要是第一个delete的时候, throw exception了, 后面又都是内存泄漏</strong></p> <p>那么, 还有办法吗? 有的! [其实是个换皮怪]</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 因为我们会修改容器中的元素, 所以不使用Container::c[begin | end]();</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">UnaryFunction</span><span class="p">);</span>
</code></pre></div></div> <p>那么, 这个UnaryFunction怎么写 ?</p> <p>STL中有这么些概念: 谓词, 基类, 函数适配器. (自行了解, 或者我后面会提及)</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// UnaryFunction的处理方法</span>

<span class="c1">// 1. 使用function object (其实就是函数重载运算符)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">DeleteObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">unary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">pointer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">beign</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DeleteObject</span><span class="o">&lt;</span><span class="n">Weight</span><span class="o">&gt;</span><span class="p">());</span>

<span class="c1">// 2. lambda算式</span>

<span class="c1">// C++14 支持lambda中auto推导, C++11, lambda必须写成具体的类型, 使用template又略显粗糙</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">){</span> <span class="k">delete</span> <span class="n">vec</span><span class="p">;</span> <span class="p">});</span> 

<span class="c1">// 3. 使用bind() C++11 提供, 不同于之前的 bin1st, bin2nd</span>
<span class="c1">// 语法丑陋, 暂不展示 [主要是bind提供适配功能, 还要依靠其他函数...]</span>
</code></pre></div></div> <p><strong>此处, 因为历史原因, 但是现在lambda一个式子就可以把函数对象, 适配器, bind通通吃掉</strong></p> <p>如果你很喜欢写函数对象也行 (lambda到std::function是不会隐式推导的, 这个时候使用函数对象适配)</p> <p>关于上面的函数对象例子, 我们必须是知道: <strong>容器元素为Weight, 才能操作, 那么又其他办法吗?</strong></p> <p>有!</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DeleteObject</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">pointer</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DeleteObject</span><span class="p">());</span>    <span class="c1">// 会自行根据传入的参数推断类型</span>
</code></pre></div></div> <p>有什么好处吗? 有的! <em>比如有的类没有虚析构函数, 那么,你继承之后, 如果误以为他有虚析构函数, 而使用基类指针delete</em> 懂了吧?</p> <p>但是我们使用模板的形式, 保证自动类型推导. <strong>是不是写的代码少, 还反而准确呢? [是的, 代码越少, 错误越少, 乱</strong>*装13就是作死]**</p> <p>但是, 回到我们的主题上来: <code class="highlighter-rouge">std::for_each</code>只是省得写显示的循环, 还是会有内存泄漏的风险</p> <p><em>即使是C++20中的提供policy的形式, 也只是可能能够不按顺序操作, 但这一切都是徒劳</em> <em>可能只有std::TS中的并行算法, 还有机会解决这种问题</em></p> <p>真的无解了吗? 怎么可能?</p> <p>想想我们之前在EffectiveC++中的解法: <strong>是的, 使用类管理资源, RAII !, 具体下来就是 智能指针</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Weight</span><span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(...)</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Weight</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Weight</span><span class="p">));</span>
    <span class="p">...</span>
    <span class="p">...</span>
<span class="p">}</span>       <span class="c1">// Memory must be released</span>
</code></pre></div></div> <p>使用智能指针的形式, 可以保证无论是手工忘记, 还是异常抛出, 资源都一定不会泄漏!</p> <h2 id="item-08--never-create-containers-of-auto_ptrs">Item 08: Never create containers of auto_ptrs.</h2> <p>这一条款是在说: <code class="highlighter-rouge">std::auto_ptr</code>类似于<code class="highlighter-rouge">std::unique_ptr</code>, 在使用中会被置空, 交出资源.</p> <p>auto_ptr并非真正意义上的智能指针, 它是历史上一个实现不完全的, <code class="highlighter-rouge">std::unqiue_str</code></p> <p>鉴于至今, 我们已经有<code class="highlighter-rouge">std::shared_ptr</code>和<code class="highlighter-rouge">std::unique_str</code>以及避免环回的<code class="highlighter-rouge">std::weak_ptr</code></p> <p>所以, 此条款, 我们不再讨论.</p> <h2 id="item-09--choose-carefully-among-erasing-options">Item 09: Choose carefully among erasing options</h2> <p>之前我们重点在如何往容器中添加元素, 现在我们来聊聊删除元素的手法 对于如何删除容器中的元素的手法, 我们分为三类,三个层次说明:</p> <h3 id="删除元素">删除元素</h3> <ol> <li>顺序容器, 我们使用erase-remove的手法</li> </ol> <p><code class="highlighter-rouge">Container::erase</code>是它擦除未指定值并减小容器的物理大小, <code class="highlighter-rouge">std::remove</code>是迁移（以移动赋值的方式[C++11]）范围中的元素进行移除。保持剩余元素的相对顺序，且不更改容器的物理大小 [即是说, 从remove返回到end()的迭代器不失效, 仍可使用]</p> <p>所以, 我们将这两个组件配合起来. 使用remove-erase的模式</p> <p>*为什么要使用<code class="highlighter-rouge">std::remove</code>直接<code class="highlighter-rouge">Container::erase</code>不是也能达成效果么? * <strong>想想之前说的, 区间形式的调用和遍历容器单元素调用, 懂了吧 ?</strong></p> <p>基本形式是这样: <code class="highlighter-rouge">vec.erase(remove(vec.begin(), vec.end(), val), vec.end());</code></p> <ol> <li><code class="highlighter-rouge">std::list</code> (是的, list虽然是顺序容器, 但是它的实现方式又类似于关联容器, 所以要单独拿出来说)</li> </ol> <p>怎么玩? 直接<code class="highlighter-rouge">list.remove(val)</code>即可,,为什么不区间 (因为<code class="highlighter-rouge">std::list::remove</code>之间移除指定val的元素)</p> <ol> <li>关联容器,我们直接erase即可, 同时保证是对数时间开销 <strong>注意: 标准关联容器, 没有remove成员函数, 且使用算法可能覆盖容器的值, 更甚至于会破坏容器</strong></li> </ol> <h3 id="按照判别式来删除">按照判别式来删除</h3> <p>也就是说, 某个满足条件的值被删除, 不仅仅是某个指定的值了.</p> <ol> <li> <p>顺序容器, 将<code class="highlighter-rouge">std::remove</code>更换为使用<code class="highlighter-rouge">std::remove_if</code>一切同往常使用</p> </li> <li> <p><code class="highlighter-rouge">std::list</code>我们同样使用<code class="highlighter-rouge">std::remove_if</code>即可</p> </li> <li> <p>关联容器, 这怎么办呢?</p> </li> </ol> <p>不不不, 不能这样来, 因为,关联容器的<code class="highlighter-rouge">Container::erase</code>使用之后会是的指向此元素的迭代器失效 什么意思, 即我们在循环中, 使用<code class="highlighter-rouge">++</code>的时候, 已经是是在一个无效的迭代器上操作, 结果是未定义的 那么,怎么办? <strong>保存迭代器的值, 然后进行操作即可, 好办法</strong></p> <p><em>另一种办法是, 使用Copy_and_Swap的手法, 通过<code class="highlighter-rouge">std::remove_copy_if</code> + <code class="highlighter-rouge">std::swap</code>操作</em></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">BadValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>                  <span class="c1">// 操作成功 !</span>
 <span class="p">}</span>
</code></pre></div></div> <p>上面的操作是难能可贵的, <strong>因为在C++11之前,关联容器的</strong><code class="highlighter-rouge">Container::erase()</code><strong>返回void</strong> 也即是说: <strong>我们无法得到删除操作后, 下一个合理的位置!</strong> 之前的做法是 <code class="highlighter-rouge">c.erase(i++);</code> 籍此保证迭代器未失效 所以说: C++11真的是带来了巨变, 为我们提供了高效的操作</p> <h3 id="删除元素和额外的操作">删除元素和额外的操作</h3> <p>怎么说呢?我们这一类说的是, 实际中经常使用的情况: 比如志记需求 (<del>完了, 迷上侯捷的说法了</del>)</p> <ol> <li>顺序容器</li> </ol> <p><strong>呦霍, 完蛋咯 ~</strong> 现在无法使用算法了, 因为我们无法在其中进行额外操作. (需求肯定是优先效率的) 怎么办呢? 而且 <strong>顺序容器删除后, 后面所有元素的迭代器都会失效的, 因为它基于连续内存分配</strong></p> <p>想想上面关联容器的做法:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">BadValue</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
	     <span class="n">log</span><span class="p">(..);</span>
         <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="p">...</span>
 <span class="p">}</span>       <span class="c1">// 同理即可 , OK!</span>
</code></pre></div></div> <ol> <li><code class="highlighter-rouge">std::list</code></li> </ol> <p>做法同其他顺序容器</p> <ol> <li>关联容器</li> </ol> <p>同我们之前的讨论, 是不是很清晰了呢 ?</p> <p><strong>小小总结一下:</strong></p> <p>对于直接删除: <code class="highlighter-rouge">remove-erase</code> + <code class="highlighter-rouge">std::list::remove</code> + <code class="highlighter-rouge">Loop: Container::erase</code> 条件删除: <code class="highlighter-rouge">remove_if-erase + lambda</code> + <code class="highlighter-rouge">std::list::remove_if</code> + <code class="highlighter-rouge">Loop: Container::erase</code> 额外操作: <code class="highlighter-rouge">Loop: return value</code> + <code class="highlighter-rouge">std::list::erase</code> + <code class="highlighter-rouge">Loop: return value</code></p> <h2 id="item-10--be-aware-of-allocator-conventions-and-restrictions">Item 10: Be aware of allocator conventions and restrictions</h2> <p>Allocator是一个相当重要的内容, 但是也没有想想中那么重要… (历史遗留问题比较严重)</p> <p>因为这部分内容是真的比较操蛋, 所以我拣重要的来说, 至于深刻理解分配机制: 等我STL源码吧.</p> <p>重要的内容有下面几点:</p> <ol> <li>分配器是一个模板, 其实不难理解, 因为他要针对各种STL容器来进行施用</li> <li>提供类型,<code class="highlighter-rouge">Allocator::pointer</code>与<code class="highlighter-rouge">Allocator::reference</code>, 但是, 始终为<code class="highlighter-rouge">T *</code>与<code class="highlighter-rouge">T &amp;</code></li> <li>尽量不要使Allocator含有状态, 也就是说: <strong>避免分配器中使用非静态成员</strong> [因为我们对于同一容器特化的不同实例, 都要能施用相同的分配和释放操作]</li> <li><code class="highlighter-rouge">std::Allocator</code>的使用习惯与<code class="highlighter-rouge">new operator</code>并不相同, 体现在函数参数传递与返回值上</li> <li><code class="highlighter-rouge">std::rebind</code>是施行于某些类型上的关键 !</li> </ol> <p>我们在这里详细来说<code class="highlighter-rouge">std::Allocator::rebind</code>, 它其实只是一个提供类型的, — <strong>模板</strong></p> <p>举个例子: <code class="highlighter-rouge">std::list</code>的普遍实现采用了链表的形式, 也就是说, 一般是这样:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">_list</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">ListNode</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="p">};</span>

<span class="c1">// list内部使用</span>
<span class="k">class</span> <span class="nc">_list</span> <span class="p">{</span>                            <span class="c1">// class不像namespace, 它必须是连续的</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">allocator_list</span><span class="p">;</span>     <span class="c1">// 使用</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>是的, 我们<code class="highlighter-rouge">list</code>的类型是<code class="highlighter-rouge">int</code>, 但是我们要分配的是<code class="highlighter-rouge">int</code>吗? <strong>否 !</strong>,我们要分配的是: <strong>ListNode</strong></p> <p>于是, <code class="highlighter-rouge">std::allocator::rebind</code>的作用出来了: <strong>重新绑定元素类型, 以供分配器使用</strong></p> <p>一般是这样的形式:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">allocator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">rebind</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=&gt;</span> 
<span class="k">typename</span> <span class="n">Allocator</span><span class="o">::</span><span class="n">rebind</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;::</span><span class="n">other</span> <span class="o">=&gt;</span>
<span class="n">allocator</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;</span> <span class="p">[</span><span class="err">即为所需分配器</span><span class="p">]</span> <span class="p">[</span><span class="n">rebind</span><span class="err">这个叫法也挺形象的</span><span class="p">]</span>
</code></pre></div></div> <h2 id="item-11--understand-the-legitimate-uses-of-custom-allocators">Item 11: Understand the legitimate uses of custom allocators</h2> <p>紧接着上一条: 这条是自定义分配器的用法</p> <p>对于这部分内容: 粗略地说两句</p> <p>首先, 符合标准Allocator一样, 提供pointer, 以及reference.</p> <p>并且不保存状态(即只有静态成员), 而且, 符合Allocator的使用习惯.</p> <p>这些内容, 反正说的比较含糊,… 实用性一般, 具体用到再细说吧.</p> <h2 id="item-12-have-realistic-expectations-about-the-thread-safety-of-stl-containers">Item 12: Have realistic expectations about the thread safety of STL containers.</h2> <p>对于STL, 我们不能对其线程安全性有过多的期望, 何出此言?</p> <p>标准只是期望: 多线程读容器OK, 多线程写容器OK.</p> <p>但是这些只是期望而已, 你不能对其有依赖, 因为有的实现符合, 有的实现并不支持.</p> <p>那么, 我们要求STL提供线程安全会怎么样?</p> <p><strong>没有好下场.</strong></p> <p>将线程同步的内容置于STL的实现中, 想法很美好,但是这无疑会让STL变得异常冗余复杂 <strong>使得STL丧失了其高效快捷的特点, 而且,退一步讲, 万一不需要线程支持, 那么多余的工作反而影响效率</strong></p> <p>基于上面的分析: 我们不要求STL来提供线程安全的支持, 我们使用手动线程同步</p> <p>怎么办呢? <code class="highlighter-rouge">std::mutex</code> + <code class="highlighter-rouge">std::cond_varible</code> 一般使用互斥锁 + 条件变量就OK</p> <p>但是, 死锁的问题, 还在威胁着我们.</p> <p>想想看, lock也不就是一种资源么? 对于资源, 我们一般怎么办? Resource Management</p> <p><strong>没错, RAII !</strong></p> <p>标准库中, <code class="highlighter-rouge">std::shared_ptr</code> 和 <code class="highlighter-rouge">std::lock_guard</code> 是已经实现的RAII实例</p> <p>通过使用这些设施 ,以及我们手动的RAII, 便可以自行完成线程安全的STL使用</p> <p>下面是C++Reference中, 对线程安全的描述: [其中标识了一部分保证的线程安全操作]</p> <p><img src="http://phxjezimr.bkt.clouddn.com/thread_safety.png" alt="线程安全" /></p> <hr /> <p>STL的内容真的好多, 实现想必是相当的精彩, (xxx之前一直喷,但是我觉得还可以, 就是写的风格不太好)</p> <p>最近确实火烧眉毛了, 但是EffectiveSTL还不错, 挺有意思的.</p> <p>其实我现在最困惑的时: 如何能够详实的将自己学到的技术落实下来.</p> <p>**可能只能多看, 同时写的时候,一开始刻意去用吧, 不然真的是有点尬, , , **</p> <p>怎么说呢, 迅速结束这些, Network Programm的内容 + Operation System的内容也不会少,</p> <p>管他呢, 干就完事了.</p> <p>November 10, 2018 5:35 PM</p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://localhost:4000/tags/#EffectiveSTL" title="Pages tagged EffectiveSTL" class="tag"><span class="term">EffectiveSTL</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/containers/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/containers/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/containers/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'Evilcrow'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
