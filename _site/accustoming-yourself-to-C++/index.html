<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css"> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title><星月夜> Accustoming Yourself to C++ &#8211; Road to Coding</title> <meta name="description" content="只要那一抹笑容尚存, 我便心无旁骛"> <meta name="keywords" content="EffectiveC++"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="<星月夜> Accustoming Yourself to C++"> <meta name="twitter:description" content="Chapter I 让自己习惯C++"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="<星月夜> Accustoming Yourself to C++"> <meta property="og:description" content="Chapter I 让自己习惯C++"> <meta property="og:url" content="http://localhost:4000/accustoming-yourself-to-C++/"> <meta property="og:site_name" content="Road to Coding"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <link rel="canonical" href="http://localhost:4000/accustoming-yourself-to-C++/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Road to Coding Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="Road to Coding photo" class="author-photo"> <h4>Road to Coding</h4> <p>只要那一抹笑容尚存, 我便心无旁骛</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:evilcrow486@gmail.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/Evil-crow" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://localhost:4000/posts/">All Posts</a></li> <li><a href="http://localhost:4000/tags/">All Tags</a></li> </ul> </li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn" style="background-color:rgba(255,255,255,0.97);"> <div class="content"> <div class="post-title "> <h1><星月夜> Accustoming Yourself to C++</h1> <h4>07 Sep 2018</h4> <a class="btn zoombtn" href="http://localhost:4000/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <p><em>C++的世界的确是缤纷多彩的, 这是一门十分强大的编程语言, 随之而来的代价自然就是其使用麻烦</em> <em>本章是全书第一章, 意在使自己熟悉使用C++,所必需要遵守的基础规则</em></p> <h2 id="item-01-view-c-as-a-federation-of-languages">Item 01: View C++ as a federation of languages</h2> <p>作为第一条款,首先我们必须承认的一点是: <strong>C++是一门复杂的多范式编程语言, 它不仅仅是一门语言</strong></p> <p>承认这一点, 使得我们明确: C++ 是一个语言联邦, 不能简单地依靠某种语言规范去学习认识它 <strong>而应该根据不同的范式情况, 去进行语言规范的转换, 从而编写高效的C++代码</strong></p> <p>目前已经被承认的C++范式有以下几种:</p> <ul> <li>面向过程编程</li> <li>基于对象编程</li> <li>面向对象编程</li> <li>泛型编程(Template)</li> <li>函数式编程</li> </ul> <p>那么,我们根据此,可以将C++划分为以下几种子语言:</p> <ol> <li>C, (C++的基础)</li> <li>Object-oriented C++, (支持面向对象范式)</li> <li>Template C++, (模板编程, 扩充为泛型编程)</li> <li>STL (Standard Template Library)</li> </ol> <p>根据上面的约定, 我们在使用不同的子部分时, 则需要遵守不同的约定.(理所当然, 对吧 ? ). 举个简单的例子:(EffC++中精巧的例子)</p> <blockquote> <p>Q: 函数调用是一门编程语言不可缺少的部分,那么以何种方式进行参数传递?</p> </blockquote> <blockquote> <p>A: 我们根据不同的联邦进行划分:</p> <ol> <li>C部分中,我们更倾向于 <em>pass by value</em></li> <li>Object-oriented 部分中, 我们倾向于 <em>pass by reference to const</em></li> <li>Template C++ 部分中, 我们一定要用 <em>pass by reference to const</em></li> <li>STL 部分中, (因为下面基于指针实现), 倾向于 <em>pass by value</em></li> </ol> </blockquote> <p>上面只是一个小的例子, 但是却反映出了”<strong>将C++视为一个语言联邦思想</strong>“的重要性</p> <blockquote> <p>请记住：</p> <ul> <li>C++高效编程守则视状况而变化， 取决于你使用C++哪一部分</li> </ul> </blockquote> <h2 id="item-02-prefer-consts-enums-inlines-to-define">Item 02: Prefer consts, enums, inlines to #define</h2> <p>C++在1990s时, 的确只是作为C语言的扩展版, 增加了基于对象的内容, 也就是写不好C++,经常被人调侃的 <em>C with class</em> 但是, 随着语言的发展与完善, C++ 已经成长为一门多范式编程语言, 而继承自C part的预处理器(CCP) 便显得有些”过时”了, (PS: 指有更好地实现方法) 作为现代C++, 我们要尽量减少对预处理器的依赖性, 因为其只是一个简单地文本替换器, 并非语言实现.</p> <p>我们对于预处理器的依赖经常表现在下面几个方面:</p> <ol> <li>#define PI 3.1415 即常量整型变量的定义</li> <li>#define max(a, b) (a) &gt; (b) ? a : b 即类函数宏, (PS: 这个max实现的有缺陷)</li> </ol> <p>&lt;1&gt; 实际上是我们为了编程的方便而使用的方法, 减少了代码变更带来的review代价 &lt;2&gt; 则是为了减少使用函数的开销， 执行任务短小的函数，开销十分浪费</p> <p>但是，以今天的眼光来看(成书于2005年，都已显得“过时”)，我们应该对已作出如下改变：</p> <h3 id="const-integeral-type">const integeral type</h3> <p>对于整型常量的设定，我们建议使用这样的方法：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PI 3.1415
</span>		<span class="cp">#=&gt;
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
</code></pre></div></div> <p>原因在于: 使用#define预处理器，只是进行简单的文本替换。PI并不能进入符号表。 无论是进行调试，还是其他操作都十分不方便，PI始终就没有出现过，作为变量来说不合理 (PS: 虽然说const为常量， 这只是编译器的约束，它仍然是可修改的变量)</p> <p>即使我们使用<code class="highlighter-rouge">const type var</code> 替代 <code class="highlighter-rouge">#define VER VAL</code>，也不能完全解决我们的问题， 常见的还有下面两个要注意的要点：</p> <ol> <li>对于C-Style，极其建议使用<code class="highlighter-rouge">str::stirng</code>。 因为<code class="highlighter-rouge">const std::string str;</code> 等价于 <code class="highlighter-rouge">const char * const ptr;</code></li> <li>class中的变量都是与对象相关的， 如果我们在class中声明了const变量。 它会因为多个对象的存在，而产生多个实体。最好使用这样的手法： <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
 	<span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>
 <span class="p">...</span>
 <span class="p">};</span>
</code></pre></div> </div> <p>这样就不会产生多份实体拷贝了</p> </li> </ol> <p>下面要说的就是，关于类中static变量，C++11开始全面支持类内初始化 如果是不支持此特性的编译器，有两个办法：</p> <ol> <li>更换最新的编译器</li> <li>使用类内声明，类外定义的手法</li> </ol> <p>比如这样：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">pi</span><span class="p">;</span>        <span class="c1">// declaration</span>
<span class="p">...</span>
<span class="p">};</span>

<span class="n">cosnt</span> <span class="k">static</span> <span class="n">Temp</span><span class="o">::</span><span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>  <span class="c1">// defination</span>
</code></pre></div></div> <p>而全面支持C++11的编译器可以这样使用</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>        <span class="c1">// declaration</span>
<span class="p">...</span>
<span class="p">};</span>

<span class="c1">// DO NOT assign to the static variable; </span>
<span class="k">const</span> <span class="k">static</span> <span class="n">Temp</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>  <span class="c1">// defination</span>
</code></pre></div></div> <p>这样就可以比较合理的解决不能类内初始化了。 但是，我们其实还可以使用<strong>enum hack</strong>的手法来处理</p> <blockquote> <p>enum hack</p> </blockquote> <blockquote> <p>所谓“enum hack”指的是，使用赋值的枚举变量来模拟类内初始化 更关键的是，<strong>enum hack的行为和预处理器类似</strong>，在某些情况下，需要预处理器的功能时，可以通过这样的手法来实现。</p> </blockquote> <p>那么，enum hack如何实现呢？ 这样写：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="p">{</span><span class="n">PI</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">};</span>
    <span class="p">....</span>
<span class="p">};</span>
</code></pre></div></div> <p>*此时为2005年，还没有enum class ( C++11 ), *</p> <p><strong>enum hack</strong>有这样两个优点：</p> <ol> <li>它一定不会浪费内存空间，同预处理器一样，不会进入符号表</li> <li>实用主义来讲，大量代码用到enum hack。 <em>说的就是你TMP（Template MetaProgramming）</em></li> </ol> <h3 id="define--macros">#define =&gt; Macros</h3> <p>使用预处理器的另一个重要场合就是: 减少函数开销的类函数宏 (getchar( )的实现方式)</p> <p>看着很美好，但是预处理器实现的类函数宏，经常是错误百出，各种各样的烦人。</p> <p>就那上面那个例子来说吧： <strong>1. 起码每个变量加上括号，同时整体还要加上括号，每步运算也要加上括号</strong> <strong>2. 更恶心的是，预处理器是文本替换，++， – 有多可怕用过的人都知道</strong></p> <p>基于上面的原因，预处理器实现类函数宏，如今也是一种不良的手法。</p> <p>使用现代C++，我们应该这样做：<code class="highlighter-rouge">inline template function</code></p> <ol> <li>使用<code class="highlighter-rouge">inline</code>是为了获得与类函数宏一样的高效，同时更获得了类型安全检查</li> <li>使用<code class="highlighter-rouge">template</code>在于，我们并不知道参数类型，使用<code class="highlighter-rouge">const T &amp;</code>理所当然</li> </ol> <p>那么，就来看一个例子吧：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define max(a, b) (a) &gt; (b) ? a : b;
</span>
<span class="cp">#=&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>使用<code class="highlighter-rouge">inline template function</code>的手法，我们既获得了高效性，还得到了类型安全。 模板泛型的适用场景不一定够多，但inline的使用场景够够的了。</p> <p>上面说了那么多，我们的目的<strong>并非是禁止使用预处理器</strong>，而是<strong>减少预处理器带来不可预料行为</strong> 毕竟我们当前使用<code class="highlighter-rouge">#include &lt;file&gt;</code>导入，<code class="highlighter-rouge">#ifndef/#define/#endif</code>控制编译仍然重要。</p> <blockquote> <p>请记住：</p> <ul> <li>对于单纯变量，最好以const对象或enums替换#define</li> <li>对于形似函数的宏（macros），最好改用inline函数替换#define</li> </ul> </blockquote> <h2 id="item-03-use-const-whenever-possible">Item 03: Use const whenever possible</h2> <p>在item 02 中，我们已经见识到const所带来的便利了。</p> <p>现在就再来谈谈const，后面还会聊到它的。</p> <p>关于const，我首先想要说说这两点：</p> <ol> <li>所谓const，只是编译器/程序员的“约束假定”，保证从编译器/程序员的方面不去修改 但是，实际上是可修改的。这点在后续关于const的讨论中很关键</li> <li>const在星号左是底层const，修饰指向。在星号右是顶层const，修饰变量本身（引用。。）</li> </ol> <p>有了上面的基础后，我们再来聊聊const。</p> <p>关于一般的内置类型使用const，我们就不再赘述了</p> <p>重点来说说类中的const =&gt; const函数</p> <h3 id="const-function">const function</h3> <p>提到const函数，有这几个：函数参数，返回值，函数被const修饰。 <strong>const函数，狭义上特指const的成员函数，表示我们并不会修改此对象，</strong></p> <p>在这里我们要考虑的重要内容是：<strong>const属性可以进行重载</strong></p> <p>我们在设计类的接口时，应该合理考虑到会遇到的参数类型，从而设计const及non-const版本 比如我们会遇到这样的场合：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Library</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">char</span> <span class="o">&amp;</span><span class="n">operastor</span><span class="p">[](</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="s">"hello ,world"</span><span class="p">);</span>
</code></pre></div></div> <p>这其中就使用了const版本的接口。 若使用const版本时，返回值并非<code class="highlighter-rouge">pass by reference to const</code> 而是 <code class="highlighter-rouge">pass by reference</code> 就会出现，const对象被意外修改的情况。 比如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">textString</span> <span class="n">t</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="sc">'J'</span><span class="p">;</span>   <span class="err">#</span><span class="o">=&gt;</span> <span class="k">const</span> <span class="n">object</span> <span class="n">t</span> <span class="n">has</span> <span class="n">been</span> <span class="n">modified</span>
</code></pre></div></div> <p>滥用cosnt，并不会对导致出现成员函数异常，但是会出现这样的错误。</p> <p>这就涉及到<em>bitwise constness</em> 与 <em>logical constness</em></p> <p>上面出现的问题本质是：<strong>在bitwise constness中改变了指针的指向，未改变指针</strong> <strong>已经违背了logical constness，但是在编译器的bitwise constness层面上非错误</strong></p> <p><strong>上面是个隐式的错误接口开放，const内部，结果导致了非const接口开放，破坏了类的常量性质</strong></p> <p>对于， 这种问题的解法便是：<strong>使用mutable来将成员常量性分离</strong> 即使在const对象的内部，mutable类型的变量仍然是可以被修改的！</p> <h3 id="const-and-non-const">const and non-const</h3> <p>在提供多个版本接口时，不可避免的是，代码的相似性与重复劳动(对程序员) 我们的建议就是：使用已经实现的部分来管控未实现的部分。 针对const与non-const要求是：<strong>使用const来实现non-const</strong></p> <p>原因便是：<strong>const版本做出承诺不修改对象，non-const可以在调用const时，正常工作</strong> <strong>反之不可，因为non-const不承诺，我们用non-const来减少const的重复工作没有承诺，原来保证不变的对象可能发生改变。</strong></p> <p><strong>而且： 因为我们在此处已经确定转型是安全的，所以使用<code class="highlighter-rouge">static_cast&lt;&gt;</code></strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">&amp;&gt;</span>
    				<span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">pos</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p>另外，这种消除重复的手法，还可以用于：使用operator==() 实现 operator!=()之类</p> <p>总之，const是个非常灵活而又实用的东西，多多使用，多多发掘。</p> <blockquote> <p>请记住：</p> <ul> <li>将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本身</li> <li>编译器强制实施bitwise constness，但编写程序应该使用“概念上的常量性”，即注意logical constness的问题，以及mutable的使用</li> <li>当const和non-const成员函数有着实质上的等价实现时，令non-const版本调用const版本实现可以避免代码重复</li> </ul> </blockquote> <h2 id="item-04make-sure-that-objects-are-initialized-before-threre-used">Item 04：Make sure that objects are initialized before thre’re used</h2> <p><em>这一部分其实是一个常识，没错，就是使用前初始化！</em></p> <p>简单的来说，按照下面几个步骤走下来，一定可以保证正确性和合理性：</p> <ol> <li>内置类型，手动初始化</li> <li>自定义类类型，依靠构造函数初始化，其中一定要注意初始化列表的问题</li> <li>处理好初始化次序不定的情况(不同编译单元中的non-local static 变量)</li> </ol> <h3 id="内置类型">内置类型</h3> <p>其中内置类型的初始化，你我也知道 —- 默认初始化(与值初始化区分)。都是未定义的值(..)</p> <h3 id="自定义类类型">自定义类类型</h3> <p>我们强调一下构造函数，来看看下面两种形式的构造函数：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Text</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Text</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">textName</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">authorName</span><span class="p">;</span>
    <span class="kt">int</span> 	    <span class="n">textNum</span><span class="p">;</span>
    <span class="kt">double</span> 	 <span class="n">textPrice</span><span class="p">;</span>

<span class="p">}</span>

<span class="c1">// ver.1</span>
<span class="n">Text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">textName</span> <span class="o">=</span> <span class="n">text</span><span class="p">;</span>
    <span class="n">authorName</span> <span class="o">=</span> <span class="n">author</span><span class="p">;</span>
    <span class="n">textNum</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">textPrice</span> <span class="o">=</span> <span class="n">price</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ver.2</span>
<span class="n">Text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">author</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">)</span>
	<span class="o">:</span> <span class="n">textName</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">authorName</span><span class="p">(</span><span class="n">author</span><span class="p">),</span> <span class="n">textNum</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">textPrice</span><span class="p">(</span><span class="n">price</span><span class="p">)</span>
<span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>ver.1 看上去更像我们传统意义上的初始化，<strong>其实是假的，这个叫赋值</strong></p> <p>ver.2 则是真正意义上的初始化。</p> <p>有这样几个点是要了解的：</p> <ol> <li>C++是为数不多严格区分赋值与初始化概念的语言的(可能是我见得少)</li> <li>C++中初始化，发生在赋值之前，或者说在构造函数值之前</li> <li><strong>我们墙裂建议使用member initialization list的形式初始化成员</strong></li> </ol> <p>主要出于下面的考量：</p> <ol> <li>初始化(拷贝构造)和default构造 + 赋值的开销一目了然，肯定是拷贝构造低</li> <li>即使自定义类型的拷贝构造和 defauilt + 赋值开销近似，但为了一致性</li> <li>如果有的类，真的丧心病狂，没有default构造了，玩锤子ver.1</li> </ol> <p>接下来，我们要注意的是初始化的顺序： <strong>1. 函数调用上，初始化在构造之前，base-class在deriver-class之前</strong> <strong>2. 具体成员与类内声明顺序相关，与list顺序无关，所以，比要互相依赖初始化</strong></p> <p>除了某些特殊情况：比如从文件，数据库读入东西时，使用ver.1形式。 支持，第二个过程，自定义类类型的初始化也确定了</p> <h3 id="不同编译单元的non-local-static-varible">不同编译单元的non-local static varible</h3> <p>最恶心人的便是：不同编译单元中的non-local static变量的初始化顺序，恶心的要死 <strong>可以说是，根本无法确定这样的顺序，因为不同的人，在不同时刻编写的代码</strong> <strong>根本无法确定初始化次序，这是个无解的难题</strong></p> <p>有句话说得好，，<em>办法总比困难多</em> 借用《Design pattern》 中单例模式的讨论，我们可以使用技巧规避这个问题</p> <p>先来补点基础： <strong>function内部的static变量叫做local static var，因为他一定经历了初始化，有定义式</strong> <strong>其他的叫做non-local static var，如namespace，global，file中的，都是从定义出产生，到程序结束消亡</strong></p> <p><strong>关键就是，你使用这样的变量时，他未定义，凉了。。。</strong> 我们的思路便是: 将使用特定的non-local static var转换为local static var使用</p> <p>也就是说，采用这样的手法：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//file1.cc</span>
<span class="k">class</span> <span class="nc">FileSyatem</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="p">...</span>
<span class="k">private</span><span class="o">:</span>
	<span class="p">...</span>
<span class="p">};</span>

<span class="n">Filesystem</span> <span class="o">&amp;</span><span class="n">get_filesystem</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">Filesystem</span> <span class="n">fs</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fs</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// file2.cc</span>
<span class="k">class</span> <span class="nc">Directory</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="p">...</span>
<span class="k">private</span><span class="o">:</span>
<span class="p">...</span>
<span class="p">};</span>

<span class="n">Directory</span> <span class="o">&amp;</span><span class="n">get_dir</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">Directory</span> <span class="n">dir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">dir</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// file3.cc</span>
<span class="c1">// Now the filesystem, directory object must be initialized</span>
<span class="n">Filesystem</span> <span class="n">global_fs</span> <span class="o">=</span> <span class="n">get_filesystem</span><span class="p">();</span>
<span class="n">Directory</span> <span class="n">global_dir</span> <span class="o">=</span> <span class="n">get_dir</span><span class="p">();</span>
</code></pre></div></div> <p>PS: 一个小问题，关于竞争状态（Race Condition), 只要是non-const的static <strong>无论是local，或non-local，都会引发竞争状态</strong> 解法：<strong>单线程阶段，完全初始化完成即可避免</strong></p> <p>总之，只要完整按照上面的三步走，就可以基本保证适用对象前初始化的问题！</p> <blockquote> <p>请记住：</p> <ul> <li>为内置类型对象执行手工初始化，因为C++不保证初始化他们</li> <li>构造函数最好使用成员初始化列表，初始化列表列出的成员变量，其排列次序应该和他们在class中的声明明次序相同</li> <li>为免除”跨编译单元之初始化次序”问题， 请以local static对象替换non-local static对象</li> </ul> </blockquote> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://localhost:4000/tags/#EffectiveC++" title="Pages tagged EffectiveC++" class="tag"><span class="term">EffectiveC++</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/accustoming-yourself-to-C++/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/accustoming-yourself-to-C++/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/accustoming-yourself-to-C++/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'Evilcrow'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
