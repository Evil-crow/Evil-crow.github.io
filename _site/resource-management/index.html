<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css"> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title><星月夜> Resource Management &#8211; Road to Coding</title> <meta name="description" content="只要那一抹笑容尚存, 我便心无旁骛"> <meta name="keywords" content="EffectiveC++"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="<星月夜> Resource Management"> <meta name="twitter:description" content="Chapter III 资源管理"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="<星月夜> Resource Management"> <meta property="og:description" content="Chapter III 资源管理"> <meta property="og:url" content="http://localhost:4000/resource-management/"> <meta property="og:site_name" content="Road to Coding"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <link rel="canonical" href="http://localhost:4000/resource-management/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Road to Coding Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="Road to Coding photo" class="author-photo"> <h4>Road to Coding</h4> <p>只要那一抹笑容尚存, 我便心无旁骛</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:evilcrow486@gmail.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/Evil-crow" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://localhost:4000/posts/">All Posts</a></li> <li><a href="http://localhost:4000/tags/">All Tags</a></li> </ul> </li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn" style="background-color:rgba(255,255,255,0.97);"> <div class="content"> <div class="post-title "> <h1><星月夜> Resource Management</h1> <h4>19 Sep 2018</h4> <a class="btn zoombtn" href="http://localhost:4000/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <p><em>C++是一门强大的编程语言, 它自信程序员拥有强大的本领驾驭它的各个方面, 所以将资源管理的任务</em> <em>全部托付给程序员(好吧, 只是为没有GC在洗地…)</em> <em>从最基础的动态内存分配 ~ 文件描述符(file descriptor) ~ 套接字(socket) ~ 线程(thread)</em> <em>资源管理的任务无处不在, 因此资源管理便成为我们严格对待的方面</em></p> <h2 id="item-13-use-objects-to-manage-resource">Item 13: Use objects to manage resource</h2> <p>对于资源管理, 说的简单了, 其实最重要的就是: <strong>资源泄漏(memory leak)的问题</strong> 1.不使用的资源, 应该及时释放 2.已经释放的资源, 绝对不能使用, 会导致未定义行为</p> <p>我们从最常见的heap-based资源开始, 先来看看我们平时是怎么做的吧,</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>                 <span class="c1">// allocate resource(int) on heap</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">get_resource</span><span class="p">(...);</span>	        <span class="c1">// func -- get resource</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_resource</span><span class="p">();</span>      <span class="c1">//request resource</span>
	<span class="p">...</span>
	<span class="k">delete</span> <span class="n">p</span><span class="p">;</span>                     <span class="c1">// release resource</span>
<span class="p">}</span>
</code></pre></div></div> <p>正如我们上面的编码, 我们先申请资源, 最后释放资源, 一切看上去是那么的井然有序. <strong>真的能如你所愿吗 ? ** <em>考虑一下: 如果在<code class="highlighter-rouge">...</code>中间,存在: 提前return, throw异常, 多重嵌套, 还会正常工作吗 ?</em> **事实上, 只要是足够正式的工程代码, 极有可能工作流是到不了 资源释放的步骤的.</strong></p> <p>当然, 通过细致而严谨的编码, 我们可以做到资源管理的安全性 但是其中的难度可想而知 另一方面, 如果并非是代码维护者, 对于代码做了某些改动, 极有可能导致资源管理的有一次失控</p> <p><strong>因此, 引入使用对象管理资源的思想, 即资源获得即初始化(RAII)</strong></p> <blockquote> <p>那么, 何为RAII?</p> <p>RAII(Resource Acquisition Is Initialization) 字面意思为: 资源获取即初始化. 是有点拗口 实际上,它遵循了两个思想:</p> <ol> <li>资源一旦初始化(/赋值)即交给对象管理</li> <li>资源的释放, 交由类机制的析构函数释放</li> </ol> </blockquote> <p>那么, RAII的优点体现在哪里? 1.将资源交给对象管理, 只要处理的得当了, 可以避免内存泄漏(某种程度上) 2.隔离了资源的所有权, 解放了程序员, 就是说: 简化了资源管理的任务</p> <p>RAII的资源管理策略, 是真的十分巧妙 !</p> <p>那么, 如何使用RAII ? 分为两类: 类库中已经采用RAII策略的设施以及手动构建RAII类(Resource-managing classes)</p> <h3 id="standard-library-facilities">Standard Library Facilities</h3> <p>目前, 在标准库中已经采用RAII的设施有: <code class="highlighter-rouge">std::shared_ptr</code>, <code class="highlighter-rouge">std::unique_ptr</code>, <code class="highlighter-rouge">std::lock_guard</code> <strong>我们建议对于heap-based资源, 使用这些设施进行管理</strong></p> <p>例如:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/*
	 * int *p = new int;
	 * std::shared_ptr&lt;int&gt; p1(p);
	 */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">);</span>     <span class="c1">// acquire resource when request</span>
<span class="p">}</span>                                         <span class="c1">// leave the block with releasing resource</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtx</span><span class="p">);</span>    <span class="c1">// std facility, not heap-based resource</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里面我们使用了, <code class="highlighter-rouge">std::shared_ptr</code>, <code class="highlighter-rouge">std::unique_ptr</code>. 这是现在C++ (C++11起)标准库设施. 在&lt; EffectiveC++ &gt;, 一书中提及的, <code class="highlighter-rouge">std::auto_ptr</code>(已废弃, 算是<code class="highlighter-rouge">std::unique_ptr</code>早期版本) <code class="highlighter-rouge">std::tr1::shared_ptr</code>已经正式纳入标准库, 并非是TR1, TR2扩展, 且TR1, TR2扩展已经废弃</p> <p>不过,使用智能指针好也罢, 不使用也罢. 我们需要注意的是: <strong>智能指针的析构, 使用delete, 非delete[]</strong> <strong>也即是说, 我们对于数组的动态内存分配, 要不然拒绝, 要不然自行构建删除器</strong> <strong>毕竟, 对于数组类型, 标准库提供了自动析构的, vector以及string等设施(顺序容器)</strong></p> <h3 id="resource-managing-classes">Resource-managing classes</h3> <p>对于常见的其他资源, 比如: <code class="highlighter-rouge">socket</code>, <code class="highlighter-rouge">file desdcriptor(fd)</code>, <code class="highlighter-rouge">thread</code>, <code class="highlighter-rouge">mutex</code>等等, <strong>我们更倾向于手动构建RAII类</strong></p> <p>例如:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">lock</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="o">~</span><span class="n">lock</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Lock</span><span class="o">::</span><span class="n">Lock</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span> <span class="o">:</span> <span class="n">mtx</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span> <span class="p">}</span>

<span class="n">Lock</span><span class="o">::~</span><span class="n">Lock</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unlock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Usage</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">Lock</span> <span class="n">lk</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">}</span>                  <span class="c1">// release resource automaticlly</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Socket</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="o">:</span> <span class="n">socket_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">Socket</span><span class="p">()</span> <span class="p">{</span>
	    <span class="o">::</span><span class="n">close</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">socket_fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Usage</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="o">::</span><span class="n">socket</span><span class="p">(...);</span>
    <span class="n">Socket</span> <span class="n">s</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">}</span>                <span class="c1">// release resource automaticlly</span>
</code></pre></div></div> <blockquote> <p>请记住:</p> <ol> <li>为防止资源泄漏. 请使用RAII对象, 它们在构造函数中获得资源并在析构函数中释放资源</li> <li><del>两个常被使用的RAII Classes 分别是 <code class="highlighter-rouge">std::tr1::shared_ptr</code> 和 <code class="highlighter-rouge">std::auto_ptr</code></del> <del>前者通常是较佳选择, 因为其Copy行为比较直观.若选择<code class="highlighter-rouge">std::auto_ptr</code>,</del> <del>复制行为会使它指向null</del></li> </ol> </blockquote> <h2 id="item-14-think-carefully-about-copying-behavior-in-resource-managing-classes">Item 14: Think carefully about copying behavior in resource-managing classes</h2> <p>Emmmmmm, 严格意义上来讲, RAII资源类, 一般而言, 是禁止拷贝的. 对, 没错. 但是, 什么事情都有例外, 万一真的出现需要拷贝的情况, 我们应该作出什么样的选择呢?</p> <p>常见的选择有下面四种:</p> <h3 id="no-copy">No Copy</h3> <p>这是最常选择的策略, 因为RAII类没有拷贝的必要与需求, 我们何必自找麻烦呢?</p> <p>那么, 禁止拷贝的手段呢? (之前的条款已经提到过了)</p> <p>两种手段: 1.使用Uncopyable/noncopyable 2.明确语义, 不需要拷贝的函数</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Boost::noncopyable</span>

<span class="k">class</span> <span class="nc">noncopyable</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="cp">#if !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) &amp;&amp; !defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS)
</span>    <span class="n">BOOST_CONSTEXPR</span> <span class="n">noncopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">noncopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="n">noncopyable</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">noncopyable</span><span class="p">()</span> <span class="p">{}</span>
<span class="cp">#endif
#if !defined(BOOST_NO_DELETE_FUNCTIONS)
</span>    <span class="n">noncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopyable</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">noncopyable</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopyable</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="cp">#else
</span><span class="k">private</span><span class="o">:</span>
    <span class="n">noncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopyable</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">noncopyable</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">noncoptable</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// using Boost::noncopyable</span>

<span class="k">class</span> <span class="nc">Lock</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lock</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Lock</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// delete copy function</span>
<span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lock</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Lock</span><span class="p">();</span>
    <span class="n">Lock</span><span class="p">(</span><span class="k">const</span> <span class="n">Lock</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Lock</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Lock</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="share-resourse">Share Resourse</h3> <p>除了禁止拷贝之外, 我们一般还可以接受, 共享资源. 即指: 不同的pointer/reference可以指向相同的资源.</p> <p>我们一般有这两种手段: 使用智能指针RCSP, 或模拟底层引用计数 这两种自然就是 heap-based资源 与 其他类型的资源</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// using std::shared_ptr (not std::tr1::shared_ptr)</span>

<span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lock</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Lock</span><span class="p">();</span>
    <span class="n">Lock</span><span class="p">(</span><span class="k">const</span> <span class="n">Lock</span> <span class="o">&amp;</span><span class="n">lk</span><span class="p">)</span> <span class="p">{</span>                   <span class="c1">// 实现太shi, 差不多这个意思</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">pmtx</span> <span class="o">=</span> <span class="n">lk</span><span class="p">.</span><span class="n">handle</span><span class="p">();</span>
	<span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">handle</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">pmtx</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unlock</span><span class="o">&gt;</span> <span class="n">pmtx</span><span class="p">;</span>        <span class="c1">// 将std::unlock作为删除器</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using reference-count</span>
<span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lock</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Lock</span><span class="p">();</span>
    <span class="n">Lock</span><span class="p">(</span><span class="k">const</span> <span class="n">Lock</span> <span class="o">&amp;</span><span class="n">lk</span><span class="p">)</span> <span class="p">{</span>                   <span class="c1">// 实现太shi, 差不多这个意思</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="n">lk</span><span class="p">.</span><span class="n">handle</span><span class="p">();</span>
		<span class="n">refCount</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">mtx</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">refCount</span><span class="p">;</span>                       <span class="c1">// 引用计数</span>
<span class="p">};</span>
<span class="c1">// 细节没注意, 基本上就是这个意思</span>
</code></pre></div></div> <h3 id="move-reference">Move Reference</h3> <p>此部分, 和上一部分类似. 其中的区别便是: 转移资源而非共享资源</p> <p><em>使用现代C++, 我们很容易想到标准库设施</em> <code class="highlighter-rouge">std::unique_ptr</code>进行使用, 其他类的资源(非heap-base)自然就是<code class="highlighter-rouge">std::move()</code>了</p> <h3 id="deep-copy">Deep Copy</h3> <p>这种需求,真的是比较少, 本身RAII资源进行拷贝就少, 深拷贝更是凤毛麟角, 这部分就不再赘述 记住: 深拷贝, 拷贝的不仅是指针/引用等, 同时还拷贝了其所指向的对象. (有什么用, 反正现在没用上)</p> <p>上述我们介绍了四种策略, 但是从真正意义上来讲: <strong>我们仅仅接受: 禁止拷贝 + 共享资源</strong> <em>转移资源/深拷贝 并非是常见且合理的做法</em></p> <blockquote> <p>请记住:</p> <ol> <li>复制RAII对象必须一并复制它所管理的资源, 所以资源的Copying行为决定RAII对象的Copying行为</li> <li>普遍而常见的RAII class copying行为是: 抑制copying, 施行引用计数法. 不过其他行为也都可能被实现</li> </ol> </blockquote> <h2 id="item-15-provide-access-to-raw-resources-in-resource-managing-classes">Item 15: Provide access to raw resources in resource-managing classes</h2> <p><em>本条款的标题叫做: 在RAII资源类中提供访问资源权限</em></p> <p>**说实话, 看着矛盾是吧? 我们好不容易封装个资源, 现在又要开放接口, 搞事情 ? **</p> <p>**客观分析: 其实这并不矛盾, 为什么? 因为我们使用class管理资源的目的并非是为了封装 ! ** **是的, 你没听错, 我们使用class管理资源的主要目的是为了能合理的, 管理和释放 ! **</p> <p>**我们甚至可以, 谨慎的实现成员函数来避免直接访问资源, 但是与APIs的交互又该怎么办 ? **</p> <p><em>并且, 纵观标准库中的RAII设施, 同样提供了接口去访问资源.</em> 比如: <code class="highlighter-rouge">std::shared_ptr::get()</code>等</p> <p><strong>所以, 我们既然本身目的并非是为了封装, 所以我们开放访问资源的接口并非不合理</strong></p> <p>下面介绍访问资源的两种方式</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using interface get() etc.</span>
<span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lock</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Lock</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sahred_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">pmtx</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unlock</span><span class="o">&gt;</span> <span class="n">pmtx</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// using operator TYPE()</span>
<span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Lock</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Lock</span><span class="p">();</span>
    <span class="k">operator</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">pmtx</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unlock</span><span class="o">&gt;</span> <span class="n">pmtx</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Usage</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">mtx</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">lock</span> <span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">lk</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>    <span class="c1">// get()</span>
	<span class="n">foo</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>          <span class="c1">// operator TYPE()</span>
<span class="p">}</span>
</code></pre></div></div> <p>那么, 我们如何抉择使用哪种方式呢?</p> <p><strong>各有优劣</strong> 1.使用显示接口, 可以是我们的意图更加明显, 除了某些极端人士嫌丑陋以外, 也没什么不好的. 2.使用隐式转换, 其实容易出问题, 有的时候会出现相反的效果</p> <blockquote> <p>请记住:</p> <ol> <li>APIs往往要求访问原始资源(raw resource), 所以每一个RAII class应该提供一个”取得其所管理之资源”的方法</li> <li>对原始资源的访问可能经由显示转换或隐式转换.一般而言显示转换比较安全, 但隐式转换对客户比较方便</li> </ol> </blockquote> <h2 id="item-16-use-the-same-form-in-corresponding-uses-of-new-and-delete">Item 16: Use the same form in corresponding uses of new and delete</h2> <p>使用配对的new和delete 看起来其实是很简单的一个道理.</p> <p>事实上就是一个很简单的道理.</p> <p><code class="highlighter-rouge">new TYPE[] -&gt; delete [] p;</code> <code class="highlighter-rouge">new TYPE -&gt; delete p;</code></p> <p>为什么要成对使用, 因为如果不匹配, 就会有这样的问题: (类似于之前讨论指针和数组名混用)</p> <p>若, 使用delete[ ]不匹配, 就有可能过多释放内存, 甚至于正在使用, 或者无法析构的内存</p> <p>若. 使用delete不匹配, 就有可能少释放内存, 基本上也是未定义行为.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// valagrid的分析</span>
<span class="o">==</span><span class="mi">6539</span><span class="o">==</span> <span class="n">Mismatched</span> <span class="n">free</span><span class="p">()</span> <span class="o">/</span> <span class="k">delete</span> <span class="o">/</span> <span class="k">delete</span> <span class="p">[]</span>
<span class="o">==</span><span class="mi">6539</span><span class="o">==</span>    <span class="n">at</span> <span class="mh">0x4C2E1E8</span><span class="o">:</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">576</span><span class="p">)</span>
<span class="o">==</span><span class="mi">6539</span><span class="o">==</span>    <span class="n">by</span> <span class="mh">0x4005BD</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">in</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">Crow</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">)</span>
<span class="o">==</span><span class="mi">6539</span><span class="o">==</span>  <span class="n">Address</span> <span class="mh">0x5aeac80</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">40</span> <span class="n">alloc</span><span class="err">'</span><span class="n">d</span>
<span class="o">==</span><span class="mi">6539</span><span class="o">==</span>    <span class="n">at</span> <span class="mh">0x4C2D8B7</span><span class="o">:</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">423</span><span class="p">)</span>
<span class="o">==</span><span class="mi">6539</span><span class="o">==</span>    <span class="n">by</span> <span class="mh">0x4005A8</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">in</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">Crow</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">)</span>
</code></pre></div></div> <p>另外强调两个点: 1.对于数组之类的, 我们更建议vector, deque, string等设施 2.尤其是typedef等使用手动new, delete简直是毁灭级的, 因为它到底用的哪种new我们一无所知</p> <p>所以, 一定要保证自己<strong>成对匹配的使用new和delete</strong></p> <p><del>我曾经在不会C++的时候, 被g卓越因为这个坑过 \白眼</del></p> <blockquote> <p>请记住:</p> <ol> <li>如果你在new表达式中使用[ ], 必须在相应的delete表达式中也使用[ ]. 如果你在表达式中不使用[ ], 一定不要在相应的delete表达式中使用[ ].</li> </ol> </blockquote> <h2 id="item-17-store-newed-objects-in-smart-pointers-in-standalone-statements">Item 17: Store newed objects in smart pointers in standalone statements</h2> <p>这句话, 看上去有点奇妙, 什么意思呢?</p> <p><em>以独立的语句将newed对象置入智能指针</em></p> <p>看个例子:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">));</span>     <span class="c1">// prototype</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">throw</span> <span class="n">exception</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">),</span> <span class="n">foo</span><span class="p">());</span>
</code></pre></div></div> <p>这其中, 在func()函数调用的时候, 实参和形参匹配时的求值顺序是未定义的</p> <p>所以, 就有可能出现,下面这样的顺序</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">1.</span> <span class="k">new</span> <span class="n">p</span><span class="p">;</span>
<span class="mf">2.</span> <span class="n">foo</span><span class="p">();</span>
<span class="mf">3.</span> <span class="n">std</span><span class="o">::</span><span class="n">sahred_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(...);</span>
</code></pre></div></div> <p>那么, 一旦在第二步骤的时候, “成功”抛出异常, 毁灭级的打击, 这已经造成内存泄露了 <strong>而且, Debug及其困难, 因为复现的难度已经十分之大 !</strong></p> <p>**所以, 应该以独立的语句将new的资源置于智能指针中, 不同语句之间的求值顺序值确定的 **</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pw</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">func</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span> <span class="n">foo</span><span class="p">());</span>
</code></pre></div></div> <p><strong>上升一下: 不仅仅是这种申请资源, 只要是需要确定的顺序的行为, 我们就一定要分成独立的语句, 有的时候紧凑, 花哨的编码, 反而是毁灭的入口</strong></p> <blockquote> <p>请记住:</p> <ol> <li>以独立语句将newed对象存储于(置入)智能指针! 如果不这样做, 一旦异常被抛出, 有可能导致难以察觉的资源泄漏.</li> </ol> </blockquote> <p><em>Tips: 我们在本节中讨论的都是资源泄漏(Resource Leak), 已经不仅仅是内存泄漏(Memory Leak)</em></p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://localhost:4000/tags/#EffectiveC++" title="Pages tagged EffectiveC++" class="tag"><span class="term">EffectiveC++</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/resource-management/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/resource-management/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/resource-management/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'Evilcrow'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
