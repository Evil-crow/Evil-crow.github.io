<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css"> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title><星月夜> Constructors, Destructors, and Assignment Operators &#8211; Road to Coding</title> <meta name="description" content="只要那一抹笑容尚存, 我便心无旁骛"> <meta name="keywords" content="EffectiveC++"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://localhost:4000/assets/img/logo.png"> <meta name="twitter:title" content="<星月夜> Constructors, Destructors, and Assignment Operators"> <meta name="twitter:description" content="Chapter II 构造/析构/赋值运算"> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="<星月夜> Constructors, Destructors, and Assignment Operators"> <meta property="og:description" content="Chapter II 构造/析构/赋值运算"> <meta property="og:url" content="http://localhost:4000/constructors-destructors-and-assignment-operators/"> <meta property="og:site_name" content="Road to Coding"> <meta property="og:image" content="http://localhost:4000/assets/img/logo.png"> <link rel="canonical" href="http://localhost:4000/constructors-destructors-and-assignment-operators/"> <link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Road to Coding Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css"> <!-- JS --> <script src="http://localhost:4000/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://localhost:4000/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://localhost:4000/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://localhost:4000/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://localhost:4000/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://localhost:4000/favicon.png" /> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(http://localhost:4000/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://localhost:4000/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://localhost:4000/assets/img/logo.png" alt="Road to Coding photo" class="author-photo"> <h4>Road to Coding</h4> <p>只要那一抹笑容尚存, 我便心无旁骛</p> </li> <li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:evilcrow486@gmail.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/Evil-crow" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://localhost:4000/posts/">All Posts</a></li> <li><a href="http://localhost:4000/tags/">All Tags</a></li> </ul> </li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn" style="background-color:rgba(255,255,255,0.97);"> <div class="content"> <div class="post-title "> <h1><星月夜> Constructors, Destructors, and Assignment Operators</h1> <h4>13 Sep 2018</h4> <a class="btn zoombtn" href="http://localhost:4000/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <ul id="markdown-toc"> <li><a href="#item-05-know-what-functions-c-silently-writes-and-calls" id="markdown-toc-item-05-know-what-functions-c-silently-writes-and-calls">Item 05: Know what functions C++ silently writes and calls</a></li> <li><a href="#item-06-explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want" id="markdown-toc-item-06-explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want">Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</a></li> <li><a href="#item-07-declare-destructors-virtual-in-polymorphic-base-class" id="markdown-toc-item-07-declare-destructors-virtual-in-polymorphic-base-class">Item 07: Declare destructors virtual in polymorphic base class</a></li> <li><a href="#item-08-prevent-exception-from-leaving-destructors" id="markdown-toc-item-08-prevent-exception-from-leaving-destructors">Item 08: Prevent exception from leaving destructors</a> <ul> <li><a href="#悄悄掩盖住错误" id="markdown-toc-悄悄掩盖住错误">悄悄掩盖住错误</a></li> <li><a href="#让他去死" id="markdown-toc-让他去死">让他去死</a></li> </ul> </li> <li><a href="#item-09-never-call-virtual-function-during-constructor-or-destructor" id="markdown-toc-item-09-never-call-virtual-function-during-constructor-or-destructor">Item 09: Never call virtual function during Constructor or Destructor</a></li> <li><a href="#item-10-have-assignment-operators-return-a-reference-to-this" id="markdown-toc-item-10-have-assignment-operators-return-a-reference-to-this">Item 10: Have assignment operators return a reference to *this</a></li> <li><a href="#item-11-handle-assignment-to-self-in-operator" id="markdown-toc-item-11-handle-assignment-to-self-in-operator">Item 11: Handle assignment to self in operator=</a> <ul> <li><a href="#使用if-else控制流" id="markdown-toc-使用if-else控制流">使用if-else控制流</a></li> <li><a href="#使用copy-and-swap-cas" id="markdown-toc-使用copy-and-swap-cas">使用Copy and Swap (“CAS”)</a></li> </ul> </li> <li><a href="#item-12-copy-all-parts-of-an-object" id="markdown-toc-item-12-copy-all-parts-of-an-object">Item 12: Copy all parts of an object</a> <ul> <li><a href="#1-局部部分" id="markdown-toc-1-局部部分">1. 局部部分</a></li> <li><a href="#2-继承成分" id="markdown-toc-2-继承成分">2. 继承成分</a></li> </ul> </li> </ul> <p><em>上一篇中,我们着重进行了C++中最最基础,和C有很大区别的地方,比如语言联邦, 减少预处理器的使用,</em> <em>多使用const, 保证使用前初始化对象等几个方面</em></p> <p><em>这一部分, 我们就来聊聊使C++语法变得如此复杂的”罪魁祸首”之一 —- 复杂的拷贝控制</em></p> <h2 id="item-05-know-what-functions-c-silently-writes-and-calls">Item 05: Know what functions C++ silently writes and calls</h2> <p><em>这是一个关键的点, 我一直因此觉得C++足够傲娇.C/C++有着强大的性能,同时他们又兼具着许多风险行为</em> <em>如何高效编程, 同时规避风险, 我觉得这就是C/C++的美感之一</em></p> <p>我们在此处要讨论的是: <strong>在你不知道的情况下, C++默默编写并调用了哪些函数</strong> (PS: 此处重要针对讨论的是 <code class="highlighter-rouge">class</code>内部的情况, global作用域内, 不可能被凭空塞函数的)</p> <p>先来看一个例子:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span> <span class="p">};</span>
</code></pre></div></div> <p>上面是一个简单地例子: <code class="highlighter-rouge">class Temp {};</code>我们并没有为它编写任何的成员函数, 那么它可以使用吗? 比如: <code class="highlighter-rouge">Temp a; // Constructor</code> <code class="highlighter-rouge">Temp a(b); // Copy-constructor</code> <code class="highlighter-rouge">Temp a = b; // Copy-operator-assignment</code> <code class="highlighter-rouge">{ .... } // Destructor</code></p> <p>经过实验, 你可以发现, 上面这些操作都是成功的! 为什么? 我们明明没有编写这些成员函数的啊! 这便是<strong>C++默默编写并调用的函数</strong></p> <p>总共有下面这四(六)类:</p> <ol> <li>Constructor</li> <li>Copy Constructor</li> <li>Copy assignment operator</li> <li>Move Constructor (C++11)</li> <li>Move assignment operator (C++11)</li> <li>Destructor</li> </ol> <p>这些默默编写的函数存在着下面的特点: 1.public &amp;&amp; inline 2.默认初始化 &amp;&amp; 逐次拷贝 3.编译器生成的版本都是non-virtual的, (继承得来的除外)</p> <p>暂且记下这些特点, 我们下面的讨论会用到, 并非分析如何处理此情况</p> <p>所以上面的例子实际上是这样子的:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
    <span class="n">Temp</span><span class="p">();</span>
    <span class="n">Temp</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Temp</span><span class="p">(</span><span class="n">Temp</span> <span class="o">&amp;&amp;</span><span class="p">);</span>
    <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Temp</span> <span class="o">&amp;&amp;</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Temp</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>那么, 编译器一定会生成这些函数吗? 是不是得思考一下?</p> <p>我们有下面的结论: <strong>assignment operator不一定会生成, 其余的函数照样会生成</strong></p> <p>考虑这样的情况: 1.内含reference的class, 2.内含const成员的class 3.base class的assignment operator为private</p> <p>来解释一下这三种情况: 1.若含有reference, 拷贝赋值函数到底是修改reference(错误)还是其所指的内容(无意义)? 2.const成员怎么可能会被修改! 3.若base class的拷贝赋值为private, derive class的拷贝赋值函数便无法生成</p> <p><strong>简单地来说, 我们设身处地的为编译器着想, 它是否可以处理这种情况, 从而进行判断</strong> <strong>上面的情况便是: 编译器无法为这些情况处理, 所以它的copy assignment operator创建失败</strong></p> <blockquote> <p>请记住</p> <p>编译器可以暗自为class传播创建default构造函数, copy构造函数, copy assignment 操作, 以及析构函数, (以及move 构造函数, move assignment操作 C++11后)</p> </blockquote> <h2 id="item-06-explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want">Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</h2> <p><em>这一条款的讨论是基于 Item 05的, 处理编译器生成函数的不二法宝</em></p> <p><strong>首先强调一个事实: 如今可以明确的说明对于编译器生成函数我们持有的态度</strong></p> <p><em>还是hepangda的说法比较准确, “ C++11之后语言的语义更加明确 “</em> <em>解释起来就是, C++之前的一些做法, 你不是很明确它的意思, 在一定条件下, 得借助注释才能迅速的理解</em></p> <p>那么,我们先来说说在现代C++中如何处理这种问题吧,</p> <p>现代C++中我们可以使用<strong>default, 以及delete</strong>来进行编译器生成函数的控制, 表明我们的态度</p> <p>如下例子:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
    <span class="n">Temp</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Temp</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Temp</span><span class="p">(</span><span class="n">Temp</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Temp</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="o">~</span><span class="n">Temp</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>通过语义明确的现代C++, 我们可以做到不想编译器自动生成的函数, 明确拒绝</strong> <strong>如此的做法,也已经成为现代C++的编程规范之一了</strong></p> <p><em>那么, 之前的C++是如何处理这样的问题呢 ?</em></p> <p>这种问题还是会出现的, 我们还是之前的态度: 我们不能假定用户并不会犯错, 所以这种情况也应该处理掉的. 那么我们的入手点在于: compiler-gengrated functions 都是默认 <code class="highlighter-rouge">public &amp; inline</code> 我们的入手点便是: 将其不能直接使用 =&gt; <strong>使用访问权限的控制手段</strong></p> <p>我们提供以下两种思路: 1.<code class="highlighter-rouge">private &amp; implemention</code> 2.<code class="highlighter-rouge">base-class &amp; implemention</code> (1.的基础上改良)</p> <p>对于1, 我们的思路很明确, 就是使用<code class="highlighter-rouge">private</code>访权控制来拒绝我们不想使用的成员函数</p> <p>但是, <code class="highlighter-rouge">member function</code>和<code class="highlighter-rouge">friend function</code>会打扰我们.</p> <p><strong>于是, 我们就给予它便不实现, implmention =&gt; 链接器会报错</strong></p> <blockquote> <p>链接器报错 link-error 上面说到的链接器报错,是这个原因: 按照常人理解, 一般没有实现的函数, 会直接编译错误对吧 ? 但是C++因为分离式编译的原因 (区别参考于Java) ,前置声明了解一下, pimpl手法基础 知道link期间才会报错, 找不到函数的引用, 也就是实现之处, “no reference to FUNC”</p> </blockquote> <p>于是方法1 可以比较好的解决这个问题了.</p> <p>尽管链接器报错, 也不会影响运行时效率, 可是我们还想尽早的报错为好, 将错误提前到编译期(Compiler) 有办法吗? 一定是有的!</p> <p>使用OOP的手法: 继承 我们可以构造一个基类(因为不给予实现),将之继承, 然后正常编写即可. **那么为什么会将报错提前至编译期呢 ? **</p> <blockquote> <p>无法进行构造, 因基类没有构造函数, 就是说一定要是用这个类构建对象, 才能错误提前到编译期</p> </blockquote> <p>举个例子如下:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">noncopy</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">noncopy</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopy</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">noncopy</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopy</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Temp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">noncopy</span> <span class="p">{</span>
<span class="p">....</span>
<span class="p">};</span>

<span class="n">Temp</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div> <p>这便是正确的使用举例</p> <p><strong>我们建议使用现代C++语义明确的手法, C++03, 乃至98的手法, 只是作为开阔思路的解法了解即可</strong></p> <blockquote> <p>请记住</p> <p>为驳回编译器自动(暗自)提供的机能, 可将相应的成员函数声明为privat并且不予实现. 使用像uncopyable这样的base class也是一种做法</p> </blockquote> <h2 id="item-07-declare-destructors-virtual-in-polymorphic-base-class">Item 07: Declare destructors virtual in polymorphic base class</h2> <p>如果要在C++中提到 <code class="highlighter-rouge">virtual</code>这个词, 经常用在这两个方面: <code class="highlighter-rouge">virtual继承</code> 与 <code class="highlighter-rouge">virtual function</code></p> <p>我们这一部分专注于<code class="highlighter-rouge">virtual function</code>的内容, 虚继承的内容都是后话.</p> <p>首先来看一个例子:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">base</span><span class="p">();</span>
    <span class="o">~</span><span class="n">base</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Aderive</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{...};</span>
<span class="k">class</span> <span class="nc">Bderive</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{...};</span>
<span class="k">class</span> <span class="nc">Cderive</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{...};</span>

<span class="n">base</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="n">get_derive_pointer</span><span class="p">();</span>   <span class="c1">// 为了多态需求使用, 基类指针(/引用皆可)</span>

<span class="k">delete</span> <span class="n">pb</span><span class="p">;</span>
</code></pre></div></div> <p><code class="highlighter-rouge">delete pb;</code><strong>会造成严重的灾难性后果 !</strong> <strong>因为delete一个基类指针, 而且它的析构函数是non-virtual, 在派生类中, 此析构仅仅是base析构</strong> <strong>这样, 你也能想到析构的下场了吧, derive部分无法析构, 且指针销毁, 只剩下一个不完全的对象</strong></p> <p>那么,正确的做法呢?</p> <p><strong>使用virtual-destructor 在base-class中 (子类继承后,virtual属性一并继承)</strong></p> <p>这个其实是多态性的基础–C++中,基类指针/引用可以指向派生类的对象, 因此才能实现多态性</p> <p>这样一来, 就可以舒服的解决这个问题了.</p> <p><em>那么, 从一个方面来考虑, 未提供nvirtual destructor的函数, 就很麻烦了, 万一被继承就要出篓子</em> <em>比如: std::stirng, std::iostream等</em> <em>EffectiveC++的作者在感慨 C++没有的 final 已经在现代C++中加入, 但是我在&lt; string &gt;中还没找到</em> <em>反正, 注意对于未提供virtual destrutor的class, 可能本来就是没有被设计作为多态base-class考虑</em></p> <p>我们再来稍微说说vitual的事,</p> <p>下面这些是, hepangda给我的科普,</p> <blockquote> <p>C++中实现的多态是成本最小的之一. 很简单的问题, 使用计算机时, 多态是我们目前不可预测的, 在编译期无法预知, 那么最简单的, 就是打表的思想, 我把可能的情况都塞进去, 到时查表就行 而具有Basic Object的语言, 就可以完全实现反射, Java, Ruby等…</p> </blockquote> <p>基于上面的这段话: virtual实际上对class进行了打表, 将可能的函数指针封进表中, 成为虚表 (virtual table) 而每个class中会留一个隐藏的虚表指针vptr (virtual ptr) 使用virtual会<strong>大程度的提高开销 ! ! !</strong>, 他会使可执行文件增加容量</p> <p>举一个EffectiveC++中的例子: (64位环境)一个类中,有两个int, 应该占8个字节, 这个时候加上一个virtual, 多一个vptr class体积增加100% !</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>        <span class="o">=&gt;</span> <span class="mi">8</span> <span class="n">Bytes</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">B</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>        <span class="o">=&gt;</span> <span class="mi">16</span> <span class="n">Bytes</span>
</code></pre></div></div> <p>另外我们再来说说<strong>抽象基类</strong>的事情: abstract class 指的是含纯虚函数的类, <em>很不幸, 我们因为没有interface的关键字, 导致定义接口要使用抽象基类的手法</em> <strong>我们要讨论的是, 如何拥有一个抽象基类</strong></p> <p><strong>其实,也不麻烦,就是标题的 纯虚析构函数 即可</strong> <em>因为纯虚 (pure virtaul), 所以是抽象基类</em> <em>同时又是 virtual 析构函数, 所以不用担心析构的问题</em></p> <p><strong>这里的窍门是: 要为 pure virtual destructor 提供一份定义</strong> <strong>否则, derive class 的destructor都会爆炸的, 具体上一条款中关于implemention的问题</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vitrual</span> <span class="o">~</span><span class="n">Temp</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Temp</span><span class="o">::~</span><span class="n">Temp</span><span class="p">()</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>因此, 给出我们使用virtual的建议: <strong>记住: 仅仅在有多态需求时使用virtual函数, 其余时候(仅作为基类, 一般类)能不用就不要用virtual</strong></p> <blockquote> <p>请记住</p> <p>polymorphic(带多态性质的) base classes 应该声明一个virtual 析构函数. 如果class带有任何virtual函数, 它就应该拥有一个virtual析构函数</p> <p>不是设计用来作为 base classes（基类）或不是设计用于 polymorphically（多态）的 classes（类）就不应该声明 virtual destructor（虚拟析构函数）</p> </blockquote> <h2 id="item-08-prevent-exception-from-leaving-destructors">Item 08: Prevent exception from leaving destructors</h2> <p>异常可谓是进行OOP中所必不可少的。 从某个方面来说, 使用异常机制可以改变程序设计的模式, 使我们更加专注于逻辑设计 将平时繁琐的错误处理情况, 按死在异常中(简单地说, 不容易分心)</p> <p>C中也实现了近似于异常的机制, 起源于goto的语法, <code class="highlighter-rouge">setjump/longjump</code> Java中的异常机制十分完善, 并且保证了足够的效率. 反观, C++中的异常机制, 因为是后来加入的体系, 所以在性能和效率上都差强人意.</p> <p>一个不得不承认的事实: <strong>C++中应该尽可能少, 甚至不使用异常, 而且我们一般对于异常的处理是杀死</strong></p> <p>那么, 我们在这一条款中, 到底要讨论什么主题呢？</p> <p><em>我们对于异常机制的使用, 以及关于OOP设计接口的一部分讨论</em></p> <p>对于异常的处理, 我们以下面的例子来谈：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SQLaffair</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">SQLaffir</span><span class="p">();</span>
    <span class="o">~</span><span class="n">SQLaffair</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">SQL</span> <span class="o">*</span><span class="n">psql</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>我们使用指针作为成员, 这也是pimpl手法的应用之一。</p> <p>我们重点的是要讨论在析构函数中, 如果发生了异常该怎么办？ 我们一般具有两种手段来处理:</p> <ol> <li>悄悄掩盖住错误</li> <li>让他去死 (PS: Let it die挺好玩的)</li> </ol> <h3 id="悄悄掩盖住错误">悄悄掩盖住错误</h3> <p>这一种处理方法, 在某种程度上是为了软件稳定的妥协。 问题并非是毁灭级的失败, 且稳定性更为重要的时候, 我们便放弃对错误的处理, 悄悄掩盖起来</p> <p>我们为什么会选择悄悄处理错误这样一种决策呢?</p> <p><em>因为在析构函数中抛出异常意味着 “中断程序” 和 “未定义的行为”</em></p> <p>即使悄悄吞下错误, 在一定程度上也比引发上面两种行为, 好得多。</p> <h3 id="让他去死">让他去死</h3> <p>这是一种大多数情况的策略</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SQLaffir</span><span class="o">::~</span><span class="n">SQLaffir</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">runtime</span><span class="p">(</span><span class="s">"msg"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">runtime</span> <span class="n">re</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>但是, 这种策略也显得过于粗暴, 用户在被强制中断, 不太友好。</p> <p>所以, 我们的建议是, 开放一个接口给用户使用, 同时析构进行调用。</p> <p>如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SQLaddair</span><span class="o">::</span><span class="n">close</span> <span class="o">=</span> <span class="n">flase</span><span class="p">;</span>  <span class="p">(</span><span class="n">TYPE</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">close</span><span class="p">;)</span>
<span class="n">SQLaffir</span><span class="o">::</span><span class="n">close</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SQLptr</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="n">close</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SQLaffair</span><span class="o">::~</span><span class="n">SQLaffair</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">close</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">SQLptr</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">catch</span><span class="p">(...)</span> <span class="p">{</span>
            <span class="c1">// 两种策略</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面的策略便是我们推崇的真正应该使用的处理手法。</p> <p>为什么这样呢？因为他有如下优点:</p> <ol> <li>析构函数中严格的使用”悄悄吞掉” 或 “让他去死”的策略, 避免抛出异常</li> <li>我们给了用户一个接口, close() 来处理异常情况</li> </ol> <p>EffC++中解释了, 使用close()与接口设计的矛盾性： 虽然从设计上来讲, 不应该将资源管理权交给用户, 因为不安全。</p> <p><strong>但是, 我们在此处将资源控制权交给用户, 为什么?</strong></p> <p>因为,关于SQL连接关闭是不可轻易吞下的错误, 我们应该给予用户以控制并处理错误的权利 所以, 此处我们先将问题暴露给用户, <strong>在用户放弃处理的时候, 我们在析构函数中, 使用两种策略处理</strong></p> <p>综上所述: <strong>1. 不能让异常在析构函数中抛出, 会导致未定义行为/crash, 应该选择悄悄吞下/让他去死</strong> <strong>2. 基于1, 我们应该作出, 必需要处理的异常, 在析构函数之前进行处理, 别让异常等到析构, 往出传播</strong></p> <p><em>EffectiveC++中, 候捷先生的翻译是: 别让异常逃离析构函数</em> <strong>私以为更妥当的翻译应该是: 在析构结束之前处理错误, 不要让异常在析构函数中抛出</strong></p> <blockquote> <p>请记住</p> <p>destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后抑制它们或者终止程序。</p> <p>如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。</p> </blockquote> <h2 id="item-09-never-call-virtual-function-during-constructor-or-destructor">Item 09: Never call virtual function during Constructor or Destructor</h2> <p>继承是面向对象编程中很重要的一个特性.</p> <p>设计并构建功能完整并强大的继承体系是一项复杂的工程.</p> <p>在这其中我们会翻一个很经典的错误: <strong>在构造/析构函数中使用virtual函数</strong> 乍看之下, 是不是还是挺有道理的.</p> <p><strong>事实上, 这是一个严重的错误: 因为在析构, 构造期间. 类并非完整的, RTTI并不能得到派生类类型</strong> <strong>因此, 我们所调用的只能是基类版本, 会导致严重的错误! 并不能达到我们的需求. 严重性可想而知.</strong></p> <p>来看这样一个例子:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">base</span><span class="p">();</span>
	<span class="o">~</span><span class="n">base</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="n">log</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">base</span><span class="o">::</span><span class="n">base</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">log</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Aderive</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Aderive</span><span class="p">();</span>
	<span class="o">~</span><span class="n">Aderive</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bderive</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Bderive</span><span class="p">();</span>
	<span class="o">~</span><span class="n">Bderive</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Aderive</span> <span class="n">ad</span><span class="p">;</span>
</code></pre></div></div> <p>上面的示例, 我们构造ad对象, 构造过程会顺利完成. <em>但是, 其中使用的log(), 是base::log(), 不得不承认, 这是个令人惊奇的事实.</em></p> <p><em>*原因正如上面所说: ** *基类构造发生在派生类部分构造之前(base part construct before derive part)</em> <em>我们使用vitual函数, RTTI得到的是base类型, 而非是derive类型, 不能满足我们的要求</em> <em>更通俗的来讲: 此时的virtual并非是virtual, 仅仅是它自己的版本</em></p> <p><em>正是因为, derive class尚未初始化完成, 使用派生类中的内容, 可能导致不安全行为/未定义行为</em> <em>所以, 不允许virtual, 仅仅能使用base::log()版本.derive construct时, virtual不会下降到derive class</em></p> <p><strong>准确的理由: 此时RTTI结果是base类型,dynamic_cast (此时进入base部分, derive部分视为未定义)</strong> <strong>析构函数也是同理的.</strong></p> <p><em>事实上, 防止构造/析构过程中出现virtual调用时很难检测的错误</em> <strong>因为, 提供了实现版本, 就会出现正常运行, 错误结果的情况.</strong></p> <p><em>注: pure virtual的版本可以通过编译, 调用会凉凉…</em></p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pure virtual method called
terminate called without an active exception
</code></pre></div></div> <p>例如:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">base</span><span class="p">()</span> <span class="p">{</span><span class="n">init</span><span class="p">();};</span>
    <span class="o">~</span><span class="n">base</span><span class="p">(){};</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span><span class="n">log</span><span class="p">();};</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">log</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                   <span class="c1">// pure virtual 运行, ERROR</span>
	<span class="c1">// virtual void log() const {cout &lt;&lt; "base";}     // Result: base</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">derive</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">derive</span><span class="p">(){};</span>
    <span class="o">~</span><span class="n">derive</span><span class="p">(){};</span>
<span class="k">private</span><span class="o">:</span> 
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">log</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"derive"</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">derive</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><em>明白了吗? 即是说, 一旦是impure virtual 就是很难处理的Bug</em></p> <p>那么, 有没有可以比较好的解决办法呢? <strong>派生类构造向基类传递参数</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;string&gt;
</span>
<span class="k">class</span> <span class="nc">Transaction</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span> 
    <span class="k">explicit</span> <span class="n">Transaction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">logTransaction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="k">const</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">};</span>

<span class="n">Transaction</span><span class="o">::</span><span class="n">Transaction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">logTransaction</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">BuyTranscation</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Transaction</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span> 
    <span class="n">BuyTranscation</span> <span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Transaction</span><span class="p">(</span><span class="n">createLogInfo</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>     <span class="c1">// 使用传参的形式完成原多态需求</span>
    <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span> 
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">createLogInfo</span><span class="p">(</span><span class="n">parameters</span><span class="p">);</span>   <span class="c1">// static保证此部分与对象无关, 无危险</span>
<span class="p">};</span>
</code></pre></div></div> <p>综合所述: <strong>不要在构造/析构中使用virtual, 因为这时刻他们的类型是base, RTTI结果亦是如此</strong></p> <p><em>或者说, 此时刻, 不会从base下降到derive层次</em></p> <blockquote> <p>请记住:</p> <p>在 construction（构造）或 destruction（析构）期间不要调用 virtual functions（虚拟函数），因为这样的调用不会转到比当前执行的 constructor（构造函数）或 destructor（析构函数）所属的 class（类）更深层的 derived class（派生类）。</p> </blockquote> <h2 id="item-10-have-assignment-operators-return-a-reference-to-this">Item 10: Have assignment operators return a reference to *this</h2> <p>此部分的内容实际上较为简单, 主要是阐述了一个关于<code class="highlighter-rouge">operator overload</code>的默认约定</p> <p>即:<strong>运算符重载应该返回*this的引用</strong></p> <p>我们可以看几个例子:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = Obj1 + Obj2;
a = getVal();
</code></pre></div></div> <p>为什么可以这样写, 因为a是左值, <strong>返回对*this的引用, 便能保证是左值</strong> <strong>若返回并非是左值, 则第二次运算会失败, 因为a仅仅是一个右值</strong></p> <p>简单地说: <strong>我们返回非<em>this引用也无大碍, 但是,为了与用户习惯以及内置类型行为近似** **我们强烈建议, 运算符重载返回对</em>this的引用.</strong></p> <p><em>PS: 这只是建议, 并非是编程规范</em></p> <blockquote> <p>请记住:</p> <p>让 assignment operators（赋值运算符）返回一个 reference to *this（引向 *this 的引用）。</p> </blockquote> <h2 id="item-11-handle-assignment-to-self-in-operator">Item 11: Handle assignment to self in operator=</h2> <p>如题所示, 这一条款我们主要讨论的是: 在<code class="highlighter-rouge">operator=</code>中处理”自赋值”情况</p> <p><del>这里再喷一下候捷先生的翻译, 不想多说</del></p> <p>自赋值的问题, 怎么回事?</p> <p>先来看一个正常的operator=</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">Temp</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这其中会造成什么问题吗? <strong>是的, 当自赋值时, 这样的运算符重载会产生未定义的行为, 因为悬垂指针</strong></p> <p><em>换种思路, 我们再来分析一下, 这种”自赋值”常见吗?</em></p> <p><em>不幸的是, 基于两方面的原因. “自赋值”是一个不好规避的问题</em> <em>1. 我们不能假设(assume)用户的行为, <del>把他们当成蠢蛋就行了</del></em> <em>2. 我们更多的遇到的情况是, “隐式”自赋值</em></p> <p>例如:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">...;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">=</span> <span class="p">...;</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div> <p><em>上面的例子便是两种常见的”隐式”自赋值情况, 需要十分的当心</em></p> <p>扯了这么多, 我们就来说说<strong>真正处理自赋值的方法</strong></p> <h3 id="使用if-else控制流">使用if-else控制流</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">Temp</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">)</span>
	    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    
	<span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="k">this</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>优点: 一旦遇到自赋值, 可以直接退出处理情况. 缺点: 增加了控制流, 开销不是那么容易抹掉的</p> <h3 id="使用copy-and-swap-cas">使用Copy and Swap (“CAS”)</h3> <p>也可以简称为CAS, 不过与那个大名鼎鼎的CAS是完全不同的东西.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Temp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Temp</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{...}</span>

<span class="k">const</span> <span class="n">Temp</span> <span class="o">&amp;</span><span class="n">Temp</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Temp</span> <span class="n">t</span><span class="p">(</span><span class="n">ths</span><span class="p">);</span>
	<span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>优点: 可以安全的处理任何情况 缺点: 当自赋值可能性比较大时, 效率不如增加控制流的手段.</p> <p><em>这两种手法, 可以比较好的处理自赋值, 选择那种,我们要根据情况来判断</em> <em>另外, 禁止自赋值行为时, assert()断言就派上用场了</em> <code class="highlighter-rouge">assert(*this == ths);</code></p> <blockquote> <p>请记住:</p> <p>当一个 object（对象）被赋值给自己的时候，确保 operator= 是行为良好的。技巧包括比较 source（源）和 target objects（目标对象）的地址，关注语句顺序，和 copy-and-swap。</p> <p>如果两个或更多 objects（对象）相同，确保任何操作多于一个 object（对象）的函数行为正确。</p> </blockquote> <h2 id="item-12-copy-all-parts-of-an-object">Item 12: Copy all parts of an object</h2> <p>拷贝时勿忘掉任何一个对象成分</p> <p>这是一句缄言, 拷贝赋值的时候, 缺少成分是最忌讳的</p> <p>那么, 我们要注意的是什么情况呢?</p> <p>主要有这样两种情况: <strong>1. 局部成分</strong> <strong>2. 继承成分</strong></p> <h3 id="1-局部部分">1. 局部部分</h3> <p>局部部分, 主要考虑的是这样的情况: 后续进行class修改时, 有的局部成分被忘记和省略</p> <p>那么唯一的办法: <strong>自己相信斟酌, 确认将所有成分进行拷贝</strong></p> <h3 id="2-继承成分">2. 继承成分</h3> <p>相对于局部部分, 继承成分乍看之下会很复杂: <strong>因为我们可能使用复杂的继承链</strong></p> <p>但是, 继承也有继承的好处.</p> <p><strong>只要我们保证层层严格使用基类的构造函数/拷贝赋值, 就可以保证每一部分不会被遗漏</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Base</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>一个重要问题: 不要试图用构造函数和拷贝构造相互实现, 没有意义! (最多使用私有方法简化重复工作)</strong></p> <blockquote> <p>请记住:</p> <p>copying functions（拷贝函数）应该保证拷贝一个 object（对象）的所有 data members（数据成员）以及所有的 base class parts（基类构件）。</p> <p>不要试图依据一个 copying functions（拷贝函数）实现另一个。作为代替，将通用功能放入一个供双方调用的第三方函数。</p> </blockquote> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://localhost:4000/tags/#EffectiveC++" title="Pages tagged EffectiveC++" class="tag"><span class="term">EffectiveC++</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/constructors-destructors-and-assignment-operators/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=http://localhost:4000/constructors-destructors-and-assignment-operators/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://localhost:4000/constructors-destructors-and-assignment-operators/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="http://localhost:4000/assets/js/jquery-1.12.0.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.dlmenu.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.goup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.magnific-popup.min.js"></script> <script src="http://localhost:4000/assets/js/jquery.fitvid.min.js"></script> <script src="http://localhost:4000/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'Evilcrow'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
