<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Road to Coding</title>
  
  <subtitle>只要那一抹笑容尚存，我便心无旁骛。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://evil-crow.github.io/"/>
  <updated>2018-10-18T03:36:24.376Z</updated>
  <id>http://evil-crow.github.io/</id>
  
  <author>
    <name>Crow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>&lt;星月夜&gt; Implementations</title>
    <link href="http://evil-crow.github.io/2018/10/09/C++/EffC++/effective5/"/>
    <id>http://evil-crow.github.io/2018/10/09/C++/EffC++/effective5/</id>
    <published>2018-10-09T15:10:00.000Z</published>
    <updated>2018-10-18T03:36:24.376Z</updated>
    
    <content type="html"><![CDATA[<p><em>讨论过设计与声明的细节之后, 实现自然水到渠成, 但是在实现的时候也不是那么顺利的, 其中也有许多坑</em><br><em>那么, 常见的坑都有哪些, 又有哪些方便易用的facilities呢, 如何提高效率是我们一直要关心的问题</em></p><h2 id="Item-26-Postpone-variable-definitions-as-long-as-possible"><a href="#Item-26-Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="Item 26: Postpone variable definitions as long as possible"></a>Item 26: Postpone variable definitions as long as possible</h2><p>核心正如标题: <strong>尽量延长定义式出现的时间</strong></p><p>你可能会疑惑,<strong> C中都是在顶层声明定义所有变量</strong>, 为何C++中变成如此 ?<br><em>C++程序员都有C基础, 这句话可能在1990s还比较适用, 现在是有点扯淡, 不过我有幸还是这样一批人</em><br><del>也不知道该说是我邮的教育方针好, 还是教育方针好呢 ?</del></p><p>先来看个例子吧, 为什么要尽量拖晚定义式出现的时间, 不显得不好看吗?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_deal_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">test_string</span><span class="params">(<span class="string">"..."</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (...)</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"..."</span>);    <span class="comment">// 症结所在</span></span><br><span class="line">    deal_with(test_string);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>众所周知, C++是支持异常系统的, 再没有任何一个catch的情况下, 最后会被<code>std::terminate()</code>终止<br>假设上述例子, 我们在异常之前定义变量, 然后抛出异常, GG了, 有一个问题:<br><strong>没错, 变量还没有被使用, 就析构了</strong>, 这便是有时候浪费资源的一种情况.</p><p>那么, 我们可以这样修改:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_deal_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span> (...)</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"..."</span>);</span><br><span class="line">    <span class="built_in">string</span> test_string;</span><br><span class="line">    test_string = <span class="string">"..."</span>;</span><br><span class="line">    deal_with(test_string);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这样可以吗 ? 虽然很抱歉, 但还是不合适的</em><br>在了解了C++之于构造和赋值的问题之后, 我们是建议: <strong>使用 初始化 &lt;= 构造 + 赋值的</strong><br>为什么呢? 根本原因: 提高效率</p><p>即,应该如此编码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_deal_somthing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span> (...)</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"..."</span>);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">test_string</span><span class="params">(<span class="string">"..."</span>)</span></span>;</span><br><span class="line">    deal_with(test_string);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然只是一点小变动, 但是它说明了一个核心问题: <strong>定义式应该 推迟到能初始化它的时刻 才合适</strong></p><p>下面来聊聊C/C++中的定义(还有声明)出现位置的问题:</p><p>为什么推迟定义呢? 还不是因为怕中间出意外, 造成无用开销.<br>所谓无用开销, 指的就是: 类似于上面的string一样的东西, 懂了吧?</p><p>那么, C中为什么还是顶层定义呢?<br><strong>1. C++中的异常机制, 更容易导致无用开销, 同时C与C++的内存布局也限制了这一部分内容</strong><br><strong>2. 还在使用顶层定义, 起码你用的是C99之前的标准, 最新的C标准支持使用时定义</strong><br><del>这里慨叹一下我们学校仍在给学弟学妹使用VC++6.0 甚至于Turbo C此类上古神器</del></p><p>现在有一个问题: 既然推迟定义位置, 那么loop的两种写法如何决断呢?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (; i != N; ++i) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如何选择呢? 这里我们要考虑的是开销问题,</p><ol><li>1个构造 + 1个析构 + n重赋值</li><li>n个构造 + n个析构</li></ol><p>当赋值的开销 &gt; 析构 + 构造(1组) 时, 选用方式二更合适一点<br>当然, 在有多次构造, 析构的时候, 开销也是不容小觑的, 方法一就显得更合适了</p><p>但是, 方法一还存在着污染命名空间的问题, 总体上而言, 方法二用的更多</p><h2 id="Item-27-Minimize-casting"><a href="#Item-27-Minimize-casting" class="headerlink" title="Item 27: Minimize casting"></a>Item 27: Minimize casting</h2><p>转型(casting) 其实是一个相当花式的玩意, 用这个可以写出很多秀的操作<br>但是, 作为开发来说, 是有点恶心. 而且, 转型并非无损, 还是有一定程度上开销的.</p><p>其他语言不太了解, 但是C/C++中的转型, 我们概括一下, 有下面几种:</p><ul><li>旧式转型<ul><li><code>(Type) var</code>:一般形式上的转型</li><li><code>Type (var)</code>: 函数形式的转型(非FP), 联想构造</li></ul></li><li>新式转型<ul><li><code>static_cast&lt;T&gt;(var)</code>: 静态转型, 一般转型比较通用, 不过必须是继承体系链上的</li><li><code>const_cast&lt;T&gt;(var)</code>: const转型, 一般用于取消常量性的转换, 仅此转型可达到</li><li><code>reinterpret&lt;T&gt;(var)</code>: 位层面上的转型, 可以理解为C中进行的指针强制类型转换等</li><li><code>dynamic_cast&lt;T&gt;(var)</code>: 动态转型, 一般用于多态需求, 可以自上向下转换, 当然开销很大</li></ul></li></ul><p>大概说说几种转型的作用范围及作用:</p><ol><li>一般进行的类型转换就使用<code>static_cast</code>就好了</li><li>用于函数重载取消常量性, 即使用const版本实现non-const版本时使用<code>const_cast</code>, 一般也仅此使用</li><li>进行<del>花式指针操作</del>, 在确保正确的时候, 进行指针层面的位解释时使用<code>reinterpert_cast</code></li><li>拥有基类handle, 想要调用派生类的func时, 使用<code>dynamic_cast</code>, 不过我们一般用其他手法规避</li></ol><p>使用程度:<br><code>static_cast, reinterpert_cast &gt;&gt; const_cast &gt; dynamic_cast</code></p><p>下面来处理两个问题:</p><h3 id="对于新式转型的理解"><a href="#对于新式转型的理解" class="headerlink" title="对于新式转型的理解"></a>对于新式转型的理解</h3><p>新式转型为何出现呢? <strong>仍然是C++最核心的目的: 避免错误, 明确语义的目的</strong></p><p>原来的<code>(Type)var 或者 Type(var)</code>涵盖了所有的转型动作, 语义十分混杂<br>C++将与拿来的转型拆成了, 四部分. 明确了语言, 使得coding也更加合理</p><p>比如说, 我们可以看看这个: <code>static_cast&lt;T&gt;(var)</code>与<code>Type(var)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">do</span>(<span class="keyword">int</span>(a));      <span class="comment">// 即使我们不这样做, 隐式的类型转换也会这样干</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">do</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a));     <span class="comment">// 新式转型应该这么写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的要说的话,其实使用就是类型转换更加符合我们的常识认知: <strong>构造一个符合类型的对象</strong></p><p>对于<code>explicit constructor</code>, <strong>是我们如今唯一值得使用旧式转型的地方</strong></p><p><strong>在其他之处, 我们建议, 使用新式转型来达到更加安全的转型, (毕竟C的旧式转型是不安全的)</strong></p><p>那么, 还有要讨论的吗? <strong>有 !</strong><br><em>我们有时候会被新式转型迷惑</em></p><p>情境: 现在持有一个派生类D的handle, 我们要在其上调用基类部分的操作, 怎么办?<br>最现实的情况, 派生类上使用基类版本的虚函数, (别问为什么, 就是这么恶心的需求)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User code</span></span><br><span class="line"><span class="keyword">void</span> Derived::func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span>&lt;Base&gt;(*<span class="keyword">this</span>).func();   <span class="comment">// Error!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码乍看一下, 可能会觉得并没有错误, 在看一眼:<br><code>static&lt;Base&gt;(*this).func();</code> <code>==</code> <code>Bse(*this).func();</code></p><p>那么, 问题来了: 实际上并非在本对象上使用基类版本的<code>func()</code><br>而是本对象基类副本上使用, (成员函数只有一个, 无所谓)<br>可以说, <strong>这与我们的预期大相径庭, 基类部分是操作失败的,</strong><br><del>用侯捷先生的话来说, 就是 败坏数据结构之始</del></p><p>该如何正确使用呢?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Derived::func()</span><br><span class="line">&#123;</span><br><span class="line">    Base::func();     <span class="comment">// Right !</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接访问公共接口即可, *this是被默认传入的.</p><p>关于新式转型与旧式转型, 还有问题吗 ? <strong>有 !</strong><br>就是关于C++内存模型的问题</p><p>在C++中, 对于同一个对象, 如果它的继承体系比较复杂的时候, <strong>他会有多个指针, 指向同一对象</strong><br><code>inhertiance: A, B -&gt; C</code><br>则, 对于<code>C c;</code>中c的handles, 如果你使用<code>A *, B *, C *</code>极有可能是不同的值<br>(单继承少, 多继承经常出现此问题)<br>在<code>Java/C#</code>中, 因为他们有<code>header</code>, 所以是一致的</p><p>这说明什么呢? =&gt; <strong>我们不能assume C++ memory model, 因此乱用转型, 自找苦吃</strong><br>即使是某一平台上的内存模型你清楚, 也不能如此, <strong>这样会失去兼容性</strong></p><p>关于新式转型与旧式转型, 还有问题吗 ? <strong>这次真的没有了</strong></p><h3 id="Dynamic-cast的杂七杂八"><a href="#Dynamic-cast的杂七杂八" class="headerlink" title="Dynamic_cast的杂七杂八"></a>Dynamic_cast的杂七杂八</h3><p>至于<code>const_cast/reinterpert_cast</code>的使用, 其实也就那么一回事, 了解一下, 并没有那么多事</p><p>但是<code>dynamic_cast</code>是个恶心的东西. 它是C中没有的, 因为C不支持继承机制.<br>那么, 他有什么问题呢?</p><p>就是: 它的机制是比较字符串判断是否是继承体系中的类型<br><strong>一旦继承体系足够复杂, 你也懂得吧 (一般4层是个界限)</strong></p><p>在足够复杂的继承体系中使用运行时类型断定 (一般结合RTTI使用), 无疑是自寻死路</p><p>我们在什么时候使用它呢 ?<br><strong>与之前的例子相反: 手持基类handle, 想要调用派生类版本内容时, 使用dynamic_cast</strong><br>你会说, 那不是有虚函数么, \抠鼻,<br>问题来了, 这个对象是你估计可能是D类, 但是只有一个B的指针, 你又想正常使用它的函数(non-virtual)<br>这个时候, 就要运行时类型判定, 懂了吧</p><p>看个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_do</span><span class="params">(Base *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(ptr)-&gt;func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *ptr = &amp;d;</span><br><span class="line"></span><br><span class="line">    func_do(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接是不能使用<code>func()</code>的, 道理你也懂吧 <code>(undefine reference to.....)</code></p><p>之后, 就是如何规避 使用<code>dynamic_cast</code></p><p>两个手法:<br><strong>1. 使用类型安全的容器(Containor)存储相关的派生类handle, 直接根除问题</strong><br><strong>2. 使用virtual-func机制, (当然你要承担virtual的开销)</strong></p><p>因为这两个手法是比较容易理解的, 我们在这里就不举例子了.</p><h2 id="Item-28-Avoid-returning-“handles”-to-object-internals"><a href="#Item-28-Avoid-returning-“handles”-to-object-internals" class="headerlink" title="Item 28: Avoid returning “handles” to object internals"></a>Item 28: Avoid returning “handles” to object internals</h2><p>emmm, 这一个主题, 其实容易被人误解,<br>这里的”handles” 指的是 <strong>句柄</strong>, 即指针, 引用, 智能指针等</p><p>它不同于我们封装数据后, 使用的<code>get()</code>系列函数</p><p>为什么呢?</p><p><strong>因为句柄可以直接控制数据,可能会引发败坏数据结构的问题</strong> <del>侯捷先生翻译, 某些方面还是可取的</del><br>那么, 这一主题, 我们强调<strong>不要返回句柄</strong>, 原因在哪里呢?</p><h3 id="破坏数据结构的封装性"><a href="#破坏数据结构的封装性" class="headerlink" title="破坏数据结构的封装性"></a>破坏数据结构的封装性</h3><p>虽然经常说的, OOP核心特性: 封装, 继承, 多态.<br>个人认为, 重要性排序: <code>封装 &gt; 继承 &gt;&gt; 多态</code><br>然而, handles的返回, 却严重破坏了<strong>封装</strong>的特性</p><p>来思考下面的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> </span>&#123;            <span class="comment">// 合格的get()函数</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getHandles</span><span class="params">()</span> </span>&#123;     <span class="comment">// 危险的返回句柄</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>正如上述例子:<br><code>getString()</code>是合格的get()函数, 保护了数据的封装性<br><code>getHandles()</code>则是危险的函数, 因为他将类中的数据开放出接口,<br>是极大的隐患 (结合bitwise const以及<code>mutable</code>关键字)</p><p>因为可能会产出下面的代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Temp p;</span><br><span class="line">p.getHandles() = <span class="string">"..."</span>;    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></p><p>在只是想要使用封装数据的时候, 意外修改了数据, 破坏了封装性</p><p>那么, 这样呢?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp;<span class="title">getHandles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>是否会更好一点?</p><p>也仅仅是好一点, 因为有的时候, 还需要<code>mutable</code>修饰可修改的部分<br>那么, 合理的办法呢? <strong>既然只是使用数据, pass-by-value有何尝不可</strong><br><strong>不能因为一部分的效率, 就置数据于不复深渊</strong></p><h3 id="悬垂指针的问题"><a href="#悬垂指针的问题" class="headerlink" title="悬垂指针的问题"></a>悬垂指针的问题</h3><p>其实, 返回handles更严重的一个问题在于: 导致悬垂指针的产生</p><p>悬垂指针: <strong>指针指向的已经是无效的内存</strong>,<br>可怖的是: 这个指针仍可以使用 (这也是我们引入智能指针的原因)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp(A *ptr);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User code</span></span><br><span class="line"><span class="keyword">auto</span> ptr = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> *pstr = &amp;(Temp(ptr).get());  <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><p>即使此处<code>const</code>, 仍然是错误!</p><p>为什么, 这是一个临时对象的handles, 下一行之后.<br><strong>临时对象被析构</strong>, pstr就已经是一个<code>dangling pointer</code>了</p><p>之后使用pstr就会造成无法挽回的错误 !</p><p>忠告: 为了保护我们数据的完整性, 封装性不被破坏, <strong>避免返回封装数据的handles</strong></p><h2 id="Item-29-Strive-for-exception-safe-code"><a href="#Item-29-Strive-for-exception-safe-code" class="headerlink" title="Item 29: Strive for exception-safe code"></a>Item 29: Strive for exception-safe code</h2><p><em>异常安全, emmm怎么说呢, OOP机制下, 这个是一定不可或缺的.为何要维护异常安全 ?</em><br><em>如何维护异常安全 ? 这些都是我们要讨论的问题</em></p><p>关于维护异常安全, 原因在于: 异常机制是会打断程序的正常控制流, 从而有可能造成资源, 数据的破坏<br>因此我们在异常机制中, 要关注: 如何做到异常安全</p><p>异常安全有两个要点:</p><ol><li><strong>不泄漏任何资源</strong></li><li><strong>不破坏任何数据</strong></li></ol><p>这便是异常安全的基准</p><h3 id="泄漏资源"><a href="#泄漏资源" class="headerlink" title="泄漏资源"></a>泄漏资源</h3><p>说到这个, 是不是觉得有一丝丝熟悉, 使得没错, 就是我们Chapter III的 Resource Management</p><p>资源, 一般指: 内存, 套接字, 线程, 互斥器, 条件变量等等resource<br>那么, 资源泄漏(leak resource)一般指的就是: <strong>未释放资源</strong>或者<strong>重复释放资源</strong></p><p>这里就不多扯淡了, <strong>就是用RAII来进行资源管理</strong><br>在如今(2018), 经历社区积淀, 官方FAQ之后,<br>使用RAII管理资源已经被证明是C++再没有GC情况下, 管理资源最方便, 安全的手段<br>C++11 STL中增加了facility – <code>std::lock_guard&lt;T&gt;</code></p><h3 id="破坏数据"><a href="#破坏数据" class="headerlink" title="破坏数据"></a>破坏数据</h3><p>什么叫破坏数据呢? <strong>恶意/无意修改</strong>或<strong>失效</strong> 这些都会对我们的开发造成不利影响或者隐患</p><p>因此,我们要做到异常安全.</p><p>保证数据不被破坏, 有三个层次的异常安全:</p><ol><li>基本承诺: 保证操作结束后, 数据一定有效</li><li>强烈保证: 失败为原数据, 只有失败成功两种结果</li><li>不抛出</li></ol><p>我们用代码来看例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Data::change_the_data(data t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt;(<span class="keyword">new</span> data(t));</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中可以看到, 先对数据进行置空, 之后重新设置新的数据.<br>那么, 问题来了: <strong>如果定义智能指针抛出异常, 现在的数据是什么样子 ? </strong></p><p>毫无疑问: 数据已经被设置为nullptr, 这个时候data被其他用户使用的结果, 可想而知.</p><p>这便是典型非异常安全.</p><p>那么, 我们首先来做到<code>基本承诺: 保证数据有效.</code></p><p>调换一下顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Data::change_the_data(data t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt;(<span class="keyword">new</span> data(t));</span><br><span class="line"><span class="keyword">this</span>-&gt;data = ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以保证, 数据一定是有效的. 但是, 这个仅仅只是最低层次的保证.<br><strong>通过语句顺序的调整基本可以做到</strong></p><p>我们再来看看高层次一点的需求<code>强烈保证: 只有成功/失败. 失败不对数据改变</code></p><p><em>也可以通过调换语句顺序实现, 但是我们提供更加合适的手法: Copy-And-Swap</em></p><p><del>说点私货, 另一个CAS指的是Compare-and-set 或 Compare-and-swap</del></p><p>这种手法叫做”拷贝-交换”手法: <strong>将改变实现在对象的副本上, 成功后进行交换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Data::change_the_data(data *t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="built_in">std</span>::shatrd_ptr&lt;data&gt; pNew(<span class="keyword">new</span> data(*t));       <span class="comment">//  Copy</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;data&gt;(<span class="keyword">new</span> data(t));</span><br><span class="line">    pNew = ptr;</span><br><span class="line"><span class="built_in">std</span>::swap(data, pNew);                          <span class="comment">// Swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便可以帮助我们做到: 强烈保证. 在异常安全的道路上更进一步.</p><p>一般情况下: <strong>无抛出 no-execpt</strong>其实十分困难.<br>最简单的: <em>有<code>new</code>的地方, 你能保证没有异常 ? </em></p><p>一般无抛出: <strong>仅仅用在内置类型, STL中</strong>, 用户自定义类型的时候, 基本上做到强烈保证就已经相当到位了</p><p><del>这里婊一下侯捷先生的翻译: (execption-safe code)异常安全代码, 翻译为”异常安全码”,真的很有误解性</del></p><h3 id="异常安全级别"><a href="#异常安全级别" class="headerlink" title="异常安全级别"></a>异常安全级别</h3><p>我们在开发一个大型系统的时候, 不可能只有一处异常, 而且异常套异常的情况多得是.<br>如何评价一个系统的异常级别呢? <strong>木桶效应</strong>.<br>如果哪一处, 没有异常安全, 那么这个系统就是非异常安全的.</p><p>这就和女性怀孕一样: 你只能说怀孕, 或者未怀孕, 不能部分怀孕 (Scott Meyers先生的比喻)</p><p>因此, 做到基本承诺其实已经十分难得了,<br><strong>但是, 我们建议异常安全级别越高越好, 也就是说强烈保证是我们追求的目标</strong></p><p>做到系统的异常安全十分不易, 但我们应该为之不懈努力.</p><h2 id="Item-30-Understand-the-ins-and-outs-of-inlining"><a href="#Item-30-Understand-the-ins-and-outs-of-inlining" class="headerlink" title="Item 30: Understand the ins and outs of inlining"></a>Item 30: Understand the ins and outs of inlining</h2><p>Emmm, 之前我们在Item 02中也提到过了 <code>用inline, const, enum较少预处理器的使用</code><br>而且, 在c99(C语言标准1999)中也提到过了<code>inline</code>关键字</p><p>那么, 真正清楚inline吗?</p><p>我们从最简单的起步, 什么是inline?</p><h3 id="inline的内容"><a href="#inline的内容" class="headerlink" title="inline的内容"></a>inline的内容</h3><p><code>inline</code>,即内联函数. 它是指将函数调用时, 使用函数本体去替换函数调用.<br>看着与<code>#define</code>类似, 实际上有很大不同.</p><p>因为<code>inline function</code>实际上仍然为函数, 他有着函数的行为, 不过减少了函数调用开销<br>但是<code>#define (marco function)</code>实际上是文本替换, 并非真正的函数行为.<br>不然我们写个<code>#define max(a, b) ((a &gt; b) ? (a) : (b))</code>里面为什么这么多括号…</p><p>一个简单的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Is this an inline function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(其实这个例子是有问题的, 我们后面再说)</p><h3 id="如何inline"><a href="#如何inline" class="headerlink" title="如何inline"></a>如何inline</h3><p>再来说说如何inline, 有两种手法: <code>显示inline</code>和<code>隐式inline</code></p><p><code>隐式inline</code>, 就是<strong>在类中定义的成员函数(注意是定义, 不是声明)</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp() &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;              <span class="comment">// 隐式的inline函数  (当然Constructor, Destrucotr inline十分危险)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>显示inline</code>, 就是在类体外,使用<code>inline</code>关键字来定义函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Temp::func()        <span class="comment">// inline key-word 用在函数定义上</span></span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="inline-和-template的纠葛"><a href="#inline-和-template的纠葛" class="headerlink" title="inline 和 template的纠葛"></a>inline 和 template的纠葛</h3><p><code>inline</code>和<code>template</code>能有什么纠葛呢?<br><strong>他们一般情况下都要写在headers中, 所以会给人产生误解: template一定inline</strong></p><p>这个一般不会提高效率, 甚至会带来严重危害!</p><p>我们inline为什么写在headers中:<br>一般情况下, <strong>C++的inline都发生在编译期间, 有极少的运行环境, 可以在运行期间完成inline</strong></p><blockquote><p>建议把inline函数的定义放到头文件中，在每个调用该inline函数的文件中包含该头文件。<br>这种方法保证了每个inline函数只有一个定义，且程序员无需复制代码，<br>并且不可能在程序的生命周期中引起无意的不匹配的事情。</p><p>摘自 C++ Primer 第三版</p></blockquote><p>也就是说inline定义式可以放在头文件中, 因为要保持一致.<br>non-inline则反而会导致”重定义”, 所以只能放声明.</p><p>在来说说template, template毕竟只是模板, 一定要进行实例化, 实例化就必须编译器可见,<br>所以也放在头文件中 (当然也有极少的运行环境, 允许运行其进行实例化, 很少)</p><p>所以, <strong>template 与 inline没有必然关系</strong>, 不是模板就必须inline (指function template)<br><strong>甚至会酿成大祸(后面inline的缺点)</strong></p><p>再来点私货: <code>static variable</code>也是在头文件中</p><p>静态变量是脱离对象, 与类直接关联的变量, 一般放在头文件中<br><strong>但是, 因为.h可能会被多个文件引用, 所以头文件中的静态变量, 并不会实例化</strong><br><strong>因此就需要在每个文件中, 声明静态变量, 否则不可见名字的</strong></p><h3 id="是否inline"><a href="#是否inline" class="headerlink" title="是否inline"></a>是否inline</h3><p>其实这里, “是否inline”的小标题是有一定程度上的误解性的.<br>这里的<em>是否</em>, 指的是, 有没有成功inline</p><ol><li><p>编译器建议, 并非强制<br>inline之后不是一定就能成功的, 要看编译器优化. <code>inline</code>只是表示有可能被编译器接受</p></li><li><p>实现关键字<br>inline是实现上用的, 在函数声明(现在应该叫函数原型 <code>function prototype</code>)上inline, 不接受inline</p></li><li><p>对于取地址的inline建议函数, 不会inline<br>看看下面这个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">void</span> (*p)();</span><br><span class="line">p = func;</span><br><span class="line">p();      <span class="comment">// out-line</span></span><br><span class="line">func();   <span class="comment">// inline</span></span><br></pre></td></tr></table></figure></li></ol><p>p是函数指针, 需要确定的地址, 这次调用时不会被inline的<br>func()调用, 则会被inline</p><p><strong>上面这一点也说明: inline不是指完全被inline, 而是对每一处调用而言.</strong></p><h3 id="inline优劣之分析"><a href="#inline优劣之分析" class="headerlink" title="inline优劣之分析"></a>inline优劣之分析</h3><p>终于分析到inline的优劣!</p><p><code>inline</code>实际上是将对函数的调用替换为函数本体. 它是真正的函数, 不过减少了函数调用的开销.<br>可以说是<code>#define宏函数</code>的语义明确版本, <code>#define</code>内容过于复杂, C++中将其含义明确</p><p>那么, 问题来了: 对于本体复杂的函数, <code>inline</code>会有什么下场 ? </p><p>代码膨胀 -&gt; 目标码膨胀(obj) -&gt; 换页机率增加 -&gt; Cache命中机率降低 -&gt; 换页失败更多<br><del>如果严重了, 甚至会导致系统抖动(System spooling), 不过这个就有点夸张了</del></p><p>也就是换句话说: <strong>如果本体够小, 直接本体替换的代价小于函数调用的开销, 那么反而会降低code大小</strong><br>即<code>inline</code>最大的优势: <strong>降低函数调用开销, 对于短小, 频繁调用的函数, 提高系统效率</strong></p><p>既然使用了inline, 你便要接受它的种种, 尤其是隐患:最严重的有两点. ( 1 + 2 )</p><ol><li>Debug十分不方便: 你无法追踪一个没有地址的函数 (全都inline了)</li><li>编译依赖性十分严重</li><li>代码膨胀(目标码亦是)</li></ol><p>我们重点说说2, 因为<code>inline</code>是将函数展开, 所以只要有变动, 客户代码一定要重新编译<br>如果使用静态链接, 只要重新链接即可 (link 即可)<br>如果使用动态链接, 甚至你都没有察觉改变(去看链接文件的变化, 例外)</p><p>虽然有优有劣, 只要我们合理使用<code>inline</code>, 则能发挥其作用, 规避其危险</p><h2 id="Item-31-Minimize-compilation-dependencies-between-files"><a href="#Item-31-Minimize-compilation-dependencies-between-files" class="headerlink" title="Item 31: Minimize compilation dependencies between files"></a>Item 31: Minimize compilation dependencies between files</h2><p>这一条款我们讨论的是: 关于文件之间编译依存性的问题</p><p>这个问题会有什么影响呢? 当我们修改Class内容之后, 点击一下编译/建立(Compile/Build)<br>本来以为1s的时间, 结果等待了足足10s, 为什么会有这种情况, 我明明只改了一个变量名啊!</p><p><em>何况这还是我们平时的小项目, 体量足够大的项目, 会有什么后果呢, 想像就知道了</em></p><p>这个问题真的这么严重吗?<br><strong>是的, 文件之间的编译依赖性过与复杂, 是软件设计的缺陷.(文件编译是恶心, 不及模块编译)</strong></p><p>我们来用例子看看应该如何解决这样的问题:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person();</span><br><span class="line">    ~Person();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">get_birthday</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Date birthday;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面其实是我们经常说到的一个东西: Class (<del>废话,我不说你也知道</del>)<br>这个类其实是将接口(interface)与实现(immplementation)糅合在一起的.</p><p>那么, 这个东西具体会导致什么问题呢?<br><strong>如果, Person Class发生改变, 你的用户代码, 就得直接重新编译 !</strong></p><p>看上去是一个小问题, 那么要是多个<code>#include</code>呢? 那个体量基本上就是超出你预期估计的了.</p><p><del>因为我一直接触的就是C/C++, 文件编译在我看来其实是很常见的, 但是模块编译才是主流</del><br><del>以文件划分编译层次, 被证明的确是不好的组织形式, 不过也是历史原因</del><br><del>仔细想想, 一旦文件划分的不好, 强耦合的代码, 互相依赖性大</del><br><del>相比于层次区分明显地Java/C#/…模块编译的语言,</del></p><p>既然有这样的问题, 那么我们能否手工解决呢? (<del>又是句废话</del>) <strong>肯定能咯</strong></p><h3 id="尝试减少编译依存性"><a href="#尝试减少编译依存性" class="headerlink" title="尝试减少编译依存性"></a>尝试减少编译依存性</h3><p>上面说到: 根本原因是繁杂的<code>#include机制</code>, 那么, 我让他不<code>#include</code>不就行了？　( ͡° ͜ʖ ͡°)</p><p>那么, 看看这样写如何？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">Date birthday;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person();</span><br><span class="line">    ~Person();</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">get_birthday</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>两个问题:</p><ol><li><code>std::string</code>的写法是错误的, 实际上是<code>typedef basic_string&lt;char&gt; string</code>特化版本<br>而且标准库设施不应该成为桎梏 <em>毕竟标准库都是大佬写的对吧</em></li><li>来你说说看, Person有多大 ( ՞ټ՞) 你也懂得吧, C++实例化, 你要是不知道类多大, 怎么玩?<br>关于这个内容, 我们已知的是: 实例化类之前, 你得知道类的大小, 就得可见类的定义式.<br>但是, 我们目前的各种举措, 就是要避免”实现部分的内容”也嵌套在”接口部分中”.</li></ol><p>这个时候, 我们可以去其他语言中寻求帮助: 比如Java/C#</p><p><em>据说他们都是有一种文件, 直接就叫interface, 其他都是class, 不得不说模块编译的确是很好的设计</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String Args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一段简单地Java代码, 在创建类的实例化对象的时候, 产出的, 都是指针<br><strong>也就是说, 我们不需要知道类的实现细节, 我们只需要一个指向它的指针即可</strong></p><p>这不就是我们现在亟待解决的问题:<br>如果我们也用<strong>一个指针隐藏实现细节</strong>,那么这个接口文件岂不就是与实现<strong>独立</strong>开来,<br>用户代码就可以不用进行编译, <strong>这样实现归实现的改变, 不会影响到接口文件,</strong><br>当然接口文件改变, 不重新编译就怪了…</p><p>那么, 怎么做呢?</p><blockquote><p>Opaque Pointer, D pointer, pimpl idiom</p><p>Wiki上叫做Opaque Pointer, Effective叫做pimpl idiom, 编译防火墙, Bridge Pattern<br>常见语言: Ada, C/C++, D, Modula-2<br>指: 将实现细节隐藏在指针之后, 使得用户不可见, 同时将实现从接口分离出去<br>作用: </p><blockquote><p>在实现修改后, 使用的模块(module)不需要重新编译, 更多的细节可以隐藏在其他文件,<br>更重要的是可以提供不同版本, 二进制目标码的兼容性</p></blockquote></blockquote><p>看着是不是还挺不错, <del>(让我说, 就是因为语言的历史原因, 不支持模块编译, 以及interface, 总是在模拟)</del></p><h3 id="Pimpl-Idiom"><a href="#Pimpl-Idiom" class="headerlink" title="Pimpl Idiom"></a>Pimpl Idiom</h3><p>那么, 这种手法的要点在哪里呢?</p><p>有下面几个要点: (Effective总结的是真的到位, 不过我会改变一些说法)</p><ol><li>能用handle, 就不用entity</li><li>用Declaration取代Definition</li><li>提供两份文件</li></ol><p>pimpl手法的核心是: <strong>尽量自满足, 不依赖其他#include, 否则依赖其他文件的声明式而非定义式</strong></p><ol><li>这点是核心, 我们使用只需要曝光名字(通过声明式)创建的handle,取代需要定义式才能创建的实体</li><li>使用声明式, 最好自满足就不依赖其他文件, 即使依赖其他文件,也是其他文件的声明式</li><li>规范化,提供两份头文件, “xxx.h” + “xxxfwd.h”</li></ol><p>这里分享, 我个人理解时的一个疑惑:</p><blockquote><p>Q:只提供声明, 没有定义, 那他怎么用啊? 而且只提供声明, … 反正就是各种不舒服</p><p>A:在 interface 中, 我们不提供定义.只有声明, 这种叫做 forward declaration<br>只要不使用 class 的细节(即实现部分), 可以不知道定义式.<br>因为我们的 interface 只负责说明它开放什么接口, 所以细节部分不知道最好.</p></blockquote><h3 id="Handle-Class"><a href="#Handle-Class" class="headerlink" title="Handle Class"></a>Handle Class</h3><p>使用Pimpl手法的类, 我们习惯意义上叫做”Handle Class”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Personfwd.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PERSONFWD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PERSONFWD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"personfwd.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;p);</span><br><span class="line">    ~Person()&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"personfwd.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PersonImpl(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line">    ~PersonImpl()&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PersonImpl::PersonImpl(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) </span><br><span class="line">    : name(name), age(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> PersonImpl::getName() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> PersonImpl::getAge() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">    : pImpl(<span class="built_in">std</span>::make_shared&lt;PersonImpl&gt;(name, age)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> Person &amp;p) : pImpl(p.pImpl) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Person::getName() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::getAge() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;getAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="keyword">new</span> Person(<span class="string">"Crow"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; p-&gt;getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Age: "</span> &lt;&lt; p-&gt;getAge() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>以上便是一个pImpl的例子, 我们稍作分析: </em><br><em>Class Person是我们使用的类, 它仅仅依赖于”person.h”, 我们将所有的Person实现细节都隐藏于</em><br><em>class Person {… private: std::shared_ptr<personimpl> pImpl;}; 背后</personimpl></em><br><em>即使PersonImpl的实现改变, 也不会丝毫影响Person的Build, 不会导致UserCode的Recomplie</em></p><p>理论上, 是仍然要提供一个 <code>XXXfwd.h</code> 来进行前置声明的</p><p><del>但是, 事实意义上: 没啥用, 首先是前置声明没多少, 因为我们合理的设计应该是模仿模块编译,类对应文件</del><br><del>平白增加文件数目, 而且是意义不大的文件, 并没有什么意义,反而造成目录文件冗余, <iosfwd>实在是东西太多</iosfwd></del></p><p>分离接口于实现, Pimpl是在使用上模拟, Java/C#的指针写法, 那么,我们有没有直接设计interface的方法</p><p><strong>有, Abstract Class</strong></p><h3 id="Abstract-Class"><a href="#Abstract-Class" class="headerlink" title="Abstract Class"></a>Abstract Class</h3><p>我们在Pimpl习语的使用, 是将实现隐藏起来.</p><p>下面的抽象基类手法, 则是真正意义上来描述接口<br>核心: <strong>抽象基类, 指具有至少一个 pure-virtual的Base Class</strong></p><p>pure-virtual的设计含义, 就是仅仅继承接口, 同时因为抽象基类是残缺类 (因为没有pure-virtual的实现)<br>所以,我们不能为其实例化.</p><p><del>怎么说呢, 抽象基类,是我觉得活生生模仿Java/C#而搞出来的东西</del>, 但是它里面可以存数据, 后面再说</p><p>那么, Abstract Class的核心在哪里呢? 即是: 抽象基类设计接口, + Virtual函数实现功能</p><p><strong>是的, 没错. 这同样是一种接口与实现的分离, 也是降低编译依存性的手段</strong><br><strong>只要接口不变, 根本无需Recomplie</strong></p><p>既然我们使用了继承体系, 那么, 梗句不同的参数, 环境变量, 场景. 我们便可以设计不同的继承来建模</p><p>之后, 同样是使用基类指针, 来完成多态功能实现 (之前的TimeKeper).</p><p>那么, 产出派生类指针的函数, 即为<strong>工厂函数 factory function</strong><br><del>婊一下侯捷先生的翻译: 这里是指虚拟的构造函数, 它直接翻译 virtual 构造函数, 误解性比较深</del><br><del>另一方面: 抽象基类基本不要构造, 同时virtual constructor确实太过分了 ( ՞ټ՞)</del></p><p>那么, 我们就来说说这个<code>factory function</code>怎么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们同样以Person Class为例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Factory function</span></span><br><span class="line">    static auto create(const std::string &amp;name, int age) -&gt; std::shared_ptr&lt;Person&gt;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Person()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inheriting class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 保持形式统一, 加上Person的构造函数</span></span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) : Person(), name(name), age(age) &#123; ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printJob</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> job;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory function</span></span><br><span class="line"><span class="keyword">auto</span> Person::create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> age) -&gt; <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> Student(name, age));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User Code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = Person::create(<span class="string">"Crow"</span>, <span class="number">20</span>);</span><br><span class="line">    p-&gt;printName();</span><br><span class="line">    p-&gt;printAge();</span><br><span class="line">    p-&gt;printJob();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们着重要说的就是, factory function. 关键点有:</p><ol><li><strong>static</strong>, 抽象基类是残缺类,不能实例化, 我们调用只能使用静态函数</li><li><strong>arguments</strong>, 我们根据不同的参数, 配置, 环境,可以生成不同的基类指针(意为: 指向不同派生类的)</li><li><strong>shared_ptr</strong>, 使用智能指针, 更方便进行管理</li></ol><p>好了, 至此我们降低编译依存性的两种手法, 介绍至此. 还有内容吗, <strong>有</strong></p><p><em>关于使用哪种手法的判断</em></p><ol><li>考虑我们的项目是否大到考虑项目的耦合程度.如果没到一定程度, 其实具象类(相对于抽象类)也不错</li><li>评价Handle Class 以及 Abstract Class的选择<br>Handle Class: 中间存在指针的间接访问. 而且,建议只有一层pImpl即可, 多层,想想就算了<br>Abstract Class: 设计优秀, 但是vptr的开销不容小觑, 加上虚表的查询, 推断. 也, 你懂得…</li></ol><p>上面虽然这么分析, 但是, 在良好的设计面前, 一定程度的开销, 也可以接受, 不是吗?<br><strong>其实个人更喜欢这种明确的设计, 虽然有开销, 具象类, 有的时候是真的冗杂</strong></p><hr><p>说点题外话:<br>其实最近压力挺大的, 100天倒计时想想有点慌.<br>只希望这最后的100天能够把自己提升上去,最简单的, 提高效率, 逼自己努力!<br><del>不过,这中间, 期中考试, 期末考试, 纳新, 是有点操蛋, 靠</del></p><p><em>至此, Chapter V结束, 请期待下一篇, 另外添加RSS订阅之后, 还请点个订阅呗</em></p>]]></content>
    
    <summary type="html">
    
      Chapter V 实现. 之前讨论了设计与声明的细节, 那么完成设计之后, 就要进行实现. 在实现上又有哪些值得注意的问题呢?
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="EffectiveC++" scheme="http://evil-crow.github.io/tags/EffectiveC/"/>
    
  </entry>
  
  <entry>
    <title>&lt;咸鱼书&gt; 运行时数据结构与内存</title>
    <link href="http://evil-crow.github.io/2018/09/27/C/Expert_C_Programming/data_mem/"/>
    <id>http://evil-crow.github.io/2018/09/27/C/Expert_C_Programming/data_mem/</id>
    <published>2018-09-27T15:14:59.455Z</published>
    <updated>2018-09-27T15:14:59.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-a-out及其传说"><a href="#一-a-out及其传说" class="headerlink" title="一, a.out及其传说"></a>一, a.out及其传说</h2><p><em>我们大家接触Linux都是从C语言开始,那么每个人第一个可运行程序都是a.out</em></p><p><em>好奇过为什么用这个东西,做缺省名吗? 哈哈,我其实之前也没有仔细考虑过,现在就来聊一聊</em></p><p>a.out指的是汇编器输出文件,<strong>但实际上,a.out不是链接器的结果吗? ? ?</strong></p><p>哈哈,这是个历史遗留问题,PDP-11汇编器输出结果为a.out,而当年最正统的UNIX机器便是PDP-11,所以</p><p>你懂得,又是个历史遗留问题 !</p><h2 id="二-a-out与C文件内容之间的关系"><a href="#二-a-out与C文件内容之间的关系" class="headerlink" title="二, a.out与C文件内容之间的关系"></a>二, a.out与C文件内容之间的关系</h2><p>C文件的内容如何映射到a.out文件中呢? 那部分填充到哪里呢? 来看看下面的图:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/src_aout.png" alt="源文件-&gt;可执行文件"></p><p>如何上图所示,首先我们要强调的是:<strong>段(segement)的概念</strong>, 此段非彼段,与Intel内存模型中的段不同</p><p>此处的段是文件中的段,大小为64KB, 最小的控制单位是section</p><p><strong>另外,对于可执行文件,有许多种格式,COSS, ELF, PE格式,我们此处以GNU使用的x86_64elf为查看对象</strong></p><p>其中a.out中有这样几个段:</p><ol><li><p>a.out的神奇数字, 用来标识a.out文件的,我们可以通过readelf来查看</p></li><li><p>BSS段, 用来存储未初始化的变量,因为未初始化,所以这个段实际上是不占空间的,他只保存了大小</p></li><li><p>数据段, 用来存储初始化的数据,(其中还有只读区等小区,不细说),而BSS段 + 数据段即为数据区</p></li><li><p>文本段, 用来储存代码的,也有叫代码段的说法,一般为.text</p></li></ol><p>这些部分是,<strong>从C源文件 -&gt; 可执行文件的部分(a.out)</strong>,一会儿我们要说到的是:</p><p><strong>从可执行文件 -&gt; 内存映像的问题, 别混淆了呦</strong></p><p>我们在此处可以玩玩这几个命令: size, readelf, objdump ,nm下面我一一来演示:</p><p>首先来看看源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @filename:    1.c</span></span><br><span class="line"><span class="comment"> * @author:      Crow</span></span><br><span class="line"><span class="comment"> * @date:        06/04/2018 21:08:09</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;    <span class="comment">// read_only</span></span><br><span class="line"><span class="keyword">int</span> b;              <span class="comment">// BSS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">4</span>;       <span class="comment">// stack_heap a.out中看不出来(堆栈毕竟是运行时数据结构)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World! %d\n"</span>, c);</span><br><span class="line">    foo();           <span class="comment">// .text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p8uroi1uf.bkt.clouddn.com/size_aout.png" alt="size a.out"></p><p><img src="http://p8uroi1uf.bkt.clouddn.com/readelf_aout.png" alt="readelf -a a.out"></p><p><img src="http://p8uroi1uf.bkt.clouddn.com/objdump_aout.png" alt="odjdump -d a.out"></p><p><img src="http://p8uroi1uf.bkt.clouddn.com/nm_aout.png" alt=""><br><img src="http://p8uroi1uf.bkt.clouddn.com/nm_aout2.png" alt="nm -n --format=sysv a.out"></p><p><strong>注意,我们的图是从高地址-&gt;低地址, 然而我们的试验结果是地址升序排序</strong></p><p><strong>从中,我们可以证明,a.out中的顺序的确是,文本段(.text),数据段(.data),BSS段(.bss)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/<span class="keyword">asm</span>/a.out.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_A_OUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_A_OUT_H</span></span><br><span class="line">                                                                                          </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a_info;    <span class="comment">/* Use macros N_MAGIC, etc for access */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_text;    <span class="comment">/* length of text, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_data;    <span class="comment">/* length of data, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_bss;     <span class="comment">/* length of uninitialized data area for file, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_syms;    <span class="comment">/* length of symbol table data in file, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_entry;   <span class="comment">/* start address */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_trsize;  <span class="comment">/* length of relocation info for text, in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> a_drsize;  <span class="comment">/* length of relocation info for data, in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TRSIZE(a) ((a).a_trsize)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_DRSIZE(a) ((a).a_drsize)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_SYMSIZE(a)    ((a).a_syms)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_A_OUT_H */</span></span></span><br></pre></td></tr></table></figure><h2 id="三-到底为什么要如此组织a-out文件"><a href="#三-到底为什么要如此组织a-out文件" class="headerlink" title="三, 到底为什么要如此组织a.out文件"></a>三, 到底为什么要如此组织a.out文件</h2><p><strong>其实很简单,就是为了可执行文件装入内存中方便</strong>, 来看这张图:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/aout_mem.png" alt="a.out到内存映像"></p><p>对于上面这张图: 我们着重说一下这样几点:</p><p><strong>1. 数据段,文本段直接映射</strong></p><p><strong>2. BSS段,根据它保存的大小进行扩展</strong></p><p><strong>3. BSS段与数据段实际上会进行合并, 统称数据区,而数据区往往就是一个程序中最大的段了</strong></p><p><strong>4. 最后我们再添加上为函数调用准备的堆栈区, 其中具体为stack + heap</strong></p><p><strong>5. 最下面地委映射区域一般是留给程序扩展,防止跑飞的</strong></p><p><strong>6. 如果有动态链接库(共享库)之类的,就直接忘堆栈上面怼</strong></p><h2 id="四-堆栈段有什么用-过程活动记录又是什么"><a href="#四-堆栈段有什么用-过程活动记录又是什么" class="headerlink" title="四, 堆栈段有什么用? 过程活动记录又是什么?"></a>四, 堆栈段有什么用? 过程活动记录又是什么?</h2><p>之前其实和很多学长也都聊过,操作系统中提到的堆栈是栈,数据结构中堆是堆,栈是栈,OK?</p><p>堆栈是一种FILO的数据结构,它很适合用于进行函数调用,为什么?</p><p><strong>尤其是我们进行递归调用的时候,需要同时维持多组函数(多个实例)的存在,同时还要保证他们一定的顺序</strong></p><p><strong>这就很符合堆栈的定义,所以堆栈段的存在很有必要于递归调用</strong></p><p><strong>也就意味着函数递归调用以外的其他作用,并非是堆栈段存在的必要意义,可以通过其他方式实现</strong></p><p>最最核心的作用就是维护了过程活动记录,CSAPP中也提到过这个东西,就是进行函数调用是的必要信息</p><p>以及调用结束之后,我们到底应该如何返回?</p><p>那么,我们就来看看过程活动记录吧</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/process.png" alt="过程活动记录"></p><p><strong>上面这个其实就是一个函数在堆栈中的内容了</strong></p><p><strong>1. 局部变量(local varibales) 即为函数内保存的自动变量(auto)缺省属性</strong></p><p><strong>2. 参数(arguments) 这其实是,形式参数,用于函数调用的</strong></p><p><strong>3. 静态链接(static link) 这个与C无关,其实是Pascal,Ada提供的特性,即函数的嵌套声明</strong></p><p><strong>我们可以通过这个静态链接指针来进行上层函数的访问,从而减少函数之间的通信</strong></p><p><strong>4. 指向先前结构的指针,很明显,就是指向上层函数(非静态链接),是说上一个过程活动记录</strong></p><p><strong>5. 返回地址(return address) 不多说了,就是函数调用结束后,返回的位置</strong></p><p><strong>过程活动记录清晰地阐述了堆栈区的实际意义,以及函数调用的实现</strong></p><p>我们的程序在运行的时候,维护一个指针fp,它指向最靠近堆栈顶端的过程活动记录,之后的全靠指针串起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/.../arch/x86/include/<span class="keyword">asm</span>/frame.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FRAME_POINTER                                                                                                              </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"> </span><br><span class="line">.macro FRAME_BEGIN</span><br><span class="line">    push %_ASM_BP</span><br><span class="line">    _ASM_MOV %_ASM_SP, %_ASM_BP</span><br><span class="line">.endm</span><br><span class="line">   </span><br><span class="line">.macro FRAME_END</span><br><span class="line">    pop %_ASM_BP</span><br><span class="line">.endm</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !__ASSEMBLY__ */</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_BEGIN             \</span></span><br><span class="line">    <span class="string">"push %"</span> _ASM_BP <span class="string">"\n"</span>           \</span><br><span class="line">    _ASM_MOV <span class="string">"%"</span> _ASM_SP <span class="string">", %"</span> _ASM_BP <span class="string">"\n"</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_END <span class="meta-string">"pop %"</span> _ASM_BP <span class="meta-string">"\n"</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_OFFSET __ASM_SEL(4, 8)</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_FRAME_POINTER */</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_BEGIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_END</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_OFFSET 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FRAME_POINTER */</span></span></span><br></pre></td></tr></table></figure><p><strong>另外哦我们要注意的一点就是: 过程活动记录很有可能不在堆栈中</strong></p><p>有两方面的原因:</p><ol><li><p>可能是编译器优化,对于依赖程度不高的,我们将过程活动记录储存在寄存器中</p></li><li><p>对于其他的架构,比如Sun的SPARC,就是使用链表进行过程活动记录的串联,并非存在堆栈中</p></li></ol><p><strong>时刻记住: 虽然我们常用x86_64架构,但是架构不止这么一种,你去看看linux目录下的Arch目录就懂了</strong></p><p>Arch–Architecture 架构</p><h2 id="五-两类内存问题"><a href="#五-两类内存问题" class="headerlink" title="五, 两类内存问题"></a>五, 两类内存问题</h2><p>最后,我们在介绍两种C语言有关却经常会出问题的内存问题:</p><p><strong>首先,说说内存分配的问题,我们可以使用malloc(),free()以及brk(), sbrk()来处理</strong></p><p><strong>具体的内容,大家下来自行进行了解</strong></p><h3 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1. 内存泄漏"></a>1. 内存泄漏</h3><p>再没有GC(垃圾回收机制)的语言实现中,内存泄漏是个永恒的话题,C中需要谨慎的进行处理</p><p>在C++中,有RAII的支持,但是内存泄漏还是个不容忽视的问题</p><p>主要是两类原因:</p><p><strong>释放或者改写正在使用的内存</strong></p><p><strong>未释放不再使用的内存</strong></p><p>我们唯一能做的就是: 慎之又慎的进行内存管理,避免内存泄漏</p><p><strong>另一方面,对于局部对象,我们可以使用alloca()来进行内存分配,这样可以避免退出函数后没有释放内存</strong></p><p><strong>但是, 局限性很大,对,出了这个函数就凉凉,所以还是好好谨慎的玩吧</strong></p><p>那么,既然它这么危险,我们有没有可以检测内存泄漏的方法?</p><p><strong>有,下米诺安就简单地介绍几个工具: swap(好像只有Sun能用), free, vmstat来查看</strong></p><p>这是最基础的方法,而我们着重介绍的就是: </p><p>Valgrind + kcachegrind</p><p>我们使用Valgrind中的工具集- callgrind进行内存泄漏的分析,然后通过kcachegrind进行图形化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_alloc</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_free</span><span class="params">(<span class="keyword">void</span> *mem_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input the size to allocate memory: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;size);</span><br><span class="line">    <span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)mem_alloc(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_alloc</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很明显的内存泄漏,我们通过valgrind的memcheck工具进行检测</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/valgrind--full_check.png" alt="valgrind --tool=memcheck --leak-check=full ./a.out "></p><p>另外我们还可以进行代码分析,如下:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/valgrind_kcachegrind.png" alt="valgrind --tool=callgrind ./a.out &amp;&amp; kcachegrind callgrind.out.*"></p><h3 id="2-总线错误-Bus-Error"><a href="#2-总线错误-Bus-Error" class="headerlink" title="2. 总线错误(Bus Error)"></a>2. 总线错误(Bus Error)</h3><p>这个错误,当时被很多人调侃过,说是”公交车错误”</p><p><em>其实,我也就是在学校的OJ上见过那么一次,</em></p><p>事实上,<strong>这是RISC架构最容易出现的问题,内存的非对齐访问,会造成总线堵塞,进而引发此错误</strong></p><p><strong>然而,沃尔玛能通常是用的都是CISC的x86_64架构,事实上通过修正电路,降低一点效率,避免这个错误</strong></p><p><strong>但是,无论如何,我们都是时刻关心内存对齐,很关键</strong></p><p>在这个之外其实还有一种错误,”Segement fault” #=&gt; “段错误”</p><p>在了解内存管理之前我对这个没有一点映像</p><p><strong>不过,现在看来,还是很关键的,这就是严重缺页错误,在分页机制中有三种映射错误</strong></p><p><strong>次要,严重,以及段错误,另外两种不多说,段错误就是映射失败,访问到不能访问的区域</strong></p><p><strong>不仅仅是TLB中没有要访问的页,内存中也没有,非法访问所造成的就是段错误,会造成程序中断进行</strong></p><p><strong>其实就是这么简单,Haha,多看点书还是有用的</strong></p><hr><p>June 5, 2018 12:43 AM</p><p><em>上面这些之后,就算咸鱼书彻底了结,C也了结了,当然kangkang的Esential C++看的也差不多,</em></p><p><em>就等C++ Primer(PS: 本来想叫C3P的,想像还是算了)就绪了.</em></p><p><em>虽然已经很晚了,不过,我有信心肝下去,干他妈的</em></p><p><em>想想后面的书: 6E, Server + Kernel 哇,脑子疼</em></p><p><em>但是,干他妈的总没错,溜了,溜了</em></p>]]></content>
    
    <summary type="html">
    
      其实这部分才是我觉得咸鱼书真正的精华,有许多书对于这部分要不不提,要不囫囵吞枣一笔带过,但是咸鱼书还是进行了比较详细的分析的,那么我们就来具体看一看整个运行时的数据结构中到底有什么?
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="Expert_C_Programming" scheme="http://evil-crow.github.io/tags/Expert-C-Programming/"/>
    
  </entry>
  
  <entry>
    <title>&lt;星月夜&gt; Designs and Declarations</title>
    <link href="http://evil-crow.github.io/2018/09/26/C++/EffC++/effective4/"/>
    <id>http://evil-crow.github.io/2018/09/26/C++/EffC++/effective4/</id>
    <published>2018-09-26T11:30:00.000Z</published>
    <updated>2018-09-27T15:10:32.302Z</updated>
    
    <content type="html"><![CDATA[<p><em>完成一个大型项目, 都是从设计开始. 设计可以很复杂, 也可以很粗糙. 但是为了程序的可维护性和发展性</em><br><em>进行一定程度上的核心设计十分关键, 我们本篇便来谈谈设计的艺术和一些技巧</em></p><h2 id="Item-18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#Item-18-Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="Item 18: Make interfaces easy to use correctly and hard to use incorrectly"></a>Item 18: Make interfaces easy to use correctly and hard to use incorrectly</h2><p>大道至简 -&gt; <code>使得接口容易被正确使用, 不易被误用</code></p><p>那么, 我们怎么才能做到<strong>容易使用</strong>这一设计准则呢?<br><del>其实, 在EffC++中也没有给出明确, 切实, 有建设性的建议</del></p><p>让我自己来说: <em>更多的从每个用户的角度出发, 让他们能够安心使用正确的接口, 便是至上之道</em></p><p>下面有几个比较有启发的例子, 我们可以来评价一下:</p><h3 id="Type-System-类型系统"><a href="#Type-System-类型系统" class="headerlink" title="Type System (类型系统)"></a>Type System (类型系统)</h3><p>先来看一个日期类, 它需要进行日期构造.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> <span class="keyword">int</span> &amp;year, <span class="keyword">const</span> <span class="keyword">int</span> &amp;month, <span class="keyword">const</span> <span class="keyword">int</span> &amp;day);   <span class="comment">// base on item 20</span></span><br><span class="line">    ~Date();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其实上面就有一个显而易见的问题: <code>Date(...)</code>构造时参数的问题<br>我们传参的顺序造成的影响? 传参的参数范围如何限制? …etc</p><p>这个时候, Type System其实是一个比较方便的手段.<br><strong>我们, 可以使用类型来显示要求用户传参内容, 及顺序</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Year</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Month</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">    Date(<span class="keyword">const</span> Year &amp;year, <span class="keyword">const</span> Month &amp;month, <span class="keyword">const</span> Day &amp;day);   <span class="comment">// base on item 20</span></span><br><span class="line">    ~Date();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using Class -- Date</span></span><br><span class="line">Date d(Year(2011), Month(3), Day(14));     // Date: 2011,3,14</span><br></pre></td></tr></table></figure><p><strong>类型系统</strong>已经在此处显示出它的作用了, 但是, 还不够.<br><em>万一, 超出范围的内容, Out of Ranage, 那就还是凉了…</em></p><p>那么, 我们就可以拿出OOP的杀器之一: 封装</p><p>我们的思路是: 将其封装, 仅仅允许其返回指定范围的结果<br>比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装month的示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">2</span>); &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Month(<span class="keyword">int</span> month) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;month = month;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using class Month</span></span><br><span class="line">Date(Year(<span class="number">2011</span>), Month::Mar(), Day(<span class="number">13</span>));    <span class="comment">// 防止Month取值越界</span></span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr-lt-T-gt"><a href="#std-shared-ptr-lt-T-gt" class="headerlink" title="std::shared_ptr&lt; T &gt;"></a>std::shared_ptr&lt; T &gt;</h3><p>这一部分,其实是RAII的一部分, 其中提到了使用智能指针的技术来管理资源.<br><strong>实际上, 直接RAII来的更方便高效</strong></p><p><em>此处, 是为了思想上认识到,接口的易用性设计,所以把智能指针单独拿出来说</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">widget *<span class="title">getWidgetPointer</span><span class="params">()</span></span>;</span><br><span class="line">Widget *pw = getWidgetPointer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; getWidgetPointere();</span><br><span class="line"><span class="keyword">auto</span> pw = getWidgetPointer();                <span class="comment">// remove the risk of memory leak at root</span></span><br></pre></td></tr></table></figure><p><strong>与其返回handle, 不如直接给它一个智能指针, 可以直接解决掉资源泄漏的问题</strong></p><blockquote><p>作为题外话, 我们再来聊聊智能指针(std::shared_ptr&lt; T &gt;)</p><p>智能指针, 首先它在实现上, 体积比较大. 不如原生指针来的痛快<br>同时, 它其中还使用了动态内存进行资源管理<br>另外, 智能指针在多线程下的表现也比较一般(尤其是内部计数)<br>但是, 它所带来的编程安全的作用, 证明我们牺牲部分效率是值得的.</p></blockquote><p><em>当然, 我们这里的重心不在智能指针上, 只是智能指针 对于接口设计的提升, 以及防止误用上, 作用很明显</em></p><blockquote><p>请记住 :</p><ol><li>好的接口很容易被正确使用, 不容易被误用. 你应该在你的所有接口中努力达成这些性质</li><li>“促进正确使用”的方法包括接口的一致性, 以及内置类型的行为兼容</li><li>“阻止误用”的方法包括建立新的类型, 限制类行上的操作, 束缚对象值,<br>以及消除客户的资源管理责任</li><li>tr1::shared_ptr(已纳入标准库 std::shared_ptr)支持定制型删除器, 这可防范DLL问题,<br>可被用来自动解除互斥锁,(不就是RAII么, \抠鼻);</li></ol></blockquote><h2 id="Item-19-Threat-class-design-as-type-design"><a href="#Item-19-Threat-class-design-as-type-design" class="headerlink" title="Item 19: Threat class design as type design"></a>Item 19: Threat class design as type design</h2><p><em>说的没错, 为了设计出高效, 简洁,易用的类, 我们应该将其当作type来设计</em><br><del>但是, 全部考虑, 基本上是不可能. 我们一般涉及的class, 能符合其中核心的要求就很可以了</del></p><p><em>EfectiveC++中提供了完整的内容,  参考这进行对比即可</em></p><blockquote><p>请记住 :</p><p>Class的设计就是Type的设计. 在定义一个新的Type之前,<br>请确定你已经考虑过被条款覆盖的所有主题</p></blockquote><h2 id="Item-20-Prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#Item-20-Prefer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="Item 20: Prefer pass-by-reference-to-const to pass-by-value"></a>Item 20: Prefer pass-by-reference-to-const to pass-by-value</h2><p>现代C++提升效率的很重要的手法之一就是: <strong>减少拷贝</strong><br>为了实现这一点, 有了下面这样的编程技巧:</p><ul><li><p>构造函数初始化列表</p></li><li><p>传引用调用</p></li><li><p>移动语义</p></li><li><p>…</p></li></ul><p>这其中, 其实用引用传参来替换值传参,<br>即pass-by-reference-to-const =&gt; pass-by-value<br>起到了十分明显的作用</p><p>传值是C++从C继承而来的.但是, 随着程序设计的体量越来越大, 系统越来越复杂.<br><strong>不假思索的传值, 已经是丧尽天良的了</strong><br>因此, 我们的建议是 <code>pass-by-reference-to-const</code></p><p>思考下面的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Bstr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Bsstr;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derive();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Dstr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> Dsstr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDerive</span><span class="params">(Derive d)</span></span>;    <span class="comment">// think this function ?</span></span><br></pre></td></tr></table></figure></p><p>思考上面的函数调用. 是不是觉得挺正常, 那么让我来给你分析一下:</p><p>1.调用Base构造函数,<br>2.Base内部还有 Bstr, Bsstr两个string的构造<br>3.调用Derive的构造函数<br>4.Derive内部还有 Dstr, Dsstr两个string的构造</p><p>总结一下: <strong>共使用了6个构造函数</strong><br><em>而且, 根据<del>函数名我们可以推断</del>, 这只是一个一般的判断函数, 过程很短, 这样大费周章的传参数</em><br><em>这一切值得吗? (引自 &lt; 冰汽时代 &gt; – 11 bits studio)</em></p><p>显然, 你自己也觉察到了: <strong>不值得, 这便是使得C++效率降低的理由之一</strong></p><p>那么, 有什么办法吗? <em>嘿嘿嘿, 求我,我就告诉你</em></p><p><del>(就当你求过我了)</del></p><p><strong>pass-by-reference-to-const</strong></p><p>这便是解决效率问题的一把杀手锏. 回到刚才的问题上, 如果这样调用函数:<br><code>bool isDerive(const Derive &amp;d);</code></p><p>传参基本上是没有开销的 (“基本上”的理由, 我们后面会讨论)</p><p>不过性能提升是因为使用reference, (不懂reference的自行面壁)</p><h3 id="To-use-pass-by-reference-to-const"><a href="#To-use-pass-by-reference-to-const" class="headerlink" title="To use pass-by-reference-to-const"></a>To use pass-by-reference-to-const</h3><p>如何使用 <code>pass-by-reference-to-const</code> ?</p><p>简单地说: 将原<code>pass-by-value</code>替换为<code>pass-by-reference-to-const</code>即可</p><p>想过没有, 为什么要用const ?</p><p><strong>使用传值的手法, 我们作出的修改并不会反映到原数据上, 只是处理它的拷贝</strong><br><strong>但是, 使用引用, 所作出的修改是在同一数据上, 所以, 为了说明不会进行修改, 我们使用const限定</strong></p><p>万一真的要修改呢? 想想我们的”万能引用” (C++ 11起), 即右值引用 + 引用折叠</p><p>即:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pass-by-reference-to-<span class="keyword">const</span>) =&gt; <span class="keyword">const</span> T &amp;     <span class="comment">// 不修改参数时</span></span><br><span class="line"></span><br><span class="line">(pass-by-R_reference) =&gt; T &amp;&amp;                  <span class="comment">// 修改参数时</span></span><br></pre></td></tr></table></figure><h3 id="the-cost-of-pass-by-reference"><a href="#the-cost-of-pass-by-reference" class="headerlink" title="the cost of pass-by-reference"></a>the cost of pass-by-reference</h3><p>上面说过, 基本没有开销, <strong>基本上</strong>, 这就是一个可以商榷的修饰词了</p><p>实际上, 因为目前而言, <strong>引用的底层实现基本上还是指针</strong>,<br>所以, 引用传参, 就是当时C中的, “传指针”行为, 它准确的传递了数据的地址</p><p>所以, 它基本上没有开销, 开销多大呢? 一个指针的大小.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kangkang拿这个搞过我</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(struct A) ? =&gt; result: <span class="number">8</span> (<span class="number">64</span>-bit)</span><br></pre></td></tr></table></figure><p><em>在可以憧憬的未来. 一旦硬件级别真正定义了引用, 那么它的开销就是 0, 就是真正意义上的别名, 无开销</em></p><h3 id="Deal-with-slice-down-object"><a href="#Deal-with-slice-down-object" class="headerlink" title="Deal with slice down object"></a>Deal with slice down object</h3><p>我们之前其实讨论过切割(slice down)的问题, 指的是, 派生类构造不完全, 仅仅只有基类部分<br>派生部分被切割掉.</p><p>那么, 在传值时, 很容易(基本上一定)发生slice的问题.<br><strong>比如, 为了多态需求, 接受形参为基类对象(派生对象)时, 传递了派生对象</strong></p><p><strong>就会导致在func内部仅仅只有Base Class的部分, 无法实现多态需求</strong></p><p>解法就是: 使用基类指针/引用, 我们这里主要推荐的是基类引用</p><p><code>bool do_something(Base obj)</code><br>=&gt;<br><code>bool do_something(Base *obj) / bool do_something(Base &amp;obj); [const 根据需求]</code></p><h3 id="Have-to-use-pass-by-reference-to-const"><a href="#Have-to-use-pass-by-reference-to-const" class="headerlink" title="Have to use pass-by-reference-to-const ?"></a>Have to use pass-by-reference-to-const ?</h3><p>虽然, 上面说的那么愉快, 我们可以将所有的情况规划到引用以内 (C++11 的右值引用)</p><p>那么, 一定使用引用吗 ? (<del>虽然, 某J语言就是这么干的</del>)<br>我们可以举出一个广泛使用传值的例子 –<strong>STL(迭代器+函数对象)及内置类型</strong></p><p>这便是我们的反例, 在这两方面, 传值的手法广泛使用.<br>我们的理由如下:</p><p>1.STL的广泛使用显而易见, 我们应该与其保持一致, 且迭代器, 函数对象目前实现也为指针<br>2.内置类型的传值, 在目前还是指针实现引用的时候, 不一定就效率低</p><p>比如说: <code>int a</code>与<code>int &amp;b</code>, 32/64位大小上是一致的. <code>char</code>, 就是个更明显的例子了.<br><strong>所以, 内置类型(或自定义小类型)传值有的时候效率会更高</strong></p><p>但是, 反对小类型传值, 也有这么两个理由:<br>1.单个内置类型开销只比引用小一点, 但是一个自定义类型中有多个内置类型时, copy成本直线上升<br>2.我们不能假定Type的实现是一成不变的, 如果实现有变化, 我们的代码需要大幅翻新 (作者下笔时:<br>  有的string实现就比一般版本大7倍)</p><p>所以, 我们的结论是: <strong>除了STL(迭代器 + 函数对象)和内置类型之外, 最好遵守我们的准则</strong></p><blockquote><p>请记住 :</p><ol><li>尽量以 pass-by-reference-to-const 替换 pass-by-value<br>前者通常比较高效, 且能避免切割问题</li><li>以上规则并不适用于内置类型, 以及STL的迭代器和函数对象.<br>对他们而言, pass-by-value往往比较恰当</li></ol></blockquote><h2 id="Item-21-Don’t-try-to-return-a-reference-when-you-must-return-a-object"><a href="#Item-21-Don’t-try-to-return-a-reference-when-you-must-return-a-object" class="headerlink" title="Item 21: Don’t try to return a reference when you must return a object"></a>Item 21: Don’t try to return a reference when you must return a object</h2><p>我们完全什么要说明这一条款呢 ?<br><em>因为经历了Item 20的洗礼, 你完全有可能任何时候都想返回引用, 事实上可取不可取呢?</em></p><p><strong>答案显然是否定的</strong></p><p>在我们需要用引用返回对象时, 我们是不能假定已经存在我们需要的对象的<br>所以, 我们就需要在函数内创建这样一个对象, 方法有二: stack / heap</p><h3 id="stack-object"><a href="#stack-object" class="headerlink" title="stack object"></a>stack object</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;stack_object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = get_value();</span><br><span class="line"><span class="keyword">return</span> a;              <span class="comment">// a allocated on stack</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子便是分配在栈上的对象, 返回reference.<br><strong>我们可以明确地说: 这就是导致程序错误的起点 !</strong></p><p><strong>在栈上分配的对象, 退出块之后便已经销毁. 所以这个引用已经失效了</strong></p><h3 id="heap-object"><a href="#heap-object" class="headerlink" title="heap object"></a>heap object</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heap object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;heap_object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *a;            <span class="comment">// a allocated on heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着很美好, 没错吧 ?<br>假象, 试问: 现在如何释放, 这个分配在heap上的内存 ? </p><p><strong>我们现在是无法得到, 隐藏在reference背后的指针的, 因此造成内存泄漏</strong><br>返回的是指针指向的内存, 我们无法得到指针的地址.取地址也并非指针地址(而是指向内存的地址);</p><h3 id="static-object"><a href="#static-object" class="headerlink" title="static object"></a>static object</h3><p>即使到了这一步, “有毅力”的人还不放弃,<br>想要试试static 对象. 是的, 没错.可以尝试, 但是来看看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    a = setValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using function</span></span><br><span class="line"></span><br><span class="line">m = getValue();</span><br><span class="line">n = getValue();</span><br><span class="line"></span><br><span class="line">m == n ? =&gt; <span class="comment">// while be true always</span></span><br></pre></td></tr></table></figure><p>这个简单的例子上, m, n已经是永久都相等了. 那么, 要是放在operator上, 后果可想而知.</p><p>至此, 甚至还想考虑static数组等等措施, 都是不切实际的 (数组大小, 如何存放 ? )</p><p>总结:<br><em>虽然析构, 构造的成本会影响我们的效率. 但是, 那是构建在程序正常运行的基础上</em><br><em>一旦我们的程序因为固执的返回引用而引发一系列错误的时候, 就显得得不偿失了</em></p><p><strong>所以, 不要畏惧pass-by-value, 如果它能带给我们正确的行为, 析构/构造的开销就交给编译器去优化了</strong></p><blockquote><p>请记住 :</p><p>绝不要返回 pointer 或 rerference指向一个 local stack 对象,<br>或返回 reference 指向一个 heap-allocated 对象,<br>或返回 pointer/reference 指向一个 local static 对象而有可能同时需要多个这样的对象.<br>条款4 已经为 “在单线程环境中合理返回 reference 指向一个 local static 对象”<br>提供了一份设计实例</p></blockquote><h2 id="Item-22-Declare-data-member-private"><a href="#Item-22-Declare-data-member-private" class="headerlink" title="Item 22: Declare data member private"></a>Item 22: Declare data member private</h2><p>我们在使用class的时候, 接触到了三种访问权限标识符:<code>public</code>, <code>protected</code>, <code>private</code></p><blockquote><p>三种访问权限关键字如何使用呢 ?</p><p>public: 公共的, 是类给外部开放的接口, 供其他用户调用<br>protected: 受保护的, 这个是给Derive Class在继承体系中使用的, 有着”内部public”的感觉<br>private: 私有的, 为了数据封装, 属于类的私有内容. 即使是派生类也无权访问</p></blockquote><p>那么, 到底何为封装呢 ? 封装的意义又在哪里呢 ?</p><p>从OOP的设计角度而言, <strong>封装就是为了屏蔽, 提高程序设计的粒度</strong></p><p>我们可以去使用封装的数据, 而不用关注起底层的实现机制. 即使底层的实现完全重写, 用户也不会意识到</p><p>合理的设计API的目的也在于此, 进行底层内容的替换不会导致客户代码被大量重写</p><p>封装能够做到: <strong>安全性, 便利性, 可维护性, 可扩展性</strong></p><p>问题来了: 如何做到合理的封装 ?<br><strong>简单地一句话: C++中, private具有封装性 和 其他没有封装</strong></p><h3 id="private-amp-protected"><a href="#private-amp-protected" class="headerlink" title="private &amp; protected"></a>private &amp; protected</h3><p><code>private</code>是我们常用的访权控制符, 除了member-func, friend-func之外,都不能进行访问.</p><p>那么, <code>protected</code>呢 ? 这个其实是被我们经常误解的一部分</p><p><code>protected</code>表面上看上去, 并不能被外部访问, 看上去是具有封装性的, <del>假象</del><br><code>protected</code>的内容,在Derive Class中是可以被随意访问的,<br>也就意味着: 修改底层, 同样会导致<strong>大量客户码重写</strong></p><p>所以, 我们说<strong>private具有封装性, 其他的都没有封装性</strong></p><blockquote><p>请记住 :</p><ol><li>切勿将成员变量声明为private. 这可赋予客户访问数据的一致性, 可细微划分访问控制,<br>允许约束条件来获得保证, 并提供class作者以充分的实现弹性</li><li>protected并不比public更具有封装性</li></ol></blockquote><h2 id="Item-23-Prefer-non-member-non-friend-functions-to-memeber-functions"><a href="#Item-23-Prefer-non-member-non-friend-functions-to-memeber-functions" class="headerlink" title="Item 23: Prefer non-member non-friend functions to memeber functions"></a>Item 23: Prefer non-member non-friend functions to memeber functions</h2><p>上一条款我们提到了封装性. 这一条款继续延伸封装性的话题.</p><p><del>EffC++使用一个Browser举例, 我就大言不惭的用我的WebServer举例了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket.h</span></span><br><span class="line"><span class="keyword">namespace</span> PlatinumServer &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">socket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    socket() = <span class="keyword">default</span>;</span><br><span class="line">    ~socket();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sock_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_sockaddr</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bind</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket.cc</span></span><br><span class="line">namespcae PlatinumServer &#123;</span><br><span class="line"><span class="keyword">void</span> socket::connect()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">1</span>;</span><br><span class="line">    setsockopt(<span class="keyword">this</span>-&gt;sock_fd, SOL_SOCKET, SO_REUSEPORT, &amp;buf, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bind())</span><br><span class="line">        err_handle(<span class="string">"bind"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!listen())</span><br><span class="line">        err_handle(<span class="string">"listen"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析一下上述代码:<br>将<code>PlatinumServer::socket::bind()</code>, <code>PlatinumServer::socket::listen()</code> Wrapper进入<code>PlatinumServer::socket::connect()</code>中<br>简单地的来说: 就是封装.</p><p><strong>事实上真的是这样吗? 答案是否定的</strong><br>这是我们曲解了OOP封装设计所导致的.</p><p>所谓封装: 指的是,将底层细节包裹尽可能深, 不被外接所侦测和访问.<br><strong>但是, 我们上面的做法, 无疑增加了对于封装内容的访问</strong></p><p>一个粗糙的指标便是: 通过可以访问的函数数目来判定其封装程度.<br>那么, 显而易见的就是: member. friend函数会访问我们封装的数据, 因此而降低我们的封装性</p><p>结论就是: 尽量以<code>non-member &amp; non-friend</code>来替代<code>member function</code></p><p>比如: 我们需要这样来实现<code>PlatinumServer::socket::connect()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket.cc</span></span><br><span class="line"><span class="keyword">namespace</span> PlatinumServer &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(socket &amp;sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">1</span>;</span><br><span class="line">    setsockopt(<span class="keyword">this</span>-&gt;sock_fd, SOL_SOCKET, SO_REUSEPORT, &amp;buf, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sock.bind())</span><br><span class="line">        err_handle(<span class="string">"bind"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!sock.listen())</span><br><span class="line">        err_handle(<span class="string">"listen"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以, 我们倾向于设计<code>PlatinumServer::connect()</code>而非<code>PlatinumServer::socket::connect()</code></p><p>这里有两个要点:</p><ol><li>我们在<code>member-fucntion</code>的对立面,应该是<code>non-member &amp; non-friend</code>, 而不是说,非成员  一定是友元,<br>这样并没有提高我们的封装程度. (下一条款, 我们会讨论成员与非成员的选择)</li><li>一个比较重要的点: <code>connect()</code>不应该被设计为成员函数, 而应该是非成员&amp;非友元函数,<br>并不意味着它不能成为其他类的函数 (<del>对Java和C井开发者而言</del>),<br>而我们在C++中的惯用做法是: <strong>将此函数放在与<code>PlatinumServer::socket</code>相同的命名空间</strong><br>正如我们上面所做的一样.</li></ol><h3 id="namespace-Class"><a href="#namespace-Class" class="headerlink" title="namespace | Class"></a>namespace | Class</h3><p>namespace(命名空间)与Class(类)并非是针锋相对的关系.<br>通过合理使用这两种工具, 我们可以减少名字冲突, 并且更好地实现封装的需求</p><p>namespace: 跨文件进行封装, 在避免名字冲突上尤其方便好用<br>class: 可以构造出相当规整的继承体系链来</p><p>但是他们也有不同之处: namespace构造出来的是平行的关系, 而class构造的是立体的架构</p><p>比如: 我们常使用的 C++ Standard Library, 并非是一个 &lt; C++StandardLibrary &gt;吧<br>他将我们要应用的不同部分, 划分到了,不同的头文件<br>e.g. &lt; vector &gt;, &lt; list &gt;, &lt; iostream &gt;等</p><p>反观, class就不能用在此处. 因为这些不同的标准库设施, 并没有实际的继承体系</p><p>合理的使用namespace/class 这些类设计工具, 会使我们事半功倍</p><blockquote><p>请记住 :</p><p>宁可拿non-member &amp; non-friend 函数替换member函数.<br>这样做可以增加封装性, 包裹弹性和机能扩充性</p></blockquote><h2 id="Item-24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#Item-24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="Item 24: Declare non-member functions when type conversions should apply to all parameters"></a>Item 24: Declare non-member functions when type conversions should apply to all parameters</h2><p>在聊聊这一条款之前, 我们先来看一个关键字 <code>ecplicit</code></p><blockquote><p>explicit</p><p>英语释义: explicit<br>adj.明确的，清楚的;直言的;详述的;不隐瞒的</p><p>这个关键字是C++, 限定在构造函数上使用的, 它表示 <strong>不允许隐式类型转换</strong><br>默认的构造函数是 non-explicit的</p></blockquote><p>具体是什么意思呢?</p><p>不允许进行隐式类型转换/复制初始化</p><p>例如: <code>vector</code>大多数构造函数都是explicit的, 会产生隐式类型转换, 造成意义不明<br><code>string</code>大多数构造函数都是non-explicit的, 可以完成隐式类型转换</p><p>我们这一条款的重心来了: 如果参数都需要类型转换的时候, 怎么办呢?</p><p>总是说运算符重载, 我们就来看看运算符重载的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line">    ~Temp();</span><br><span class="line">    Temp <span class="keyword">operator</span>+(Temp &amp;rhs);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Temp Temp::<span class="keyword">operator</span>+(Temp &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Temp(<span class="keyword">this</span>-&gt;a + rhs.getA(), <span class="keyword">this</span>-&gt;b + rhs.getB());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们常见的, 运算符重载的两种形式之一: 成员函数(另一种为: 友元函数)<br>那么, 下面的场景, 它应用的怎么样呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Temp a;</span><br><span class="line"><span class="keyword">auto</span> m = a + <span class="number">3</span>;             <span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">auto</span> n = <span class="number">3</span> + a;             <span class="comment">// Compiler Error !</span></span><br></pre></td></tr></table></figure><p>为什么会这样呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换一下</span></span><br><span class="line"><span class="keyword">auto</span> m = a.<span class="keyword">operator</span>+(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> n = <span class="number">3.</span><span class="keyword">operator</span>+(a);</span><br></pre></td></tr></table></figure><p>可以看出, a中是有, <code>Temp::operator+(...)</code>此成员函数的, 没有, 自然是的调用失败<br>而且, 我们在全局范围内, 并不能找到 <code>Temp operator+(Temp &amp;lhs, Temp &amp;rhs);</code>函数</p><p><em>Tips: 其中可能会迷惑, 3并非是Temp类型, 如何进行调用的呢? 想想explicit吧 !</em></p><p>最后回到我们的重点上来: 如何实现需求呢?<br><strong>那就是: 使用non-member function</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Temp <span class="keyword">operator</span>+(Temp &amp;lhs, Temp &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Temp(lhs.getA() + rhs.getA(), lhs.getB() + rhs.getB());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便可以很好的解决我们目前遇到的问题了.<br>(<del>也即是说,我们平时实现的习惯是值得商榷的, 因为我们仅进行相同类型之间的运算</del>)</p><p>那么, 我们的问题来了:<br><strong>上一条款着重说明了, </strong><code>member function</code><strong>相对的是</strong><code>non-member &amp; non-friend function</code><br>那么, 我们在这一条款中讨论的, non-member function, 是否也应该是non-friend呢?</p><p>在此情景下, 此函数不应该被设计为 <code>friend</code>函数, 原因: <strong>我们可以用接口访问私有数据</strong><br><strong>因此应该尽可能避免破坏封装性, 我们应该减少友元的出现</strong></p><p><em>因为, 友元和成员, 不可避免的会破坏封装程度</em></p><blockquote><p>请记住 :</p><p>如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换,<br>那么此函数一定是个non-member</p></blockquote><h2 id="Item-25-Consider-support-for-a-non-throwing-swap"><a href="#Item-25-Consider-support-for-a-non-throwing-swap" class="headerlink" title="Item 25: Consider support for a non-throwing swap"></a>Item 25: Consider support for a non-throwing swap</h2><p><code>std::swap()</code>是<code>C++ STL</code>中一个有意思的玩意. 后来它有多大作用不考虑.</p><p>但是, 它在我们平常使用中,是有相当大的便利的.</p><p>先来看看它的标准实现, 不出所料, 模板实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;m, T &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">Temp</span><span class="params">(m)</span></span>;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个实现是没有什么意思的, 因为只是进行了对象的赋值和拷贝.(<strong>注意, 一定是可拷贝的, 才能swap</strong>)</p><p>现在介绍一种,C++标准库中的手法: <a href="https://en.wikipedia.org/wiki/Opaque_pointer" target="_blank" rel="noopener">pimpl idiom&gt;&gt;</a></p><p>这种手法: 主要是通过不透明指针隐藏类的实现, 同时维护稳定的ABI接口, 以及减少编译依赖的<br>(~~当然, 没有一种手法是毫无缺点的, 在模板特化, 运行开销, 堆栈开销上, pimpl idiom也有不足)</p><p>pimpl idiom (D pointer, 不透明指针), 这不是我们这里讨论的重点</p><p>我们在这里要讨论的是, 如果是pimpl手法的实现, <code>std::swap()</code>还值得这样做吗?</p><p><strong>肯定是不可行的</strong>, 平白无故多拷贝构造了一个对象, 在本质上只是需要进行指针的交换的时候</p><p>现在, 来考虑一下, 有什么合理的手法来处理呢?</p><h3 id="特化模板"><a href="#特化模板" class="headerlink" title="特化模板"></a>特化模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    XXX *impl_idiom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Temp&gt;(Temp &amp;a, Temp &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    swap(a.impl_idiom, b.impl_idiom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们不能向std中添加任何玩意, (毕竟标准委员会也不是吃闲饭的, ),但是特化模板是可以被接受的<br>仍然是,看上去十分美好. ==通过特化模板, 对于指定类型, 直接交换pimpl指针==<br>但是, 事实上是不能通过编译的<br><strong>因为, impl_idiom成员是私有的, 我们不能随意访问它</strong></p><p>我们便萌生出, 添加接口/友元, 两种办法.<br>明确的可以说: 添加接口, 是在逃避问题, 而且它还可能引发之后出现的一系列新的问题<br>那么, 友元就可取吗? <em>也不是不行, 但我们这里一般使用类STL的手法</em></p><h3 id="类STL手法"><a href="#类STL手法" class="headerlink" title="类STL手法"></a>类STL手法</h3><p>其实是对上面方法的改进. 我们通过使用<code>public member-function + 特化template</code>的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Temp &amp;rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(impl_idiom, ths.impl_idiom);   <span class="comment">// member-func 可访问同类型私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Temp&gt;(Temp &amp;a, Temp &amp;b) &#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便是STL通用模式: 类开放公共接口, 模板进行特化调用此接口. 也是为了不适使用friend破坏封装<br>这个手法能够很好的通过编译, 同时正常的工作</p><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>但是, 需求永远也不能满足.</p><p>当我们编写的是类模板, 而不是简单地类时, 问题又出现了. 我们对function template进行偏特化</p><p><strong>标准明确规定, 对类模板可以进行全特化/偏特化, 函数模板不能进行偏特化</strong><br><em>并非实现问题, 函数模板的偏特化, 一般由函数(模板)重载形式来实现</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;                                    <span class="comment">// function-template偏特化失败</span></span><br><span class="line"><span class="keyword">void</span> swap&lt;Temp&lt;T&gt;&gt;(Temp&lt;T&gt; &amp;a, Temp&lt;T&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 怎么办呢? ==&gt; 函数重载来完成偏特化的需求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function template overload</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Temp&lt;T&gt; &amp;a, Temp&lt;T&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可行吗? 是的, 这个是可行的. 但是它仍然违背了<strong>我们不建议向std中添加内容</strong>这一准则</p><p>还有办法吗? <strong>有的, 限制命名空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TempStuff &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Temp&lt;T&gt; &amp;a, Temp&lt;T&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当然, 现在也就算不上是函数重载了.</strong></p><p>现在, 我们来分析一下, 调用的方法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Temp a, b;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(...)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">templaet &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;XX&gt;(...) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">namespace</span> XX &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX</span> &#123;</span>...&#125;</span><br><span class="line"></span><br><span class="line">templaet &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(XX&lt;T&gt; &amp;a, XX&lt;T&gt; &amp;b)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>using std::swap</code>意义何在 ?</p><p>这是为了配合下面的 <code>swap(a, b);</code> 调用的<br>因为C++具有一套复杂的名字查找规则,(==ADL尤其甚之==) [此处暂且不表]<br><code>swap(a, b);</code>的调用形式是必须的<br>当我们namespace具有特化的版本(模板类时) [3] / std特化版本(全特化) [2] 时, 优先调用(pimpl_idiom)<br>当没有这些实现时, 我们调用<code>std::swap</code>, 来进行一般的交换. [pass-by-value]<br>所以,<code>using std::swap</code>的名字曝光吧.</p></blockquote><p>同时, 我们要注意的是,<br><code>using std::swap; std::swap(a, b);</code><strong>的编码是禁止的</strong><br>这会使我们前功尽弃, 我们为了提高效率库的特化版本, 并不会被查找, 会直接使用std版本(对象拷贝)<br><em>当然,这里会使用全特化版本 [2], 不过你的类若是模板类, 那么命名空间内的T版本无法被调用 [3]</em></p><p>现在, 我们合理的梳理一下顺序:</p><ol><li>为Class编写public的swap接口成员函数<br>2-1. 若是class, 则进行std的特化版本<code>template &lt;&gt; void swap&lt;XX&gt;() {...}</code> + <code>XX.swap()</code><br>2-2. 若是class template, 我们便在Class命名空间中, 进行专属swap template编码 + <code>XX.swap()</code></li><li>进行swap调用, 核心是 <code>using std::swap;</code> + <code>swap(a, b);</code></li></ol><p>至此, 我们已经实现了一个基本高效的swap了.<br>最后一点: <strong>绝对不要抛出Execption</strong></p><p>Emmmm, C++ 11新加入了一个东西, <code>noexecpt</code>, 表示不抛出<br><strong>因为, 在我们不提示的时候, 编译器默认做好了抛出异常的准备, 会有一些无用功</strong></p><p>而我们明确的指示不抛出, 则可以大幅提高效率.</p><p><strong>而且, 我们进行手动swap编码时, 基本都是pimpl</strong><br><strong>而pimpl是指针, 是内置类型</strong><br><strong>内置类型进行拷贝, 是绝不会抛出异常的的</strong></p><p><strong>所以, 不抛出异常的swap就显得尤其关键 ! </strong></p><blockquote><p>请记住 :</p><ol><li>当<code>std::swap</code>对你的类型效率不高时, 提供一个swap成员函数, 并确定这个函数不抛出异常</li><li>如果你提供一个<code>member swap</code>, 也该提供一个<code>non-member swap</code>用来调用前者<br>对于Classes(非template), 需要特化std::swap</li><li>调用swap时应该针对 swap,使用<code>using std::swap</code>声明式,<br>然后调用swap并且不带有”命名空间资格修饰”</li><li>为”用户定义类型”进行<code>std templates</code>全特化是好的,<br>但千万不要尝试在std内加入某些对std而言是全新的东西</li></ol></blockquote><p>本篇中, 我们讨论了设计的问题, 下一篇与此篇息息相关, 那便是关于实现(implementations)的内容</p>]]></content>
    
    <summary type="html">
    
      Chapter IV 设计与声明. 其实这是一个复杂的问题. 我们在这里谈一些基本, 核心的设计准则. 其中涵盖了Class的设计与声明手法.
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="EffectiveC++" scheme="http://evil-crow.github.io/tags/EffectiveC/"/>
    
  </entry>
  
  <entry>
    <title>&lt;星月夜&gt; Resource Management</title>
    <link href="http://evil-crow.github.io/2018/09/19/C++/EffC++/effective3/"/>
    <id>http://evil-crow.github.io/2018/09/19/C++/EffC++/effective3/</id>
    <published>2018-09-19T11:36:00.000Z</published>
    <updated>2018-09-27T15:10:38.494Z</updated>
    
    <content type="html"><![CDATA[<p><em>C++是一门强大的编程语言, 它自信程序员拥有强大的本领驾驭它的各个方面, 所以将资源管理的任务</em><br><em>全部托付给程序员(好吧, 只是为没有GC在洗地…)</em><br><em>从最基础的动态内存分配 ~ 文件描述符(file descriptor) ~ 套接字(socket) ~ 线程(thread)</em><br><em>资源管理的任务无处不在, 因此资源管理便成为我们严格对待的方面</em></p><h2 id="Item-13-Use-objects-to-manage-resource"><a href="#Item-13-Use-objects-to-manage-resource" class="headerlink" title="Item 13: Use objects to manage resource"></a>Item 13: Use objects to manage resource</h2><p>对于资源管理, 说的简单了, 其实最重要的就是: <strong>资源泄漏(memory leak)的问题</strong><br>1.不使用的资源, 应该及时释放<br>2.已经释放的资源, 绝对不能使用, 会导致未定义行为</p><p>我们从最常见的heap-based资源开始, 先来看看我们平时是怎么做的吧,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;                 <span class="comment">// allocate resource(int) on heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_resource</span><span class="params">(...)</span></span>;        <span class="comment">// func -- get resource</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = get_resource();      <span class="comment">//request resource</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;                     <span class="comment">// release resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正如我们上面的编码, 我们先申请资源, 最后释放资源, 一切看上去是那么的井然有序.<br><strong>真的能如你所愿吗 ? </strong><br><em>考虑一下: 如果在<code>...</code>中间,存在: 提前return, throw异常, 多重嵌套, 还会正常工作吗 ?</em><br><strong>事实上, 只要是足够正式的工程代码, 极有可能工作流是到不了 资源释放的步骤的.</strong></p><p>当然, 通过细致而严谨的编码, 我们可以做到资源管理的安全性<br>但是其中的难度可想而知<br>另一方面, 如果并非是代码维护者, 对于代码做了某些改动, 极有可能导致资源管理的有一次失控</p><p><strong>因此, 引入使用对象管理资源的思想, 即资源获得即初始化(RAII)</strong></p><blockquote><p>那么, 何为RAII?</p><p>RAII(Resource Acquisition Is Initialization)<br>字面意思为: 资源获取即初始化. 是有点拗口<br>实际上,它遵循了两个思想:</p><ol><li>资源一旦初始化(/赋值)即交给对象管理</li><li>资源的释放, 交由类机制的析构函数释放</li></ol></blockquote><p>那么, RAII的优点体现在哪里?<br>1.将资源交给对象管理, 只要处理的得当了, 可以避免内存泄漏(某种程度上)<br>2.隔离了资源的所有权, 解放了程序员, 就是说: 简化了资源管理的任务</p><p>RAII的资源管理策略, 是真的十分巧妙 !</p><p>那么, 如何使用RAII ?<br>分为两类: 类库中已经采用RAII策略的设施以及手动构建RAII类(Resource-managing classes)</p><h3 id="Standard-Library-Facilities"><a href="#Standard-Library-Facilities" class="headerlink" title="Standard Library Facilities"></a>Standard Library Facilities</h3><p>目前, 在标准库中已经采用RAII的设施有:<br><code>std::shared_ptr</code>, <code>std::unique_ptr</code>, <code>std::lock_guard</code><br><strong>我们建议对于heap-based资源, 使用这些设施进行管理</strong></p><p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * int *p = new int;</span></span><br><span class="line"><span class="comment"> * std::shared_ptr&lt;int&gt; p1(p);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>);     <span class="comment">// acquire resource when request</span></span><br><span class="line">&#125;                                         <span class="comment">// leave the block with releasing resource</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(&amp;mtx);    <span class="comment">// std facility, not heap-based resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们使用了, <code>std::shared_ptr</code>, <code>std::unique_ptr</code>. 这是现在C++ (C++11起)标准库设施.<br>在&lt; EffectiveC++ &gt;, 一书中提及的, <code>std::auto_ptr</code>(已废弃, 算是<code>std::unique_ptr</code>早期版本)<br><code>std::tr1::shared_ptr</code>已经正式纳入标准库, 并非是TR1, TR2扩展, 且TR1, TR2扩展已经废弃</p><p>不过,使用智能指针好也罢, 不使用也罢.<br>我们需要注意的是:<br><strong>智能指针的析构, 使用delete, 非delete[]</strong><br><strong>也即是说, 我们对于数组的动态内存分配, 要不然拒绝, 要不然自行构建删除器</strong><br><strong>毕竟, 对于数组类型, 标准库提供了自动析构的, vector以及string等设施(顺序容器)</strong></p><h3 id="Resource-managing-classes"><a href="#Resource-managing-classes" class="headerlink" title="Resource-managing classes"></a>Resource-managing classes</h3><p>对于常见的其他资源, 比如:<br><code>socket</code>, <code>file desdcriptor(fd)</code>, <code>thread</code>, <code>mutex</code>等等, <strong>我们更倾向于手动构建RAII类</strong></p><p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lock(<span class="built_in">std</span>::mutex &amp;mutex);</span><br><span class="line">~lock();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lock::Lock(<span class="built_in">std</span>::mutex &amp;mutex) : mtx(mutex) &#123; <span class="built_in">std</span>::lock(mtx); &#125;</span><br><span class="line"></span><br><span class="line">Lock::~Lock()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::unlock(mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex a;</span><br><span class="line"><span class="function">Lock <span class="title">lk</span><span class="params">(a)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;                  <span class="comment">// release resource automaticlly</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Socket(<span class="keyword">int</span> fd) : socket_fd(fd) &#123; ; &#125;</span><br><span class="line">~Socket() &#123;</span><br><span class="line">    ::close(socket_fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = ::socket(...);</span><br><span class="line">    <span class="function">Socket <span class="title">s</span><span class="params">(fd)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;                <span class="comment">// release resource automaticlly</span></span><br></pre></td></tr></table></figure><blockquote><p>请记住:</p><ol><li>为防止资源泄漏. 请使用RAII对象, 它们在构造函数中获得资源并在析构函数中释放资源</li><li><del>两个常被使用的RAII Classes 分别是 <code>std::tr1::shared_ptr</code> 和 <code>std::auto_ptr</code></del><br><del>前者通常是较佳选择, 因为其Copy行为比较直观.若选择<code>std::auto_ptr</code>,</del><br><del>复制行为会使它指向null</del></li></ol></blockquote><h2 id="Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#Item-14-Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="Item 14: Think carefully about copying behavior in resource-managing classes"></a>Item 14: Think carefully about copying behavior in resource-managing classes</h2><p>Emmmmmm, 严格意义上来讲, RAII资源类, 一般而言, 是禁止拷贝的.<br>对, 没错.<br>但是, 什么事情都有例外, 万一真的出现需要拷贝的情况, 我们应该作出什么样的选择呢?</p><p>常见的选择有下面四种:</p><h3 id="No-Copy"><a href="#No-Copy" class="headerlink" title="No Copy"></a>No Copy</h3><p>这是最常选择的策略, 因为RAII类没有拷贝的必要与需求, 我们何必自找麻烦呢?</p><p>那么, 禁止拷贝的手段呢? (之前的条款已经提到过了)</p><p>两种手段:<br>1.使用Uncopyable/noncopyable<br>2.明确语义, 不需要拷贝的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boost::noncopyable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) &amp;&amp; !defined(BOOST_NO_CXX11_NON_PUBLIC_DEFAULTED_FUNCTIONS)</span></span><br><span class="line">    <span class="function">BOOST_CONSTEXPR <span class="title">noncopyable</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    ~noncopyable() = <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    noncopyable() &#123;&#125;</span><br><span class="line">    ~noncopyable() &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(BOOST_NO_DELETE_FUNCTIONS)</span></span><br><span class="line">    noncopyable(<span class="keyword">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    noncopyable(<span class="keyword">const</span> noncopyable &amp;);</span><br><span class="line">    noncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncoptable &amp;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using Boost::noncopyable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> :</span> <span class="keyword">public</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete copy function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    Lock(<span class="keyword">const</span> Lock &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Lock &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Lock &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Share-Resourse"><a href="#Share-Resourse" class="headerlink" title="Share Resourse"></a>Share Resourse</h3><p>除了禁止拷贝之外, 我们一般还可以接受, 共享资源.<br>即指: 不同的pointer/reference可以指向相同的资源.</p><p>我们一般有这两种手段: 使用智能指针RCSP, 或模拟底层引用计数<br>这两种自然就是 heap-based资源 与 其他类型的资源<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using std::shared_ptr (not std::tr1::shared_ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    Lock(<span class="keyword">const</span> Lock &amp;lk) &#123;                   <span class="comment">// 实现太shi, 差不多这个意思</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;pmtx = lk.handle();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex&gt; handle() &#123;</span><br><span class="line">        <span class="keyword">return</span> pmtx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex, <span class="built_in">std</span>::unlock&gt; pmtx;        <span class="comment">// 将std::unlock作为删除器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using reference-count</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    Lock(<span class="keyword">const</span> Lock &amp;lk) &#123;                   <span class="comment">// 实现太shi, 差不多这个意思</span></span><br><span class="line">        mtx = lk.handle();</span><br><span class="line">refCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">mutex &amp;<span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mtx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> refCount;                       <span class="comment">// 引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 细节没注意, 基本上就是这个意思</span></span><br></pre></td></tr></table></figure><h3 id="Move-Reference"><a href="#Move-Reference" class="headerlink" title="Move Reference"></a>Move Reference</h3><p>此部分, 和上一部分类似. 其中的区别便是: 转移资源而非共享资源</p><p><em>使用现代C++, 我们很容易想到标准库设施</em><br><code>std::unique_ptr</code>进行使用, 其他类的资源(非heap-base)自然就是<code>std::move()</code>了</p><h3 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h3><p>这种需求,真的是比较少, 本身RAII资源进行拷贝就少, 深拷贝更是凤毛麟角, 这部分就不再赘述<br>记住: 深拷贝, 拷贝的不仅是指针/引用等, 同时还拷贝了其所指向的对象. (有什么用, 反正现在没用上)</p><p>上述我们介绍了四种策略, 但是从真正意义上来讲:<br><strong>我们仅仅接受: 禁止拷贝 + 共享资源</strong><br><em>转移资源/深拷贝 并非是常见且合理的做法</em></p><blockquote><p>请记住:</p><ol><li>复制RAII对象必须一并复制它所管理的资源, 所以资源的Copying行为决定RAII对象的Copying行为</li><li>普遍而常见的RAII class copying行为是: 抑制copying, 施行引用计数法. 不过其他行为也都可能被实现</li></ol></blockquote><h2 id="Item-15-Provide-access-to-raw-resources-in-resource-managing-classes"><a href="#Item-15-Provide-access-to-raw-resources-in-resource-managing-classes" class="headerlink" title="Item 15: Provide access to raw resources in resource-managing classes"></a>Item 15: Provide access to raw resources in resource-managing classes</h2><p><em>本条款的标题叫做: 在RAII资源类中提供访问资源权限</em></p><p><strong>说实话, 看着矛盾是吧? 我们好不容易封装个资源, 现在又要开放接口, 搞事情 ? </strong></p><p><strong>客观分析: 其实这并不矛盾, 为什么? 因为我们使用class管理资源的目的并非是为了封装 ! </strong><br><strong>是的, 你没听错, 我们使用class管理资源的主要目的是为了能合理的, 管理和释放 ! </strong></p><p><strong>我们甚至可以, 谨慎的实现成员函数来避免直接访问资源, 但是与APIs的交互又该怎么办 ? </strong></p><p><em>并且, 纵观标准库中的RAII设施, 同样提供了接口去访问资源.</em><br>比如: <code>std::shared_ptr::get()</code>等</p><p><strong>所以, 我们既然本身目的并非是为了封装, 所以我们开放访问资源的接口并非不合理</strong></p><p>下面介绍访问资源的两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using interface get() etc.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    <span class="built_in">std</span>::sahred_ptr&lt;<span class="built_in">std</span>::mutex&gt; &amp;get() &#123;</span><br><span class="line">        <span class="keyword">return</span> pmtx;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex, <span class="built_in">std</span>::unlock&gt; pmtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using operator TYPE()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock();</span><br><span class="line">    ~Lock();</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pmtx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex, <span class="built_in">std</span>::unlock&gt; pmtx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Usage</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::mutex&gt; &amp;mtx)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(lock lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(lk.get());    <span class="comment">// get()</span></span><br><span class="line">foo(lk);          <span class="comment">// operator TYPE()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 我们如何抉择使用哪种方式呢?</p><p><strong>各有优劣</strong><br>1.使用显示接口, 可以是我们的意图更加明显, 除了某些极端人士嫌丑陋以外, 也没什么不好的.<br>2.使用隐式转换, 其实容易出问题, 有的时候会出现相反的效果</p><blockquote><p>请记住:</p><ol><li>APIs往往要求访问原始资源(raw resource), 所以每一个RAII class应该提供一个”取得其所管理之资源”的方法</li><li>对原始资源的访问可能经由显示转换或隐式转换.一般而言显示转换比较安全, 但隐式转换对客户比较方便</li></ol></blockquote><h2 id="Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#Item-16-Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="Item 16: Use the same form in corresponding uses of new and delete"></a>Item 16: Use the same form in corresponding uses of new and delete</h2><p>使用配对的new和delete 看起来其实是很简单的一个道理.</p><p>事实上就是一个很简单的道理.</p><p><code>new TYPE[] -&gt; delete [] p;</code><br><code>new TYPE -&gt; delete p;</code></p><p>为什么要成对使用, 因为如果不匹配, 就会有这样的问题: (类似于之前讨论指针和数组名混用)</p><p>若, 使用delete[ ]不匹配, 就有可能过多释放内存, 甚至于正在使用, 或者无法析构的内存</p><p>若. 使用delete不匹配, 就有可能少释放内存, 基本上也是未定义行为.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valagrid的分析</span></span><br><span class="line">==<span class="number">6539</span>== Mismatched <span class="built_in">free</span>() / <span class="keyword">delete</span> / <span class="keyword">delete</span> []</span><br><span class="line">==<span class="number">6539</span>==    at <span class="number">0x4C2E1E8</span>: <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span>*) (vg_replace_malloc.c:<span class="number">576</span>)</span><br><span class="line">==<span class="number">6539</span>==    by <span class="number">0x4005BD</span>: main (in /home/Crow/a.out)</span><br><span class="line">==<span class="number">6539</span>==  Address <span class="number">0x5aeac80</span> is <span class="number">0</span> bytes inside a block of size <span class="number">40</span> alloc'd</span><br><span class="line">==<span class="number">6539</span>==    at <span class="number">0x4C2D8B7</span>: <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">unsigned</span> <span class="keyword">long</span>) (vg_replace_malloc.c:<span class="number">423</span>)</span><br><span class="line">==<span class="number">6539</span>==    by <span class="number">0x4005A8</span>: main (in /home/Crow/a.out)</span><br></pre></td></tr></table></figure><p>另外强调两个点:<br>1.对于数组之类的, 我们更建议vector, deque, string等设施<br>2.尤其是typedef等使用手动new, delete简直是毁灭级的, 因为它到底用的哪种new我们一无所知</p><p>所以, 一定要保证自己<strong>成对匹配的使用new和delete</strong></p><p><del>我曾经在不会C++的时候, 被g卓越因为这个坑过 \白眼</del></p><blockquote><p>请记住:</p><ol><li>如果你在new表达式中使用[ ], 必须在相应的delete表达式中也使用[ ].<br>如果你在表达式中不使用[ ], 一定不要在相应的delete表达式中使用[ ].</li></ol></blockquote><h2 id="Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#Item-17-Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="Item 17: Store newed objects in smart pointers in standalone statements"></a>Item 17: Store newed objects in smart pointers in standalone statements</h2><p>这句话, 看上去有点奇妙, 什么意思呢?</p><p><em>以独立的语句将newed对象置入智能指针</em></p><p>看个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(std::shared_ptr&lt;int&gt; sp, void (*foo));     // prototype</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>), foo());</span><br></pre></td></tr></table></figure></p><p>这其中, 在func()函数调用的时候, 实参和形参匹配时的求值顺序是未定义的</p><p>所以, 就有可能出现,下面这样的顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">new</span> p;</span><br><span class="line"><span class="number">2.</span> foo();</span><br><span class="line"><span class="number">3.</span> <span class="built_in">std</span>::sahred_ptr&lt;<span class="keyword">int</span>&gt; (...);</span><br></pre></td></tr></table></figure><p>那么, 一旦在第二步骤的时候, “成功”抛出异常, 毁灭级的打击, 这已经造成内存泄露了<br><strong>而且, Debug及其困难, 因为复现的难度已经十分之大 !</strong></p><p><strong>所以, 应该以独立的语句将new的资源置于智能指针中, 不同语句之间的求值顺序值确定的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pw(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">func(pw, foo());</span><br></pre></td></tr></table></figure><p><strong>上升一下: 不仅仅是这种申请资源, 只要是需要确定的顺序的行为, 我们就一定要分成独立的语句, 有的时候紧凑, 花哨的编码, 反而是毁灭的入口</strong></p><blockquote><p>请记住:</p><ol><li>以独立语句将newed对象存储于(置入)智能指针!<br>如果不这样做, 一旦异常被抛出, 有可能导致难以察觉的资源泄漏.</li></ol></blockquote><p><em>Tips: 我们在本节中讨论的都是资源泄漏(Resource Leak), 已经不仅仅是内存泄漏(Memory Leak)</em></p>]]></content>
    
    <summary type="html">
    
      Chapter III 资源管理
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="EffectiveC++" scheme="http://evil-crow.github.io/tags/EffectiveC/"/>
    
  </entry>
  
  <entry>
    <title>&lt;星月夜&gt; Constructors, Destructors, and Assignment Operators</title>
    <link href="http://evil-crow.github.io/2018/09/13/C++/EffC++/effective2/"/>
    <id>http://evil-crow.github.io/2018/09/13/C++/EffC++/effective2/</id>
    <published>2018-09-13T14:49:00.000Z</published>
    <updated>2018-09-27T15:10:45.892Z</updated>
    
    <content type="html"><![CDATA[<p><em>上一篇中,我们着重进行了C++中最最基础,和C有很大区别的地方,比如语言联邦, 减少预处理器的使用,</em><br><em>多使用const, 保证使用前初始化对象等几个方面</em></p><p><em>这一部分, 我们就来聊聊使C++语法变得如此复杂的”罪魁祸首”之一 —- 复杂的拷贝控制</em></p><h2 id="Item-05-Know-what-functions-C-silently-writes-and-calls"><a href="#Item-05-Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="Item 05: Know what functions C++ silently writes and calls"></a>Item 05: Know what functions C++ silently writes and calls</h2><p><em>这是一个关键的点, 我一直因此觉得C++足够傲娇.C/C++有着强大的性能,同时他们又兼具着许多风险行为</em><br><em>如何高效编程, 同时规避风险, 我觉得这就是C/C++的美感之一</em></p><p>我们在此处要讨论的是: <strong>在你不知道的情况下, C++默默编写并调用了哪些函数</strong><br>(PS: 此处重要针对讨论的是 <code>class</code>内部的情况, global作用域内, 不可能被凭空塞函数的)</p><p>先来看一个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure><p>上面是一个简单地例子: <code>class Temp {};</code>我们并没有为它编写任何的成员函数, 那么它可以使用吗?<br>比如:<br><code>Temp a;     // Constructor</code><br><code>Temp a(b);  // Copy-constructor</code><br><code>Temp a = b; // Copy-operator-assignment</code><br><code>{ .... }    // Destructor</code></p><p>经过实验, 你可以发现, 上面这些操作都是成功的!<br>为什么? 我们明明没有编写这些成员函数的啊! 这便是<strong>C++默默编写并调用的函数</strong></p><p>总共有下面这四(六)类:</p><ol><li>Constructor</li><li>Copy Constructor</li><li>Copy assignment operator</li><li>Move Constructor        (C++11)</li><li>Move assignment operator (C++11)</li><li>Destructor</li></ol><p>这些默默编写的函数存在着下面的特点:<br>1.public &amp;&amp; inline<br>2.默认初始化 &amp;&amp; 逐次拷贝<br>3.编译器生成的版本都是non-virtual的, (继承得来的除外)</p><p>暂且记下这些特点, 我们下面的讨论会用到, 并非分析如何处理此情况</p><p>所以上面的例子实际上是这样子的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    Temp();</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;);</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;);</span><br><span class="line">    Temp(Temp &amp;&amp;);</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(Temp &amp;&amp;);</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 编译器一定会生成这些函数吗? 是不是得思考一下?</p><p>我们有下面的结论:<br><strong>assignment operator不一定会生成, 其余的函数照样会生成</strong></p><p>考虑这样的情况:<br>1.内含reference的class,<br>2.内含const成员的class<br>3.base class的assignment operator为private</p><p>来解释一下这三种情况:<br>1.若含有reference, 拷贝赋值函数到底是修改reference(错误)还是其所指的内容(无意义)?<br>2.const成员怎么可能会被修改!<br>3.若base class的拷贝赋值为private, derive class的拷贝赋值函数便无法生成</p><p><strong>简单地来说, 我们设身处地的为编译器着想, 它是否可以处理这种情况, 从而进行判断</strong><br><strong>上面的情况便是: 编译器无法为这些情况处理, 所以它的copy assignment operator创建失败</strong></p><blockquote><p>请记住</p><p>编译器可以暗自为class传播创建default构造函数, copy构造函数, copy assignment 操作,<br>以及析构函数, (以及move 构造函数, move assignment操作 C++11后)</p></blockquote><h2 id="Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want"><a href="#Item-06-Explicitly-disallow-the-use-oof-compiler-genreated-functions-you-do-not-want" class="headerlink" title="Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want"></a>Item 06: Explicitly disallow the use oof compiler-genreated functions you do not want</h2><p><em>这一条款的讨论是基于 Item 05的, 处理编译器生成函数的不二法宝</em></p><p><strong>首先强调一个事实: 如今可以明确的说明对于编译器生成函数我们持有的态度</strong></p><p><em>还是hepangda的说法比较准确, “ C++11之后语言的语义更加明确 “</em><br><em>解释起来就是, C++之前的一些做法, 你不是很明确它的意思, 在一定条件下, 得借助注释才能迅速的理解</em></p><p>那么,我们先来说说在现代C++中如何处理这种问题吧,</p><p>现代C++中我们可以使用<strong>default, 以及delete</strong>来进行编译器生成函数的控制, 表明我们的态度</p><p>如下例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line">    Temp() = <span class="keyword">default</span>;</span><br><span class="line">    Temp(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Temp(Temp &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Temp &amp;<span class="keyword">operator</span>=(Temp &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~Temp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>通过语义明确的现代C++, 我们可以做到不想编译器自动生成的函数, 明确拒绝</strong><br><strong>如此的做法,也已经成为现代C++的编程规范之一了</strong></p><p><em>那么, 之前的C++是如何处理这样的问题呢 ?</em></p><p>这种问题还是会出现的, 我们还是之前的态度: 我们不能假定用户并不会犯错, 所以这种情况也应该处理掉的.<br>那么我们的入手点在于: compiler-gengrated functions 都是默认 <code>public &amp; inline</code><br>我们的入手点便是: 将其不能直接使用 =&gt; <strong>使用访问权限的控制手段</strong></p><p>我们提供以下两种思路:<br>1.<code>private &amp; implemention</code><br>2.<code>base-class &amp; implemention</code> (1.的基础上改良)</p><p>对于1, 我们的思路很明确, 就是使用<code>private</code>访权控制来拒绝我们不想使用的成员函数</p><p>但是, <code>member function</code>和<code>friend function</code>会打扰我们.</p><p><strong>于是, 我们就给予它便不实现, implmention =&gt; 链接器会报错</strong></p><blockquote><p>链接器报错 link-error<br>上面说到的链接器报错,是这个原因:<br>按照常人理解, 一般没有实现的函数, 会直接编译错误对吧 ?<br>但是C++因为分离式编译的原因 (区别参考于Java) ,前置声明了解一下, pimpl手法基础<br>知道link期间才会报错, 找不到函数的引用, 也就是实现之处, “no reference to FUNC”</p></blockquote><p>于是方法1 可以比较好的解决这个问题了.</p><p>尽管链接器报错, 也不会影响运行时效率, 可是我们还想尽早的报错为好, 将错误提前到编译期(Compiler)<br>有办法吗? 一定是有的!</p><p>使用OOP的手法: 继承<br>我们可以构造一个基类(因为不给予实现),将之继承, 然后正常编写即可.<br><strong>那么为什么会将报错提前至编译期呢 ? </strong></p><blockquote><p>无法进行构造, 因基类没有构造函数, 就是说一定要是用这个类构建对象, 才能错误提前到编译期</p></blockquote><p>举个例子如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopy</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    noncopy(<span class="keyword">const</span> noncopy &amp;);</span><br><span class="line">    noncopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> noncopy &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> :</span> <span class="keyword">public</span> noncopy &#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Temp t;</span><br></pre></td></tr></table></figure></p><p>这便是正确的使用举例</p><p><strong>我们建议使用现代C++语义明确的手法, C++03, 乃至98的手法, 只是作为开阔思路的解法了解即可</strong></p><blockquote><p>请记住</p><p>为驳回编译器自动(暗自)提供的机能, 可将相应的成员函数声明为privat并且不予实现.<br>使用像uncopyable这样的base class也是一种做法</p></blockquote><h2 id="Item-07-Declare-destructors-virtual-in-polymorphic-base-class"><a href="#Item-07-Declare-destructors-virtual-in-polymorphic-base-class" class="headerlink" title="Item 07: Declare destructors virtual in polymorphic base class"></a>Item 07: Declare destructors virtual in polymorphic base class</h2><p>如果要在C++中提到 <code>virtual</code>这个词, 经常用在这两个方面: <code>virtual继承</code> 与 <code>virtual function</code></p><p>我们这一部分专注于<code>virtual function</code>的内容, 虚继承的内容都是后话.</p><p>首先来看一个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base();</span><br><span class="line">    ~base();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cderive</span> :</span> <span class="keyword">public</span> base &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">base *pb = get_derive_pointer();   <span class="comment">// 为了多态需求使用, 基类指针(/引用皆可)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br></pre></td></tr></table></figure></p><p><code>delete pb;</code><strong>会造成严重的灾难性后果 !</strong><br><strong>因为delete一个基类指针, 而且它的析构函数是non-virtual, 在派生类中, 此析构仅仅是base析构</strong><br><strong>这样, 你也能想到析构的下场了吧, derive部分无法析构, 且指针销毁, 只剩下一个不完全的对象</strong></p><p>那么,正确的做法呢?</p><p><strong>使用virtual-destructor 在base-class中 (子类继承后,virtual属性一并继承)</strong></p><p>这个其实是多态性的基础–C++中,基类指针/引用可以指向派生类的对象, 因此才能实现多态性</p><p>这样一来, 就可以舒服的解决这个问题了.</p><p><em>那么, 从一个方面来考虑, 未提供nvirtual destructor的函数, 就很麻烦了, 万一被继承就要出篓子</em><br><em>比如: std::stirng, std::iostream等</em><br><em>EffectiveC++的作者在感慨 C++没有的 final 已经在现代C++中加入, 但是我在&lt; string &gt;中还没找到</em><br><em>反正, 注意对于未提供virtual destrutor的class, 可能本来就是没有被设计作为多态base-class考虑</em></p><p>我们再来稍微说说vitual的事,</p><p>下面这些是, hepangda给我的科普,</p><blockquote><p>C++中实现的多态是成本最小的之一. 很简单的问题, 使用计算机时, 多态是我们目前不可预测的,<br>在编译期无法预知, 那么最简单的, 就是打表的思想, 我把可能的情况都塞进去, 到时查表就行<br>而具有Basic Object的语言, 就可以完全实现反射, Java, Ruby等…</p></blockquote><p>基于上面的这段话:<br>virtual实际上对class进行了打表, 将可能的函数指针封进表中, 成为虚表 (virtual table)<br>而每个class中会留一个隐藏的虚表指针vptr (virtual ptr)<br>使用virtual会<strong>大程度的提高开销 ! ! !</strong>, 他会使可执行文件增加容量</p><p>举一个EffectiveC++中的例子:<br>(64位环境)一个类中,有两个int, 应该占8个字节, 这个时候加上一个virtual, 多一个vptr<br>class体积增加100% !</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;        =&gt; <span class="number">8</span> Bytes</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~B();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;        =&gt; <span class="number">16</span> Bytes</span><br></pre></td></tr></table></figure><p>另外我们再来说说<strong>抽象基类</strong>的事情:<br>abstract class 指的是含纯虚函数的类,<br><em>很不幸, 我们因为没有interface的关键字, 导致定义接口要使用抽象基类的手法</em><br><strong>我们要讨论的是, 如何拥有一个抽象基类</strong></p><p><strong>其实,也不麻烦,就是标题的 纯虚析构函数 即可</strong><br><em>因为纯虚 (pure virtaul), 所以是抽象基类</em><br><em>同时又是 virtual 析构函数, 所以不用担心析构的问题</em></p><p><strong>这里的窍门是: 要为 pure virtual destructor 提供一份定义</strong><br><strong>否则, derive class 的destructor都会爆炸的, 具体上一条款中关于implemention的问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vitrual ~Temp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Temp::~Temp() &#123; ; &#125;</span><br></pre></td></tr></table></figure><p>因此, 给出我们使用virtual的建议:<br><strong>记住: 仅仅在有多态需求时使用virtual函数, 其余时候(仅作为基类, 一般类)能不用就不要用virtual</strong></p><blockquote><p>请记住</p><p>polymorphic(带多态性质的) base classes 应该声明一个virtual 析构函数. 如果class带有任何virtual函数, 它就应该拥有一个virtual析构函数</p><p>不是设计用来作为 base classes（基类）或不是设计用于 polymorphically（多态）的 classes（类）就不应该声明 virtual destructor（虚拟析构函数）</p></blockquote><h2 id="Item-08-Prevent-exception-from-leaving-destructors"><a href="#Item-08-Prevent-exception-from-leaving-destructors" class="headerlink" title="Item 08: Prevent exception from leaving destructors"></a>Item 08: Prevent exception from leaving destructors</h2><p>异常可谓是进行OOP中所必不可少的。<br>从某个方面来说, 使用异常机制可以改变程序设计的模式, 使我们更加专注于逻辑设计<br>将平时繁琐的错误处理情况, 按死在异常中(简单地说, 不容易分心)</p><p>C中也实现了近似于异常的机制, 起源于goto的语法, <code>setjump/longjump</code><br>Java中的异常机制十分完善, 并且保证了足够的效率.<br>反观, C++中的异常机制, 因为是后来加入的体系, 所以在性能和效率上都差强人意.</p><p>一个不得不承认的事实:<br><strong>C++中应该尽可能少, 甚至不使用异常, 而且我们一般对于异常的处理是杀死</strong></p><p>那么, 我们在这一条款中, 到底要讨论什么主题呢？</p><p><em>我们对于异常机制的使用, 以及关于OOP设计接口的一部分讨论</em></p><p>对于异常的处理, 我们以下面的例子来谈：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLaffair</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SQLaffir();</span><br><span class="line">    ~SQLaffair();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SQL *psql;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们使用指针作为成员, 这也是pimpl手法的应用之一。</p><p>我们重点的是要讨论在析构函数中, 如果发生了异常该怎么办？<br>我们一般具有两种手段来处理:</p><ol><li>悄悄掩盖住错误</li><li>让他去死 (PS: Let it die挺好玩的)</li></ol><h3 id="悄悄掩盖住错误"><a href="#悄悄掩盖住错误" class="headerlink" title="悄悄掩盖住错误"></a>悄悄掩盖住错误</h3><p>这一种处理方法, 在某种程度上是为了软件稳定的妥协。<br>问题并非是毁灭级的失败, 且稳定性更为重要的时候, 我们便放弃对错误的处理, 悄悄掩盖起来</p><p>我们为什么会选择悄悄处理错误这样一种决策呢?</p><p><em>因为在析构函数中抛出异常意味着 “中断程序” 和 “未定义的行为”</em></p><p>即使悄悄吞下错误, 在一定程度上也比引发上面两种行为, 好得多。</p><h3 id="让他去死"><a href="#让他去死" class="headerlink" title="让他去死"></a>让他去死</h3><p>这是一种大多数情况的策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQLaffir::~SQLaffir()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::runtime(<span class="string">"msg"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::runtime re) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 这种策略也显得过于粗暴, 用户在被强制中断, 不太友好。</p><p>所以, 我们的建议是, 开放一个接口给用户使用, 同时析构进行调用。</p><p>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SQLaddair::close = flase;  (TYPE: <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; close;)</span><br><span class="line">SQLaffir::close()</span><br><span class="line">&#123;</span><br><span class="line">    SQLptr.close();</span><br><span class="line">    close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SQLaffair::~SQLaffair()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SQLptr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">            <span class="comment">// 两种策略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的策略便是我们推崇的真正应该使用的处理手法。</p><p>为什么这样呢？因为他有如下优点:</p><ol><li>析构函数中严格的使用”悄悄吞掉” 或 “让他去死”的策略, 避免抛出异常</li><li>我们给了用户一个接口, close() 来处理异常情况</li></ol><p>EffC++中解释了, 使用close()与接口设计的矛盾性：<br>虽然从设计上来讲, 不应该将资源管理权交给用户, 因为不安全。</p><p><strong>但是, 我们在此处将资源控制权交给用户, 为什么?</strong></p><p>因为,关于SQL连接关闭是不可轻易吞下的错误, 我们应该给予用户以控制并处理错误的权利<br>所以, 此处我们先将问题暴露给用户, <strong>在用户放弃处理的时候, 我们在析构函数中, 使用两种策略处理</strong></p><p>综上所述:<br><strong>1. 不能让异常在析构函数中抛出, 会导致未定义行为/crash, 应该选择悄悄吞下/让他去死</strong><br><strong>2. 基于1, 我们应该作出, 必需要处理的异常, 在析构函数之前进行处理, 别让异常等到析构, 往出传播</strong></p><p><em>EffectiveC++中, 候捷先生的翻译是: 别让异常逃离析构函数</em><br><strong>私以为更妥当的翻译应该是: 在析构结束之前处理错误, 不要让异常在析构函数中抛出</strong></p><blockquote><p>请记住</p><p>destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后抑制它们或者终止程序。</p><p>如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。</p></blockquote><h2 id="Item-09-Never-call-virtual-function-during-Constructor-or-Destructor"><a href="#Item-09-Never-call-virtual-function-during-Constructor-or-Destructor" class="headerlink" title="Item 09: Never call virtual function during Constructor or Destructor"></a>Item 09: Never call virtual function during Constructor or Destructor</h2><p>继承是面向对象编程中很重要的一个特性.</p><p>设计并构建功能完整并强大的继承体系是一项复杂的工程.</p><p>在这其中我们会翻一个很经典的错误: <strong>在构造/析构函数中使用virtual函数</strong><br>乍看之下, 是不是还是挺有道理的.</p><p><strong>事实上, 这是一个严重的错误: 因为在析构, 构造期间. 类并非完整的, RTTI并不能得到派生类类型</strong><br><strong>因此, 我们所调用的只能是基类版本, 会导致严重的错误! 并不能达到我们的需求. 严重性可想而知.</strong></p><p>来看这样一个例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base();</span><br><span class="line">~base();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">log</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base::base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aderive</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Aderive();</span><br><span class="line">~Aderive();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bderive</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bderive();</span><br><span class="line">~Bderive();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Aderive ad;</span><br></pre></td></tr></table></figure></p><p>上面的示例, 我们构造ad对象, 构造过程会顺利完成.<br><em>但是, 其中使用的log(), 是base::log(), 不得不承认, 这是个令人惊奇的事实.</em></p><p><strong>原因正如上面所说: </strong><br><em>基类构造发生在派生类部分构造之前(base part construct before derive part)</em><br><em>我们使用vitual函数, RTTI得到的是base类型, 而非是derive类型, 不能满足我们的要求</em><br><em>更通俗的来讲: 此时的virtual并非是virtual, 仅仅是它自己的版本</em></p><p><em>正是因为, derive class尚未初始化完成, 使用派生类中的内容, 可能导致不安全行为/未定义行为</em><br><em>所以, 不允许virtual, 仅仅能使用base::log()版本.derive construct时, virtual不会下降到derive class</em></p><p><strong>准确的理由: 此时RTTI结果是base类型,dynamic_cast (此时进入base部分, derive部分视为未定义)</strong><br><strong>析构函数也是同理的.</strong></p><p><em>事实上, 防止构造/析构过程中出现virtual调用时很难检测的错误</em><br><strong>因为, 提供了实现版本, 就会出现正常运行, 错误结果的情况.</strong></p><p><em>注: pure virtual的版本可以通过编译, 调用会凉凉…</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pure virtual method called</span><br><span class="line">terminate called without an active exception</span><br></pre></td></tr></table></figure></p><p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base() &#123;init();&#125;;</span><br><span class="line">    ~base()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="built_in">log</span>();&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;                   <span class="comment">// pure virtual 运行, ERROR</span></span><br><span class="line"><span class="comment">// virtual void log() const &#123;cout &lt;&lt; "base";&#125;     // Result: base</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    derive()&#123;&#125;;</span><br><span class="line">    ~derive()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"derive"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derive b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>明白了吗? 即是说, 一旦是impure virtual 就是很难处理的Bug</em></p><p>那么, 有没有可以比较好的解决办法呢? <strong>派生类构造向基类传递参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;info)</span></span>;</span><br><span class="line">    void logTransaction(const std::string &amp;info) const);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;info)</span><br><span class="line">&#123;</span><br><span class="line">    logTransaction(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTranscation</span> :</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    BuyTranscation (parameters)</span><br><span class="line">        : Transaction(createLogInfo(parameters))     <span class="comment">// 使用传参的形式完成原多态需求</span></span><br><span class="line">    &#123; ... &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">createLogInfo</span><span class="params">(parameters)</span></span>;   <span class="comment">// static保证此部分与对象无关, 无危险</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>综合所述:<br><strong>不要在构造/析构中使用virtual, 因为这时刻他们的类型是base, RTTI结果亦是如此</strong></p><p><em>或者说, 此时刻, 不会从base下降到derive层次</em></p><blockquote><p>请记住:</p><p>在 construction（构造）或 destruction（析构）期间不要调用 virtual functions（虚拟函数），因为这样的调用不会转到比当前执行的 constructor（构造函数）或 destructor（析构函数）所属的 class（类）更深层的 derived class（派生类）。</p></blockquote><h2 id="Item-10-Have-assignment-operators-return-a-reference-to-this"><a href="#Item-10-Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="Item 10: Have assignment operators return a reference to *this"></a>Item 10: Have assignment operators return a reference to *this</h2><p>此部分的内容实际上较为简单, 主要是阐述了一个关于<code>operator overload</code>的默认约定</p><p>即:<strong>运算符重载应该返回*this的引用</strong></p><p>我们可以看几个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Obj1 + Obj2;</span><br><span class="line">a = getVal();</span><br></pre></td></tr></table></figure><p>为什么可以这样写, 因为a是左值, <strong>返回对*this的引用, 便能保证是左值</strong><br><strong>若返回并非是左值, 则第二次运算会失败, 因为a仅仅是一个右值</strong></p><p>简单地说: <strong>我们返回非*this引用也无大碍, 但是,为了与用户习惯以及内置类型行为近似</strong><br><strong>我们强烈建议, 运算符重载返回对*this的引用.</strong></p><p><em>PS: 这只是建议, 并非是编程规范</em></p><blockquote><p>请记住:</p><p>让 assignment operators（赋值运算符）返回一个 reference to <em>this（引向 </em>this 的引用）。</p></blockquote><h2 id="Item-11-Handle-assignment-to-self-in-operator"><a href="#Item-11-Handle-assignment-to-self-in-operator" class="headerlink" title="Item 11: Handle assignment to self in operator="></a>Item 11: Handle assignment to self in operator=</h2><p>如题所示, 这一条款我们主要讨论的是: 在<code>operator=</code>中处理”自赋值”情况</p><p><del>这里再喷一下候捷先生的翻译, 不想多说</del></p><p>自赋值的问题, 怎么回事?</p><p>先来看一个正常的operator=</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Temp &amp;Temp::<span class="keyword">operator</span>=(<span class="keyword">const</span> Object &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = rhs.p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中会造成什么问题吗? <strong>是的, 当自赋值时, 这样的运算符重载会产生未定义的行为, 因为悬垂指针</strong></p><p><em>换种思路, 我们再来分析一下, 这种”自赋值”常见吗?</em></p><p><em>不幸的是, 基于两方面的原因. “自赋值”是一个不好规避的问题</em><br><em>1. 我们不能假设(assume)用户的行为, <del>把他们当成蠢蛋就行了</del></em><br><em>2. 我们更多的遇到的情况是, “隐式”自赋值</em></p><p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = ...;</span><br><span class="line"><span class="keyword">int</span> &amp;a = ...;</span><br><span class="line">*p = a;</span><br></pre></td></tr></table></figure></p><p><em>上面的例子便是两种常见的”隐式”自赋值情况, 需要十分的当心</em></p><p>扯了这么多, 我们就来说说<strong>真正处理自赋值的方法</strong></p><h3 id="使用if-else控制流"><a href="#使用if-else控制流" class="headerlink" title="使用if-else控制流"></a>使用if-else控制流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Temp &amp;Temp::<span class="keyword">operator</span>=(<span class="keyword">const</span> Object &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span> == rhs)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = rhs.p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点: 一旦遇到自赋值, 可以直接退出处理情况.<br>缺点: 增加了控制流, 开销不是那么容易抹掉的</p><h3 id="使用Copy-and-Swap-“CAS”"><a href="#使用Copy-and-Swap-“CAS”" class="headerlink" title="使用Copy and Swap (“CAS”)"></a>使用Copy and Swap (“CAS”)</h3><p>也可以简称为CAS, 不过与那个大名鼎鼎的CAS是完全不同的东西.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Temp &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Temp &amp;rhs);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">const</span> Temp &amp;lhs, <span class="keyword">const</span> Temp &amp;rhs)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Temp::swap(<span class="keyword">const</span> Temp &amp;rhs, <span class="keyword">const</span> Temp &amp;rhs) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Temp &amp;Temp::<span class="keyword">operator</span>=(<span class="keyword">const</span> Object &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Temp t(ths);</span><br><span class="line">swap(*<span class="keyword">this</span>, t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点: 可以安全的处理任何情况<br>缺点: 当自赋值可能性比较大时, 效率不如增加控制流的手段.</p><p><em>这两种手法, 可以比较好的处理自赋值, 选择那种,我们要根据情况来判断</em><br><em>另外, 禁止自赋值行为时, assert()断言就派上用场了</em><br><code>assert(*this == ths);</code></p><blockquote><p>请记住:</p><p>当一个 object（对象）被赋值给自己的时候，确保 operator= 是行为良好的。技巧包括比较 source（源）和 target objects（目标对象）的地址，关注语句顺序，和 copy-and-swap。</p><p>如果两个或更多 objects（对象）相同，确保任何操作多于一个 object（对象）的函数行为正确。</p></blockquote><h2 id="Item-12-Copy-all-parts-of-an-object"><a href="#Item-12-Copy-all-parts-of-an-object" class="headerlink" title="Item 12: Copy all parts of an object"></a>Item 12: Copy all parts of an object</h2><p>拷贝时勿忘掉任何一个对象成分</p><p>这是一句缄言, 拷贝赋值的时候, 缺少成分是最忌讳的</p><p>那么, 我们要注意的是什么情况呢?</p><p>主要有这样两种情况:<br><strong>1. 局部成分</strong><br><strong>2. 继承成分</strong></p><h3 id="1-局部部分"><a href="#1-局部部分" class="headerlink" title="1. 局部部分"></a>1. 局部部分</h3><p>局部部分, 主要考虑的是这样的情况: 后续进行class修改时, 有的局部成分被忘记和省略</p><p>那么唯一的办法: <strong>自己相信斟酌, 确认将所有成分进行拷贝</strong></p><h3 id="2-继承成分"><a href="#2-继承成分" class="headerlink" title="2. 继承成分"></a>2. 继承成分</h3><p>相对于局部部分, 继承成分乍看之下会很复杂: <strong>因为我们可能使用复杂的继承链</strong></p><p>但是, 继承也有继承的好处.</p><p><strong>只要我们保证层层严格使用基类的构造函数/拷贝赋值, 就可以保证每一部分不会被遗漏</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个重要问题: 不要试图用构造函数和拷贝构造相互实现, 没有意义! (最多使用私有方法简化重复工作)</strong></p><blockquote><p>请记住:</p><p>copying functions（拷贝函数）应该保证拷贝一个 object（对象）的所有 data members（数据成员）以及所有的 base class parts（基类构件）。</p><p>不要试图依据一个 copying functions（拷贝函数）实现另一个。作为代替，将通用功能放入一个供双方调用的第三方函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Chapter II 构造/析构/赋值运算
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="EffectiveC++" scheme="http://evil-crow.github.io/tags/EffectiveC/"/>
    
  </entry>
  
  <entry>
    <title>&lt;星月夜&gt; Accustoming Yourself to C++</title>
    <link href="http://evil-crow.github.io/2018/09/07/C++/EffC++/effective1/"/>
    <id>http://evil-crow.github.io/2018/09/07/C++/EffC++/effective1/</id>
    <published>2018-09-07T09:38:00.000Z</published>
    <updated>2018-09-27T15:10:54.061Z</updated>
    
    <content type="html"><![CDATA[<p><em>C++的世界的确是缤纷多彩的, 这是一门十分强大的编程语言, 随之而来的代价自然就是其使用麻烦</em><br><em>本章是全书第一章, 意在使自己熟悉使用C++,所必需要遵守的基础规则</em></p><h2 id="Item-01-View-C-as-a-federation-of-languages"><a href="#Item-01-View-C-as-a-federation-of-languages" class="headerlink" title="Item 01: View C++ as a federation of languages"></a>Item 01: View C++ as a federation of languages</h2><p>作为第一条款,首先我们必须承认的一点是:<br><strong>C++是一门复杂的多范式编程语言, 它不仅仅是一门语言</strong></p><p>承认这一点, 使得我们明确: C++ 是一个语言联邦, 不能简单地依靠某种语言规范去学习认识它<br><strong>而应该根据不同的范式情况, 去进行语言规范的转换, 从而编写高效的C++代码</strong></p><p>目前已经被承认的C++范式有以下几种:</p><ul><li>面向过程编程</li><li>基于对象编程</li><li>面向对象编程</li><li>泛型编程(Template)</li><li>函数式编程</li></ul><p>那么,我们根据此,可以将C++划分为以下几种子语言:</p><ol><li>C, (C++的基础)</li><li>Object-oriented C++, (支持面向对象范式)</li><li>Template C++, (模板编程, 扩充为泛型编程)</li><li>STL (Standard Template Library)</li></ol><p>根据上面的约定, 我们在使用不同的子部分时, 则需要遵守不同的约定.(理所当然, 对吧 ? ).<br>举个简单的例子:(EffC++中精巧的例子)</p><blockquote><p>Q: 函数调用是一门编程语言不可缺少的部分,那么以何种方式进行参数传递?</p></blockquote><blockquote><p>A: 我们根据不同的联邦进行划分: </p></blockquote><ol><li>C部分中,我们更倾向于 <em>pass by value</em></li><li>Object-oriented 部分中, 我们倾向于 <em>pass by reference to const</em></li><li>Template C++ 部分中, 我们一定要用 <em>pass by reference to const</em> </li><li>STL 部分中, (因为下面基于指针实现), 倾向于 <em>pass by value</em></li></ol><p>上面只是一个小的例子, 但是却反映出了”<strong>将C++视为一个语言联邦思想</strong>“的重要性</p><blockquote><p>请记住：</p><ul><li>C++高效编程守则视状况而变化， 取决于你使用C++哪一部分</li></ul></blockquote><h2 id="Item-02-Prefer-consts-enums-inlines-to-define"><a href="#Item-02-Prefer-consts-enums-inlines-to-define" class="headerlink" title="Item 02: Prefer consts, enums, inlines to #define"></a>Item 02: Prefer consts, enums, inlines to #define</h2><p>C++在1990s时, 的确只是作为C语言的扩展版, 增加了基于对象的内容,<br>也就是写不好C++,经常被人调侃的 <em>C with class</em><br>但是, 随着语言的发展与完善, C++ 已经成长为一门多范式编程语言, 而继承自C part的预处理器(CCP)<br>便显得有些”过时”了, (PS: 指有更好地实现方法)<br>作为现代C++, 我们要尽量减少对预处理器的依赖性, 因为其只是一个简单地文本替换器, 并非语言实现.</p><p>我们对于预处理器的依赖经常表现在下面几个方面:</p><ol><li>#define PI 3.1415 即常量整型变量的定义</li><li>#define max(a, b) (a) &gt; (b) ? a : b 即类函数宏, (PS: 这个max实现的有缺陷)</li></ol><p><1> 实际上是我们为了编程的方便而使用的方法, 减少了代码变更带来的review代价</1></p><p><2> 则是为了减少使用函数的开销， 执行任务短小的函数，开销十分浪费</2></p><p>但是，以今天的眼光来看(成书于2005年，都已显得“过时”)，我们应该对已作出如下改变：</p><h3 id="const-integeral-type"><a href="#const-integeral-type" class="headerlink" title="const integeral type"></a>const integeral type</h3><p>对于整型常量的设定，我们建议使用这样的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span></span><br><span class="line">#=&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pi = <span class="number">3.1415</span>;</span><br></pre></td></tr></table></figure><p>原因在于:<br>使用#define预处理器，只是进行简单的文本替换。PI并不能进入符号表。<br>无论是进行调试，还是其他操作都十分不方便，PI始终就没有出现过，作为变量来说不合理<br>(PS: 虽然说const为常量， 这只是编译器的约束，它仍然是可修改的变量)</p><p>即使我们使用<code>const type var</code> 替代 <code>#define VER VAL</code>，也不能完全解决我们的问题，<br>常见的还有下面两个要注意的要点：</p><ol><li>对于C-Style，极其建议使用<code>str::stirng</code>。<br>因为<code>const std::string str;</code> 等价于 <code>const char * const ptr;</code> </li><li><p>class中的变量都是与对象相关的， 如果我们在class中声明了const变量。<br>它会因为多个对象的存在，而产生多个实体。最好使用这样的手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> pi = <span class="number">3.1415</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就不会产生多份实体拷贝了</p></li></ol><p>下面要说的就是，关于类中static变量，C++11开始全面支持类内初始化<br>如果是不支持此特性的编译器，有两个办法：</p><ol><li>更换最新的编译器</li><li>使用类内声明，类外定义的手法</li></ol><p>比如这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> pi;        <span class="comment">// declaration</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cosnt <span class="keyword">static</span> Temp::pi = <span class="number">3.1415</span>;  <span class="comment">// defination</span></span><br></pre></td></tr></table></figure></p><p>而全面支持C++11的编译器可以这样使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> pi = <span class="number">3.1415</span>;        <span class="comment">// declaration</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DO NOT assign to the static variable; </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> Temp::pi;  <span class="comment">// defination</span></span><br></pre></td></tr></table></figure></p><p>这样就可以比较合理的解决不能类内初始化了。<br>但是，我们其实还可以使用<strong>enum hack</strong>的手法来处理</p><blockquote><p>enum hack</p></blockquote><blockquote><p>所谓“enum hack”指的是，使用赋值的枚举变量来模拟类内初始化<br>更关键的是，<strong>enum hack的行为和预处理器类似</strong>，在某些情况下，需要预处理器的功能时，可以通过这样的手法来实现。</p></blockquote><p>那么，enum hack如何实现呢？ 这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;PI = <span class="number">3.1415</span>&#125;;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>此时为2005年，还没有enum class ( C++11 ), </em></p><p><strong>enum hack</strong>有这样两个优点：</p><ol><li>它一定不会浪费内存空间，同预处理器一样，不会进入符号表</li><li>实用主义来讲，大量代码用到enum hack。 <em>说的就是你TMP（Template MetaProgramming）</em></li></ol><h3 id="define-gt-Macros"><a href="#define-gt-Macros" class="headerlink" title="#define =&gt; Macros"></a>#define =&gt; Macros</h3><p>使用预处理器的另一个重要场合就是: 减少函数开销的类函数宏 (getchar(  )的实现方式)</p><p>看着很美好，但是预处理器实现的类函数宏，经常是错误百出，各种各样的烦人。</p><p>就那上面那个例子来说吧：<br><strong>1. 起码每个变量加上括号，同时整体还要加上括号，每步运算也要加上括号</strong><br><strong>2. 更恶心的是，预处理器是文本替换，++， – 有多可怕用过的人都知道</strong></p><p>基于上面的原因，预处理器实现类函数宏，如今也是一种不良的手法。</p><p>使用现代C++，我们应该这样做：<code>inline template function</code></p><ol><li>使用<code>inline</code>是为了获得与类函数宏一样的高效，同时更获得了类型安全检查</li><li>使用<code>template</code>在于，我们并不知道参数类型，使用<code>const T &amp;</code>理所当然</li></ol><p>那么，就来看一个例子吧：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (a) &gt; (b) ? a : b;</span></span><br><span class="line"></span><br><span class="line">#=&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> T &amp;max(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>inline template function</code>的手法，我们既获得了高效性，还得到了类型安全。<br>模板泛型的适用场景不一定够多，但inline的使用场景够够的了。</p><p>上面说了那么多，我们的目的<strong>并非是禁止使用预处理器</strong>，而是<strong>减少预处理器带来不可预料行为</strong><br>毕竟我们当前使用<code>#include &lt;file&gt;</code>导入，<code>#ifndef/#define/#endif</code>控制编译仍然重要。</p><blockquote><p>请记住：</p><ul><li>对于单纯变量，最好以const对象或enums替换#define</li><li>对于形似函数的宏（macros），最好改用inline函数替换#define</li></ul></blockquote><h2 id="Item-03-Use-const-whenever-possible"><a href="#Item-03-Use-const-whenever-possible" class="headerlink" title="Item 03: Use const whenever possible"></a>Item 03: Use const whenever possible</h2><p>在item 02 中，我们已经见识到const所带来的便利了。</p><p>现在就再来谈谈const，后面还会聊到它的。</p><p>关于const，我首先想要说说这两点：</p><ol><li>所谓const，只是编译器/程序员的“约束假定”，保证从编译器/程序员的方面不去修改<br>但是，实际上是可修改的。这点在后续关于const的讨论中很关键</li><li>const在星号左是底层const，修饰指向。在星号右是顶层const，修饰变量本身（引用。。）</li></ol><p>有了上面的基础后，我们再来聊聊const。</p><p>关于一般的内置类型使用const，我们就不再赘述了</p><p>重点来说说类中的const =&gt; const函数</p><h3 id="const-function"><a href="#const-function" class="headerlink" title="const function"></a>const function</h3><p>提到const函数，有这几个：函数参数，返回值，函数被const修饰。<br><strong>const函数，狭义上特指const的成员函数，表示我们并不会修改此对象，</strong></p><p>在这里我们要考虑的重要内容是：<strong>const属性可以进行重载</strong></p><p>我们在设计类的接口时，应该合理考虑到会遇到的参数类型，从而设计const及non-const版本<br>比如我们会遇到这样的场合：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> &amp;operastor[](<span class="keyword">char</span> *str);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="string">"hello ,world"</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这其中就使用了const版本的接口。<br>若使用const版本时，返回值并非<code>pass by reference to const</code> 而是 <code>pass by reference</code><br>就会出现，const对象被意外修改的情况。<br>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> textString <span class="title">t</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *ch = &amp;t[<span class="number">0</span>];</span><br><span class="line">*ch = <span class="string">'J'</span>;   #=&gt; <span class="keyword">const</span> object t has been modified</span><br></pre></td></tr></table></figure><p>滥用cosnt，并不会对导致出现成员函数异常，但是会出现这样的错误。</p><p>这就涉及到<em>bitwise constness</em> 与 <em>logical constness</em></p><p>上面出现的问题本质是：<strong>在bitwise constness中改变了指针的指向，未改变指针</strong><br><strong>已经违背了logical constness，但是在编译器的bitwise constness层面上非错误</strong></p><p><strong>上面是个隐式的错误接口开放，const内部，结果导致了非const接口开放，破坏了类的常量性质</strong></p><p>对于， 这种问题的解法便是：<strong>使用mutable来将成员常量性分离</strong><br>即使在const对象的内部，mutable类型的变量仍然是可以被修改的！</p><h3 id="const-and-non-const"><a href="#const-and-non-const" class="headerlink" title="const and non-const"></a>const and non-const</h3><p>在提供多个版本接口时，不可避免的是，代码的相似性与重复劳动(对程序员)<br>我们的建议就是：使用已经实现的部分来管控未实现的部分。<br>针对const与non-const要求是：<strong>使用const来实现non-const</strong></p><p>原因便是：<strong>const版本做出承诺不修改对象，non-const可以在调用const时，正常工作</strong><br><strong>反之不可，因为non-const不承诺，我们用non-const来减少const的重复工作没有承诺，原来保证不变的对象可能发生改变。</strong></p><p><strong>而且： 因为我们在此处已经确定转型是安全的，所以使用<code>static_cast&lt;&gt;</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> str[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;</span><br><span class="line">    (<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Temp &amp;&gt;(*<span class="keyword">this</span>)[pos]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，这种消除重复的手法，还可以用于：使用operator==() 实现 operator!=()之类</p><p>总之，const是个非常灵活而又实用的东西，多多使用，多多发掘。</p><blockquote><p>请记住：</p><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本身</li><li>编译器强制实施bitwise constness，但编写程序应该使用“概念上的常量性”，即注意logical constness的问题，以及mutable的使用</li><li>当const和non-const成员函数有着实质上的等价实现时，令non-const版本调用const版本实现可以避免代码重复</li></ul></blockquote><h2 id="Item-04：Make-sure-that-objects-are-initialized-before-thre’re-used"><a href="#Item-04：Make-sure-that-objects-are-initialized-before-thre’re-used" class="headerlink" title="Item 04：Make sure that objects are initialized before thre’re used"></a>Item 04：Make sure that objects are initialized before thre’re used</h2><p><em>这一部分其实是一个常识，没错，就是使用前初始化！</em></p><p>简单的来说，按照下面几个步骤走下来，一定可以保证正确性和合理性：</p><ol><li>内置类型，手动初始化</li><li>自定义类类型，依靠构造函数初始化，其中一定要注意初始化列表的问题</li><li>处理好初始化次序不定的情况(不同编译单元中的non-local static 变量)</li></ol><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>其中内置类型的初始化，你我也知道 —- 默认初始化(与值初始化区分)。都是未定义的值(..)</p><h3 id="自定义类类型"><a href="#自定义类类型" class="headerlink" title="自定义类类型"></a>自定义类类型</h3><p>我们强调一下构造函数，来看看下面两种形式的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Text() = <span class="keyword">default</span>;</span><br><span class="line">    Text(<span class="built_in">std</span>::<span class="built_in">string</span> text, <span class="built_in">std</span>::<span class="built_in">string</span> author, <span class="keyword">int</span> num, <span class="keyword">double</span> price);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> textName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> authorName;</span><br><span class="line">    <span class="keyword">int</span>     textNum;</span><br><span class="line">    <span class="keyword">double</span>  textPrice;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ver.1</span></span><br><span class="line">Text(<span class="built_in">std</span>::<span class="built_in">string</span> text, <span class="built_in">std</span>::<span class="built_in">string</span> author, <span class="keyword">int</span> num, <span class="keyword">double</span> price)</span><br><span class="line">&#123;</span><br><span class="line">    textName = text;</span><br><span class="line">    authorName = author;</span><br><span class="line">    textNum = num;</span><br><span class="line">    textPrice = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ver.2</span></span><br><span class="line">Text(<span class="built_in">std</span>::<span class="built_in">string</span> text, <span class="built_in">std</span>::<span class="built_in">string</span> author, <span class="keyword">int</span> num, <span class="keyword">double</span> price)</span><br><span class="line">: textName(text), authorName(author), textNum(num), textPrice(price)</span><br><span class="line">&#123; ; &#125;</span><br></pre></td></tr></table></figure></p><p>ver.1 看上去更像我们传统意义上的初始化，<strong>其实是假的，这个叫赋值</strong></p><p>ver.2 则是真正意义上的初始化。</p><p>有这样几个点是要了解的：</p><ol><li>C++是为数不多严格区分赋值与初始化概念的语言的(可能是我见得少)</li><li>C++中初始化，发生在赋值之前，或者说在构造函数值之前</li><li><strong>我们墙裂建议使用member initialization list的形式初始化成员</strong></li></ol><p>主要出于下面的考量：</p><ol><li>初始化(拷贝构造)和default构造 + 赋值的开销一目了然，肯定是拷贝构造低</li><li>即使自定义类型的拷贝构造和 defauilt + 赋值开销近似，但为了一致性</li><li>如果有的类，真的丧心病狂，没有default构造了，玩锤子ver.1</li></ol><p>接下来，我们要注意的是初始化的顺序：<br><strong>1. 函数调用上，初始化在构造之前，base-class在deriver-class之前</strong><br><strong>2. 具体成员与类内声明顺序相关，与list顺序无关，所以，比要互相依赖初始化</strong></p><p>除了某些特殊情况：比如从文件，数据库读入东西时，使用ver.1形式。<br>支持，第二个过程，自定义类类型的初始化也确定了</p><h3 id="不同编译单元的non-local-static-varible"><a href="#不同编译单元的non-local-static-varible" class="headerlink" title="不同编译单元的non-local static varible"></a>不同编译单元的non-local static varible</h3><p>最恶心人的便是：不同编译单元中的non-local static变量的初始化顺序，恶心的要死<br><strong>可以说是，根本无法确定这样的顺序，因为不同的人，在不同时刻编写的代码</strong><br><strong>根本无法确定初始化次序，这是个无解的难题</strong></p><p>有句话说得好，，<em>办法总比困难多</em><br>借用《Design pattern》 中单例模式的讨论，我们可以使用技巧规避这个问题</p><p>先来补点基础：<br><strong>function内部的static变量叫做local static var，因为他一定经历了初始化，有定义式</strong><br><strong>其他的叫做non-local static var，如namespace，global，file中的，都是从定义出产生，到程序结束消亡</strong></p><p><strong>关键就是，你使用这样的变量时，他未定义，凉了。。。</strong><br>我们的思路便是: 将使用特定的non-local static var转换为local static var使用</p><p>也就是说，采用这样的手法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSyatem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Filesystem &amp;<span class="title">get_filesystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Filesystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory &amp;<span class="title">get_dir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Directory dir;</span><br><span class="line">    <span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file3.cc</span></span><br><span class="line"><span class="comment">// Now the filesystem, directory object must be initialized</span></span><br><span class="line">Filesystem global_fs = get_filesystem();</span><br><span class="line">Directory global_dir = get_dir();</span><br></pre></td></tr></table></figure></p><p>PS: 一个小问题，关于竞争状态（Race Condition), 只要是non-const的static<br><strong>无论是local，或non-local，都会引发竞争状态</strong><br>解法：<strong>单线程阶段，完全初始化完成即可避免</strong></p><p>总之，只要完整按照上面的三步走，就可以基本保证适用对象前初始化的问题！</p><blockquote><p>请记住：</p><ul><li>为内置类型对象执行手工初始化，因为C++不保证初始化他们</li><li>构造函数最好使用成员初始化列表，初始化列表列出的成员变量，其排列次序应该和他们在class中的声明明次序相同</li><li>为免除”跨编译单元之初始化次序”问题， 请以local static对象替换non-local static对象</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      Chapter I 让自己习惯C++
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="EffectiveC++" scheme="http://evil-crow.github.io/tags/EffectiveC/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试系列(一)</title>
    <link href="http://evil-crow.github.io/2018/08/08/GDB/multprocess/"/>
    <id>http://evil-crow.github.io/2018/08/08/GDB/multprocess/</id>
    <published>2018-08-08T06:34:00.000Z</published>
    <updated>2018-08-08T07:43:23.727Z</updated>
    
    <content type="html"><![CDATA[<p><em>摘要里面也说了,既然GDB功能如此强大,毋庸置疑.它的学习曲线也就不是一般的麻烦</em></p><p><em>这里我们暂时不去追究它的细节,而是就事论事,对于这种工具,需求驱动的效率会更高一点.</em></p><p><em>那么,就近入主题吧,Mission Start ~</em></p><p><del>起因是学妹在写myshell的练习时,遇到了奇怪的问题, 我都忘的差不多了…</del></p><p>问题: <strong>管道命令,第一次输出无效,之后的输出全部有效</strong></p><p>而且此前已经查实,参数的解析是没有问题的.这种束手无策的时候,不用多想, GDB上去怼.</p><p><a href="https://github.com/XiyouLinuxGroup-2018-Summer/TeamD/blob/master/Code/%E8%B5%96%E9%91%AB/%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A0/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/6.c" target="_blank" rel="noopener">源代码 &gt;&gt;</a></p><p>恐怕以后链接失效, 在这里贴出要重点调试的代码…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid2;</span><br><span class="line"><span class="keyword">int</span> fd2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pid2=fork())&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[31m 进程２创建错误\n\033[0m"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((find(arg[<span class="number">0</span>]))==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[31m %s：找不到命令\n\033[0m"</span>,arg[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fd2=open(<span class="string">"/tmp/newfile"</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">dup2(fd2,<span class="number">1</span>);</span><br><span class="line">execvp(arg[<span class="number">0</span>],arg);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">waitpid(pid2,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((find(argnext[<span class="number">0</span>]))==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[31m %s：找不到子命令\n\033[0m"</span>,argnext[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fd2=open(<span class="string">"/tmp/newfile"</span>,O_RDONLY);</span><br><span class="line">dup2(fd2,<span class="number">0</span>);</span><br><span class="line">execvp(argnext[<span class="number">0</span>],argnext);</span><br><span class="line"><span class="keyword">if</span>(remove(<span class="string">"/tmp/newfile"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"remove error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><em>这个代码与我们平时写的玩具有不同之处在于, 它是multprocess的(多进程的)</em></p><p><strong>那么,我们就要注意如何使用GDB调试多进程的程序了</strong></p><blockquote><p>GDB在调试多进程符方面还是又不错的性能的,(多线程就不表了)</p></blockquote><blockquote><p>其中涉及的主要参数是:</p></blockquote><blockquote><p>follow-fork-mode , 表示追踪进程的模式,有parent, child可选</p></blockquote><blockquote><p>detach-on-fork , 表示是否分离子进程, 有off, on可选</p></blockquote><blockquote><p>info inferiors , 查看目前的进程表</p></blockquote><blockquote><p>inferiors ID , 可以切换到对应进程,(注意: 是GDB划分的ID, 并非进程的PID)</p></blockquote><p>基本流程:</p><ul><li><p>设置追踪模式(子进程/父进程), 分离方式(分离/不分离)</p></li><li><p>调试程序 { gdb execulate }</p></li><li><p>标记断点 { b | breakpoint } line</p></li><li><p>运行程序 { r / run }</p></li><li><p>切换进程 { inferiors ID }</p></li></ul><p>如下图:</p><p>我们终于找到了Bug所在.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/gdb_multprocess1.jpg" alt="设置属性"></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/gdb_multprocess2.jpg" alt="切换进程"></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/gdb_multprocess3.jpg" alt="收到错误信号"></p><p><em>那么,问题找到了,仅下来的Bug就好好改吧</em></p><p><strong>WARNING: 恰当的例子,真的可遇不可求, 我们应该用他们好好练手</strong> </p><p><strong>如果大家有不错的例子,也可以私戳我, 啊, 你说啥, 线程的调试?等学妹这一周的Bug吧</strong></p>]]></content>
    
    <summary type="html">
    
      众所周知,GDB是一个强大的调试工具.这些没用的吹逼话就不多说了.GDB好不好用,谁用了谁知道,不过好的Bug真的是可遇不可求.每一个Bug都是上辈子的缘分, 呸, 胡侃罢了..
    
    </summary>
    
      <category term="Tools" scheme="http://evil-crow.github.io/categories/Tools/"/>
    
    
      <category term="GDB" scheme="http://evil-crow.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux的常用配置</title>
    <link href="http://evil-crow.github.io/2018/07/31/Evilcrow/linux_setting/"/>
    <id>http://evil-crow.github.io/2018/07/31/Evilcrow/linux_setting/</id>
    <published>2018-07-31T08:14:00.000Z</published>
    <updated>2018-07-31T08:29:43.973Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是一篇自己给自己看的使用指南, 还是认真的记录一下比较好</em></p><h2 id="一-基础内容"><a href="#一-基础内容" class="headerlink" title="一, 基础内容"></a>一, 基础内容</h2><p>这一部分是每一个Linux安装成功之后,所要进行的合理操作</p><p>这里,针对我的机型,我用Fedora来举例子, 当然基本上是通用的redhat配置</p><h3 id="1-添加自己的sudo权限"><a href="#1-添加自己的sudo权限" class="headerlink" title="1. 添加自己的sudo权限"></a>1. 添加自己的sudo权限</h3><p>作为Redhat系的传统,不提供sudo权限的添加,需要自己去进行修改.</p><p>Debian系设置好sudo权限,之后自行passwd</p><p>具体操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/sudoers</span><br><span class="line">/ALL</span><br><span class="line">(多按几次n, 找到ALL,有root的地方)</span><br><span class="line">a</span><br><span class="line">(仿照上面进行自己用户名的添加)</span><br><span class="line">Esc -&gt; :wq!</span><br><span class="line"></span><br><span class="line">退出终端(刷新一下, OK!)</span><br></pre></td></tr></table></figure><h3 id="2-添加合理的软件源"><a href="#2-添加合理的软件源" class="headerlink" title="2. 添加合理的软件源"></a>2. 添加合理的软件源</h3><p>作为Fedora用户,着重推荐这两个源, FDZH以及RPMFusion的源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://repo.fdzh.org/FZUG/free/27/x86_64/noarch/fzug-release-27-0.2.noarch.rpm</span><br><span class="line">RPM Fusion的源需要去官网下载repo,之后使用rpm安装即可</span><br></pre></td></tr></table></figure><p><a href="https://rpmfusion.org" target="_blank" rel="noopener">RPMFusion&gt;&gt;</a></p><p><a href="https://github.com/FZUG/repo/wiki/添加-FZUG-源" target="_blank" rel="noopener">FDZH&gt;&gt;</a></p><p>其他的源,根据自己的使用情况进行配置</p><p>添加好源之后,进行软件源的获取缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf makecache</span><br></pre></td></tr></table></figure><h3 id="3-快捷键的设置"><a href="#3-快捷键的设置" class="headerlink" title="3. 快捷键的设置"></a>3. 快捷键的设置</h3><p>此处,对于gnome可以按照这样的顺序:</p><ul><li>setting -&gt; device -&gt; keyboard -&gt; add shortcuts</li></ul><p>对于KDE,可以这样来设置</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/kde_shortcuts.png" alt="setting shortcuts"></p><h3 id="4-关闭神油SElinux"><a href="#4-关闭神油SElinux" class="headerlink" title="4. 关闭神油SElinux"></a>4. 关闭神油SElinux</h3><p>我基本也没用过, 反正就是个神油玩意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/selinux/config</span><br><span class="line"><span class="string">"SELINUX=enabled"</span> -&gt; <span class="string">"SELINUX=disabled"</span></span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure><h3 id="5-善用alias"><a href="#5-善用alias" class="headerlink" title="5. 善用alias"></a>5. 善用alias</h3><p>在~/.bashrc中善于添加命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> aliyun_Crow=<span class="string">'ssh Crow@ww.xxx.yyy.zzz'</span></span><br></pre></td></tr></table></figure><p>上面的命令别名配上,ssh免密码登录简直不要太nice</p><p>另外就是自己写的几个小脚本,在其他地方也使用了,做些合理性判断,挺好用的</p><h2 id="二-KDE的一些设置"><a href="#二-KDE的一些设置" class="headerlink" title="二, KDE的一些设置"></a>二, KDE的一些设置</h2><blockquote><p>目前最期待KDE plasma 5.13了,终于可以方便的改屏保,加速进入桌面的速度,减少内存开销</p></blockquote><blockquote><p>不过说好的6.12正式版推送,Fedora目前也没有啥动静,心累.(不过一段时间内,是不会更新28了)</p></blockquote><blockquote><p>(还好,说这话的时候,29的Alpha版还没出,差点打脸)</p></blockquote><p>这部分就是专门针对于KDE的设置了,用gnome的同学,我可能提供不了多少帮助了</p><p>不过有两点:</p><ol><li><p>gnome使用 <code>sudo dnf install gnome-tweak-tool</code> 超级好用</p></li><li><p>gnome下IDE字体显示还是很好看的,KDE简直看不了,逼得我用Vim + VSCode</p></li></ol><p>下面是对于KDE的完整配置方案,包括了Konsole呦(就那个初始丑的不像样子的终端)</p><p>… (挖个坑,保证一周内填上去)</p><hr><p>update: July 31, 2018 11:33 AM</p><p><del>好吧,汪汪汪…</del></p><p>首先,我们从setting界面来入手</p><h3 id="Appearance"><a href="#Appearance" class="headerlink" title="Appearance"></a>Appearance</h3><h4 id="Workspce-Theme"><a href="#Workspce-Theme" class="headerlink" title="Workspce Theme"></a>Workspce Theme</h4><h5 id="Look-And-Feel"><a href="#Look-And-Feel" class="headerlink" title="Look And Feel"></a>Look And Feel</h5><p>使用Fedora主题, Breeze(<em>emmm,其实区别不大,但是我们毕竟是使用Fedora嘛</em>),</p><p>Breeze Dark则是暗色调, 个人不习惯.</p><p>这一处,Fedora基本符合我的口味,主要影响plasma, 颜色主题, 窗口和鼠标主题,</p><p>,喜欢的话,右下角还有 <code>Get New Looks...</code>按钮,可以自行挑选,商店就那样子…</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/LookAndFeel.png" alt="Look And Feel"></p><h5 id="Desktop-Theme"><a href="#Desktop-Theme" class="headerlink" title="Desktop Theme"></a>Desktop Theme</h5><p>这部分设置主要体现在任务栏的显示上. 见下:</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/air.png" alt="Air"></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/dark.png" alt="Dark"></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/breeze.png" alt="breeze"></p><h5 id="Cursor-Theme"><a href="#Cursor-Theme" class="headerlink" title="Cursor Theme"></a>Cursor Theme</h5><p>这部分设置主要是鼠标指针的设置,自行适配即可.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/CursorTheme.png" alt="Cursor Theme"></p><h5 id="Splash-Screen"><a href="#Splash-Screen" class="headerlink" title="Splash Screen"></a>Splash Screen</h5><p>这个很简单,就是开机进入的动画</p><p><em>不是开机的壁纸,仅仅只是输入密码后,KDE Loading期间显示的东西.</em></p><p><em>但是,5.13听说会加速进入桌面的时间…</em></p><h4 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h4><p>此处没有子选项,而且变化不大.这里的颜色选项.主要是用来控制Dialog的色彩的.还可以自行再进行编辑</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/ColorScheme.png" alt="Color Scheme"></p><h4 id="Fonts"><a href="#Fonts" class="headerlink" title="Fonts"></a>Fonts</h4><p>不过说了,<strong>就是控制字体的地方</strong></p><p>其中主要影响的是: </p><ul><li><p><strong>General(Software中的字体)</strong></p></li><li><p><strong>Small(鼠标放上去的浮动字体)</strong></p></li><li><p><strong>Toolbar(工具栏字体)</strong></p></li><li><p><strong>Menu(菜单栏字体)</strong></p></li><li><p><strong>Window title(窗口标题字体)</strong></p></li></ul><p><strong>Warning:</strong> 虽然我是KDE粉丝,但是<strong>KDE的字体真的难看到模糊,尤其是软件中,IDEA,Pychrm,CLion</strong></p><p>这些都是重灾区,反观,不套用系统字体的编辑器玩的好好的,<strong>Consolas,在KDE中默认渲染不是等宽</strong></p><p><em>不过也不是没有办法,我们后面再聊</em></p><p><em>我的字体设置也不是很好看,但是还凑合能看,诸君可做参考</em></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/Fonts.png" alt="Fonts"></p><h4 id="Icons"><a href="#Icons" class="headerlink" title="Icons"></a>Icons</h4><p>简单粗暴,就是进行图标的设置,怎么说呢,这个看个人喜好了.推荐去: </p><ol><li><p><a href="https://store.kde.org/" target="_blank" rel="noopener">KDE Store &gt;&gt;</a></p></li><li><p><a href="https://www.gnome-look.org/browse/ord/latest/" target="_blank" rel="noopener">Gnome-look &gt;&gt;</a></p></li></ol><p>虽然两个不是同一家,这些个性化内容都是通用的.</p><p>个人比较推荐 <a href="https://store.kde.org/p/1178976/" target="_blank" rel="noopener">plane&gt;&gt;</a> 这一套图标的,(<em>VSC很好看,除了chrome中间的空洞勉强接受,其他完美</em>)</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/WindowsDescl.png" alt="Window Decorations"></p><h4 id="Application-Style"><a href="#Application-Style" class="headerlink" title="Application Style"></a>Application Style</h4><p>其中还有另外三个子选项:</p><h5 id="Widget-Style"><a href="#Widget-Style" class="headerlink" title="Widget Style"></a>Widget Style</h5><h5 id="Window-Decorations"><a href="#Window-Decorations" class="headerlink" title="Window Decorations"></a>Window Decorations</h5><h5 id="GNOME-Application-Style-GTK"><a href="#GNOME-Application-Style-GTK" class="headerlink" title="GNOME Application Style(GTK)"></a>GNOME Application Style(GTK)</h5><p>第一个没啥意思,基本不管,第三个是处理GTK系列应用程序在KDE上的应用风格(有需要的童鞋摸索一下)</p><p>我一般用原生的KDE应用,不需要GTK应用,\滑稽.</p><p>我们重点来看第二个,Window Decoration</p><p><strong>主要是用来进行窗口按钮图案,扁平化风格的.同时,要十分注意右下角的,Border Size谁用谁知道</strong></p><p>我十分推荐这么几款: </p><p>Breezemite(模仿Mac OS X的红绿灯)</p><p>Winux (Win10一模一样的窗口风格)</p><p>PlainJane(是因为我的红绿灯有问题,但是简洁好看)</p><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p>这里不是我们配置的重点,所以大致挑一些来说.大部分维持默认即可</p><h4 id="Window-Management"><a href="#Window-Management" class="headerlink" title="Window Management"></a>Window Management</h4><h5 id="Task-Switcher"><a href="#Task-Switcher" class="headerlink" title="Task Switcher"></a>Task Switcher</h5><p>任务切换者,是在进行任务切换的时候.选择的方式,有多种.推荐<code>Flip Switch</code>,不过还是看个人喜好了</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/TaskSwitcher.png" alt="Task Switcher"></p><h4 id="Startup-and-Shutdown"><a href="#Startup-and-Shutdown" class="headerlink" title="Startup and Shutdown"></a>Startup and Shutdown</h4><h5 id="Login-Screen-SDDM"><a href="#Login-Screen-SDDM" class="headerlink" title="Login Screen(SDDM)"></a>Login Screen(SDDM)</h5><p>选择登录界面,其中比较重要的就是,选择screen之后,可以自行设置Backgroud.</p><h5 id="Autostart"><a href="#Autostart" class="headerlink" title="Autostart"></a>Autostart</h5><p>开机自启动的软件,不多说,latte神器,这个我们后面会提到.</p><h4 id="啊啊啊啊啊啊啊-找到了"><a href="#啊啊啊啊啊啊啊-找到了" class="headerlink" title="啊啊啊啊啊啊啊 ! ! ! 找到了 !"></a>啊啊啊啊啊啊啊 ! ! ! 找到了 !</h4><p>如何设置锁屏壁纸,在<code>Desktop Behavior -&gt; Screen Locking</code>中修改即可</p><h4 id="Double-click-open-file"><a href="#Double-click-open-file" class="headerlink" title="Double-click open file"></a>Double-click open file</h4><p>很多上手KDE国人,最不适应的一点就是: 单击打开文件,点击 + 号进行选中</p><p>那么,没有办法解决吗? 有的,见下图</p><p><code>设备管理 -&gt; 鼠标设置 -&gt; 一般设置 -&gt; icons,图标设置(包含打开方式)</code></p><p><em>KDE的基础配置差不多这么多,还有很多等待我们去发掘,如有其他有意思的设置,可以分享出来</em></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/OpenFIle.png" alt="Double-click to Open file"></p><h2 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h2><p>好了,重中之重,软件的配置肯定是必不可少的了.</p><p>下面会介绍在生产方面以及其他方面高效的工具了</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>不多说了,”编辑器之神”不是盖得,很好用.</p><p>这里推荐一个Vim配置,超厉害,还集成了YouCompleteMe的配置,爽到.</p><p>其中目前尚未补完README,估计是个大坑,地址在此: <a href="https://github.com/Evil-crow/Crow-Vim" target="_blank" rel="noopener">Crow-Vim &gt;&gt;</a></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/Vim.png" alt="Vim"></p><h3 id="gcc套件"><a href="#gcc套件" class="headerlink" title="gcc套件"></a>gcc套件</h3><p>虽然Linux平台上,默认使用GNU C Compiler套件包括(gcc, g++, gdb等),试试clang也是不错的</p><p>尤其是clang-format,超好用,另外推荐一个二进制包集合<a href="http://www.gnu.org/software/binutils/" target="_blank" rel="noopener">Binutils &gt;&gt;</a></p><h3 id="Google-chrome"><a href="#Google-chrome" class="headerlink" title="Google-chrome"></a>Google-chrome</h3><p>新时代的超强浏览器,超爽,主要和VPN契合度也比较高.好用,而且Google 的Cloud Service特别厉害</p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>虽然宇宙第一IDE–Visual Studio已经改名上了Mac OS X.不过最近还没有登录Linux平台的想法</p><p>让小弟VSC来试试水,超好用,推荐插件:</p><ul><li>C++ Intellisense (补全神器)</li><li>C/C++ (提供语言支持,可以进行静态语法分析)</li><li>One Monokai (变体Monokai,超好看)</li><li>VSCode Great Icons (好看的Icons图标)</li><li>Ruby Solargraph (提供Ruby补全,等着吧,Ruby劳资会回来的,不过可能上RM)</li></ul><p><img src="http://p8pmsq2a4.bkt.clouddn.com/vscode.png" alt="VS Code"></p><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>说是Github出的新一代编辑器,不过目前貌似也就只是写前端舒服一点(Ruby会捡回来,前端,口可口可)</p><p>(说不定就用WebStorm去了)</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/atom.png" alt="Atom"></p><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h3><p>使用时间很短,因为维护不积极,心累.已弃之.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/st.png" alt="Sublime Text"></p><h3 id="Qt-Creator"><a href="#Qt-Creator" class="headerlink" title="Qt Creator"></a>Qt Creator</h3><p>没什么多说的,C++ Qt GUI的IDE, 写C++鸡肋一点,但是写Qt很强,图形界面做的也比较好看</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/Qt.png" alt="Qt Cteator"></p><h3 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h3><p>除VS以外的王牌C++IDE,个人审美倾向于CLion. 不过前面提到过KDE字体有问题</p><p><strong>曲线救国: 从Win,或者其他地方export正常的setting.jar,在这里import进行</strong></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/CLion.png" alt="CLion"></p><h3 id="Haroopad"><a href="#Haroopad" class="headerlink" title="Haroopad"></a>Haroopad</h3><p>我见过的有史以来的最好的MarkDown编辑器,支持:</p><ul><li>html/css嵌套</li><li>mathjax的支持</li><li>多种theme</li><li>语法高亮</li></ul><p>简单地说,解释能力强,Markdown标记支持完善,同时颜值高 <a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">Haroopad &gt;&gt;</a></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/Haroopad.png" alt="Haroopad"></p><h3 id="netease-cloud-music"><a href="#netease-cloud-music" class="headerlink" title="netease-cloud-music"></a>netease-cloud-music</h3><p>超好用的网易云音乐,Fedora27目前不支持,但是github上有deb封包转化的rpm包</p><p><em>有点小问题,不过无伤大雅</em></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/netease-cloud.png" alt="netease-cloud-music"></p><h3 id="Shadowsocks-qt5"><a href="#Shadowsocks-qt5" class="headerlink" title="Shadowsocks-qt5"></a>Shadowsocks-qt5</h3><p>shadowsocks的话题不多说,仅仅介绍这个好看的客户端,C++Qt编写.</p><p>好看,快捷,其中存在一个问题: 当libbortan库指定版本不存在时, </p><p><strong>一般是库版本更新太快,重新做一个软链接,程序正常启动,否则会找不到链接库而启动失败</strong></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/ss-qt5.png" alt="Shdowsocks-qt5"></p><h3 id="fcitx小企鹅输入法"><a href="#fcitx小企鹅输入法" class="headerlink" title="fcitx小企鹅输入法"></a>fcitx小企鹅输入法</h3><p>fcitx只是一个框架引擎, 它可以搭载任何输入法, 我们要推荐的就是<strong>Rime,中州韵</strong></p><p>具体的可以访问官网,基本是这样子. <a href="https://www.baidu.com/link?url=-G25PobK8KLfBGkeuSSuWSpQmjzNqFTVj20t02l6Anu&amp;wd=&amp;eqid=99014f4700010abf000000035b6017de" target="_blank" rel="noopener">Rime &gt;&gt;</a></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/fcitx.png" alt="Fcitx-rime"></p><h3 id="文字编辑"><a href="#文字编辑" class="headerlink" title="文字编辑"></a>文字编辑</h3><p>大家可以使用Linux版的WPS,<em>我一般就切系统了…</em></p><h3 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h3><p>要想写C/C++事半功倍,必须了解（终端使用的工具）</p><h3 id="IntelliJ-IDEA／RubyMime等"><a href="#IntelliJ-IDEA／RubyMime等" class="headerlink" title="IntelliJ IDEA／RubyMime等"></a>IntelliJ IDEA／RubyMime等</h3><p>同CLion,主攻语言不同罢了,所以功能有差异,风格近似</p><h3 id="Latte-Dock"><a href="#Latte-Dock" class="headerlink" title="Latte Dock"></a>Latte Dock</h3><p>KDE专属Dock,甩什么<code>dash-to-dock</code>, <code>cairo-dock</code>十八条街.</p><p>原生支持wayland,Fedora适性也是没问题的,超级好看兼好用</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/latte.png" alt="latte"></p><hr><p><em>差不多所了,这一次的介绍就到此,我们有机会下次再补充</em></p><p><em>估计差不多了</em></p><p><em>有钱了,上Mac OS X. 当然KDE仍然是个好桌面,继续用下去</em></p><p>update: July 31, 2018 4:13 PM</p>]]></content>
    
    <summary type="html">
    
      用了这么久的Linux,也稍稍记录一下自己的配置吧,以免以后需要
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://evil-crow.github.io/categories/Unix-Linux/"/>
    
      <category term="EvilCrow" scheme="http://evil-crow.github.io/categories/Unix-Linux/EvilCrow/"/>
    
    
  </entry>
  
  <entry>
    <title>关于github绿点的常见问题--邮箱</title>
    <link href="http://evil-crow.github.io/2018/07/28/tools/git_tool/"/>
    <id>http://evil-crow.github.io/2018/07/28/tools/git_tool/</id>
    <published>2018-07-28T06:52:48.710Z</published>
    <updated>2018-07-28T06:52:42.593Z</updated>
    
    <content type="html"><![CDATA[<p><em>正如前面所说,今天遇到的问题就是github的绿点提交有问题,提交后并没有找到记录,很苦恼(不好装逼)</em></p><p><strong>首先,声明本文只是解决常见的问题,便是邮箱绑定不符的问题</strong></p><p>若是其他的问题, 请参考: <a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/" target="_blank" rel="noopener">传送门</a></p><p>解决方法有以下两种:</p><ol><li><p>进行新的邮箱绑定 如下图:</p><p> <img src="http://p8pmsq2a4.bkt.clouddn.com/git_name_email.png" alt=""></p><p> 先查看本地上进行git-push时的用户名和邮箱</p><p> <img src="http://p8pmsq2a4.bkt.clouddn.com/git_email_addition.png" alt=""></p><p> 可以通过添加多个邮箱的方式来追回记录</p></li><li><p>通过修改提交repo的方式来进行修改</p><p> 参考资料: <a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">git_help</a></p><p> 我们可以按照下面几步来进行操作</p><p> 一, 得到需要修改的commit的repo</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare https://github.com/user/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># user 为用户名</span></span><br><span class="line"><span class="comment"># repo为commit的仓库名</span></span><br></pre></td></tr></table></figure><p> 二, 使用script文件来进行repo的修改</p><p> sh文件内容如下:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git filter-branch --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">OLD_EMAIL="旧的Email地址"</span></span><br><span class="line"><span class="string">CORRECT_NAME="正确的用户名"</span></span><br><span class="line"><span class="string">CORRECT_EMAIL="正确的邮件地址"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_NAME="$CORRECT_NAME"</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">'</span> --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><p> 三, 使用脚本文件修改repo,重新提交</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repo.git</span><br><span class="line">bash script.sh</span><br><span class="line"></span><br><span class="line">git push --force --tags origin <span class="string">'refs/heads/*'</span>   <span class="comment"># 提交新修改的repo</span></span><br></pre></td></tr></table></figure><p> 四, 删除旧repo</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf repo.git</span><br></pre></td></tr></table></figure><p> 至此,便完成了追回提交记录的工作了.</p><p> 我们不得不感叹git作为一个版本控制工具的强大. git需要学习的东西还有很多.</p><p> 好(努)好(力)学(装)习(逼)</p><p> May 14, 2018 4:42 PM</p></li></ol>]]></content>
    
    <summary type="html">
    
      虽然最近的代码提交量少,但是还是有点干货的,但是上去一看,一直都是白的,真是让我好生苦恼,一番查询后找到了,解决方法,遂决定记录下来
    
    </summary>
    
      <category term="Tools" scheme="http://evil-crow.github.io/categories/Tools/"/>
    
    
      <category term="git" scheme="http://evil-crow.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>一个C语言指针的问题让我翻车</title>
    <link href="http://evil-crow.github.io/2018/07/28/C/two_level_array/"/>
    <id>http://evil-crow.github.io/2018/07/28/C/two_level_array/</id>
    <published>2018-07-28T02:33:00.000Z</published>
    <updated>2018-09-13T14:55:29.040Z</updated>
    
    <content type="html"><![CDATA[<p><em>现在真的是水的不行.一天天的,混不下去了,以后还是转业算了,当个肥宅最TM开心了</em></p><p>起因是小伙伴问了我一个需求实现: 函数中分配二维数组,返回值又已经被使用.</p><p>那么,<strong>自然而然就是指针的指针了,传参数三维指针(不然改个锤子)</strong></p><p>以往的代码实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">foo</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * <span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line"><span class="comment">// *(p + i) = (char *)malloc(sizeof(char) * n);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一般的二维数组的分配实现.</p><p>改用指针的指针传递,实际上至需要修改其中几个小地方就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> ***p, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*p) = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * <span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        (*p)[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了,不使用数组下标语法糖的形式,使用原生指针怎么写?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(*p + i) = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br></pre></td></tr></table></figure><p>而之前的错误形式是这样的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(**p + i) = ....       <span class="comment">// x</span></span><br></pre></td></tr></table></figure><p>究其本质,还是自大,不扎实.</p><p>不过想了一下,主要是这些没考虑到:</p><ul><li><p>简便写法 <code>(*p)[i]</code>, 没错,这样解引用就和原来一样了</p></li><li><p>为什么可以写成<code>*(*p + i)</code>？</p><p>同理，想想之前的下标语法糖，　这里只不过解引用了一下，还原为二维指针，然后进行移动</p><p>到了其他的位置，　当然是一个维度中，也就是<code>int a[m][n]</code>,m层次上的移动.从(*p)[0][n]到</p><p>(*p)[1][n], 之后解引用不就是对应一维指针,(指向字符串的),然后该咋来咋来,该咋用咋用.</p><p><strong>这其中有一个很重要的点: 数组名就是数组首元素地址,进行与整型的计算时,就是数组元素移动</strong></p><p><strong>我特么把</strong><code>*(*p + i)</code>和<code>*(&amp;(*p) + i)</code><strong>混淆了,后面的才是下一个指向二维数组的指针</strong></p><p><code>arr[index] = *(arr + index)</code><strong>这么简单的问题都凉了,GG算了</strong></p></li><li><p>为什么不能写<code>(**p + i)</code></p><p>为什么,这到是个锤子! <code>(char **)p =&gt; (char) **p</code>,此时加上整型的计算结果,是整型.</p><p>我们要获取可使用的指针,或去糖之后,都是有解引用的,这个简直不能看.而且此时<code>(**p) =&gt; char *</code></p><p>内存并没有分配,是未定义的值,求得的结果是nil +　index的值.. </p></li><li><p>另外再扯一点</p><p>事实上, 分清数组和指针,多看两眼</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello world"</span>;        <span class="comment">// str中保存了字符串字面量的地址</span></span><br><span class="line"><span class="keyword">char</span> sstr[<span class="number">100</span>] = <span class="string">"..."</span>;           <span class="comment">// sstr中存的就是值,sstr地址值与sstr[0]一致</span></span><br></pre></td></tr></table></figure></li></ul><p>好了,就说这么多吧.后面的自己在想想就好了.</p><p>有兴趣了,看看这几个就可以了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">12</span>];</span><br><span class="line">a[<span class="number">1</span>];        <span class="comment">// *(a + 1)</span></span><br><span class="line">&amp;a;          <span class="comment">// value: &amp;a == &amp;a[0]; &amp;a + 1 == &amp;a[0] + sizeof(int) * array_length;</span></span><br><span class="line">&amp;a+<span class="number">1</span>;        <span class="comment">// &amp;a[0] + sizeof(int) * array_length</span></span><br><span class="line">*(a+<span class="number">1</span>);      <span class="comment">// a[1], a=&gt; &amp;a[0], *(&amp;a[0] + 1) = a[1]</span></span><br><span class="line">(<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>)[<span class="number">-1</span>];  <span class="comment">//a[12];</span></span><br></pre></td></tr></table></figure><p><em>PS: 今天看到了很多牛皮的博客,牛皮的人怎么这么多,我有想了想我,唉,垃圾一个,脑子疼</em></p><p><em>我觉得,以后不能再把心情这种写在技术总结里面了,太消极,别人看见也不好</em></p><p><em>而且,我文笔并不好啊,就是个看漫画,打游戏的死肥宅.</em></p><p><strong>如果有机会了,准备写写漫画或者游戏的简评,</strong></p><p><em>再说吧,太远了,还是先弄好C++了.(逃</em></p><p>July 28, 2018 11:41 AM</p>]]></content>
    
    <summary type="html">
    
      翻车了,翻车了,指针又翻车了,还是代码写的少,混得多了.
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="hole" scheme="http://evil-crow.github.io/tags/hole/"/>
    
  </entry>
  
  <entry>
    <title>VI Function</title>
    <link href="http://evil-crow.github.io/2018/07/14/C++/C++Primer/C3P_VI/"/>
    <id>http://evil-crow.github.io/2018/07/14/C++/C++Primer/C3P_VI/</id>
    <published>2018-07-14T03:53:00.000Z</published>
    <updated>2018-09-13T14:52:29.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-返回数组的指针-引用"><a href="#一-返回数组的指针-引用" class="headerlink" title="一.返回数组的指针/引用"></a>一.返回数组的指针/引用</h2><p>有以下四种形式的操作:</p><h3 id="1-直接撸"><a href="#1-直接撸" class="headerlink" title="1.直接撸"></a>1.直接撸</h3><p>这个就需要扎实一点的C声明基础了,(PS: 不清楚的可以翻我之前写过的东西)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type (*/&amp; function(arguments))[<span class="built_in">array</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*func())[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="2-使用类型别名"><a href="#2-使用类型别名" class="headerlink" title="2.使用类型别名"></a>2.使用类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arr = <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">arr *<span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-使用后置类型-C-11新特性"><a href="#3-使用后置类型-C-11新特性" class="headerlink" title="3.使用后置类型 (C++11新特性)"></a>3.使用后置类型 (C++11新特性)</h3><p>这个特性十分好用, 前面使用auto做返回类型占位符, 后面使用’-&gt;’进行标识</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto func() -&gt; Type;</span><br><span class="line"></span><br><span class="line">auto func() -&gt; int(*)[10];</span><br></pre></td></tr></table></figure><p>不过要注意的是: 后面的Type,一定是类型,也就是说,没有变量名,复杂类型时好用,简单类型没必要</p><h3 id="4-使用decltype-类型说明符"><a href="#4-使用decltype-类型说明符" class="headerlink" title="4.使用decltype()类型说明符"></a>4.使用decltype()类型说明符</h3><p>既然上面用了auto, decltype肯定也是可以用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(variable) */&amp; func();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">descltype(a) *func();</span><br></pre></td></tr></table></figure><p><strong>不过,其中要注意的是,decltype(), 仅仅能获取类型,并不能转换为指针/引用,所以*/&amp;还是必不可少的</strong></p><p>下面通过一个例子来进行展示用法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数原型,返回数组的引用,且数组中包含10个string对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> (&amp;func())[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">using</span> str_arr = <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function">str_arr &amp;<span class="title">func_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">auto func__() -&gt; std::string (&amp;)[10];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(a) &amp;func___();</span><br></pre></td></tr></table></figure><p><strong>返回数组这样写,所以,返回函数指针大家也懂了吧,也就是 [ ] 与 ( ) 的区别</strong></p><p><em>当然, C/C++禁止返回函数类型(C++11目前不清楚),只能返回函数指针</em></p><h2 id="二-函数原型-签名-声明"><a href="#二-函数原型-签名-声明" class="headerlink" title="二,函数原型,签名,声明"></a>二,函数原型,签名,声明</h2><p>这其实是几个混淆的概念,不过也差不多,不同的叫法罢了</p><p>以后,规定代码习惯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;       <span class="comment">// 显式说明无参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;<span class="comment">// 隐式说明无参</span></span><br></pre></td></tr></table></figure><p>以后约定, <strong>除了函数定义,以外其他部分使用隐式无参说明</strong></p><p><em>不然太难看了</em></p><p>也就是下面这种结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Temp();</span><br><span class="line">~Temp();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Temp::Temp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-关于传参"><a href="#三-关于传参" class="headerlink" title="三, 关于传参"></a>三, 关于传参</h2><p><em>既然,我们写了C++, 就要写C++风格的C++, 毕竟不是竞赛选手, C风格的C++还是算了吧</em></p><p>有以下两个要求:</p><h3 id="1-尽量使用引用"><a href="#1-尽量使用引用" class="headerlink" title="1. 尽量使用引用"></a>1. 尽量使用引用</h3><p><em>区别于C中大量使用指针,C++建议摒弃指针,在尽可能的情况下,多用引用</em></p><ul><li><p>指针不安全,引用一定是经过初始化的</p></li><li><p>指针会引起大程度的拷贝,引用可以避免类类型,大数组的拷贝开销</p></li></ul><h3 id="2-尽量使用常量引用"><a href="#2-尽量使用常量引用" class="headerlink" title="2. 尽量使用常量引用"></a>2. 尽量使用常量引用</h3><p><em>将对常量的引用变量定义为普通引用是常见的错误,对没错, 是错误.</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag = is_string("Hello, world");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若为普通引用,则不能这样调用</span></span><br></pre></td></tr></table></figure><p><strong>其中,关键的就是,const在不同程度上赋值时的相容性,顶层无意义, 底层需注意</strong></p><p>上面只是其中一个问题, 另一方面,更重要的是:</p><p><strong>大型程序开发时, 多层函数嵌套,可能就传递了一个参数</strong></p><p>但是,上层是const string&amp;, 内层是普通引用,那就不能直接使用</p><p>有以下,三个办法:</p><ul><li><p>实现一个新的版本,overloaded, 去你妈的, 累死了</p></li><li><p>在其中,做一个副本拷贝, string str为s 的副本</p></li><li><p>根本上解决,修改普通引用为常量引用, 对的没错,是这样.</p></li></ul><p>总结:</p><p><strong>1. 尽量用引用,避免使用指针</strong></p><p><strong>2. 在确定不会发生修改变量的时候, 一定传递参数为对常量的引用, 即 const引用</strong></p><p>update: July 13, 2018 11:57 PM</p><h2 id="四-可变参数"><a href="#四-可变参数" class="headerlink" title="四, 可变参数"></a>四, 可变参数</h2><p>这个东西,大家平时摸得最多的函数,—启蒙函数 printf(“%s”,…);</p><p>C++中三种实现可变参数的方法:</p><h3 id="1-initializer-list"><a href="#1-initializer-list" class="headerlink" title="1. initializer_list"></a>1. initializer_list</h3><p>对于相同类型可变参,使用initializer_list类模板</p><p>其基本操作如下:</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>initializer_list&lt; T &gt; lt</td><td>初始化</td></tr><tr><td>initializer_list&lt; string &gt; lt = {a, b, c…}</td><td>初始化</td></tr><tr><td>lt2(lt)</td><td>复制初始化(构造函数重载),两个initializer_list, 共享同一组元素</td></tr><tr><td>lt2 = lt</td><td>同上,(C++对C复制的兼容)</td></tr><tr><td>lt.size()</td><td>lt的元素个数</td></tr><tr><td>lt.begin()</td><td>容器通用操作, 头迭代器</td></tr><tr><td>lt.end()</td><td>容器通用操作, 尾迭代器</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : init)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; lt = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">    func(lt);</span><br><span class="line">    func(&#123;<span class="string">"haha"</span>, <span class="string">"Bloodbore"</span>, <span class="string">"The last of US"</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意: initializer_list中的元素,是const只读的, 所以说,不能用头尾指针迭代,懂我意思吧</strong></p><h3 id="2-使用可变参模板"><a href="#2-使用可变参模板" class="headerlink" title="2. 使用可变参模板"></a>2. 使用可变参模板</h3><p>后面在&lt; 模板 &gt; 模块会详细分析的</p><h3 id="3-省略形参符"><a href="#3-省略形参符" class="headerlink" title="3. 省略形参符"></a>3. 省略形参符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure><p>还是那句话,写C++风格的C++, 这个做法,是留给与C接口的C++函数的</p><p>就像<code>extern &quot;C&quot;</code>一样</p><h2 id="五-返回的二三事"><a href="#五-返回的二三事" class="headerlink" title="五, 返回的二三事"></a>五, 返回的二三事</h2><h3 id="1-引用返回是左值"><a href="#1-引用返回是左值" class="headerlink" title="1. 引用返回是左值"></a>1. 引用返回是左值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global array</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not-reference return value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return value: reference</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = func1();</span><br><span class="line">    func2() = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : a)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>是的,一般函数返回值都是用来接收, 但是引用返回就是左值</strong></p><p><strong>不过,符合左值,那就给他放左边呗, 很正常的, 当然得是非常量引用,即非const引用</strong></p><h3 id="2-使用列表初始化返回值"><a href="#2-使用列表初始化返回值" class="headerlink" title="2. 使用列表初始化返回值"></a>2. 使用列表初始化返回值</h3><p><strong>注意, 使用列表初始化时, 内置类型只能包含一个值,(这不废话么)</strong></p><p><strong>其他类型,由其构造函数决定放回的列表如何用来初始化返回类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"Bloodbore"</span>, <span class="string">"The Last Of US"</span>, <span class="string">"Final Fansty X/X-2"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec = func();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.begin(); i != vec.end(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六-函数重载-Overloaded"><a href="#六-函数重载-Overloaded" class="headerlink" title="六, 函数重载(Overloaded)"></a>六, 函数重载(Overloaded)</h2><p><em>不由得,想起了,某老师的, 函数重(zhong)载, 大家懂得都懂, 还有下学期的爪哇也是他 \摊手</em></p><h3 id="1-为什么要有函数重载"><a href="#1-为什么要有函数重载" class="headerlink" title="1. 为什么要有函数重载"></a>1. 为什么要有函数重载</h3><p><em>肯定是有硬性需求呗,</em></p><p>工程量越来越大,起名字越来越难. 另一方面,就是有些功能类似,只是参数/返回类型略有区别的函数</p><p><del>另外起名字占位,岂不是很丑陋 ?</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C style</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs_double</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ style</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么,函数重载根据什么来区分?</p><p><strong>函数传入参数的类型或者个数, 其中必须要有差异, 编译器才能进行正确的重载选择</strong></p><p><strong>切记: 返回类型是不能进行区分的, 因为函数执行后,才能获取到返回类型</strong></p><h3 id="2-函数重载的坑"><a href="#2-函数重载的坑" class="headerlink" title="2. 函数重载的坑"></a>2. 函数重载的坑</h3><p>主要有三个方面会出现函数重载失败的情况: (当然重载失败有语法上的,也有运行时的,这里指语法上的)</p><ul><li>省略形参名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;       <span class="comment">// 语法上,重载失败, 同一函数</span></span><br></pre></td></tr></table></figure><ul><li>类型别名</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> funck = <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(fuck)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>const的情况</li></ul><p>这里<code>const</code>怎么会插上一脚呢?, 因为进行赋值时, const的特点: <strong>顶层无意义(可忽略), 底层需注意</strong></p><p>赋值时, 顶层const属性丢失,所以是一样的,底层对常量的指针和引用,都是不一样的,可进行函数重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *)</span></span>;          <span class="comment">// 重载失败, 顶层const属性丢失</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="function">viud <span class="title">foo</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;           <span class="comment">// success, 对常量的引用和常量引用的确是不同的</span></span><br></pre></td></tr></table></figure><h3 id="3-const-cast到底怎么玩"><a href="#3-const-cast到底怎么玩" class="headerlink" title="3. const_cast到底怎么玩?"></a>3. const_cast到底怎么玩?</h3><p>之前说过,基本上是在overloaded中使用这个显式的转换</p><p><strong>const_cast&lt;&gt;, 基本上用于进行const形参接收普通形参是的情况</strong></p><p><strong>简单地说,我们使用const形参,他可以相容普通形参,的那是我们要让其优先选择非常量形参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">is_string</span><span class="params">(cosnt <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> stirng &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">is_stirng</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> i = is_string(cosnt_cast&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span> &amp;&gt;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的实现一般, (C++在之后面向对象的时候,我们更倾向于用已经实现的函数去实现新的功能)</p><p><code>const&lt;Type&gt;(var)</code> 实现从<code>const &lt;=&gt; non-const</code>的转换</p><p>根据我们的需要进行转换, 同时,这个转换只是进行<code>const</code>属性的改变</p><p>若用其实现<code>static_cast</code>的功能,肯定就错了.</p><p><strong>注意: <code>const &lt;=&gt; non-const</code>之间进行转换的时候,我们要自己保证转换的可行性,别乱j8给人修改</strong></p><h2 id="来深层次的分析Overloaded"><a href="#来深层次的分析Overloaded" class="headerlink" title="来深层次的分析Overloaded"></a>来深层次的分析Overloaded</h2><h3 id="1-编译器实现"><a href="#1-编译器实现" class="headerlink" title="1. 编译器实现"></a>1. 编译器实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 据说, 经过编译后,是这个名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _func_int(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">void</span> _func_double(<span class="keyword">double</span>);</span><br></pre></td></tr></table></figure><p>这样,直接检索名字不就行了.</p><h3 id="2-Overloaded的过程"><a href="#2-Overloaded的过程" class="headerlink" title="2. Overloaded的过程"></a>2. Overloaded的过程</h3><p>首先从结果上来说,有这样三种结果:</p><p>最佳匹配, 重载失败, 二义性错误</p><p>来看过程:</p><ul><li><p>1.首先确定本次调用的函数集,成为<strong>候选函数</strong></p><p><em>候选函数的条件, 函数名符合, 且作用域内可见</em></p></li><li><p>2.在候选函数中,选择出,<strong>可行函数</strong></p><p><em>可行函数的条件, 函数参数个数符合, 每个实参类型符合,或者可以发生转换</em></p></li><li><p>3.寻找<strong>最佳匹配</strong></p><p>如果能够找到,则存在最佳匹配,进行调用.</p><p>如果还存在多个可行函数,无法抉择,则产生二义性错误</p></li></ul><p><strong>那么,如何选择最佳函数?</strong></p><p>首先, 之后一个参数的函数, 很简单: 是就是, 不是就不是</p><p>那么,多个参数的函数呢?</p><p>要求符合下面两个要求:</p><p><strong>1. 任何一个参数的匹配都不劣于其他可行函数</strong></p><p><strong>2. 至少有一个参数的匹配优于其他可行函数的对应参数匹配</strong></p><p><em>通俗点说, 各方面表现不差于别人,还有其他亮点, 就被录取了</em></p><p>如下图:</p><p> <img src="http://p8uroi1uf.bkt.clouddn.com/overloaded.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 候选函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * void func(int);</span></span><br><span class="line"><span class="comment"> * void func(int, int);</span></span><br><span class="line"><span class="comment"> * void func(double, double);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 2. 可行函数</span></span><br><span class="line"><span class="comment"> * void func(int, int);</span></span><br><span class="line"><span class="comment"> * void func(double, double);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 3. 最佳匹配</span></span><br><span class="line"><span class="comment"> * 两个函数,都分别在其中一个参数上最佳匹配</span></span><br><span class="line"><span class="comment"> * 又在另一个参数上,有转换</span></span><br><span class="line"><span class="comment"> * 所以,结果是 二义性错误</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-C-类型转换层次"><a href="#3-C-类型转换层次" class="headerlink" title="3. C++类型转换层次"></a>3. C++类型转换层次</h3><p>为了适合函数重载(当然还有其他地方)</p><p>C++将类型转换分为下唉面这么几个层次:</p><ul><li><p>精确匹配</p><ol><li><p>实参类型与形参匹配 (精确匹配)</p></li><li><p>array-to-pointer, function-to-pointer ,在传参过程中</p></li><li><p>顶层cosnt的添加与删除</p></li></ol></li><li><p>const转换实现的匹配</p></li><li><p>类型提升带来的匹配</p></li><li><p>算术类型转换或指针转换</p></li><li><p>类类型的转换.</p></li></ul><p><strong>根据上面5个层次的不同,来分析函数重载的最佳匹配即可</strong></p><p>update: July 14, 2018 11:53 AM</p>]]></content>
    
    <summary type="html">
    
      好久没写博客,其实可以将一些闲杂的知识点,细碎的总结一下, 就按每章的形式进行总结吧
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="C++Primer" scheme="http://evil-crow.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>MySQL入门</title>
    <link href="http://evil-crow.github.io/2018/06/25/SQL/MySQL_start/"/>
    <id>http://evil-crow.github.io/2018/06/25/SQL/MySQL_start/</id>
    <published>2018-06-24T17:42:00.000Z</published>
    <updated>2018-07-28T04:13:52.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-安装问题"><a href="#一-安装问题" class="headerlink" title="一,安装问题"></a>一,安装问题</h2><p>此处仅仅谈到Linux平台的安装方法,Win下可以通过现成安装包方式安装</p><p>Mac没接触过,不了解.不过听说<code>brew</code>也挺好用?(反正我是<code>dnf</code>毒奶粉)</p><p>下面的流程摘自MySQL官网,相当于间接翻译一下,(…), Fc的特化版本,其他发行版同理,有区别</p><p>在官网中可以找到适合自己发行版的repo,按照说明选择的好,至于不对应版本,会有什么差错,我也不知道.</p><p><a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">这是官网链接&gt;&gt;</a></p><p>首先里面提供了三个版本</p><p><code>MySQL Enterprise Edition</code><br><code>MySQL Cluster CGE</code><br><code>MySQL Community Edition</code></p><p>如果你是个人用户,或者学习用,还是乖乖用社区版,完全足够了</p><p><a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">所以,这个才是真的链接&gt;&gt;</a></p><p>左边侧栏,就可以选择合理的,安装方式,</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/website.png" alt="左侧边栏"></p><p>我们以MySQL Yum Repository安装为例来说明:</p><h3 id="1-找到适合自己的repo"><a href="#1-找到适合自己的repo" class="headerlink" title="1. 找到适合自己的repo"></a>1. 找到适合自己的repo</h3><p>在下面的选择中进行repo下载:</p><p>然后使用<code>sudo rpm -Uvh your-system-version.rpm</code></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/repoi.png" alt="repo"></p><p>(隔壁的dpkg同理,packman惹不起)</p><h3 id="2-选择版本系列"><a href="#2-选择版本系列" class="headerlink" title="2. 选择版本系列"></a>2. 选择版本系列</h3><p>习惯使用repo的人会知道,同一个repo也会有不同的版本, 而MySQL经常比较的就是5.x和现在的8.x了</p><p><em>6.x是留给告诉迭代的版本的, 也就是现在5.x的后继,7.x是留给集群版本的,提前插眼</em></p><p><em>所以现在最新的就是8.x了,不用疑惑的</em></p><p><code>shell&gt; yum repolist all | grep mysql</code> 查看现在支持的版本</p><p><code>shell&gt; sudo dnf config-manager --disable mysql80-community</code><br><code>shell&gt; sudo dnf config-manager --enable mysql57-community</code></p><p>进行指定版本的限制</p><p><code>shell&gt; yum repolist all | grep mysql</code> 重新查看,即可,要使用5.7还是8.0随意</p><h3 id="3-进行repo缓存"><a href="#3-进行repo缓存" class="headerlink" title="3. 进行repo缓存"></a>3. 进行repo缓存</h3><p><code>shell&gt; sudo dnf makecache</code></p><h3 id="4-安装mysql"><a href="#4-安装mysql" class="headerlink" title="4. 安装mysql"></a>4. 安装mysql</h3><p><code>shell&gt; sudo yum install mysql-community-server</code></p><p>会自动处理依赖的</p><h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5. 启动服务"></a>5. 启动服务</h3><p><code>shell&gt; sudo systemctl start mysqld</code> 启动服务</p><p><code>shell&gt; sudo systemctl status mysqld</code> 查看服务状态</p><h3 id="6-进行密码的设定"><a href="#6-进行密码的设定" class="headerlink" title="6. 进行密码的设定"></a>6. 进行密码的设定</h3><p>MySQL Server Initialization (as of MySQL 5.7): At the initial start up of the server, the following happens, given that the data directory of the server is empty:</p><p>The server is initialized.</p><p>An SSL certificate and key files are generated in the data directory.</p><p>The validate_password plugin is installed and enabled.</p><p>A superuser account ‘root‘@’localhost’ is created. A password for the superuser is set and stored in the error log file. To reveal it, use the following command:</p><p><code>shell&gt; sudo grep &#39;temporary password&#39; /var/log/mysqld.log</code></p><p>Change the root password as soon as possible by logging in with the generated, temporary password and set a custom password for the superuser account:</p><p><code>shell&gt; mysql -uroot -p</code></p><p><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;;</code></p><p>上面这段话的意思时: 启动服务,mysql已经默认创建了root@localhost用户</p><p>同时给你吧密码安排到日志文件里面了,你运行第一条命令找出密码,然后进去改密码</p><p>就这样就好了</p><p>但是,<strong>我TM日志是空的…</strong></p><p>所以还有下面的邪道方法:</p><p>进入<code>/etc/my.cnf</code> 进行登录不需要密码的状态,具体是添加</p><p><code>skip-grant-tables</code>,实现免密码登录</p><p><code>mysql -uroot</code>  登入数据库</p><p><code>update user set password=password(&#39;123456&#39;) where user=&#39;root&#39; and host=&#39;localhost&#39;;</code></p><p>修改用户名密码</p><p>记得完了修改文件,取消免密码登录,然后<strong>重启服务</strong>,就可以正常使用了</p><h2 id="二-初始MySQL"><a href="#二-初始MySQL" class="headerlink" title="二,初始MySQL"></a>二,初始MySQL</h2><p>作为一个经典的SQL,这么多年来经久不衰还是由他的理由的</p><p>有下面几个了解一下的:</p><ol><li><p>默认port –3306</p></li><li><p>有社区版和专业版</p></li><li><p>现属于Oracle公司</p></li></ol><p>了解足够了</p><h2 id="三-常用的最基础操作"><a href="#三-常用的最基础操作" class="headerlink" title="三,常用的最基础操作"></a>三,常用的最基础操作</h2><h3 id="1-启动和停止服务"><a href="#1-启动和停止服务" class="headerlink" title="1. 启动和停止服务"></a>1. 启动和停止服务</h3><p>这个就够了,有使用Linux经验的,谁还是不会撞墙去吧…</p><h3 id="2-登录与退出"><a href="#2-登录与退出" class="headerlink" title="2. 登录与退出"></a>2. 登录与退出</h3><p>登录是这样的形式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql [-option] [-arguments]</span><br></pre></td></tr></table></figure><p>常用option:</p><ol><li><p>-p –passwd[] 指定密码</p></li><li><p>-P 指定端口</p></li><li><p>-u 指定用户</p></li><li><p>-H 指定主机</p></li><li><p>–prompt 设定提示符</p></li><li><p>-D 指定数据库</p></li></ol><p>退出就比较简单了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; quit;</span><br><span class="line">shell&gt; <span class="built_in">exit</span>;</span><br><span class="line">shell&gt; \q;</span><br></pre></td></tr></table></figure><p>三种形式都可以</p><h3 id="3-SQL命名规范"><a href="#3-SQL命名规范" class="headerlink" title="3. SQL命名规范"></a>3. SQL命名规范</h3><p>虽然网上说随个人习惯,不敏感大小写,但是还是遵循一下规范的好:</p><p><strong>命令, 函数, 保留字一律使用大写</strong></p><p><strong>数据库名, 表名, 索引名等一律使用小写</strong></p><p><strong>SQL语句一律都是 ; 结尾</strong></p><p>也就是说,出来是这种画风</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> k1;</span><br></pre></td></tr></table></figure><h3 id="4-常用操作"><a href="#4-常用操作" class="headerlink" title="4. 常用操作"></a>4. 常用操作</h3><h4 id="1-gt-显式-切换-创建数据库"><a href="#1-gt-显式-切换-创建数据库" class="headerlink" title="1&gt; 显式,切换,创建数据库"></a>1&gt; 显式,切换,创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] K2 [<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name;</span><br></pre></td></tr></table></figure><p>花括号为必选项, 方括号为可选项. 后面是设置编码, [IF NOT EXISTS], 可以免除一个WARNING</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;    // 显示数据库</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">database</span>;      // 切换数据库</span><br></pre></td></tr></table></figure><h4 id="2-gt-修改数据库属性"><a href="#2-gt-修改数据库属性" class="headerlink" title="2&gt; 修改数据库属性"></a>2&gt; 修改数据库属性</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [db_name] [<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [=] charset_name</span><br></pre></td></tr></table></figure><p>比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> K2 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8;   //修改K2数据库编码为utf-8</span><br></pre></td></tr></table></figure><h4 id="3-gt-删除数据库"><a href="#3-gt-删除数据库" class="headerlink" title="3&gt; 删除数据库"></a>3&gt; 删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">DATABASE</span> | <span class="keyword">SCHEMA</span>&#125; [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] db_name</span><br></pre></td></tr></table></figure><p>IF EXISTS 的用法同上</p><h4 id="4-gt-闲杂命令"><a href="#4-gt-闲杂命令" class="headerlink" title="4&gt; 闲杂命令"></a>4&gt; 闲杂命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();    // 显示版本</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>();       // 显示日期;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();       // 显示用户;</span><br></pre></td></tr></table></figure><p>(PS: 数据库操作还是挺好玩的,我都是跑路了,当个数据库管理员也不错,开玩笑的,还是写C/C++舒服)</p><hr>]]></content>
    
    <summary type="html">
    
      这两天要做数电课设,还要带电脑过去,不过你也懂我,我肯定是不会好好做的,所以慕课网还是挺有意思的,有些挺好的免费课程,这两天闲的(其实也不是闲,被闲下来...),入手一下MySQL和Docker玩玩,以后有时间了,MongDB也了解一下(Redis随缘了)
    
    </summary>
    
      <category term="SQL" scheme="http://evil-crow.github.io/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://evil-crow.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>C/C++坑点总结</title>
    <link href="http://evil-crow.github.io/2018/06/20/C++/Other/C_C++_expr/"/>
    <id>http://evil-crow.github.io/2018/06/20/C++/Other/C_C++_expr/</id>
    <published>2018-06-20T13:04:00.000Z</published>
    <updated>2018-09-13T14:52:58.587Z</updated>
    
    <content type="html"><![CDATA[<p><em>下面都是我进行C/C++语言知识的坑点总结,当然也就是说,以后可能会有Kernel, Server总结</em></p><p><em>当然,不在乎头发了,这都不是事(笑)</em></p><h2 id="18-6-20"><a href="#18-6-20" class="headerlink" title="18.6.20"></a>18.6.20</h2><h3 id="1-函数传参的指针与引用"><a href="#1-函数传参的指针与引用" class="headerlink" title="1. 函数传参的指针与引用"></a>1. 函数传参的指针与引用</h3><p>曾经可能在无数的书上看过:</p><blockquote><p>要修改变量的值,要不使用传值(call by value) + 返回值(return value)</p></blockquote><blockquote><p>要不就使用传址(call by pointer) (PS: 当然前面说的话有问题,传地址也是传值,指针的值)</p></blockquote><blockquote><p>只不过是指针有修改指向变量的特性罢了. </p><p>另一种传参方式,C中没有,C++中用引用,即call by reference</p></blockquote><p>上面的话,其实看的人玄乎.就会写出这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">add_data</span><span class="params">(Node *head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_data_</span><span class="params">(Node **head)</span></span>;</span><br></pre></td></tr></table></figure><p>第二种是正确的,第一种也是正确的,是的,没错,但是解释起来都是牵强的</p><p><strong>并非上面两种解释方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_data</span><span class="params">(Node *head)</span></span>;</span><br></pre></td></tr></table></figure><p>不信,你试试这样进行修改,也完全是可以的.</p><p>那么,实际上是什么问题?</p><p>用我的话来解释, </p><p><strong>修改函数外部的对象,传对象的地址(即指针),或者对象的引用进来,便可以直接修改外部的值</strong></p><p><strong>传值,进来,进行修改,然后将值返回, 来修改外部变量的值,是重新给对象赋值的做法</strong></p><p><strong>这其中会出产生一个误区, 函数形参也是自动变量,为什么可以返回指针</strong></p><p><code>Node *add_data(Node *data);</code>, 这个函数,它传入指针,<strong>实质上发生了这样的事:</strong></p><p><strong>使用实参初始化形参,然后操作形参,形参在函数结束后的确这个指针对象被释放,但是它的值还是有效的</strong></p><p><strong>这里的值,指的是他和指向的值,它的值,要这样获取,&amp;head, 此head对象释放,但是它的值还保证有效</strong></p><p><strong>而这个值,返回之后,进行赋值,整个过程中没有变化,所以这个指针返回值是可以的</strong></p><p><strong>我们经常说的,不要返回指针,指的是: 函数内部船舰的对象的指针,因为这些对象都会被释放</strong></p><p><strong>他们的指针,返回后的操作,都是未定义的危险行为</strong></p><p>上面说了那么多,我们实际怎么操作呢?</p><p><em>1. 首先思考,是否需要对传入的参数,进行改变, 从而选择参数的地址,或者函数结束后重新赋值的方式</em></p><p><em>2. 返回非函数内部创建的对象的指针,是可行的,因为他不随函数结束而释放,典型的是malloc,引用同理</em></p><p><em>3. 指针,也只是值,不要特殊对待,之后call by value以及call by reference</em></p><h3 id="2-关于printf控制符的选择"><a href="#2-关于printf控制符的选择" class="headerlink" title="2. 关于printf控制符的选择"></a>2. 关于printf控制符的选择</h3><p>不知道大家有没有疑惑过,float的控制符,是%f</p><p><em>那么,double的控制符到底是什么 ? </em></p><p>如果也使用%f是会出错的</p><p><strong>结论是: printf使用%f, scanf]使用%lf</strong></p><p><em>但是,在进行文件格式化写入,读出(fprintf, fscanf)是还是有问题…</em></p><p><strong>不过,使用open, write, read等系统调用,好像就没有这个问题了</strong></p><h3 id="3-关于错误处理"><a href="#3-关于错误处理" class="headerlink" title="3. 关于错误处理"></a>3. 关于错误处理</h3><p>这个其实是一个偏向于系统设计的问题</p><p>C++中有异常处理,不多考虑了</p><p>C中虽然有non-local “goto”, 但是很容易混乱也不提</p><p>所以,<strong>建议像Linux系统调用设计一样</strong></p><p><strong>我们可以设置全局的错误标识量,然后返回error code,再用标准的错误函数去进行错误信息的处理</strong></p><p><strong>这样就会显得错误处理自然了许多, 同时也不会是软件耦合度过高</strong></p><hr>]]></content>
    
    <summary type="html">
    
      C/C++中的坑点确实太多,经常遇到,所以也经常进行总结,这样才能起到温故而知新的目的,这篇Blog就是为此准备的,每次有新的问题都会进行更新
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="hole" scheme="http://evil-crow.github.io/tags/hole/"/>
    
  </entry>
  
  <entry>
    <title>指针与引用</title>
    <link href="http://evil-crow.github.io/2018/06/10/C++/Other/pointer_and_reference/"/>
    <id>http://evil-crow.github.io/2018/06/10/C++/Other/pointer_and_reference/</id>
    <published>2018-06-10T13:02:00.000Z</published>
    <updated>2018-09-13T14:53:05.409Z</updated>
    
    <content type="html"><![CDATA[<p><em>最近总算开始正事了,其实C++ primer还是挺好看的,讲道理,真的.</em></p><p><em>不过,需要转换思维的东西有点多,这一系列算是自己看C++ Primer的感想</em></p><p><em>也不能算是系列笔记,有想法的写一写,同时会将C++11 的内容单独列出来,能写C++11 还是写11吧</em></p><h2 id="一-C-中的复合类型"><a href="#一-C-中的复合类型" class="headerlink" title="一, C++中的复合类型"></a>一, C++中的复合类型</h2><p>C++中来分类型,其实就两种内置类型与自定义类型</p><p>内置类型,就算术类型与复合类型.</p><p>算术类型不提,我们重点来说说复合类型之中的指针与引用</p><p><strong>指针: 用修饰符 *来定义声明</strong></p><p><strong>引用: 用修饰符 &amp;来定义声明</strong></p><blockquote><p>指针: 本身是一个对象, 它存储了指向其他对象的地址,所以有指向对象的指针的指针,有多维指针</p></blockquote><blockquote><p>引用: 本身是一个绑定对象的别名,他不是一个对象,所以没有引用的引用,引用的指针</p></blockquote><p>我们着重来说说这两者的区别:</p><ol><li><p>首先是本质上, 指针是对象, 引用并非对象.所以有多维指针,指针的引用.但是没有多维引用,引用指针</p></li><li><p>从是否有初始化的必要上. 指针可以不初始化(但是是随机值,建议初始化), </p><p>引用因为绑定对象不可变,所以必须初始化.而且初始化后绑定对象不可更改,指针则可以任意修改.</p></li></ol><h2 id="二-一些问题的解答"><a href="#二-一些问题的解答" class="headerlink" title="二, 一些问题的解答"></a>二, 一些问题的解答</h2><h3 id="1-引用绑定唯一对象为什么还能赋值"><a href="#1-引用绑定唯一对象为什么还能赋值" class="headerlink" title="1. 引用绑定唯一对象为什么还能赋值?"></a>1. 引用绑定唯一对象为什么还能赋值?</h3><p>上面我们说过,引用绑定的对象是唯一的,仅仅在初始化的时候完成绑定.之后便不能修改.那么下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> &amp;c = a;</span><br><span class="line">c = b;    <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>为什么? 不是绑定对象后,引用不能修改么…</p><p><strong>haha, 实际上是被使用指针的习惯禁锢住了, 使用引用的时候,就已经变成绑定的对象了</strong></p><p><strong>所以, 我们在初始化的步骤以外,并不可能修改引用绑定的对象,这也是为什么使用引用必须初始化的原因</strong></p><p>上面的代码中,使用,引用c变成(int)a, 引用b变成(int)a</p><h3 id="2-指针的四种状态"><a href="#2-指针的四种状态" class="headerlink" title="2. 指针的四种状态"></a>2. 指针的四种状态</h3><p>我们可以定义指针,指针在他的生命周期中可以存在四种状态:</p><ol><li><p>指向某一个对象</p></li><li><p>指向某一个对象的下一个位置</p></li><li><p>指向空(即空指针)</p></li><li><p>无效指针,其他例外情况(一般为野指针)</p></li></ol><p>1, 4不多说,2的情况,可能大家会比较会比较奇怪</p><p>其实2的情况,即使是C中也是保留的.</p><p><strong>C中,保证数组末端下一个位置的指针有效,但是其中的内容不作保证</strong></p><p><strong>C++中,在使用STL中的end()方法时,获取到的就是容器末尾的下一个位置,同样是保证指针有效</strong></p><p>这都是为了处理一些边界情况,或者做一些有效性判断而保证的.</p><h3 id="3-关于空指针-Null-Pointer"><a href="#3-关于空指针-Null-Pointer" class="headerlink" title="3. 关于空指针(Null Pointer)"></a>3. 关于空指针(Null Pointer)</h3><p>空指针,是一个特殊情况,即是为了保证指针不乱指向,出现一线难以调试的Bug存在的,一般用来初始化,</p><p>或者收尾工作使用.</p><p>常用来做空指针的几个值: nullptr, 0, NULL(需要&lt; cstdlib &gt;)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> *q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *r = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>其中,我们强烈建议,使用<code>int *p = nullpter</code>的形式</p><p><code>NULL</code>也只是<code>#include &lt;cstdlib&gt;</code>中的一个<code>#define NULL 0</code></p><p>0 也不能很明确的标识Null Pointer, 故使用C++11标准新规定的nullpter最为恰当</p><h3 id="4-指针比较时的相等情况"><a href="#4-指针比较时的相等情况" class="headerlink" title="4. 指针比较时的相等情况"></a>4. 指针比较时的相等情况</h3><p>一般来讲,我们用指针来做判断,进行比较不会出什么大问题,但是也有例外</p><p>下面的这种情况,没有遇到之前是匪夷所思的,不过理解其中原因也就没问题了</p><p><strong>某一个对象的指针,可能等于某个对象下一个位置的指针</strong></p><p><strong>其中的原因就是: 编译器可能进行了连续的内存分配,将两个变量连续分配,就会出现这种情况</strong></p><h3 id="5-复合类型的声明"><a href="#5-复合类型的声明" class="headerlink" title="5. 复合类型的声明"></a>5. 复合类型的声明</h3><p>类型在复合一点,就是指针的指针,指针的引用了</p><p><strong>因为,引用并非实际对象,只是绑定对象的别名,所以不存在引用的引用,引用的指针,切记</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **c = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *&amp;r = b;</span><br><span class="line"><span class="keyword">int</span> **&amp;t = c;</span><br></pre></td></tr></table></figure><p>上面,指针的引用,指针的指针的引用看上去是有点蛋疼.</p><p><strong>我们从最靠近标识符的符号开始分析,一切就比较明了了</strong></p><p>具体可以参见这篇博客<a href="https://evil-crow.github.io/2018/05/23/C/Expert_C_Programming/c_statement/">传送门&gt;&gt;</a> ,讲道理,没有C声明晦涩,复杂(C++和C恶心声明程度更甚)</p><h2 id="三-事实上-const才是最恶心的"><a href="#三-事实上-const才是最恶心的" class="headerlink" title="三, 事实上,const才是最恶心的"></a>三, 事实上,const才是最恶心的</h2><p>const是一个很有用的关键字,它赋予了变量在一定情况下的只读属性</p><p>那么,指针/引用和const结合起来就比较恶心了</p><h3 id="1-const和指针"><a href="#1-const和指针" class="headerlink" title="1. const和指针"></a>1. const和指针</h3><p>这个其实都是我们在C中玩烂的内容了,</p><p>无非就是两种,指向const的指针和const指针.不过现在我们赋予他们两个新的名字</p><p><strong>顶层const(top-level): 指的是对本身的const</strong></p><p><strong>底层const(low-level): 指的是对指向对象的const</strong></p><p>顶层/底层const于指针之间的关系,在C++中同C,没有啥区别</p><p>我们重点来说说对于引用的问题</p><h3 id="2-对const的引用"><a href="#2-对const的引用" class="headerlink" title="2. 对const的引用"></a>2. 对const的引用</h3><p>在const上,很多人也在说,const的顶层/底层啥的</p><p><strong>其实,我个人觉得引用,就叫对const的引用就好,不要扯上顶层/底层的概念</strong></p><p><strong>为什么? 因为引用本身就不是对象,顶层const失去意义.</strong></p><p><strong>底层cosnt说的是,指向对象,但是引用绑定同一个,没有指向啊</strong></p><p><em>其实,讲道理,也可以说着两种顶层/底层const, 因为引用指向常量(具有const的变量)时,就是底层const</em></p><p><em>而引用,虽然本身并非对象,没有顶层const的概念,但是他初始化绑定后不可变,也可以说时有种”顶层”感觉</em></p><p>所以,我的建议是,对const的引用,说法足矣.别整那些有的没的</p><h3 id="3-拷贝时的const"><a href="#3-拷贝时的const" class="headerlink" title="3. 拷贝时的const"></a>3. 拷贝时的const</h3><p><em>这个才是,const这里的重点,呃喔门进行程序设计的时候,免不了进行赋值操作等各种东西</em></p><p><em>那么,对于含有const的变量,拷贝之时,有什么要注意的吗?</em></p><p><strong>简单的来说,顶层const属性会丢失. (引用不讲顶层const的概念,不多说)</strong></p><p><strong>如果,需要顶层cosnt,手动加上const即可</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> src = &amp;temp;</span><br><span class="line"><span class="keyword">int</span> *des = src;     #=&gt; des, <span class="keyword">int</span>* 顶层<span class="keyword">const</span>丢失</span><br></pre></td></tr></table></figure><p>引用这里的情况,其实是这样,</p><p><strong>指针,会丢失顶层const,但是引用”隐式的”含有顶层const属性,(也因为它没有顶层const的概念)</strong></p><p><strong>所以才说,引用后不再是顶层const了, 但是你引用的const变量,依然是const变量,</strong></p><p><strong>不能因为引用,就使得对外开放,通过引用将const变量修改,所以引用是底层const(也就是对const的引用)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;        <span class="comment">// j #=&gt; int</span></span><br><span class="line"><span class="keyword">int</span> &amp;k = i;       <span class="comment">// Error, 应该改为 const int &amp;k = i;</span></span><br></pre></td></tr></table></figure><p>另外的情况就是: <strong>底层const会进行保留</strong></p><p>用指针来说,若指向对象是const变量,则指针一定要是底层const指针,不然就会被意外修改</p><p>对引用,只能说是另一种形式的”底层”const,引用绑定const变量,</p><p>即是说引用绑定对象不可变,也是一种形式的”底层”const</p><p>而引用,自身绑定的对象不可变,也就是另一种形式的”顶层”const</p><h3 id="4-指针-引用赋值时类型不匹配的情形之一"><a href="#4-指针-引用赋值时类型不匹配的情形之一" class="headerlink" title="4. 指针/引用赋值时类型不匹配的情形之一"></a>4. 指针/引用赋值时类型不匹配的情形之一</h3><p>我们进行数据赋值操作时,常常要注意一个问题: <strong>类型匹配的问题</strong></p><p><em>C/C++中比较弱类型的部分,会自动发生类型转换,C中一般给warning:,C++一般是error:</em></p><p>但是,在指针,引用赋值时,一般情况下要严格遵守类型匹配原则,除了两种情况以外:</p><p><em>首先,必须是不同类型的指针,不同类型的引用之间. 算术类型与指针/引用时无论如何不能进行转换的,</em></p><p><strong>我们的例外情况之一就是: 对于初始化cosnt引用,可以赋予不同类型的引用</strong></p><p><strong>但是,要求是,可以完成类型转换的情况,而且,更甚于使用字面量,非const变量,表达式之类的进行初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;a = db;              <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">3.14</span>;      <span class="comment">// b = 3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">3</span>;               <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;d = <span class="number">3</span>;         <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>首先来说说进行,不同引用/指针类型之间的赋值.</p><p>其实在其中完成了这样的步骤:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = db;</span><br><span class="line">cosnt <span class="keyword">int</span> &amp;b = temp;</span><br></pre></td></tr></table></figure><p>对,没错.实际上他用了一个临时值来进行保存,这个临时值发生了类型准换,当然会丢失精度</p><p>那么<code>int &amp;a = db</code>为什么会失败?</p><p>因为,我们实际上时进行临时值的绑定,修改临时值并不能修改<code>db</code>,但是const变量就不是为了修改的</p><p>而<code>int &amp;a</code>时为了修改的,既然绑定临时值并不能修改,所以,这样的行为自然就是错误的了.</p><p>指针的话,</p><p><strong>指的是,可以使用非常量指针,来进行常量指针(是底层cosnt,顶层const想都不用想)的初始化</strong></p><p><strong>不同指针类型之间,进行初始化,如果不使用强制类型转化(轻则:warning, 重则:error)</strong></p><p><em>至于,为什么可以忽略顶层const, 引用不需要考虑,而指针,即使开放出去,新赋值的指针也只能修改</em></p><p><em>他们指向的对象,而不能修改原指针</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> src = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *des = src;</span><br></pre></td></tr></table></figure><p>即: des只能修改a,修改不到src,所以,src的顶层cosnt属性,不要就不要了.</p><h2 id="四-处理类型"><a href="#四-处理类型" class="headerlink" title="四, 处理类型"></a>四, 处理类型</h2><p>如今C++发展日新月异,越来越牛<del>(gou)</del>皮<del>(pi)</del></p><p>类型也是越写越长,我们逐渐难以推断出,某个变量到底会是什么类型,这就是个十足的问题了</p><p>于是乎,出现了这么几种进行类型推导的好东西:</p><h3 id="1-typedef"><a href="#1-typedef" class="headerlink" title="1. typedef"></a>1. typedef</h3><p>其实C中也用过了,就是类型别名(type alias),这个东西只能你自己起名字</p><p><em>局限性还是很大的,你要是也不认识,不就没办法玩了</em></p><p><strong>所以,我们推荐下面这几种方法</strong></p><h3 id="2-模板类型推导"><a href="#2-模板类型推导" class="headerlink" title="2. 模板类型推导"></a>2. 模板类型推导</h3><p>很牛皮, 不过我现在也用不上,不提了,后面补</p><h3 id="3-auto自动类型推导"><a href="#3-auto自动类型推导" class="headerlink" title="3. auto自动类型推导"></a>3. auto自动类型推导</h3><p>这个是C++11种新出来的好东西</p><p>这东西,当年也是从C中出来的,不过已经废了很多年了(PS: 表示自动变量有个球用)</p><p>所以,C++11对此关键字,继续重写.作为自动类型推导关键字</p><p><strong>auto根据初始值,进行类型推导,所以它必需要进行初始化,不然搞锤子</strong></p><p><strong>另外,auto其实是模板类型推导过来的,所以实际上auto就是个占位符T,不能用做类型</strong></p><p><code>auto i = auto j;</code>这就是错误的,编译会炸的</p><p><em>auto自动类型推导,会根据情况,进行一定程度的修改,使其更符合自动类型推导</em></p><p><strong>也就是说,会出现不一致的情况,它会忽略顶层const,底层cosnt则会保留,如果有需要顶层const,显式声明.</strong></p><p><strong>对于字面量的情况,必须是对cosnt的引用,否则还是编译不通过,很简单,不能为非const引用绑定字面值</strong></p><p><code>auto &amp;i = 42</code>错误, <code>const auto &amp;i = 42</code> 编译通过</p><p>另外,要注意的:<strong>对引用使用时,auto会使用引用绑定的类型进行推导</strong></p><p>也就是说: <strong>一般变量进行类型推导, 变量的顶层const属性会丢失. 而引用则能保留顶层const属性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i;    <span class="comment">// a #=&gt; int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = i;   <span class="comment">// b #=&gt; const int&amp;</span></span><br></pre></td></tr></table></figure><p><em>好吧,我错怪C++ Primer的翻译了,我的错.</em></p><p>来看看下面这些例子,和你想的一样吗?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;      <span class="comment">// i #=&gt; const int</span></span><br><span class="line"><span class="keyword">auto</span> j = i;            <span class="comment">// j #=&gt; int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;k = i;     <span class="comment">// k #=&gt; const int &amp;, 没有const,会error</span></span><br><span class="line"><span class="keyword">auto</span> *p = &amp;i;          <span class="comment">// p #=&gt; const int *, 因为它指向const常量,所以得是底层cosnt指针</span></span><br><span class="line"><span class="keyword">auto</span> p = &amp;i;           <span class="comment">// 结果同上,指针不显式声明可以推导,引用则会被推导为一般类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> j2 = i, &amp;k2 = i; <span class="comment">// j2 #=&gt; const int k2 #=&gt; const int &amp;</span></span><br></pre></td></tr></table></figure><h3 id="4-decltype类型指示符"><a href="#4-decltype类型指示符" class="headerlink" title="4. decltype类型指示符"></a>4. decltype类型指示符</h3><p><em>上面使用auto时,你可能还会抱怨,会出问题,不一定符合,const会丢失之类的</em></p><p>但是,我明确的说,<strong>decltype一定符合你的需求,它会切实进行类型推导</strong></p><p>当然,两个类型推导之间会所不同. 具体来说:</p><ol><li><p><code>auto</code>是根据初始值进行类型推导,所以它一定会发生赋值操作</p><p>而<code>decltype</code>只是根据表达式结果推导,并不实际计算</p></li><li><p><code>auto</code>在对于引用推导时,使用引用绑定类型,<code>decltype</code>则会将其作为引用使用.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> i = a; <span class="comment">// i #=&gt; int ,丢失顶层const, a只是个const int,使用引用绑定类型</span></span><br><span class="line"><span class="keyword">decltype</span>(a) b;  <span class="comment">// Error, 推导出来是引用类型,而引用类型必须初始化</span></span><br></pre></td></tr></table></figure></li></ol><p> <strong>切记: 引用类型,只有在<code>decltype</code>这里是引用,其他时候都使用其绑定类型</strong></p><ol start="3"><li>便是,<code>decltype</code>中奇特的<code>(())</code>了, 他会将变量作为表达式,获取引用类型</li></ol><p><strong><code>decltype</code>中有一个大坑, 当decltype的表达式可以作为赋值语句的左值时,decltype的结果是引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) a = i;       <span class="comment">// a #=&gt; int </span></span><br><span class="line"><span class="keyword">decltype</span>(*p) b;              <span class="comment">// Error, b #=&gt; int &amp;</span></span><br></pre></td></tr></table></figure><p><strong>不要奇怪解引用的结果是引用,因为它可以作为左值</strong></p><p>总结一下: </p><p><strong>1. 使用变量,一定会得到你想要的变量类型,当然,在你不使用<code>decltype((var))</code>的情况下</strong></p><p><strong>2. 使用表达式, 如果可以作为左值,那么,他就是引用,上面的r+0, 并不能做引用,它是int</strong></p><p>讲道理,上面这些还是收货颇丰的.</p><h2 id="X-附C-11使用部分"><a href="#X-附C-11使用部分" class="headerlink" title="X: 附C++11使用部分"></a>X: 附C++11使用部分</h2><p><em>这部分是关于C++11 特性使用的实例,每次补上几个,从一开始就要求自己使用C++11</em></p><h3 id="1-long-long类型"><a href="#1-long-long类型" class="headerlink" title="1. long long类型"></a>1. long long类型</h3><p>其实就是个类型扩展,没啥意思,C中也引入了,C11中</p><h3 id="2-列表初始化"><a href="#2-列表初始化" class="headerlink" title="2. 列表初始化"></a>2. 列表初始化</h3><p>这个之前比较鸡肋,现在C++11全面支持,我们可以这样用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">type a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">type <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">type a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><strong>使用列表初始化,最大的好处就是: 再出现丢失精度风险的时候,会报warning</strong></p><p>当然肯定不止这么一点,我们后面再说</p><h3 id="3-nullptr常量"><a href="#3-nullptr常量" class="headerlink" title="3. nullptr常量"></a>3. nullptr常量</h3><p>这个是为了C++11 全面兼容,0 效果一般,不明显, NULL需要&lt; cstdlib &gt;支持,不如直接使用nullptr </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;  <span class="comment">// declare a null pointer</span></span><br></pre></td></tr></table></figure><h3 id="4-constexpr变量"><a href="#4-constexpr变量" class="headerlink" title="4. constexpr变量"></a>4. constexpr变量</h3><p>在确定会是常量时,我们使用constexpr,来让编译器进行检测,一般只能用静态区变量/表达式初始化.</p><p>因为堆栈上的变量,地址未分配,编译期不能确定.后面还会有constexpr函数出现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">4</span>, b = <span class="number">5</span>;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>要求,必须足够简单,能够在编译期确定值</p><h3 id="5-类型别名说明符-auto自动类型推导-decltype类型指示符"><a href="#5-类型别名说明符-auto自动类型推导-decltype类型指示符" class="headerlink" title="5. 类型别名说明符, auto自动类型推导, decltype类型指示符"></a>5. 类型别名说明符, auto自动类型推导, decltype类型指示符</h3><p>这三个家伙是为了同一目的的.</p><p><code>using</code>只是半个<code>typedef</code>的替代品,完全一致</p><p><code>auto</code>, <code>decltype</code>前面已经详细说过,就看看怎么用吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">using</span> Node = struct node;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.begin(), i != vec.end(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省得写 std::vector&lt;int&gt;::iterator it = vec.begin();</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((a)) b = a;   #=&gt; b#=&gt; <span class="keyword">int</span> &amp;</span><br></pre></td></tr></table></figure><p>最后再给大家两个建议:</p><ol><li><p>多去外面的世界看看,挺好的</p></li><li><p>多用IDE,类型推导不明确时,鼠标放上去就行了,Vim还没有这种功能</p></li><li><p>typeid(var).name(), 输出的结果真的是俄式踏马的瓜皮…</p></li></ol><hr><p>这次我们就先说到这里,C++还是很有意思的,就是内容太多了.</p><p>现在还是要爆肝,一般也就在是在迷糊的时候写博客</p><p>不然,哪有那么多时间,E3期间,就等大法放大招好吧.</p><p>他要是放大招,我就,我就 立马买张25仔:完全版 庆祝一下.</p><p>June 11, 2018 12:20 AM</p>]]></content>
    
    <summary type="html">
    
      C++ Primer第二章,有感
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="C++Primer" scheme="http://evil-crow.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>Linux x86_64系统调用的实现过程</title>
    <link href="http://evil-crow.github.io/2018/06/07/TLPI/syscall/"/>
    <id>http://evil-crow.github.io/2018/06/07/TLPI/syscall/</id>
    <published>2018-06-07T14:10:00.000Z</published>
    <updated>2018-07-28T04:14:12.663Z</updated>
    
    <content type="html"><![CDATA[<p><em>由于系统调用的分析实现其中涉及一些内核/OS方面的知识,不是十分重要的,我们不进行详细说明</em></p><p><em>另外, 此分析,基于glibc-2.26以及Linux-Kernel-4.17,可以获取相关源码阅读</em></p><p>从我们以往的理解上来看,系统调用就是使用OS提供的接口,不也就是调用么?</p><p>System Call涉及了用户/内核态的切换,有些是需要进入内核态完成的,所以系统调用的存在就很有必要</p><p>更重要的一点就是: <strong>使用系统调用,仅仅暴露接口,保证了内核不会被无意/恶意破坏</strong></p><p>下面我们开始具体的系统调用实现分析:</p><h2 id="一-从使用一个系统调用开始"><a href="#一-从使用一个系统调用开始" class="headerlink" title="一, 从使用一个系统调用开始"></a>一, 从使用一个系统调用开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/tmp/file"</span>, O_RDONLY, <span class="keyword">mode_t</span> mode);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">do_something(errno);</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面便是一个简单地使用系统调用的例子,使用了open(系统调用)</p><p>那么下一步, <strong>就是,open()函数的实现到底在哪里呢?</strong></p><p>有两种方法查看:</p><h3 id="1-使用GDB单步进入"><a href="#1-使用GDB单步进入" class="headerlink" title="1. 使用GDB单步进入"></a>1. 使用GDB单步进入</h3><p>这个时候,GDB的Step指令就十分重要了,对于open(),函数它可以单步进入啊!</p><p>这不就很明显的看出<code>open()</code>实现在哪里了?</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/gdb_s.png" alt="gdb step指令"></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/locate.png" alt="locate 确定文件位置"></p><p>如上</p><h3 id="2-合理推测-ಡωಡ"><a href="#2-合理推测-ಡωಡ" class="headerlink" title="2. 合理推测(ಡωಡ)"></a>2. 合理推测(ಡωಡ)</h3><p>我们使用的系统调用都是C实现,而在Linux平台下,使用最多的是GNU C,依赖的libc库为glibc</p><p>(PS: 上面是我的本机环境,各位可以根据自己的机器环境去C库进行实现的查找)</p><p>见我们的实现依赖于glibc,那么去C可查找理所当然了</p><p>然后使用查找关键字的方法就定位到open64.c上了</p><p><strong>此处,有一个巨坑,关于/usr/src/debug/, 这个里面glibc不全啊</strong></p><p><strong>只是为了调试需要,所集成的一部分glibc实现,同时需要注意我们使用的C库一般都是发行版提供</strong></p><p><strong>需要去看glibc源码才能真正看清楚</strong></p><h2 id="二-分析一个系统调用的源码"><a href="#二-分析一个系统调用的源码" class="headerlink" title="二, 分析一个系统调用的源码"></a>二, 分析一个系统调用的源码</h2><p>那么,现在就来刺激的了,分析系统调用的源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sysdeps/unix/sysv/linux/open64.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copyright (C) 1991-2018 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">   This file is part of the GNU C Library.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">   modify it under the terms of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License as published by the Free Software Foundation; either</span></span><br><span class="line"><span class="comment">   version 2.1 of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The GNU C Library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">   Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License along with the GNU C Library; if not, see</span></span><br><span class="line"><span class="comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sysdep-cancel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;not-cancel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OFF_T_MATCHES_OFF64_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTRA_OPEN_FLAGS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTRA_OPEN_FLAGS O_LARGEFILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,</span></span><br><span class="line"><span class="comment">   a third argument is the file protection.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line"> mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strong_alias (__libc_open64, __open64)</span><br><span class="line">libc_hidden_weak (__open64)</span><br><span class="line">weak_alias (__libc_open64, open64)</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !IS_IN (rtld)</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__open64_nocancel (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">    &#123;</span><br><span class="line">      va_list arg;</span><br><span class="line">      va_start (arg, oflag);</span><br><span class="line">      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line">      va_end (arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line">      mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">strong_alias (__libc_open64, __open64_nocancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">libc_hidden_def (__open64_nocancel)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OFF_T_MATCHES_OFF64_T</span></span><br><span class="line">strong_alias (__libc_open64, __libc_open)</span><br><span class="line">strong_alias (__libc_open64, __open)</span><br><span class="line">libc_hidden_weak (__open)</span><br><span class="line">weak_alias (__libc_open64, open)</span><br><span class="line"></span><br><span class="line">strong_alias (__open64_nocancel, __open_nocancel)</span><br><span class="line">libc_hidden_weak (__open_nocancel)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><em>备注: 在本目录下,其实是有4个于open()有关的文件,分别是open.c,open64.c, openat.c, openat64.c</em></p><p><em>但是,事实上他们是指不同层次,不同平台上的系统调用,剥开之后,最后都是openat()函数</em></p><p><em>但是,我本机是64为,所以是封装的64位openat()函数文件,即open64.c</em></p><p>我们可以一行一行分析这个函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function open() -&gt; __libc_open64()</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">int</span></span><br><span class="line"><span class="number">2</span> __libc_open64 (<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> oflag, ...)</span><br><span class="line"><span class="number">3</span> &#123;</span><br><span class="line"><span class="number">4</span>   <span class="keyword">int</span> mode = <span class="number">0</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>   <span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line"><span class="number">7</span>     &#123;</span><br><span class="line"><span class="number">8</span>       va_list arg;</span><br><span class="line"><span class="number">9</span>       va_start (arg, oflag);</span><br><span class="line"><span class="number">10</span>      mode = va_arg (arg, <span class="keyword">int</span>);</span><br><span class="line"><span class="number">11</span>      va_end (arg);</span><br><span class="line"><span class="number">12</span>    &#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span>  <span class="keyword">return</span> SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS,</span><br><span class="line"><span class="number">15</span> mode);</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> strong_alias (__libc_open64, __libc_open)</span><br><span class="line"><span class="number">18</span> strong_alias (__libc_open64, __open)</span><br><span class="line"><span class="number">19</span> libc_hidden_weak (__open)</span><br><span class="line"><span class="number">20</span> weak_alias (__libc_open64, open)</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> strong_alias (__open64_nocancel, __open_nocancel)</span><br><span class="line"><span class="number">23</span> libc_hidden_weak (__open_nocancel)</span><br></pre></td></tr></table></figure><p><em>上面的C是典型的GNU风格,两个空格,看的我想打人,写惯了K&amp;R C的人表示脑子疼</em></p><p>6 ~ 8行就是简单的参数判断,我们可以略过</p><p>其实你可能会奇怪,好端端的<code>open()</code>,系统调用怎么变成了,<code>__libc_open64()</code></p><p><strong>注意17 ~ 23行的宏,他们将别名实现为了宏,事实上,调用open(),就是__libc_open64()</strong></p><p>那么,重心来了,就是14行,它实现了,<code>SYSCALL_CANCEL</code>宏来进行操作</p><p>看到这里,这一部分文件就足够了,我们已经知道了<code>__libc_open64()</code>只是一个warpper function了</p><p>这便是TLPI中第一部分的,Warpper函数</p><h2 id="三-Warpper-Function如何Warpper"><a href="#三-Warpper-Function如何Warpper" class="headerlink" title="三,Warpper Function如何Warpper"></a>三,Warpper Function如何Warpper</h2><p>我们要去看warpper function如何工作,也就是去看它是如何进行封装,并且完成用户/系统态切换的</p><p>首先,Warrpper的过程,各个平台上都应该是一致的,所以我们去看,sysdeps/unix/sysdeps.h</p><p>这个文件中都是宏定义,那么,我们就一步一步来吧,我将宏定义的顺序整理了一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort the macros 已知 SYSCALL_CANCEL</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_CANCEL(...) \</span></span><br><span class="line">  (&#123;     \</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> sc_ret;     \</span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)      \</span><br><span class="line">      sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);      \</span><br><span class="line">    <span class="keyword">else</span>     \</span><br><span class="line">      &#123;     \</span><br><span class="line"><span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC ();     \</span><br><span class="line">sc_ret = INLINE_SYSCALL_CALL (__VA_ARGS__);     \</span><br><span class="line">        LIBC_CANCEL_RESET (sc_cancel_oldtype);     \</span><br><span class="line">      &#125;     \</span><br><span class="line">    sc_ret;     \</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">(&#123; <span class="keyword">long</span> <span class="keyword">int</span> sc_ret; <span class="keyword">if</span> (SINGLE_THREAD_P) sc_ret = INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); <span class="keyword">else</span> &#123; <span class="keyword">int</span> sc_cancel_oldtype = LIBC_CANCEL_ASYNC (); sc_ret = INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode); LIBC_CANCEL_RESET (sc_cancel_oldtype); &#125; sc_ret; &#125;);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INLINE_SYSCALL_CALL(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_DISP(b,...) \</span></span><br><span class="line">  __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL__INLINE_SYSCALL_NARGS(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode)(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS(...) \</span></span><br><span class="line">  __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)</span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL__INLINE_SYSCALL_NARGS_X (openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,)(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span></span><br><span class="line"><span class="comment">// 这是最神奇的宏,一个计数宏,计算参数的宏</span></span><br><span class="line"></span><br><span class="line">+------------------------+</span><br><span class="line">__INLINE_SYSCALL4(openat, AT_FDCWD, file, oflag | EXTRA_OPEN_FLAGS, mode);</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_CONCAT_X(a,b)     a##b</span></span><br></pre></td></tr></table></figure><p>所以,同一处理后,获取到的是<code>__INLINE_SYSCALLn(name, arguments...); [n个参数]</code></p><p>然后用同文件下的宏继续处理后,可以获取到 <code>INLINE_SYSCALL (name, nr, arguments...);</code></p><p>既然我们分析的是x86_64平台上系统调用的实现,那么我们就去x86_64下找东西吧</p><p>下面找得到的就是具体的上述宏平台上的依赖实现了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysdeps/unix/sysv/linux/x86_64/sysdeps.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL(name, nr, args...) \</span></span><br><span class="line">  (&#123;      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL (name, , nr, args);      \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))      \</span><br><span class="line">      &#123;      \</span><br><span class="line">__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));      \</span><br><span class="line">resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define a macro with explicit types for arguments, which expands inline</span></span><br><span class="line"><span class="comment">   into the wrapper code for a system call.  It should be used when size</span></span><br><span class="line"><span class="comment">   of any argument &gt; size of long int.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> INLINE_SYSCALL_TYPES</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INLINE_SYSCALL_TYPES(name, nr, args...) \</span></span><br><span class="line">  (&#123;      \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar = INTERNAL_SYSCALL_TYPES (name, , nr, args);  \</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (resultvar, )))      \</span><br><span class="line">      &#123;      \</span><br><span class="line">__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));      \</span><br><span class="line">resultvar = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">-1</span>;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INTERNAL_SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL(name, err, nr, args...)\</span></span><br><span class="line">internal_syscall#<span class="meta">#nr (SYS_ify (name), err, args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> INTERNAL_SYSCALL_NCS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SYSCALL_NCS(number, err, nr, args...)\</span></span><br><span class="line">internal_syscall#<span class="meta">#nr (number, err, args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall0(number, err, dummy...)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall1(number, err, arg1)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall2(number, err, arg1, arg2)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall3(number, err, arg1, arg2, arg3)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall4(number, err, arg1, arg2, arg3, arg4)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall5(number, err, arg1, arg2, arg3, arg4, arg5)\</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg5, __arg5) = ARGIFY (arg5); \</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg5, _a5) <span class="keyword">asm</span> (<span class="string">"r8"</span>) = __arg5;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),\</span><br><span class="line">      <span class="string">"r"</span> (_a5)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> internal_syscall6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_syscall6(number, err, arg1, arg2, arg3, arg4, arg5, arg6) \</span></span><br><span class="line">(&#123;\</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> resultvar;\</span><br><span class="line">    TYPEFY (arg6, __arg6) = ARGIFY (arg6); \</span><br><span class="line">    TYPEFY (arg5, __arg5) = ARGIFY (arg5); \</span><br><span class="line">    TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span><br><span class="line">    TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span><br><span class="line">    TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span><br><span class="line">    TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg6, _a6) <span class="keyword">asm</span> (<span class="string">"r9"</span>) = __arg6;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg5, _a5) <span class="keyword">asm</span> (<span class="string">"r8"</span>) = __arg5;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg4, _a4) <span class="keyword">asm</span> (<span class="string">"r10"</span>) = __arg4;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg3, _a3) <span class="keyword">asm</span> (<span class="string">"rdx"</span>) = __arg3;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg2, _a2) <span class="keyword">asm</span> (<span class="string">"rsi"</span>) = __arg2;\</span><br><span class="line">    <span class="keyword">register</span> TYPEFY (arg1, _a1) <span class="keyword">asm</span> (<span class="string">"rdi"</span>) = __arg1;\</span><br><span class="line">    <span class="keyword">asm</span> <span class="keyword">volatile</span> (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),\</span><br><span class="line">      <span class="string">"r"</span> (_a5), <span class="string">"r"</span> (_a6)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL);\</span><br><span class="line">    (<span class="keyword">long</span> <span class="keyword">int</span>) resultvar;\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>此文件内容超多,所以我们只截取其中重要的部分</strong></p><p>我们可以看到下面这样的实现流程:</p><p><code>INLINE_SYSCALL(name, nr, args...)</code> -&gt; <code>INTERNAL_SYSCALL(name, ,nr, args)</code> -&gt;</p><p><code>internal_syscall##nr (SYS_ify (name), err, args);</code></p><p>下面就是具体对应不同参数的函数实现了,其中实现了,产生软中断,进入内核态,然后参数入寄存器,传参</p><p>那么,这一些列函数中我们可以看到:</p><p><strong>参数只能是6个,可以传递7个参数,一个是系统调用名,是吗? 错的,传递的参数只是建议范围内为7个</strong></p><p><strong>其余的呢? 入栈, Register参数就7个罢了</strong></p><p>我们来具体看看函数实现,尤其是其中的内联汇编部分(其实我汇编很烂,Intel都不行,ATT就更不多说了)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (\</span><br><span class="line">    <span class="string">"syscall\n\t"</span>\</span><br><span class="line">    : <span class="string">"=a"</span> (resultvar)\</span><br><span class="line">    : <span class="string">"0"</span> (number), <span class="string">"r"</span> (_a1), <span class="string">"r"</span> (_a2), <span class="string">"r"</span> (_a3), <span class="string">"r"</span> (_a4),\</span><br><span class="line">      <span class="string">"r"</span> (_a5), <span class="string">"r"</span> (_a6)\</span><br><span class="line">    : <span class="string">"memory"</span>, REGISTERS_CLOBBERED_BY_SYSCALL)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其他的不多说,其中最重要的就是, <code>&quot;syscall\n\t&quot;</code>这个东西了</p><blockquote><p>在32位机上,使用<code>int 0x80</code> 第128中断号,陷入内核,进行系统调用</p></blockquote><blockquote><p>在ARM上,使用<code>swi</code>执行陷入内核</p></blockquote><blockquote><p>唯独少有人说x86_64平台上的软中断,也就是<code>syscall</code>中断向量</p></blockquote><p>你没有听错,这个B就是叫syscall中断vector,qtmd,看了我半天</p><p><em>不过这也是我内核基础不扎实的恶果,深感惭愧</em></p><p>至此,Warpper function的任务顺利完成,下来就需要切换到内核态处理了.</p><p>我们接下来就得看LinuxKernel的代码了</p><h2 id="四-关于中断的小了解"><a href="#四-关于中断的小了解" class="headerlink" title="四,关于中断的小了解"></a>四,关于中断的小了解</h2><p>中断是在引入保护模式(protect mode)之后很重要的一个特性,以此来陷入内核,进入内核态</p><p><strong>一般的fault,会重复指令,syscall会vector+1, 执行下一条</strong></p><p><em>此处,中断的内容,同样是Kernel重要知识,当然我还是不够清楚,不能清晰地翻出汇编指令解析</em></p><p><em>但是,syscall的流程还是比较清楚的</em></p><p>首先,来看内核的中断处理例程</p><p>既然是64位,肯定看arch/x86/entry/entry_64.S</p><p>简单说一下,entry这几个文件</p><blockquote><p>entry_32.S是32位机使用的</p></blockquote><blockquote><p>entry_64.S是64位机使用的,但是说实话,很像是拼凑的,凌乱不堪,就在32基础上改得,32看着十分清晰</p></blockquote><blockquote><p>entry_64_compat.S 是兼容的,在64位机器上按照32的形式运行,用的是32位的接口</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64_trampoline)</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">movq</span>$entry_SYSCALL_64_stage2, %rdi</span><br><span class="line">JMP_NOSPEC %rdi</span><br><span class="line">END(entry_SYSCALL_64_trampoline)</span><br><span class="line"></span><br><span class="line"><span class="meta">.popsection</span></span><br><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64_stage2)</span><br><span class="line">UNWIND_HINT_EMPTY</span><br><span class="line">popq%rdi</span><br><span class="line"><span class="keyword">jmp</span>entry_SYSCALL_64_after_hwframe</span><br><span class="line">END(entry_SYSCALL_64_stage2)</span><br><span class="line"></span><br><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">swapgs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">movq</span>%rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"><span class="keyword">movq</span>PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq$__USER_DS/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">pushqPER_CPU_VAR(rsp_scratch)/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">pushq%r11/* pt_regs-&gt;flags */</span><br><span class="line">pushq$__USER_CS/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">pushq%rcx/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line"><span class="meta">GLOBAL</span>(entry_SYSCALL_64_after_hwframe)</span><br><span class="line">pushq%rax/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line"></span><br><span class="line">TRACE_IRQS_OFF</span><br><span class="line"></span><br><span class="line">/* IRQs are off. */</span><br><span class="line"><span class="keyword">movq</span>%rax, %rdi</span><br><span class="line"><span class="keyword">movq</span>%rsp, %rsi</span><br><span class="line"><span class="keyword">call</span>do_syscall_64/* returns with IRQs disabled */</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line">END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure><p>其中删去了很多内容,但是整个思路是:</p><ol><li><p>去中断向量表查看中断偏移量(很惭愧,没找到),</p></li><li><p>对应的entry_64.S进行section的调用</p></li><li><p>对于syscall就是调用到了(其中还有两个函数被我删掉了,仅保留了核心)<code>entry_SYSCALL_64</code></p><p><em>其中ENTRY(), END(),都是宏用来进符号表中的函数声明</em></p></li><li><p>在<code>entry_SYSCALL_64</code>中调用了<code>do_syscall_64()</code></p></li></ol><p><code>do_syscall_64()</code>这是一个外部函数,在common.c中的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/x86/entry/common.c</span></span><br><span class="line"></span><br><span class="line">__<span class="function">visible <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">enter_from_user_mode();</span><br><span class="line">local_irq_enable();</span><br><span class="line">ti = current_thread_info();</span><br><span class="line"><span class="keyword">if</span> (READ_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY)</span><br><span class="line">nr = syscall_trace_enter(regs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NB: Native and x32 syscalls are dispatched from the same</span></span><br><span class="line"><span class="comment"> * table.  The only functional difference is the x32 bit in</span></span><br><span class="line"><span class="comment"> * regs-&gt;orig_ax, which changes the behavior of some syscalls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nr &amp;= __SYSCALL_MASK;</span><br><span class="line"><span class="keyword">if</span> (likely(nr &lt; NR_syscalls)) &#123;</span><br><span class="line">*nr = array_index_nospec(nr, NR_syscalls);</span><br><span class="line">*regs-&gt;ax = sys_call_table[nr](regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中标上*的两句就是最重要的,它会去sys_call_table[]全局例程调用表中查找我们想要调用的例程</p><p>为什么有这样的机制呢?</p><p>因为中断号页只有255,所有的系统调用共享syscall对应的入口,所以我们需要一个数组</p><p><strong>在都进入内核态之后,根据每个系统调用的唯一编号来进行唯一标识与识别</strong></p><p>这个编号的确定,是有各种各样的宏确定的,<strong>同时要保证LinuxKernel与glibc的编号一致,</strong></p><p>我们可以来看这两个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/include/asm/unistd_64.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line">.........</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>确定好编号后,就可以访问指定函数的地址了</p><h2 id="五-真正的系统调用实现"><a href="#五-真正的系统调用实现" class="headerlink" title="五,真正的系统调用实现"></a>五,真正的系统调用实现</h2><p>我们可以查看此文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /include/linux/syscalls.h</span></span><br><span class="line"><span class="comment">// 此文件实现了所有系统调用的声明以及SYSCALL_DEFINEx宏</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)\</span></span><br><span class="line">asmlinkage <span class="keyword">long</span> sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span></span><br><span class="line">__attribute__((alias(__stringify(__se_sys##name))));\</span><br><span class="line">ALLOW_ERROR_INJECTION(sys##name, ERRNO);\</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line">asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));\</span></span><br><span class="line">asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__))\</span></span><br><span class="line">&#123;\</span><br><span class="line"><span class="keyword">long</span> ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="line">__MAP(x,__SC_TEST,__VA_ARGS__);\</span><br><span class="line">__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\</span><br><span class="line"><span class="keyword">return</span> ret;\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line"><span class="comment">/* fs/eventfd.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_eventfd2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fs/eventpoll.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">struct epoll_event __user *event)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">sigset_t</span> __user *sigmask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> sigsetsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fs/fcntl.c */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_dup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fildes)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_dup3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> oldfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> newfd, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fcntl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_fcntl64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>经常看到其他文档上说到sys_open()是入口,这其实都是早期的说法,实际上,是由宏生成真正的函数定义</p><p>同时我们可以根据,此文件中的注释,找到根本意义上的Syscall定义,比如<code>epoll_ctl()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following function implements the controller interface for</span></span><br><span class="line"><span class="comment"> * the eventpoll file that enables the insertion/removal/change of</span></span><br><span class="line"><span class="comment"> * file descriptors inside the interest set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="keyword">int</span> full_check = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">error = -EBADF;</span><br><span class="line">f = fdget(epfd);</span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line">................</span><br></pre></td></tr></table></figure><p><strong>上述即为真真正正最底层,最底层<code>epoll_ctl()</code>的实现</strong></p><p><strong>至此,我们便真正追踪到了,系统调用的实现了,其他系统调用的源码,查看方法同理</strong></p><h2 id="六-扩展阅读"><a href="#六-扩展阅读" class="headerlink" title="六,扩展阅读"></a>六,扩展阅读</h2><p><a href="https://my.oschina.net/fileoptions/blog/908682" target="_blank" rel="noopener">关于ARM实现</a></p><p><a href="https://zhuanlan.zhihu.com/c_144857088" target="_blank" rel="noopener">关系不大,但有价值的glibc分析(脚本Warpper)</a></p><p>书籍推荐: &lt; Linux内设设计与实现 &gt;        (PS: 虽然是基于2.6.32,但还是很有意义)</p><h2 id="其他的一些闲杂事情"><a href="#其他的一些闲杂事情" class="headerlink" title="其他的一些闲杂事情"></a>其他的一些闲杂事情</h2><p>主要还是最近烦,感觉自己要玩了(beibei狗),看TLPI,突发奇想,想看看syscall的真正实现</p><p>但是网上都是ARM,X86是实现(2.6.32),没有X86_64,4版本内核的实现</p><p>于是乎我决定来稿一搞</p><p>但是自身水平又不行,所以也比较磕绊,其实分析也是不完整的</p><p>最后,系统调用的退出,如何添加自己的系统调用这些内容都是不全面的</p><p><strong>还是自己学习不扎实,后面落实后会补充的,起码这两天干的事,还是挺有意义的</strong></p><p><em>接下来,回归主要任务,TLPI作为辅修,是时候C3P就绪了</em></p><p><strong>虽然很烦,但还是那句话:</strong></p><blockquote><p>生命转瞬即逝, 没时间丧,Fighting!</p></blockquote><p>June 8, 2018 2:00 AM</p>]]></content>
    
    <summary type="html">
    
      在看TLPI的时候,虽然重要的是系统调用的接口使用,但是系统调用到底是怎么一回事? 虽然有点小题大做,但是还是十分重要的,网上的大多数材料提到的也是Linux在ARM的分析实现,由于我自己使用的是x86_64, 所以还是来看看Linux Syscall的具体实现吧
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://evil-crow.github.io/categories/Unix-Linux/"/>
    
    
      <category term="Syscall" scheme="http://evil-crow.github.io/tags/Syscall/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊C中的异常处理</title>
    <link href="http://evil-crow.github.io/2018/06/04/C/Expert_C_Programming/error_jmp/"/>
    <id>http://evil-crow.github.io/2018/06/04/C/Expert_C_Programming/error_jmp/</id>
    <published>2018-06-03T16:02:00.000Z</published>
    <updated>2018-09-13T14:54:20.167Z</updated>
    
    <content type="html"><![CDATA[<p><em>所谓异常处理机制,其实就是处理程序可能会发生地错误.</em></p><p><em>那么,我们的主要步骤也就是两个: 抓取异常, 处理异常</em></p><p><em>C++中我们使用throw(抛出异常)以及catch(捕获及处理异常)</em></p><p><em>C中我们使用longjmp()来进行抛出, setjmp()来处理异常</em></p><h2 id="一-setjmp-与longjmp"><a href="#一-setjmp-与longjmp" class="headerlink" title="一, setjmp()与longjmp()"></a>一, setjmp()与longjmp()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数使用来实现非本地跳转的,即”non local gotos”</p><p><em>将执行从一个函数转移到一个函数在另一个函数中的预定位置,setjmp()函数动态的建立将要控制的目标</em></p><p><em>而longjmp()函数执行转移</em></p><p><strong>我们说setjmp()函数用来建立将要控制的目标,那他怎么建立呢?</strong></p><p>通过查看man文档以及 /usr/include/setjmp.h可知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/setjmp.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/setjmp.h&gt;        /* Get '__jmp_buf'.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/types/__sigset_t.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Calling environment, plus possibly a saved signal mask.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">NOTE:</span> The machine-dependent definitions of `__sigsetjmp'</span></span><br><span class="line"><span class="comment">       assume that a `jmp_buf' begins with a `__jmp_buf' and that</span></span><br><span class="line"><span class="comment">       `__mask_was_saved' follows it.  Do not move these members</span></span><br><span class="line"><span class="comment">       or add others before it.  */</span></span><br><span class="line">    __jmp_buf __jmpbuf;     <span class="comment">/* Calling environment.  */</span></span><br><span class="line">    <span class="keyword">int</span> __mask_was_saved;   <span class="comment">/* Saved the signal mask?  */</span></span><br><span class="line">    <span class="keyword">__sigset_t</span> __saved_mask;    <span class="comment">/* Saved signal mask.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的结构体成员,分别是调用环境(保存堆栈指针, 指令等), 是否保存标志位的标志, 保存的信号掩码</span></span><br><span class="line"><span class="comment">// 而且,注释严重声明: 前两个成员是不能互相交换位置的.</span></span><br><span class="line"><span class="comment">// 如果要详细查看__jmp_buf 可以去看/usr/include/bits/setjmp.h</span></span><br></pre></td></tr></table></figure><p>即: setjmp()的参数,jmp_buf实际上就是保存现场的,而longjmp()就是用来恢复现场的.</p><p><strong>保存现场,就是保存活动记录…</strong></p><p>其中sigsetjmp(), siglongjmp(), 即可以理解为signal-setjmp(), signal-longjmp()</p><p><em>只是额外提供了对进程信号的可预测处理, 在此不表,用法与non-signal版本差不多,不多说</em></p><p><strong>介绍了这么多,那么这两个函数如何使用呢?</strong></p><p>我们可以从他们的返回值入手</p><p><strong>setjmp()直接返回值,也就是第一次调用为0, 之后longjmp()无返回值,但是longjmp()的参数val</strong></p><p><strong>作为setjmp()第二次之后的返回值, 若未指定val,setjmp()之后返回的不是0, 而是1</strong></p><p><strong>但是,setjmp() + longjmp()的严重问题是,他也不能随意跳转,只能是setjmp()保存过活动记录的地方</strong></p><p><em>其实有过C++经验的,可以勉强将setjmp(), 看成try字句</em></p><h2 id="二-Notes"><a href="#二-Notes" class="headerlink" title="二, Notes:"></a>二, Notes:</h2><p>1&gt; 注意</p><p>其中需要注意的是,jmp系列函数是通过保存现场来实现非本地跳转的,其中需要注意的一点就是:</p><p><strong>编译器会将变量优化为寄存器变量,所以在调用longjmp()之后,自动变量的值是未指定的</strong></p><p><strong>为什么这样讲, 因为你使用longjmp()的时候,jmp_buf的内容被销毁</strong></p><p><strong>所以自动变量(存在register中)的就凉凉了</strong></p><p>如果满足下面的条件:</p><ol><li><p>相应的setjmp()函数是局部的</p></li><li><p>自动变量值在setjmp()以及longjmp()之间发生了变化</p></li><li><p>变量没有被声明为volatile (反之,也就是说变量声明为volatile就不会被优化至寄存器)</p></li></ol><p><strong>则我们要求使用siglongjmp()函数</strong></p><p>2&gt; 可读性分析</p><p>关于可读性是一个大问题, 尽管non-local gotos可以被随意使用, 但是相比于local gotos,</p><p><strong>goto字句,起码还有goto语句以及label的提示啊</strong></p><p>但是,jmp函数,甚至多个longjmp()共享同一个jmp_buf变量进行操作</p><p>另外有一点: 甚至setjmp()以及longjmp()不在同一个文件模块中</p><p><strong>所以,我们建议除非迫不得已,请使用其他的替代方案</strong></p><p>3&gt; 警告</p><ol><li><p>如调用一个函数,此函数调用了setjmp(),却在longjmp()之前返回,那么它的行为是未定义的</p></li><li><p>在多线程程序中, 如果一个longjmp()函数使用了不同线程中的jmp_buf,那么它的行为同样是未定义的</p></li></ol><p>此外,讨论的一些,非异步信号安全函数,此处暂时不涉及,不清楚,之后有机会会填坑</p><h2 id="三-non-local-gotos的例子"><a href="#三-non-local-gotos的例子" class="headerlink" title="三, non-local gotos的例子"></a>三, non-local gotos的例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"set.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret_val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret_val = setjmp(jmp)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Back to main.c and ret_val is %d\n"</span>, ret_val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"First time through\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The ret_val: %d\n"</span>, ret_val);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SET_H          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt; </span></span></span><br><span class="line">jmp_buf jmp;     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;            </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"set.h"</span>               </span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span>                </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is set.c\n"</span>); </span><br><span class="line">    longjmp(jmp, <span class="number">4</span>);           </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YOu can't get here!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下,大家看了代码基本就懂了:</p><p><img src="http://p8uroi1uf.bkt.clouddn.com/jmp.png" alt="./a.out"></p><h2 id="四-Linux内核的错误处理"><a href="#四-Linux内核的错误处理" class="headerlink" title="四, Linux内核的错误处理"></a>四, Linux内核的错误处理</h2><p>大家可以去看看代码,实际上内核的错误处理是使用多重goto来实现的</p><p>比较下面两种形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error1) &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error2) &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_something();</span><br><span class="line"><span class="keyword">if</span> (error1)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"><span class="keyword">if</span> (error2)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">do_something();</span><br></pre></td></tr></table></figure><p><strong>很明显的可以看出,第二种的做法着实方便,提高了程序设计的维度,不会影响设计的重心</strong></p><p><strong>将错误处理集中在其他地方</strong></p><p>June 4, 2018 8:57 PM</p>]]></content>
    
    <summary type="html">
    
      今天在了解C++中的异常机制的时候,想起来C中实际上也是存在异常处理的,只不过我们平时用的比较少而已,而C中的异常处理机制,主要依赖于setjmp()以及longjmp()这两个函数,下面我们来看看这两个函数的用法,以及Linux内核中的异常处理机制
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="Expert_C_Programming" scheme="http://evil-crow.github.io/tags/Expert-C-Programming/"/>
    
  </entry>
  
  <entry>
    <title>&lt;咸鱼书&gt; 链接那点事</title>
    <link href="http://evil-crow.github.io/2018/05/30/C/Expert_C_Programming/c_link/"/>
    <id>http://evil-crow.github.io/2018/05/30/C/Expert_C_Programming/c_link/</id>
    <published>2018-05-30T13:58:00.000Z</published>
    <updated>2018-09-27T15:14:05.131Z</updated>
    
    <content type="html"><![CDATA[<p><em>编译系统很早就接触了,但是编译系统中到底干了什么?</em></p><p><em>我们今天来着重看一看链接的那点事</em></p><h2 id="1-编译系统"><a href="#1-编译系统" class="headerlink" title="1. 编译系统"></a>1. 编译系统</h2><p>首先,来看那一看编译系统都干了什么:</p><p><img src="http://oz3e8fi42.bkt.clouddn.com/complier_system.png" alt="编译系统"></p><p>而我们今天着重来说的就是: <strong>链接</strong>的过程</p><h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h2><p>链接到底发生了什么?</p><p>我们都知道,在汇编器作用完成后, 汇编文件.s被转化成为目标文件(可重定位的目标文件).o</p><p>.o文件是已经编译,优化二进制文件,只要成功进行装配就可以了.</p><p>软件开发的工程浩大,如果所有的内容都是自己从头开始编写,势必力不从心,难以维系</p><p>所以,我们倡导多使用库,对于一些基础内容,已经编译好的库,我们直接去链接即可.</p><p>这也就是,我们今天来讨论链接内容的原因.</p><p>首先,我们要明确一个概念: <strong>所谓链接,其中重要的有两点: 1.链接方式, 2. 链接时机</strong></p><p>这两点就是链接中最核心的内容.</p><p>我们先来从链接方式说起.</p><h2 id="3-静态链接"><a href="#3-静态链接" class="headerlink" title="3. 静态链接"></a>3. 静态链接</h2><p>C从很早就支持分离式编译,这个特性在C++中也支持,即是说,对于一个大型软件</p><p><strong>只要分块得当,大家完全可以分离式开发,最后进行模块的装配即可</strong></p><p>链接也是这样一个道理, 但是,链接去装拼的是函数库.</p><p>比如我们整天使用的C库,很多C库会默认链接 libc.so -&gt; libc.so.6</p><p><strong>因为是最基础的库,自动链接,而是我们平时不注意这些链接细节</strong></p><p>静态链接: </p><blockquote><p><strong>实际上说的就是, 链接库, 链接时,直接将需要的库一次性装入可执行文件</strong></p></blockquote><blockquote><p><strong>这样装配成功的可执行文件中包含了所需要库中函数实现的所有内容</strong></p></blockquote><blockquote><p><strong>比如说, 我调用printf, 静态链接了C库, 于是我的a.out中便包含了printf实现的所有目标文件</strong></p></blockquote><p> 那么,来分析一下静态链接的优缺点:</p><p> 优点: </p><ol><li><p>静态链接将库中所需要的内容直接装入可执行文件,使得可执行文件脱离静态库,即无需依赖库</p></li><li><p>因为装配的内容全部发生在链接时,所以运行时程序速度快,1% ~ 5% (相比于动态链接链接)</p></li></ol><p>缺点: 尽管静态链接有优秀的地方,但它的缺点也比较严重</p><ol><li><p>静态链接因为直接将每一个.o所需要的库文件装入, 他们相互之间不可见,于是相同的模块</p><p>甚至会悲壮在进入内存多次, 严重消耗了内存空间,举个简单的例子: printf若占0.2K, 一个大型程序</p><p>如果调用printf 2k次, 那么此可执行程序中,printf的内容就占了200KB的内容, 严重浪费内存</p><p>而且,这样的浪费情况,在早期的计算机系统中,甚至是致命的.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/static_link.png" alt="静态链接"></p><p>当然我们在分析后,发现了静态链接可能会造成在可执行文件中出现多份拷贝的问题,</p><p>早期的计算机如何如何处理呢? 是这样干的:</p><p><strong>他们将程序对于函数库的依赖实现在内核中,woc!, 这是个很严重的问题</strong></p><p><strong>会造成可怕的”内核膨胀”,后果不堪设想</strong></p><p>基于上面的问题,静态链接在特殊的历史时期还是比较有用的,但是现在,毫无疑问的过时了</p><p>所以,我们来介绍动态链接</p></li></ol><h2 id="4-动态链接"><a href="#4-动态链接" class="headerlink" title="4. 动态链接"></a>4. 动态链接</h2><p>首先,我们来说说为什么要有动态链接:</p><p><strong>1. 为了解决内存中重复库代码的问题,内核膨胀实际上是很危险的做法</strong></p><p><strong>2. 还是为了实现软件库更新迭代的便捷性</strong></p><p>我们先来说说动态链接,然后具体进行分析,并说说它如何解决上面其中的问题</p><p>动态链接:</p><blockquote><p><strong>首先,要明确的是, 动态链接是为了改进静态链接的.</strong></p></blockquote><blockquote><p><strong>我们首要解决的问题,便是多份库实现的拷贝问题,解法就是,维持一份拷贝</strong></p></blockquote><blockquote><p><strong>只要装入后在内存中维持一份库文件的拷贝,效率要好很多(隐含:链接后,a.out仅仅保留文件名)</strong></p></blockquote><blockquote><p><strong>(库文件的位置,符号表等内容,并未进行装入,推迟到运行时真正链接)</strong></p></blockquote><blockquote><p><strong>即是说,只要是在内存中维系了一份库文件拷贝的链接方式,便是动态链接</strong></p></blockquote><p>其实,我这里的说法和&lt; C专家编程 &gt; (“咸鱼书”) 还是不一样的.</p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/dynamic_pi.png" alt="动态链接"></p><p>因为下面我们就要说说链接的第二点了: 2. 装入时机</p><p>因为静态库已经过时(这说法也不全面)的问题,我们主要讨论动态链接</p><ol><li><p>装入时动态链接</p><p>如上所说,两种装入时机,第一种便是传统的装入时(Link期间)进行动态链接,</p><p>这个时候,链接器会进行查找,他会将目标文件中的所需要的库文件装入内存</p><p><strong>这就有一个问题了,有些模块的使用程度并不高: 尤其是错误处理模块</strong></p><p>动态链接的方式,可以有效的减少内存压力,但是利用率还是没有明显提升</p><p>错误模块仍然被装入,会导致,多个错误模块的装入但未使用的情况.</p><p><strong>而现在,十分流行的便是运行时动态链接(JIT Just-In-Time)的模式</strong></p></li><li><p>运行时动态链接</p><p>上面说到过,装入时动态链接,它的位置是可变的,可以是内存中任意位置.但是,结构是静态的</p><p><strong>即是说,装入多少模块,模块之间的顺序都是固定的.有的模块如果没有使用还是会浪费</strong></p><p>因此引入了运行时动态链接的方式: 装入时,不进行链接.一直将模块的链接推迟到运行时进行</p><p>(PS: 是不是有一种静态语言和动态语言的感觉,编译时/运行时确定类型,滑稽)</p><p>这样,如果需要错误处理模块,便由OS去寻找模块并装入,可以大大提高效率</p></li></ol><p>好了,常见的链接方式介绍完毕,我们再来比较一下这几种方式:</p><p>静态链接: </p><ul><li>在我们需要摆脱库依赖,而且程序对此库依赖程度小时使用,也就不会造成太多内存拷贝.</li></ul><p>动态链接: </p><ul><li><p>如果我们要经常调用某个库,我们便使用动态链接的形式,虽然说动态链接的运行都会变慢,</p><p>尤其是运行时动态链接,将链接时机推迟,但是另一方面会提高效率,(比其他两种更快的装入速度)</p><p><strong>可以说装入时动态链接基本上已经使用的很少了</strong></p></li></ul><p>上面是综合来讲,其实将链接方式和链接时机分开来说,也不过是这样:</p><ol><li><p>静态链接: 可以摆脱库依赖,重复拷贝多</p></li><li><p>动态链接: 仅维护一份共享拷贝,无法摆脱库依赖</p></li><li><p>静态装入: 位置是静态的,同时会将不一定运行的模块进行装入</p></li><li><p>动态装入: 绝不会装入任何一个不使用的模块,不过运行速度降低(在当今的机器配置下,都不是问题)</p></li></ol><h2 id="5-动态链接的优点"><a href="#5-动态链接的优点" class="headerlink" title="5. 动态链接的优点"></a>5. 动态链接的优点</h2><p>既然动态链接是目前的主流,我们就来看看动态链接的优点:</p><ol><li><p>生成的可执行文件小得多,因为具体模块的实现,并没有装入可执行文件中,是推迟到running是链接</p></li><li><p>因为进行推迟,所以装入速度很快,比起它链接方式都要快,的那是缺点就是理论上运行速度慢</p><p> 不过,这都不是事,在当下的计算机硬件水平下,堆配置就可以了(我游民老哥标配四路泰坦(ಡωಡ))</p></li></ol><blockquote><p>　动态链接重要的目的之一便是：　ABI(Application Binary Interface)应用程序二进制接口<br>　<br>　历史的经验表明: 软件版本的更新迭代,往往会出现严重的问题, 不兼容,各种各样的问题<br>　<br>　而且,每次进行新的库迭代,都要进行重新编译,(对于静态链接)<br>　<br>　这显然是他妈的操蛋,所以动态链接出现了,它要求操作系统提供一套二进制接口<br>　<br>　应用程序进行链接时,不去考虑器具体实现,只使用接口.<br>　<br>　是不是进行库版本的迭代,一下简单多了,我们甚至可以同时维护多个版本的库进行选择<br>　<br>　(PS: 是不是由了一点面向对象的感觉,ABI正是一种中间件,自然的处理了程序与库之间的关系)</p></blockquote><p>一般我们约定,库文件放在指定的位置,编译系统按照默认的规定去进行编译链接.但是,</p><p>我们还可以给编译器传参,(ಡωಡ) -I,-L,-l这些可不能白瞎了,还可以-Wl,-rpath=XXX 给链接器传参</p><p><em>此处,我们建议尽量只使用动态链接,因为这样,我们的版本更新十分方便,并且容错率高</em></p><p>说了这么多,静态链接库,动态链接库实体是什么样的呢?</p><p>静态链接库成为archive,使用ar生成 “XXX.a”</p><p>动态链接库,使用gcc或者ld生成(怀疑?),”libXXX.so.x.y.z”</p><h2 id="6-如何生成链接库"><a href="#6-如何生成链接库" class="headerlink" title="6. 如何生成链接库"></a>6. 如何生成链接库</h2><p><strong>首先,我们要严正声明,咸鱼书中的是基于SPARC上面的cc编译器</strong></p><p><strong>与我们日常在x86_64机器上使用的gcc/clang/msvc有很大不同,命令也是</strong></p><p><strong>我下面的操作是基于gcc x86_64机器进行的操作</strong></p><p>上面我们说过静态链接库,使用ar生成,喜爱面试我们的步骤:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">file: hello.c</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello. I'm a static link test\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: hello.h</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">file: main.c</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我们的测试文件,下面是具体的步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c</span><br><span class="line"></span><br><span class="line">ar -rcv -o libhello.a hello.o</span><br><span class="line"></span><br><span class="line">gcc main.c -L . -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment">#=&gt; </span></span><br><span class="line">[Crow@EvilCrow ~]$ ./a.out </span><br><span class="line">Hello. I<span class="string">'m a static link test</span></span><br></pre></td></tr></table></figure><p><img src="http://p8pmsq2a4.bkt.clouddn.com/static_link_ter.png" alt="静态链接"></p><p>其中需要注意的是:</p><ul><li><p>ar中的选项,-rcv ,显示,更新,创建新的archive,即是说,对于一个archive,我们可以进行包的增删改</p></li><li><p>gcc中 -L 指的是链接目录,对于静态,动态都适用</p></li><li><p>-l说明要链接的库名, 一般都是libXXX.so XXX就是要进行链接的名字</p></li></ul><p>下面是,动态链接库的创建,可以使用链接器ld,我们此处使用简单地gcc:</p><p>文件一致.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c hello.c</span><br><span class="line"></span><br><span class="line">gcc -shared -fPIC -o libhello.so hello.o</span><br><span class="line"></span><br><span class="line">gcc main.c -L . -Wl,-rpath=. -lhello</span><br><span class="line"></span><br><span class="line"><span class="comment">#=&gt;</span></span><br><span class="line">[Crow@EvilCrow ~]$ ./a.out </span><br><span class="line">Hello. I<span class="string">'m a dynamic link test</span></span><br></pre></td></tr></table></figure><p><img src="http://p8pmsq2a4.bkt.clouddn.com/dynamic_link.png" alt="动态链接"></p><p>其中需要注意的是:</p><ul><li><p>外面说的共享库和动态库是一个东西Win下DLL(Dynamic Loading Libary)</p><p>Linux下 .so(Shared Object)</p></li><li><p>-fPIC(- file Position Independent Code) 表示与位置无关,很容易对数据进行重定位</p><p>我们的建议是: <strong>函数库应始终使用与位置无关的代码,共享库建议使用PIC</strong></p><p>为什么,因为共享库维护同一份拷贝,我们使用PIC,可以有效的减少换页.可以按需求任意位置装入</p><p>否则就成了静态共享库了(SVR3上一个奇葩玩意,不提)</p></li><li><p>-shared 这个选项一定要有啊,否则,是不能生成共享库的(动态库)</p></li><li><p>-L. 之后,,为什么还要有 -Wl,-rpath=. 动态库因为可以通过同时维护多个,而且运行时必须存在</p><p>所以,我们即需要指定链接目录,也需要运行目录,一般,/usr/lib64下,都是链接指向-&gt;</p><p>-Wl,rpath=XX, 纯属是gcc的命令问题,cc,只即使用-R(running dir),-Wl,…表示向链接器传参</p><p>如果我们不使用这个选项,也是可以的.将我们的共享库放在/usr/lib64, 或者/usr/local/lib64下</p><p>/usr /usr/local区别不用我说了, </p><p>另一种方法在ld.so.conf中添加我们共享库所在目录,然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig 即可(需要sudo)</span><br></pre></td></tr></table></figure></li></ul><p> 之后,动态链接,就不需要指定目录了,静态链接同理</p><p>我们下面列出一些常用库,及其链接方式</p><table><thead><tr><th>#include文件</th><th>库路径名</th><th>选项</th></tr></thead><tbody><tr><td>&lt; math.h &gt;</td><td>/usr/lib64/libm.so</td><td>-lm</td></tr><tr><td>&lt; math.h &gt;</td><td>/usr/lib64/libm.a</td><td>-lm</td></tr><tr><td>&lt; stdio.h &gt;</td><td>/usr/lib6/libc.so</td><td>自动链接</td></tr><tr><td>……</td><td>……</td><td>…..</td></tr></tbody></table><p>提取库中的符号: nm命令(我使用的不太多,大家可以去man一下)</p><h2 id="7-使用静态库提取符号更严格"><a href="#7-使用静态库提取符号更严格" class="headerlink" title="7. 使用静态库提取符号更严格"></a>7. 使用静态库提取符号更严格</h2><p>因为共享库,推迟到运行时链接(我们现在就不考虑装入时链接了)</p><p>所以,链接命令顺序无所谓,运行时统一去链接</p><p>但是,静态库就必须在直接完成链接,所以,一旦有符号为装入,GG</p><p>而且,静态库,<strong>链接时,不是将其装入,而是装入undeference symbol</strong></p><p><strong>也就是说,gcc -lhello main.c -L. ,会提示找不到hello</strong></p><p>因为先链接库, 而库中hello是已经定义了的符号,</p><p><strong>因此,我们强烈建议,-l选项放在最后,虽然这有违, UNIX命令使用顺序,选项放在最后</strong></p><p><strong>不过为了程序顺利运行,这都不是事</strong></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/static_error.png" alt="静态链接顺序"></p><h2 id="8-Interpositioning"><a href="#8-Interpositioning" class="headerlink" title="8. Interpositioning"></a>8. Interpositioning</h2><p>曾经,由很多人都干过,定义与C保留字名相同的函数</p><p>不过C标准是支持这样的行为的,与OOP中对于类成员函数的重写类似</p><p>但是,在C中,如果你重写了某一个函数</p><p><strong>注意,注意,所有使用该保留字函数,都会被你写的函数进行替换,很严重的问题! ! !</strong></p><p><strong>有解吗? 有, 使用static关键字,限制命名空间, 其实OOP也就是限制了命名空间</strong></p><h2 id="9-建议"><a href="#9-建议" class="headerlink" title="9. 建议"></a>9. 建议</h2><p>说了这么多,其实也不是说静态链接就一无是处</p><p>事实上,它没有湮灭在历史长河中,就说明了它的存在性</p><p><strong>比如说,需要给没有函数库的机器上执行,那不得需要静态编译来脱离函数库依赖么,</strong></p><p><strong>而且,以目前的计算机硬件水平,基本可以忽略内存多余拷贝</strong></p><p><strong>多说一句: 一般默认选择动态链接,找不到libXXX.so时去找libXXX.a</strong></p><p>最后,有一个疑问: 现如今,使用的到底是装入时动态链接, 还是运行时动态链接? 可以交流一下呗,</p><p>而且这两种模式,是否可以手动指定?</p><p>最后,此次的链接知识开个小头,等CSAPP中的精华内容吧,甚至C可以直接在程序设计层面调用共享库</p><p>May 25, 2018 2:18 PM</p><hr><p>Update: May 25, 2018 2:18 PM</p><p>更新, 今天在问了老王之后,得到两个概念:</p><ol><li><p>gcc也只是一个driver, 其内部自行调用ccl,cpp,as,ld之类的组件 即Binuntils</p></li><li><p><strong>可以确定的是链接是在运行时进行的,ld-linux-x86_64.so.2实际上可以单独运行</strong></p></li></ol><p><strong>也就是说,在链接完成后,可执行文件中填入了链接器,证明是运行时完成动态链接</strong></p><p><img src="http://p8pmsq2a4.bkt.clouddn.com/runtime_dynamic_link.png" alt="strings a.out | grep ld"></p>]]></content>
    
    <summary type="html">
    
      编译系统是C/C++一部分重要的内容,编译的内容过于复杂,需要系统学习编译原理,但是链接的内容就比较容易理解,对系统性的依赖比较小,但是链接的知识十分的重要
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="Expert_C_Programming" scheme="http://evil-crow.github.io/tags/Expert-C-Programming/"/>
    
  </entry>
  
  <entry>
    <title>&lt;咸鱼书&gt; 数组与指针</title>
    <link href="http://evil-crow.github.io/2018/05/29/C/Expert_C_Programming/array_pointer/"/>
    <id>http://evil-crow.github.io/2018/05/29/C/Expert_C_Programming/array_pointer/</id>
    <published>2018-05-29T14:14:00.000Z</published>
    <updated>2018-09-27T15:16:03.771Z</updated>
    
    <content type="html"><![CDATA[<p><em>数组与指针, 真的是C中, 甚至于C++中也是让人头大的问题, 脑子疼</em></p><p><em>但是越难的东西就越要去干他一发,不是吗?</em></p><h2 id="一-声明与定义"><a href="#一-声明与定义" class="headerlink" title="一, 声明与定义"></a>一, 声明与定义</h2><p>声明与定义我们之前一直都在说,都是实际上这两个的区别还是很大的.</p><p>主要表现在以下方面:</p><p><strong>定义: 定义实际上是特殊的声明, 他告诉编译器有这个变量及其类型,并且为他分配空间</strong></p><p><strong>声明: 声明则是表明存在这个变量,它的定义在别处.比如extern,表示变量在别处</strong></p><p>我们常见的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> a[];      <span class="comment">// 这是合法的, 表明a数组定义在别处,所以不需要提供数组长度</span></span><br></pre></td></tr></table></figure><h2 id="二-左右值的问题"><a href="#二-左右值的问题" class="headerlink" title="二, 左右值的问题"></a>二, 左右值的问题</h2><p>这其实也是个历史遗留问题, 很多时候我们都说过左右值,但是从没有详细的谈过</p><p>记得最早扯到左右值, 其实是在&lt; C Primer Plus &gt; 中的”=”运算符中,其声明:</p><p>只有可修改的左值,可以放在赋值运算符的左侧,可修改的左值是C中新定义的概念</p><blockquote><p>左值: 指的是可以获取到地址的内容, 所以编译期一定要获取到期内容</p></blockquote><blockquote><p>右值: 只需要获取到它的值即可.只有运行时才能取得值.</p><p>所以全局变量在赋值时,要求是const experssion(常量表达式)</p><p>数组的维数也是这么要求的,不过在C99推出VLA后,这些都是过去式了.</p></blockquote><p><em>那么,C中可修改的左值到底是为了什么呢?</em></p><p><strong>它的存在是为了遏制数组名赋值的滥用,后面会提到,数组名会被编译器改为首元素的地址</strong></p><p><strong>bingo! 数组名也是左值(可以获取到其地址),但它并不是可修改的左值,可修改的左值就是为处理此情况</strong></p><h2 id="三-array与pointer的访问模式"><a href="#三-array与pointer的访问模式" class="headerlink" title="三, array与pointer的访问模式"></a>三, array与pointer的访问模式</h2><p>看下面的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"Linux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *a = <span class="string">"Linux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问模式</span></span><br><span class="line"><span class="keyword">char</span> temp = a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>上面的代码中,两种类型肯定不能同时存在!</p><p>这里,我们只是来说说编译器的思维模式,如何来进行访问:</p><p><strong>对于数组, 取得a的地址, 然后根据下标i以及数据类型,获取偏移量, 直接拿到即可</strong></p><p><strong>对于指针, 其实只有8个字节(64位), 那么,访问时,a[4] #=&gt; *(a+4), 先取出a中的内容</strong></p><p><strong>然后 a中的地址 + sizeof(类型) * 下标 =&gt; 地址, 取出内容</strong></p><p>所以说,指针访问多了一次dereference, 多访问了一次, 在现在来看是无法影响效率的.但是指针更加灵活.</p><h2 id="四-交叉访问会出现什么结果"><a href="#四-交叉访问会出现什么结果" class="headerlink" title="四,交叉访问会出现什么结果?"></a>四,交叉访问会出现什么结果?</h2><p><em>此处的交叉访问是我自己拟出来的一个概念, 主要是下面两种情况:</em></p><h3 id="1-定义为指针-声明为数组"><a href="#1-定义为指针-声明为数组" class="headerlink" title="1. 定义为指针, 声明为数组."></a>1. 定义为指针, 声明为数组.</h3><p>定义为指针,声明为数组,也是不少人干过的事, 会发生什么样的结果.我们先看看这张图:</p><p>上面这幅图就表明了,定义为指针,声明为数组:</p><p>**会导致,访问时, 将地址解释为数据,牛头不对马嘴, 此处将地址部分解释为ASC II 字符,显然是不正确的.</p><p><strong>严重情况下,修改地址, 这个指针的提领内容就永远也访问不到了</strong></p><h3 id="2-定义为数组-声明为指针"><a href="#2-定义为数组-声明为指针" class="headerlink" title="2. 定义为数组, 声明为指针"></a>2. 定义为数组, 声明为指针</h3><p>同上面,先来看看图:</p><p>上面这幅图就表明了,定义为数组,声明为指针:</p><p><strong>会导致, 访问时, 将数组内容解释为地址,然后去这个地址提领操作, 显然也是不正确的,</strong></p><h2 id="五-array与pointer到底何时相同-何时不同"><a href="#五-array与pointer到底何时相同-何时不同" class="headerlink" title="五, array与pointer到底何时相同,何时不同?"></a>五, array与pointer到底何时相同,何时不同?</h2><p>上面说了这么多,我们就直截了当的说清,到底什么时候数组与指针相同,什么时候指针不能等同数组!</p><p>总结如下:</p><p><strong>1. 数组总是可以写为指针的访问形式, 这是基于底层实现的基地址 + 偏移量的原因</strong></p><p><strong>2. 在进行函数传递参数的时候, 数组一律被转化为指针,这是为了效率考虑,而且大多数时候</strong></p><p><strong> 我们真的不需要完整的数组内容可可拷贝, 只是对其中一部分内容感兴趣</strong></p><p><strong>3. 另外一点,就是数组名表示数组首元素地址</strong></p><p>上面这些,就是数组与指针相同的时候,其他时候都是不同的.</p><p><strong>编译器看变量的时候, 一个变量就是地址, 一个指针就是地址的地址</strong></p><h2 id="六-实际上-为什么会发生混淆"><a href="#六-实际上-为什么会发生混淆" class="headerlink" title="六, 实际上,为什么会发生混淆?"></a>六, 实际上,为什么会发生混淆?</h2><p>这个锅,要甩在出版社身上了!</p><p>众所周知, &lt; the C Programming Language &gt; 中提到数组与指针</p><blockquote><p>As format parementers in function definition<br>(翻页)<br>char s[]<br>is same as<br>char *s;</p></blockquote><p>OK, 就是这么简单地一件事, 当然锅不能全甩在出版社身上了,开个玩笑而已.</p><h2 id="七-专门来说一说字符串指针与其他的指针"><a href="#七-专门来说一说字符串指针与其他的指针" class="headerlink" title="七, 专门来说一说字符串指针与其他的指针"></a>七, 专门来说一说字符串指针与其他的指针</h2><p>简单地说,字符指针是个骚东西.</p><p><strong>因为,它可以根据后面的NUL来标识终止.这样的话,就不需要额外的变量来控制边界访问</strong></p><p>比如: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>其中便是直接通过终止字符来标识, 不然一般二维指针,是需要两个变量标识的;</p><p>另外一点就是,使用字符指针,会自动分配空间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"linux"</span>;     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">f</span> = &#123;</span><span class="number">3.14</span>, ...&#125;; <span class="comment">// Error , 需要分配空间</span></span><br></pre></td></tr></table></figure><p>另外对于指针数组进行赋值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str[] = &#123;</span><br><span class="line">    &#123;<span class="string">"Linux"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Xiyou"</span>&#125;,</span><br><span class="line">&#125;;                     <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *integer[] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;                    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>其他类型的指针数组赋值, 安心用数组名赋值好吧 (滑稽;</p><p>实际上所谓的字符串,只是一个字符指针,但是其他的类型,可都是需要分配空间的呀! ! !</p><h2 id="八-一段深刻的代码"><a href="#八-一段深刻的代码" class="headerlink" title="八, 一段深刻的代码"></a>八, 一段深刻的代码</h2><p>下面这段代码,可以帮助你搞清楚,数组与指针之间的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"NieR:Automata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_array</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p\n"</span>,&amp;<span class="built_in">array</span>, &amp;(<span class="built_in">array</span>[<span class="number">0</span>]), &amp;(<span class="built_in">array</span>[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_pointer</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p, %p\n"</span>,&amp;ptr, &amp;(ptr[<span class="number">0</span>]), &amp;(ptr[<span class="number">1</span>]), ++ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func_array(str);</span><br><span class="line">    func_pointer(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p\n"</span>,&amp;str[<span class="number">0</span>], &amp;(str[<span class="number">0</span>]), &amp;(str[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#=&gt; </span><br><span class="line"><span class="number">0x7ffdf69e1978</span>, <span class="number">0x400630</span>, <span class="number">0x400631</span></span><br><span class="line"><span class="number">0x7ffdf69e1978</span>, <span class="number">0x400631</span>, <span class="number">0x400632</span>, <span class="number">0x400631</span></span><br><span class="line"><span class="number">0x400630</span>, <span class="number">0x400630</span>, <span class="number">0x400631</span></span><br></pre></td></tr></table></figure><p>我们现在来解释输出结果:</p><p>首先,因为用的是指针,所以第1,2行第1列与后面不同, 后面的地址都是str在静态区的内容</p><p><strong>而前面就是实际上str指针的地址, 这就是提领的意义</strong></p><p>另外后面,的不同,是因为操作的非原子性, 可以让睡一会儿,或者上个锁处理.</p><p><strong>另外,整天说传值, 传址, 实际上哪有传地址,地址其实也是值,函数参数传递就是进行值传递!</strong></p><h2 id="九-多维指针与Iliffc向量-指针数组"><a href="#九-多维指针与Iliffc向量-指针数组" class="headerlink" title="九, 多维指针与Iliffc向量(指针数组)"></a>九, 多维指针与Iliffc向量(指针数组)</h2><p>之前很多人整天说<strong>二维数组与二维指针相同, 头给你打烂</strong></p><p>实际上,,二维指针与二维数组区别很大,另外加上一个Iliffc向量(便是数组指针)</p><p>具体情况是下面这样:</p><ul><li><p>二维数组: int a[4][5]  #=&gt; 20x4 个字节</p></li><li><p>指针数组: int *a[5] #=&gt; 5x8 个字节</p></li><li><p>二维指针: int **a #=&gt; 8个字节</p></li></ul><p>他们进行访问的方法也就不同了:</p><ul><li><p>二维数组直接在基地址上进行偏移量的求取即可.</p></li><li><p>指针数组在一次偏移量上找到对应指针,然后提领到其他内存位置, 在进行一次偏移量求取</p></li><li><p>所以,二维指针进行量此提领,然后去找偏移量找到数据.</p></li></ul><p>那么,在存取效率上,有什么问题?</p><p><strong>推荐使用数组指针, 因为数组指针可以保证字符串个数,但是对于每个字符串不限制长度</strong></p><p><strong>这样就可以大幅度减少系统中的内存开销,节省空间.</strong></p><p><strong>一般情况下,我们尽量能不使用字符串拷贝,就不拷贝,而是引用它的指针,因为拷贝的开销太大了</strong></p><p><strong>但是,从另一方面来说,锯齿状数组,即Iliffc向量,因为大小不同,会将数据存在不同的页面上</strong></p><p><strong>另一方面考虑来说, 不停的换页,会严重降低效率</strong></p><p>说到这里,其实让我想起来了当年小组面试,康康抛出来的一个问题:</p><p><em>如何动态分配二维数组 ?</em></p><p>今天我就再来说一说:</p><p>两种方法:</p><p>一.</p><p>1&gt; 循环两次分配,先分配一维数组的i个指针的空间, </p><p>2&gt; 然后分配二维数组中的j个指针空间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标分配char a[m][n]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> **a = <span class="literal">NULL</span>;</span><br><span class="line">a = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    a[i] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br></pre></td></tr></table></figure><p>二,</p><p>另外一种办法,就是直接分配总大小的空间,然后再去分配一维数组指针,缺点是整个全部分配</p><p>优点是可以分配出连续的内存来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> **a = <span class="literal">NULL</span>;</span><br><span class="line">a = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *) * m);</span><br><span class="line">a[<span class="number">0</span>] = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * m * n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    a[i] = a[<span class="number">0</span>] + n * i * <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br></pre></td></tr></table></figure><p>一次性分配,也只是指最后一步的时候,一次性分配,前面还是一样的</p><p>切记:<strong>多维数组的动态分配类似于递归的形式,一层一层分配进去, 一层一层释放出来,严格按照栈的顺序</strong></p><p>十, 数组转换为指针形式是非递归的</p><p>上面说过,数组是可以转换为指针的,切记,<strong>这是非递归的</strong></p><p><strong>意思便是: 二维数组,会变成指针数组,而非二维指针</strong></p><p>所以,我们可以说,<strong>main()的原型参数是指针数组,而并非函数指针,这样便可以减少空间开销(锯齿形数组</strong></p><hr><p>PS: </p><p>就说点其他的话吧, 最近真的是脑子疼,没一点劲</p><p>各种各样的恶心事,就不说了,康康刚才和我聊了一会儿</p><p>让我感受到了时间的紧迫性,</p><p>然而我整天都是在逃避,哈哈,可笑得很.整天作逼清高,就他妈一个王八蛋</p><p>玩锤子 !</p><p>好了,丧这些就够了,在丧下去就真的完了,已经菜到忘了多维数组的动态内存分配了,靠</p><p>菜菜菜,有什么办法呢?</p><p>干他妈一票大的!</p><p>明天, 不,今天开始吧.</p><p>C的内容到此为止,后面就是C++, 服务器, 内核(按重要性次序)</p><p>反正怎么说,咸鱼书后面的内容,燃我看得很害怕, 大公司面试的问题,是真的可怕,这还是20多年前的问题</p><p>真的是感受到恐惧,唉,以前就是个瓜皮,现在开始尽力弥补吧</p><p>有这样一句话:</p><blockquote><p>生命转瞬即逝, 没时间丧      - 单读</p></blockquote><p>所以,明天,不是今天开始,大干一场!</p><p>May 30, 2018 12:39 AM</p>]]></content>
    
    <summary type="html">
    
      这些内容分别对应咸鱼书第IV, IX, X章,在此处放在一起来解释.其实这还是一个老生常谈的问题, 数组与指针, 指针与数组, 傻傻分不清楚. 今天之际就彻底撕开数组与指针之间的那层小小联系吧.另外说实话,咸鱼书后面提供的程序员面试的秘密,真的太难了,看的人脑子疼.
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="Expert_C_Programming" scheme="http://evil-crow.github.io/tags/Expert-C-Programming/"/>
    
  </entry>
  
  <entry>
    <title>&lt;咸鱼书&gt; 一些常见的技巧</title>
    <link href="http://evil-crow.github.io/2018/05/28/C/Expert_C_Programming/c_technology/"/>
    <id>http://evil-crow.github.io/2018/05/28/C/Expert_C_Programming/c_technology/</id>
    <published>2018-05-28T14:43:00.000Z</published>
    <updated>2018-09-27T15:14:12.989Z</updated>
    
    <content type="html"><![CDATA[<p><em>因为只是一些有选择的编程技巧, 我们同样使用小点来描述</em></p><h2 id="类型提升的问题"><a href="#类型提升的问题" class="headerlink" title="类型提升的问题"></a>类型提升的问题</h2><p> 这是C中至今仍然会出现的问题,就是类型提升的问题.</p><p> 起因是:优化编译器,统一类型,编译器只考虑堆栈区的变量数目,而不考虑其类型大小,</p><p> 但是,计算结束后,要回到原类型, <strong>也就是对于类型提升后的结果进行裁剪,恢复其原类型</strong></p><p> 在最早的编译器实现中,甚至只存在,int,double,指针三种类型(当然在今天看来已经是天方夜谭了)</p><p> 那么,类型提升的规则如下:</p><p> <strong>对于,小于int的类型: char, short, 位段, 枚举统一提升为int(在不损失精度时),否则为unsigned int</strong></p><p> <strong>对于float类型, 统一提升为double类型</strong></p><p> <strong>备注: 如果运算后结果一致, 也可以省略类型提升</strong></p><p> 看个简单地例子:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%zu\n"</span>,<span class="keyword">sizeof</span> <span class="string">'A'</span>); #=&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这就是类型提升的问题所在, ‘A’字符提升为int类型, 得到结果4(PS: 强制类型转换就可以发挥作用了)</p><h2 id="函数原型与函数声明"><a href="#函数原型与函数声明" class="headerlink" title="函数原型与函数声明"></a>函数原型与函数声明</h2><p> 函数声明是K&amp;R C中的概念, 函数原型是ANSI C中的概念, 这个概念是从C++中引进的.</p><p> <strong>我们之前一直强调, 函数原型的引入是为了编译器更房变得进行类型检查</strong></p><p> <strong>同时,它还有一个巨大的作用, 阻止类型检查, 会严格限定函数的参数接收值</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">char a, char b         </span><br><span class="line"><span class="comment">// 这里如果传入的参数是char, 实际上接受到会是int(类型提升),然后函数内部裁剪为char(函数原型)</span></span><br><span class="line">&#123;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span>         <span class="comment">// 此处严格接收char类型的参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>变量进行裁剪,一般情况下问题不大. 主要是溢出的处理, 但是一旦出现问题,就完蛋了</strong></p><h2 id="严格使用统一类型函数原型-声明"><a href="#严格使用统一类型函数原型-声明" class="headerlink" title="严格使用统一类型函数原型/声明"></a>严格使用统一类型函数原型/声明</h2><p> 既然存在函数原型/函数声明.那么,如何选择就成为一个问题了?</p><p> 要求是: <strong>严格使用函数声明, 或者函数原型,严禁混用</strong></p><p> 我们的建议是: <em>统一使用函数原型</em></p><p> 混合使用的时候, 会出现下面的问题:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原型 -&gt; 声明    </span><br><span class="line"></span><br><span class="line">#=结果=&gt; 期望接收类型提升后的类型,实际上接收到的是原类型, 传入<span class="keyword">short</span>,实际一次接收两个<span class="keyword">short</span></span><br><span class="line"></span><br><span class="line">声明 -&gt; 原型</span><br><span class="line"></span><br><span class="line">#=结果=&gt; 传参为类型提升后的值, 是接受到原类型, <span class="keyword">int</span> -&gt; <span class="keyword">short</span>, 丢失精度</span><br></pre></td></tr></table></figure><h2 id="单字符模式"><a href="#单字符模式" class="headerlink" title="单字符模式"></a>单字符模式</h2><p> 通常情况下,我们都是通过回车来获取一个字符这里提供两种方法</p><p> 1.使用stty系统调用</p><p>  是我想起来了,当时暑假聊天室的字符不回显</p><p> 2.使用一些系统编程函数(System Call)–ioctl</p><p> 具体用法可以下来查阅,不细说,以后啃蕨菜的时候,会详尽解释(Linux/UNIX系统编程手册)</p><h2 id="关于强制类型转换的一些事"><a href="#关于强制类型转换的一些事" class="headerlink" title="关于强制类型转换的一些事"></a>关于强制类型转换的一些事</h2><p> 强制类型转换实际上有什么用呢? 实际上有这样两个作用:</p><p> 1&gt; 类型转换 ,完成特定类型的需求</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)<span class="string">'A'</span></span><br></pre></td></tr></table></figure><p> 2&gt; 消除类型歧义, 防止不必要的类型提升</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">char</span>)<span class="string">'A'</span>   <span class="comment">// 上面sizeof例子的正确改法</span></span><br></pre></td></tr></table></figure><p> 另外,我们再建议一种进行类型转换的方法:</p><p> <strong>要转换,你肯定是要获取类型的,对吧.所以如何获取函数类型就是个问题</strong></p><p> 去掉标识符,改为* =&gt; 去掉形式参数名 =&gt; 整体加上()</p><p> 即可获取到一个函数的类型转换运算符</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> *b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr = func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'A'</span>;</span><br><span class="line">(<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">char</span> *))ptr(<span class="number">3</span>, &amp;ch);        <span class="comment">// 正确的调用方法</span></span><br></pre></td></tr></table></figure><p>上面的便是本次的内容,其中有许多内容是现在可以摒弃掉的(好吧,有的也看的我云里雾里)</p><p>如有问题,可以在评论区进行讨论沟通</p>]]></content>
    
    <summary type="html">
    
      此一节在原书中名为,&quot;程序员分不清圣诞节和万圣节&quot;是一个对于八进制数抖机灵的内容,实质上它是想要说一些C中的编程技巧,但是其中的一些技巧,在目前看来已经是过时的了,我们有选择的进行使用
    
    </summary>
    
      <category term="C/C++" scheme="http://evil-crow.github.io/categories/C-C/"/>
    
    
      <category term="Expert_C_Programming" scheme="http://evil-crow.github.io/tags/Expert-C-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Binutils の size</title>
    <link href="http://evil-crow.github.io/2018/05/27/tools/size/"/>
    <id>http://evil-crow.github.io/2018/05/27/tools/size/</id>
    <published>2018-05-27T03:49:00.000Z</published>
    <updated>2018-07-28T04:14:33.726Z</updated>
    
    <content type="html"><![CDATA[<p><em>既然说到size命令,这是一个Linux下,用于查看可执行文件各段size的工具</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">SIZE(1)                          GNU Development Tools                          SIZE(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       size - list section sizes and total size.</span><br><span class="line">    <span class="comment">#size - 列出各section的大小以及总大小</span></span><br><span class="line"></span><br><span class="line">SYNOPSIS        <span class="comment"># 简介 [sɪˈnɒpsɪs]</span></span><br><span class="line">       size [-A|-B|--format=compatibility]</span><br><span class="line">            [--<span class="built_in">help</span>]</span><br><span class="line">            [-d|-o|-x|--radix=number]</span><br><span class="line">            [--common]</span><br><span class="line">            [-t|--totals]</span><br><span class="line">            [--target=bfdname] [-V|--version]</span><br><span class="line">            [objfile...]</span><br><span class="line"></span><br><span class="line">DESCRIPTION           <span class="comment">#命令描述</span></span><br><span class="line">       The GNU size utility lists the section sizes---and the total size---<span class="keyword">for</span> each of</span><br><span class="line">       the object or archive files objfile <span class="keyword">in</span> its argument list.  By default, one line</span><br><span class="line">       of output is generated <span class="keyword">for</span> each object file or each module <span class="keyword">in</span> an archive.</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># GNU size效用是列出section的大小 --- 和总大小---对于每个目标文件 或 静态链接库参数列表       </span></span><br><span class="line"><span class="comment"># 中目标文件. 默认情况下, 每一行的输出被各个目标文件所隔离开,或是静态链接库中的模块</span></span><br><span class="line"></span><br><span class="line">       objfile... are the object files to be examined.  If none are specified, the file</span><br><span class="line">       <span class="string">"a.out"</span> will be used.</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 参数[object...]是要被检测的目标文件(可执行文件). 如果没有被指定, 会使用"a.out"文件</span></span><br><span class="line"></span><br><span class="line">OPTIONS    <span class="comment">#参数: 选项</span></span><br><span class="line">       The <span class="built_in">command</span> line options have the following meanings:</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 命令行选项有以下的含义:</span></span><br><span class="line"></span><br><span class="line">       -A</span><br><span class="line">       -B</span><br><span class="line">       --format=compatibility <span class="comment"># 兼容性 [kəmˌpætəˈbɪləti]</span></span><br><span class="line">           Using one of these options, you can choose whether the output from GNU size</span><br><span class="line">           resembles  <span class="comment"># 与..想像  [rɪˈzembl] </span></span><br><span class="line">   output from System V size (using -A, or --format=sysv), or</span><br><span class="line">           Berkeley size (using -B, or --format=berkeley).  The default is the one-line</span><br><span class="line">           format similar to Berkeley<span class="string">'s.</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string"># 使用这些其中之一的选项, 你可以选择GNU输出是使用UNIX 第五版(使用选项 -A, 或者选项   </span></span><br><span class="line"><span class="string"># --format=sysv), 或者伯克利(即BSD系列)(使用选项-B, 或者选项 --format=berkeley).  # 默认是一行输出的格式与伯克利模式相似 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           Here is an example of the Berkeley (default) format of output from size:</span></span><br><span class="line"><span class="string"># 这里是伯克利格式的输出示例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   $ size --format=Berkeley ranlib size</span></span><br><span class="line"><span class="string">                   text    data    bss     dec     hex     filename</span></span><br><span class="line"><span class="string">                   294880  81920   11592   388392  5ed28   ranlib</span></span><br><span class="line"><span class="string">                   294880  81920   11888   388688  5ee50   size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           This is the same data, but displayed closer to System V conventions:</span></span><br><span class="line"><span class="string"># 这是相同的数据, 但是显示方式更接近于System V 转换:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   $ size --format=SysV ranlib size</span></span><br><span class="line"><span class="string">                   ranlib  :</span></span><br><span class="line"><span class="string">                   section         size         addr</span></span><br><span class="line"><span class="string">                   .text         294880         8192</span></span><br><span class="line"><span class="string">                   .data          81920       303104</span></span><br><span class="line"><span class="string">                   .bss           11592       385024</span></span><br><span class="line"><span class="string">                   Total         388392</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   size  :</span></span><br><span class="line"><span class="string">                   section         size         addr</span></span><br><span class="line"><span class="string">                   .text         294880         8192</span></span><br><span class="line"><span class="string">                   .data          81920       303104</span></span><br><span class="line"><span class="string">                   .bss           11888       385024</span></span><br><span class="line"><span class="string">                   Total         388688</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       --help</span></span><br><span class="line"><span class="string">           Show a summary of acceptable arguments and options.</span></span><br><span class="line"><span class="string"># 显示可接受的参数和选项摘要     summary  [ˈsʌməri] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       -d</span></span><br><span class="line"><span class="string">       -o</span></span><br><span class="line"><span class="string">       -x</span></span><br><span class="line"><span class="string">       --radix=number</span></span><br><span class="line"><span class="string">           Using one of these options, you can control whether the size of each section</span></span><br><span class="line"><span class="string">           is given in decimal (-d, or --radix=10); octal (-o, or --radix=8); or</span></span><br><span class="line"><span class="string">           hexadecimal (-x, or --radix=16).  In --radix=number, only the three values</span></span><br><span class="line"><span class="string">           (8, 10, 16) are supported.  The total size is always given in two radices;</span></span><br><span class="line"><span class="string">           decimal and hexadecimal for -d or -x output, or octal and hexadecimal if</span></span><br><span class="line"><span class="string">           you'</span>re using -o.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 使用下面这些选项, 你可以控制每一个section的大小是以十进制, 八进制, 或者十六进制给</span></span><br><span class="line"><span class="comment"># 出 . 在 --radix=number选项中, 只支持(8, 10, 16)进制三种取值. 总大小总是以两种形</span></span><br><span class="line"><span class="comment"># 式给出 十进制和十六进制 使用 -d 或 -x 输出. 或者八进制和十六进制如果你使用-o选项</span></span><br><span class="line"></span><br><span class="line">       --common</span><br><span class="line">           Print total size of common symbols <span class="keyword">in</span> each file.  When using Berkeley format</span><br><span class="line">           these are included <span class="keyword">in</span> the bss size.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 打引出每个文件中的一般符号, 当使用伯克利格式时(-B选项), 这些是包含在bss的大小中的</span></span><br><span class="line"></span><br><span class="line">       -t</span><br><span class="line">       --totals</span><br><span class="line">           Show totals of all objects listed (Berkeley format listing mode only).</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 显示所有被列出的目标文件的总计 (仅限伯克利格式的模式选择)</span></span><br><span class="line"></span><br><span class="line">       --target=bfdname</span><br><span class="line">           Specify that the object-code format <span class="keyword">for</span> objfile is bfdname.  This option may</span><br><span class="line">           not be necessary; size can automatically recognize many formats.</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify 指定 [ˈspesɪfaɪ], 指定目标文件代码是使用bfdname的格式. 此选项不是必需的;   </span></span><br><span class="line"><span class="comment"># size可以自动分辨许多格式</span></span><br><span class="line">       -V</span><br><span class="line">       --version</span><br><span class="line">           Display the version number of size.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 显示size命令的版本号</span></span><br><span class="line">       @file</span><br><span class="line">           Read <span class="built_in">command</span>-line options from file.  The options <span class="built_in">read</span> are inserted <span class="keyword">in</span> place</span><br><span class="line">           of the original @file option.  If file does not exist, or cannot be <span class="built_in">read</span>,</span><br><span class="line">           <span class="keyword">then</span> the option will be treated literally, and not removed.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 从文件阅读命令行选项. 选项阅读是被嵌入在 @file选项的起源之处的. 如果此文件不存在.   </span></span><br><span class="line"><span class="comment"># 或者不能被读取, 那么选项将被按照字面意思解释, 不会被移除.                         </span></span><br><span class="line"><span class="comment"># literally [ˈlɪtərəli] 逐字地</span></span><br><span class="line">   </span><br><span class="line">           Options <span class="keyword">in</span> file are separated by whitespace.  A whitespace character may be</span><br><span class="line">           included <span class="keyword">in</span> an option by surrounding the entire option <span class="keyword">in</span> either single or</span><br><span class="line">           double quotes.  Any character (including a backslash) may be included by</span><br><span class="line">           prefixing the character to be included with a backslash.  The file may</span><br><span class="line">           itself contain additional @file options; any such options will be processed</span><br><span class="line">           recursively.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 选项在文件中空白分开, (意译: 选项使用时被空格分开). 一个空白字符可以被包含在一个选项中,</span></span><br><span class="line"><span class="comment"># 依靠整个选项周围是单个或双引用(意译: 使用引用时, 可以将空白字符包含在选项中). </span></span><br><span class="line"><span class="comment"># 任何字符(包括反斜线 \ ) 都可能被包含,靠字符的前缀靠使用反斜线. </span></span><br><span class="line"><span class="comment"># 这个文件其自身包含@file选项; 任何这样的选项将会被递归调用</span></span><br><span class="line"><span class="comment"># prefix 前缀的 [ˈpri:fɪks]</span></span><br><span class="line"><span class="comment"># recursive 回归的, 递归的,[rɪˈkɜ:sɪv] </span></span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">       ar(1), objdump(1), readelf(1), and the Info entries <span class="keyword">for</span> binutils.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 推荐查阅, ar, objdump, readelf 同时info binutils(GNU二进制工具集)的细节</span></span><br><span class="line"></span><br><span class="line">COPYRIGHT</span><br><span class="line">       Copyright (c) 1991-2017 Free Software Foundation, Inc.</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 1991- 2017 自由软件基金会</span></span><br><span class="line"></span><br><span class="line">       Permission is granted to copy, distribute and/or modify this document under the</span><br><span class="line">       terms of the GNU Free Documentation License, Version 1.3 or any later version</span><br><span class="line">       published by the Free Software Foundation; with no Invariant Sections, with no</span><br><span class="line">       Front-Cover Texts, and with no Back-Cover Texts.  A copy of the license is</span><br><span class="line">       included <span class="keyword">in</span> the section entitled <span class="string">"GNU Free Documentation License"</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这些, 有兴趣,去了解GNU执照, 不多说了</span></span><br><span class="line">binutils-2.29                          2017-07-24   <span class="comment"># size亦属于GNU二进制工具包                              SIZE(1)</span></span><br></pre></td></tr></table></figure><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_A.png" alt="-A Option"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_B.png" alt="-B Option"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_d_x_h.png" alt="--format"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_t.png" alt="-t Option"></p><p><img src="http://p9dfr0ocx.bkt.clouddn.com/size_V.png" alt="-V Option"></p><p><em>如有疑问, 或者有任何新发现, 可以随时交流, 此系列不是近仅作翻译, 有值得关注的点会谈谈其他的</em></p><p><em>size直接看man文档已经很足够了, 我们下次再见(ಡωಡ)</em></p>]]></content>
    
    <summary type="html">
    
      最近看咸鱼书,其中有许多原来不曾注意到的工具,正好恰逢四级英语考试,对于,不是很复杂的命令(500行以内),我们来翻译一下man中的内容吧!
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://evil-crow.github.io/categories/Unix-Linux/"/>
    
    
      <category term="Binuntils" scheme="http://evil-crow.github.io/tags/Binuntils/"/>
    
  </entry>
  
</feed>
